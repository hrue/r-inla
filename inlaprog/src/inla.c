
/* inla.c
 * 
 * Copyright (C) 2007-2022 Havard Rue
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *  * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * The author's contact information:
 *
 *        Haavard Rue
 *        CEMSE Division
 *        King Abdullah University of Science and Technology
 *        Thuwal 23955-6900, Saudi Arabia
 *        Email: haavard.rue@kaust.edu.sa
 *        Office: +966 (0)12 808 0640
 *
 */

#ifndef GITCOMMIT
#define GITCOMMIT "current developer version"
#endif

#if defined(__sun__)
#include <stdlib.h>
#endif
#if defined(__FreeBSD__)
#include <unistd.h>
#endif
#if defined(__linux__)
#include <getopt.h>
#endif
#include <float.h>
#if !defined(__FreeBSD__)
#include <malloc.h>
#endif

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <math.h>
#include <signal.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <ltdl.h>

#if !defined(WINDOWS)
#include <sys/resource.h>
#endif

#if defined(__APPLE__)
#include <sys/types.h>
#include <sys/sysctl.h>
#endif

#include "rmath.h"

#include "GMRFLib/GMRFLib.h"
#include "GMRFLib/GMRFLibP.h"
#if !defined(ISNAN)
#  define ISNAN(x) (isnan(x)!=0)
#endif


static const char GitID[] = "file: " __FILE__ "  " GITCOMMIT;

#if !defined(INLA_TAG)
#define INLA_TAG "devel"
#endif

#include <unistd.h>
#include <stdlib.h>
#if defined(WIN32) || defined(WINDOWS)
#include <windows.h>
#include <direct.h>
#endif

#include "inla.h"
#include "my.h"
#include "spde.h"
#include "spde2.h"
#include "spde3.h"
#include "eval.h"
#include "ar.h"
#include "pc-priors.h"
#include "R-interface.h"
#include "fgn.h"
#include "tweedie.h"
#include "pc-powerlink.h"
#include "cgeneric.h"

#define PREVIEW (10)
#define MODEFILENAME ".inla-mode"
#define MODEFILENAME_FMT "%02x"

#define TSTRATA_MAXTHETA (11L)				       /* as given in models.R */
#define SPDE2_MAXTHETA (100L)				       /* as given in models.R */
#define SPDE3_MAXTHETA (100L)				       /* as given in models.R */
#define GENERIC3_MAXTHETA (11L)				       /* as given in models.R */
#define AR_MAXTHETA (10L)				       /* as given in models.R */
#define LINK_MAXTHETA (10L)				       /* as given in models.R */
#define STRATA_MAXTHETA (10L)				       /* as given in models.R */
#define NMIX_MMAX (15L)					       /* as given in models.R */
#define POM_MAXTHETA (10L)				       /* as given in models.R */
#define INTSLOPE_MAXTHETA (10L)				       /* as given in models.R */
#define BGEV_MAXTHETA (10L)

G_tp G = { 1, INLA_MODE_DEFAULT, 4.0, 0.5, 2, 0, GMRFLib_REORDER_DEFAULT, 0, 0 };

const int keywords_len = 7;
const char *keywords[] = {
	"FIXED", "INITIAL", "PRIOR", "HYPERID", "PARAMETERS", "TO.THETA", "FROM.THETA", NULL
};

// defined in R-interface.c
extern double R_rgeneric_cputime;

int G_norm_const_len = 0;
double *G_norm_const = NULL;				       /* store static normalization constants for likelihoods */
void **G_norm_const_v = NULL;
char *G_norm_const_compute = NULL;			       /* to be computed */

/* 
   default values for priors
 */
#define DEFAULT_GAMMA_PRIOR_A          1.0
#define DEFAULT_GAMMA_PRIOR_B          0.00005
#define DEFAULT_NORMAL_PRIOR_PRECISION 0.001

/* 
   these are the same, just that the interface is cleaner with the `ds'
 */
#define OFFSET(idx_) ds->offset[idx_]
#define OFFSET2(idx_) mb_old->offset[idx_]
#define OFFSET3(idx_) mb->offset[idx_]

#define LINK_INIT							\
	double *_link_covariates = NULL;				\
	Link_param_tp *predictor_invlinkfunc_arg = (Link_param_tp *) (ds->predictor_invlinkfunc_arg[idx]); \
	if (ds->link_covariates) {					\
		_link_covariates = Calloc(ds->link_covariates->ncol, double); \
		GMRFLib_matrix_get_row(_link_covariates, idx, ds->link_covariates); \
	}								\
	double _lp_scale = 1.0;						\
	if (ds->lp_scale && ds->lp_scale[idx] >= 0) {					\
		_lp_scale = ds->lp_scale_beta[(int)ds->lp_scale[idx]][thread_id][0]; \
	}

#define LINK_END				\
	Free(_link_covariates)

#define PREDICTOR_LINK_EQ(_fun) (ds->predictor_invlinkfunc == (_fun))

#define PREDICTOR_INVERSE_LINK(xx_)					\
	ds->predictor_invlinkfunc(thread_id, _lp_scale * (xx_), MAP_FORWARD, (void *)predictor_invlinkfunc_arg, _link_covariates)

#define PREDICTOR_INVERSE_IDENTITY_LINK(xx_) (_lp_scale * (xx_))

#define PREDICTOR_LINK(xx_)						\
	(ds->predictor_invlinkfunc(thread_id, (xx_), MAP_BACKWARD, (void *)predictor_invlinkfunc_arg, _link_covariates) / _lp_scale)

#define PREDICTOR_INVERSE_LINK_LOGJACOBIAN(xx_)  \
	log(ABS(_lp_scale * ds->predictor_invlinkfunc(thread_id, _lp_scale * (xx_), MAP_DFORWARD, (void *)predictor_invlinkfunc_arg, _link_covariates)))

#define PENALTY (-100.0)				       /* wishart3d: going over limit... */

#define READ(fd, buf, num, type)					\
	if (1) {							\
		if (num > 0) {						\
			int bytes_read;					\
			bytes_read = read(fd, (void *) buf, (size_t) ((num)*sizeof(type))); \
			assert(bytes_read == (int) ((num)*sizeof(type))); \
		}							\
	}

#define WRITE(fd, buf, num, type)					\
	if (1) {							\
		if (num > 0) {						\
			int bytes_written;				\
			bytes_written = write(fd, (void *) buf, (size_t) ((num)*sizeof(type))); \
			assert(bytes_written == (int) ((num)*sizeof(type))); \
		}							\
	}

#define WRITE_MSG(fd, Id, msg)					\
	if (1) {						\
		int _id = (Id);					\
		WRITE(fd, &_id, 1, int);			\
		char *dup_msg = GMRFLib_strdup(msg);		\
		WRITE(fd, dup_msg, strlen(dup_msg)+1, char);	\
		Free(dup_msg);					\
	}

#define CODE_NEEDED \
	if (1) {							\
		fprintf(stderr, "\n\n%s: %d  CODE NEEDED HERE!\n\n", __FILE__, __LINE__); \
		exit(1);						\
		assert(0==1);						\
	}

// these versions (in my.c) cache the result when the argument is integer
#define gsl_sf_lngamma(_x) my_gsl_sf_lngamma(_x)
#define gsl_sf_lnchoose_e(_a, _b, _c) my_gsl_sf_lnchoose_e(_a, _b, _c)

forceinline double inla_interpolate_mode(double *x, double *y)
{
	// give 3 values (x,y), return the mode. truncate at the boundary

	double xm = (y[0] * x[1] * x[1] - y[0] * x[2] * x[2] - y[1] * x[0] * x[0] + y[1] * x[2] * x[2] + y[2] * x[0] * x[0] - y[2] * x[1] * x[1]) /
	    (y[0] * x[1] - y[0] * x[2] - y[1] * x[0] + y[1] * x[2] + y[2] * x[0] - x[1] * y[2]) / 0.2e1;

	double xmin = DMIN(x[0], DMIN(x[1], x[2]));
	double xmax = DMAX(x[0], DMAX(x[1], x[2]));
	xm = TRUNCATE(xm, xmin, xmax);

	return (xm);
}

int inla_ncpu(void)
{
#if defined(_SC_NPROCESSORS_ONLN)			       /* Linux, Solaris, AIX */
	return (int) sysconf(_SC_NPROCESSORS_ONLN);
#elif defined(__APPLE__)				       /* MacOSX */
	int count = -1;
	size_t size = sizeof(count);
	sysctlbyname("hw.ncpu", &count, &size, NULL, 0);
	return count;
#elif (defined(WIN32) || defined(WINDOWS))		       /* Windows */
	SYSTEM_INFO SystemInfo;
	GetSystemInfo(&SystemInfo);
	return SystemInfo.dwNumberOfProcessors;
#else
	return -1;
#endif
}

int inla_mkdir(const char *dirname)
{
#if defined(WINDOWS)
	return mkdir(dirname);
#else
	return mkdir(dirname, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
#endif
}

// this is from https://stackoverflow.com/questions/2513505/how-to-get-available-memory-c-g
// return RAM in Mb
#if defined(WIN32) || defined(WINDOWS)
unsigned long long getTotalSystemMemory()
{
	MEMORYSTATUSEX status;
	status.dwLength = sizeof(status);
	GlobalMemoryStatusEx(&status);
	return ((status.ullTotalPhys / 1024L / 1024L));
}
#else
unsigned long long getTotalSystemMemory()
{
	long pages = sysconf(_SC_PHYS_PAGES);
	long page_size = sysconf(_SC_PAGE_SIZE);
	return ((pages * page_size) / 1024L / 1024L);
}
#endif

forceinline double map_identity(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the idenity map-function
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return arg;
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return arg;
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return 1.0;
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_inverse(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the inverse map-function, assuming > 0
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return 1.0 / arg;
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return 1.0 / arg;
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return -1.0 / SQR(arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise. assuming positive...
		 */
		return 0.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_identity_scale(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the idenity map-function
	 */
	double scale = (param ? *((double *) param) : 1.0);

	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return arg * scale;
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return arg / scale;
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return scale;
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return (scale > 0 ? 1.0 : 0.0);
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_exp(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the exp-map-function
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return exp(arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return log(arg);
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return exp(arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_exp_scale(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the exp-map-function with scaling
	 */
	double scale = *((double *) param);
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return exp(scale * arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return log(arg) / scale;
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return exp(scale * arg) * scale;
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return (scale > 0.0 ? 1.0 : 0.0);
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_negexp(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the negexp-map-function
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return exp(-arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return -log(arg);
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return -exp(-arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 0.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

double map_exp_scale2(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the exp-map-function with a scale
	 */
	double *p = (double *) param;
	double a = p[0], b = p[1];

	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return a * exp(b * arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return log(arg / a) / b;
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return a * b * exp(b * arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return (map_exp_scale2(1.0, MAP_FORWARD, param) > map_exp_scale2(0.0, MAP_FORWARD, param) ? 1 : -1);
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_invrobit(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the inverse of the robit link: cdf of student t (scaled to have variance 1)
	 */
	double df_intern = *((double *) param);
	double df = map_dof(df_intern, MAP_FORWARD, NULL);
	double scale = sqrt(df / (df - 2.0));

	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return MATHLIB_FUN(pt) (arg / scale, df, 1, 0);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return MATHLIB_FUN(qt) (arg, df, 1, 0) * scale;
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return MATHLIB_FUN(dt) (arg / scale, df, 0) / scale;
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double inla_get_sn_param(inla_sn_arg_tp * output, double **param)
{
	// param = *(skew_intern, intercept_intern)
	return (map_invsn_core(0.0, MAP_FORWARD, (void *) param, output));
}

forceinline double map_invsn(double arg, map_arg_tp typ, void *param)
{
	return (map_invsn_core(arg, typ, param, NULL));
}

forceinline double map_invsn_core(double arg, map_arg_tp typ, void *param, inla_sn_arg_tp * output)
{
	// if 'output' is !NULL, just return the contents. its a backdoor avoid duplicating code

#define MAP(_x) log((_x)/(1.0 - (_x)))
#define iMAP(_x) (exp(_x)/(1.0+exp(_x)))
#define diMAP(_x) (exp(_x)/SQR(1.0+exp(_x)))

	/*
	 * the inverse link is the cdf of the sn, scaled to have E()=1 and Var()=1
	 */
	static inla_sn_table_tp **table = NULL;
	static char first = 1;

	int i, j, id = 0;
	const int debug = 0;
	double alpha, dx = 0.02, range = 10.0, p, pp, omega, delta, xi, skew, skew_intern, skew_max = GMRFLib_SN_SKEWMAX;
	double **par, intercept, intercept_intern, intercept_alpha;

	par = (double **) param;
	assert(par);
	assert(par[0]);
	assert(par[1]);
	skew_intern = *(par[0]);
	intercept_intern = *(par[1]);

	// parameters are SKEW and INTERCEPT
	skew = map_phi(skew_intern, MAP_FORWARD, (void *) &skew_max);
	if (!ISNAN(intercept_intern)) {
		intercept_alpha = map_probability(intercept_intern, MAP_FORWARD, NULL);
	} else {
		intercept_alpha = NAN;
	}

	if (debug) {
		printf("map_invsn: enter with arg= %g, skew= %g, intercept_alpha= %g\n", arg, skew, intercept_alpha);
	}

	if (first) {
#pragma omp critical (Name_375605f5a0a02853485931b7541aa2de0692bb42)
		if (first) {
			if (debug) {
				fprintf(stderr, "map_invsn: build table\n");
			}
			table = Calloc(GMRFLib_CACHE_LEN, inla_sn_table_tp *);
			for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
				table[i] = Calloc(1, inla_sn_table_tp);
				table[i]->alpha = INLA_REAL_BIG;
				table[i]->cdf = NULL;
				table[i]->icdf = NULL;
			}
			first = 0;
		}
	}

	alpha = inla_pc_sn_skew2alpha(skew);
	delta = alpha / sqrt(1.0 + SQR(alpha));
	omega = 1.0 / sqrt(1.0 - 2.0 * SQR(delta) / M_PI);
	xi = -omega * delta * sqrt(2.0 / M_PI);
	GMRFLib_CACHE_SET_ID(id);
	if (debug) {
		printf("...this gives alpha= %g, delta= %g, omega= %g, xi= %g\n", alpha, delta, omega, xi);
	}

	if (!ISEQUAL(alpha, table[id]->alpha)) {
		int len = (int) (2.0 * range / dx + 0.5) + 1, llen = 0;
		double *work, *x, *y, *yy, nc = 0.0, xx;

		if (debug) {
			fprintf(stderr, "map_invsn: build new table for alpha=%g id=%1d\n", alpha, id);
		}

		work = Calloc(3 * len, double);
		x = work;
		y = work + len;
		yy = work + 2 * len;

		for (xx = -range, i = 0, llen = 0; xx <= range; xx += dx, i++) {
			x[i] = xx;
			if (alpha != 0.0) {
				double z = (xx - xi) / omega;
				y[i] = 2.0 / omega * MATHLIB_FUN(dnorm) (z, 0.0, 1.0, 0) * MATHLIB_FUN(pnorm) (alpha * z, 0.0, 1.0, 1, 0);
			} else {
				y[i] = MATHLIB_FUN(dnorm) (xx, 0.0, 1.0, 0);
			}
			llen++;
		}
		len = llen;

		if (debug) {
			// check that we have done it right...
			double mom[4] = { 0, 0, 0, 0 }, negative = 0;
			for (i = 0; i < len; i++) {
				mom[0] += y[i];
				mom[1] += y[i] * x[i];
				mom[2] += y[i] * SQR(x[i]);
				mom[3] += y[i] * gsl_pow_3(x[i]);
				negative += y[i] * (x[i] < 0);
			}
			mom[1] /= mom[0];
			mom[2] /= mom[0];
			mom[3] /= mom[0];
			negative /= mom[0];
			printf("map_invsn: alpha= %.6g, negative= %.6g moments: %.6g %.6g %.6g\n", alpha, negative, mom[1], mom[2], mom[3]);
		}

		for (i = j = 0; i < len; i++) {
			if (!ISNAN(y[i]) && !ISINF(y[i])) {
				x[j] = x[i];
				y[j] = y[i];
				j++;
			}
		}
		len = j;

		for (i = 0, nc = 0.0; i < len; i++) {
			nc += y[i];
		}

		nc = 1.0 / nc;
		for (i = 0; i < len; i++) {
			y[i] *= nc;
		}

		yy[0] = y[0];
		for (i = 1; i < len; i++) {
			yy[i] = yy[i - 1] + (y[i] + y[i - 1]) / 2.0;
		}
		for (i = 0; i < len; i++) {
			y[i] = MAP(yy[i]);
		}

		for (i = j = 0; i < len; i++) {
			if (!ISNAN(y[i]) && !ISINF(y[i])) {
				x[j] = x[i];
				y[j] = y[i];
				j++;
			}
		}
		len = j;
		// Remove values in 'y' that are to close (difference is to small)
		GMRFLib_unique_additive2(&len, y, x, GMRFLib_eps(0.75));

		table[id]->alpha = alpha;
		table[id]->xmin = x[0];
		table[id]->xmax = x[len - 1];
		table[id]->pmin = iMAP(y[0]);
		table[id]->pmax = iMAP(y[len - 1]);

		GMRFLib_spline_free(table[id]->cdf);	       /* ok if NULL */
		GMRFLib_spline_free(table[id]->icdf);	       /* ok if NULL */

		table[id]->cdf = GMRFLib_spline_create(x, y, len);
		table[id]->icdf = GMRFLib_spline_create(y, x, len);
		Free(work);
	}

	// ...as the mapping using this reparameterisation
	if (!ISNAN(intercept_intern)) {
		intercept = GMRFLib_spline_eval(intercept_intern, table[id]->icdf);
	} else {
		// this removes the intercept from the model
		intercept = 0.0;
	}

	if (debug) {
		printf("... intercept_alpha= %g intercept= %g\n", intercept_alpha, intercept);
	}

	if (output) {
		output->omega = omega;
		output->xi = xi;
		output->intercept = intercept;
		output->alpha = alpha;
		return 0.0;
	}

	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		arg = TRUNCATE(intercept + arg, table[id]->xmin, table[id]->xmax);
		p = GMRFLib_spline_eval(arg, table[id]->cdf);
		return iMAP(p);

	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		arg = TRUNCATE(arg, table[id]->pmin, table[id]->pmax);
		return GMRFLib_spline_eval(MAP(arg), table[id]->icdf) - intercept;

	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		arg = TRUNCATE(intercept + arg, table[id]->xmin, table[id]->xmax);
		p = GMRFLib_spline_eval(arg, table[id]->cdf);
		pp = GMRFLib_spline_eval_deriv(arg, table[id]->cdf);
		return diMAP(p) * pp;

	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise
		 */
		return 1.0;

	default:
		abort();
	}
	abort();

#undef MAP
#undef iMAP
#undef diMAP
	return 0.0;
}

forceinline double map_invprobit(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the inverse probit function
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return gsl_cdf_ugaussian_P(arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return gsl_cdf_ugaussian_Pinv(arg);
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return gsl_ran_ugaussian_pdf(arg);

	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_invloglog(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the inverse loglog function
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return exp(-exp(-arg));
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return -log(-log(arg));
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return exp(-arg - exp(-arg));
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_invcauchit(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the inverse cauchit function
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return M_1_PI * atan(arg) + 0.5;
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return tan(M_PI * (arg - 0.5));
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return M_1_PI / (SQR(arg) + 1.0);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_invcloglog(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the inverse cloglog function
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return ONE_MINUS_EXP(-exp(arg));
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return log(-LOG_ONE_MINUS(arg));
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return exp(arg - exp(arg));
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_beta(double x, map_arg_tp typ, void *param)
{
	/*
	 * the map for the beta parameter, which can have a lower and upper range as well. If range.low=range.high, then its
	 * interpreted as range.low = -INF and range.high = INF, ie the mapping is the identity. If range.high = INF and
	 * range.low != INF, then the mapping is range.low + exp(...).
	 */

	double *range = (double *) param;

	if (param == NULL || ISEQUAL(range[0], range[1])) {
		return map_identity(x, typ, param);
	}

	if (ISINF(range[1]) && !ISINF(range[0])) {
		switch (typ) {
		case MAP_FORWARD:
			/*
			 * extern = func(local) 
			 */
			return range[0] + exp(x);
		case MAP_BACKWARD:
			/*
			 * local = func(extern) 
			 */
			return log(x - range[0]);
		case MAP_DFORWARD:
			/*
			 * d_extern / d_local 
			 */
			return exp(x);
		case MAP_INCREASING:
			/*
			 * return 1.0 if montone increasing and 0.0 otherwise 
			 */
			return 1.0;
		default:
			abort();
		}
	} else if (ISINF(range[0]) && !ISINF(range[1])) {
		FIXME("the case: ISINF(range[0]) && !ISINF(range[1]), is not yet implemented.");
		exit(EXIT_FAILURE);
	} else {
		/*
		 * Then the mapping is
		 * 
		 * range[0] + exp(x)/(1 + exp(x)) * (range[1] - range[0]) 
		 */

		double d = range[1] - range[0], xx;

		switch (typ) {
		case MAP_FORWARD:
			return range[0] + d * exp(x) / (1.0 + exp(x));
		case MAP_BACKWARD:
			xx = (x - range[0]) / d;
			return log(xx / (1.0 - xx));
		case MAP_DFORWARD:
			xx = exp(x);
			return d * xx / SQR(1.0 + xx);
		case MAP_INCREASING:
			return 1.0;
		default:
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}
	}
	return 0.0;
}

forceinline double map_1exp(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the 1/exp-map-function
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return exp(-arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return -log(arg);
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return -exp(-arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 0.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_sqrt1exp(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the sqrt(1/exp) map
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return exp(-0.5 * arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return -2.0 * log(arg);
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return -0.5 * exp(-0.5 * arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 0.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_dof(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the map-function for the degrees of freedom for the student-t 
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return 2.0 + exp(arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return log(arg - 2.0);
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return exp(arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_dof5(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the map-function for the degrees of freedom for the student-t 
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return 5.0 + exp(arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return log(arg - 5.0);
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return exp(arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_phi(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the map-function for the lag-1 correlation in the AR(1) model. The
	 * extra argument, if present, is the range (default = 1)
	 */
	double xx;
	double range = (param ? *((double *) param) : 1.0);

	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		xx = exp(arg);
		return (range * (2.0 * (xx / (1.0 + xx)) - 1.0));
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return log((1.0 + arg / range) / (1.0 - arg / range));
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		xx = exp(arg);
		return (range * 2.0 * xx / SQR(1.0 + xx));
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return (range >= 0 ? 1.0 : -1.0);
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_rho(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the map-function for the correlation in the 2D iid model
	 */
	return map_phi(arg, typ, param);
}

forceinline double map_precision(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the map-function for the precision variables 
	 */
	return map_exp(arg, typ, param);
}

forceinline double map_range(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the map-function for the range
	 */
	return map_exp(arg, typ, param);
}

forceinline double map_alpha_weibull(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the map-function for the range
	 */
	double scale = INLA_WEIBULL_ALPHA_SCALE;
	return map_exp_scale(arg, typ, (void *) &scale);
}

forceinline double map_alpha_gompertz(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the map-function for the range
	 */
	double scale = INLA_GOMPERTZ_ALPHA_SCALE;
	return map_exp_scale(arg, typ, (void *) &scale);
}

forceinline double map_prec_qkumar(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the map-function for the precision
	 */
	double scale = INLA_QKUMAR_PREC_SCALE;
	return map_exp_scale(arg, typ, (void *) &scale);
}

forceinline double map_p_weibull_cure(double arg, map_arg_tp typ, void *param)
{
	/*
	 * the map-function for the p parameter in L_WEIBULL_CURE
	 */
	return map_invlogit(arg, typ, param);
}

forceinline double map_invlogit(double x, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * extern = exp(local) / (1 + exp(local)) 
	 */
	double xx;

	switch (typ) {
	case MAP_FORWARD:
		xx = exp(x);
		return xx / (1.0 + xx);
	case MAP_BACKWARD:
		return log(x / (1.0 - x));
	case MAP_DFORWARD:
		xx = exp(x);
		return xx / SQR(1.0 + xx);
	case MAP_INCREASING:
		return 1.0;
	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
	return 0.0;
}

forceinline double map_probability(double x, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * extern = exp(local) / (1 + exp(local)) 
	 */
	double xx;

	switch (typ) {
	case MAP_FORWARD:
		xx = exp(x);
		return xx / (1.0 + xx);
	case MAP_BACKWARD:
		return log(x / (1.0 - x));
	case MAP_DFORWARD:
		xx = exp(x);
		return xx / SQR(1.0 + xx);
	case MAP_INCREASING:
		return 1.0;
	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
	return 0.0;
}

forceinline double map_shape_svnig(double arg, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * the mapping for the shape-parameters in the stochvol-nig model. shape = 1 + exp(shape_intern)
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return 1.0 + exp(arg);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return log(arg - 1.0);
	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		return exp(arg);
	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise 
		 */
		return 1.0;
	default:
		abort();
	}
	abort();
	return 0.0;
}

forceinline double map_H(double x, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * extern = 1/2  + 1/2 * exp(local) / (1 + exp(local)) 
	 */
	double xx;

	switch (typ) {
	case MAP_FORWARD:
		xx = exp(x);
		return 0.5 + 0.5 * xx / (1.0 + xx);
	case MAP_BACKWARD:
		return log((2.0 * x - 1.0) / (2.0 * (1.0 - x)));
	case MAP_DFORWARD:
		xx = exp(x);
		return 0.5 * xx / SQR(1.0 + xx);
	case MAP_INCREASING:
		return 1.0;
	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
	return 0.0;
}

forceinline double map_interval(double x, map_arg_tp typ, void *param)
{
	/*
	 * extern = A  + (B-A) * exp(C * local) / (1 + exp(C * local)) ,  B > A, C>0
	 */
	double *ABC = (double *) param;
	double A = ABC[0];
	double B = ABC[1];
	double C = 1.0;					       /* no longer in use */
	double ex;

	// printf("%g %g %g %g %g\n", x, A, B, C, (double) typ);

	switch (typ) {
	case MAP_FORWARD:
		ex = exp(C * x);
		return A + (B - A) * ex / (1.0 + ex);
	case MAP_BACKWARD:
		return log(-(A - x) / (B - x)) / C;
	case MAP_DFORWARD:
		ex = exp(C * x);
		return C * (B - A) * ex / SQR(1.0 + ex);
	case MAP_INCREASING:
		return 1.0;
	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
	return 0.0;
}

forceinline double map_group_rho(double x, map_arg_tp typ, void *param)
{
	/*
	 * extern = 
	 */
	assert(param != NULL);
	int ngroups = *((int *) param);
	double xx;

	switch (typ) {
	case MAP_FORWARD:
		xx = exp(x);
		return (xx - 1.0) / (xx + ngroups - 1.0);
	case MAP_BACKWARD:
		return log((1.0 + (ngroups - 1.0) * x) / (1.0 - x));
	case MAP_DFORWARD:
		xx = exp(x);
		return (xx * ngroups) / SQR(xx + ngroups - 1.0);
	case MAP_INCREASING:
		return 1.0;
	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
	return 0.0;
}

forceinline double map_invtan(double x, map_arg_tp typ, void *UNUSED(param))
{
	/*
	 * y = 2*atan(x), so that |y| <= Pi
	 */
	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		return 2.0 * atan(x);
	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		return tan(x / 2.0);
	case MAP_DFORWARD:
		return 2.0 / (1.0 + SQR(x));
	case MAP_INCREASING:
		return 1.0;
	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
	return 0.0;
}

forceinline double link_this_should_not_happen(int UNUSED(thread_id), double UNUSED(x), map_arg_tp UNUSED(typ), void *UNUSED(param),
					       double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	FIXMEstderr("This function is called because a wrong link function is used.");
	abort();
	return 0.0;
}

forceinline double link_probit(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_invprobit(x, typ, param);
}

forceinline double link_robit(int thread_id, double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	Link_param_tp *p = (Link_param_tp *) param;
	double dof_intern = p->dof_intern[thread_id][0];

	return map_invrobit(x, typ, (void *) &dof_intern);
}

forceinline double link_sn(int thread_id, double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	Link_param_tp *p = (Link_param_tp *) param;
	double skew = p->sn_skew[thread_id][0], intercept = p->sn_intercept[thread_id][0], *par[2];

	par[0] = &skew;
	par[1] = &intercept;

	return map_invsn(x, typ, (void *) par);
}

forceinline double link_power_logit(int thread_id, double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	Link_param_tp *p = (Link_param_tp *) param;
	double power = p->power_intern[thread_id][0];
	double intercept = p->intercept_intern[thread_id][0];
	double *par[2];

	par[0] = &power;
	par[1] = &intercept;

	return map_inv_powerlink_core(x, typ, (void *) par, NULL);
}

forceinline double link_tan(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	return map_invtan(x, typ, param);
}

forceinline double link_cloglog(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_invcloglog(x, typ, param);
}

forceinline double link_loglog(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_invloglog(x, typ, param);
}

forceinline double link_cauchit(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_invcauchit(x, typ, param);
}

forceinline double link_log(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_exp(x, typ, param);
}

forceinline double link_loga(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
#define MAP(_x) log((_x)/(1.0 - (_x)))
#define iMAP(_x) (exp(_x)/(1.0+exp(_x)))
#define diMAP(_x) (exp(_x)/SQR(1.0+exp(_x)))

	Link_param_tp *par = (Link_param_tp *) param;
	double a = par->a;

	static inla_loga_table_tp **table = NULL;
	static char first = 1;

	int i, id = 0;
	const int debug = 0;
	double dx = 0.1, xx, range = 25.0, p, pp;

	if (first) {
#pragma omp critical (Name_a862df53446b09ea53b4bd233636df42f8acd1ff)
		if (first) {
			if (debug) {
				fprintf(stderr, "link_loga: init tables\n");
			}
			table = Calloc(GMRFLib_CACHE_LEN, inla_loga_table_tp *);
			for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
				table[i] = Calloc(1, inla_loga_table_tp);
				table[i]->a = NAN;
				table[i]->cdf = NULL;
				table[i]->icdf = NULL;
			}
			first = 0;
		}
	}

	GMRFLib_CACHE_SET_ID(id);
	if (a != table[id]->a) {
		int len, llen;
		double *work, *x, *y, p;
		if (debug) {
			fprintf(stderr, "link_loga: build new table for a=%g [%1d]\n", a, id);
		}

		// count to find the length
		for (xx = -range, len = 0; xx <= 2 * range; xx += (ABS(xx) < 3.0 ? dx / 5.0 : dx), len++);
		work = x = Calloc(2 * len, double);
		y = work + len;

		for (xx = -range, i = 0, llen = 0; xx <= 2 * range; xx += (ABS(xx) < 3.0 ? dx / 5.0 : dx), i++, llen++) {
			p = iMAP(xx);
			if (p == 1.0) {
				// no point of going further if this happens. we need this as a small value of 'a' makes this
				// happen rather quickly
				break;
			}
			y[i] = xx;
			x[i] = log(p) - a * LOG_ONE_MINUS(p);  // log(p/(1-p)^a)
		}
		len = llen;

		table[id]->a = a;
		table[id]->p_intern_min = y[0];
		table[id]->p_intern_max = y[len - 1];
		table[id]->eta_min = x[0];
		table[id]->eta_max = x[len - 1];

		GMRFLib_spline_free(table[id]->cdf);	       /* ok if NULL */
		GMRFLib_spline_free(table[id]->icdf);	       /* ok if NULL */

		table[id]->cdf = GMRFLib_spline_create(x, y, len);
		table[id]->icdf = GMRFLib_spline_create(y, x, len);
		Free(work);
	}

	switch (typ) {
	case MAP_FORWARD:
		/*
		 * extern = func(local) 
		 */
		x = TRUNCATE(x, table[id]->eta_min, table[id]->eta_max);
		p = GMRFLib_spline_eval(x, table[id]->cdf);
		return (iMAP(p));

	case MAP_BACKWARD:
		/*
		 * local = func(extern) 
		 */
		x = TRUNCATE(MAP(x), table[id]->p_intern_min, table[id]->p_intern_max);
		return GMRFLib_spline_eval(x, table[id]->icdf);

	case MAP_DFORWARD:
		/*
		 * d_extern / d_local 
		 */
		x = TRUNCATE(x, table[id]->eta_min, table[id]->eta_max);
		p = GMRFLib_spline_eval(x, table[id]->cdf);
		pp = GMRFLib_spline_eval_deriv(x, table[id]->cdf);
		return diMAP(p) * pp;

	case MAP_INCREASING:
		/*
		 * return 1.0 if montone increasing and 0.0 otherwise
		 */
		return 1.0;

	default:
		abort();
	}
	abort();

	return 0.0;
}

forceinline double link_neglog(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_negexp(x, typ, param);
}

forceinline double link_logit(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_invlogit(x, typ, param);
}

forceinline double link_identity(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_identity(x, typ, param);
}

forceinline double link_inverse(int UNUSED(thread_id), double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	return map_inverse(x, typ, param);
}

forceinline double link_logoffset(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	Link_param_tp *p;
	double beta, off, sign;

	if (!cov) {
		char *msg;
		GMRFLib_sprintf(&msg, "You need to pass the covariates to the link.model[logoffset] in the inla()-argument 'link.covariates'");
		inla_error_general(msg);
		exit(1);
	}
	if (cov[0] < 0.0) {
		char *msg;
		GMRFLib_sprintf(&msg, "The covariates to link.model[logoffset] must be all >= 0.0. Yours is [%g].", cov[0]);
		inla_error_general(msg);
		exit(1);
	}

	p = (Link_param_tp *) param;
	beta = exp(p->beta_intern[thread_id][0]);
	off = beta * cov[0];
	sign = (p->variant == 0 ? 1.0 : -1.0);

	switch (typ) {
	case MAP_FORWARD:
		return off + sign * exp(x);
	case MAP_BACKWARD:
		return log(sign * (x - off));
	case MAP_DFORWARD:
		return sign * exp(x);
	case MAP_INCREASING:
		return sign;
	default:
		abort();
	}
	return NAN;
}

forceinline double link_logitoffset(int thread_id, double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	Link_param_tp *p;
	double prob;

	p = (Link_param_tp *) param;
	prob = map_probability(p->prob_intern[thread_id][0], MAP_FORWARD, NULL);

	switch (typ) {
	case MAP_FORWARD:
		return prob + (1.0 - prob) * map_probability(x, MAP_FORWARD, NULL);
	case MAP_BACKWARD:
		return map_probability((x - prob) / (1.0 - prob), MAP_BACKWARD, NULL);
	case MAP_DFORWARD:
		return (1.0 - prob) * map_probability(x, MAP_DFORWARD, NULL);
	case MAP_INCREASING:
		return 1.0;
	default:
		abort();
	}
	return NAN;
}

forceinline double link_sslogit(int thread_id, double x, map_arg_tp typ, void *param, double *UNUSED(cov))
{
	Link_param_tp *p;
	double sens, spec, a, b, xx;

	p = (Link_param_tp *) param;
	sens = map_probability(p->sensitivity_intern[thread_id][0], MAP_FORWARD, NULL);
	spec = map_probability(p->specificity_intern[thread_id][0], MAP_FORWARD, NULL);

	// sens * pi + (1-spec)*(1-pi) = a * pi + b
	a = sens + spec - 1.0;
	b = 1.0 - spec;

	switch (typ) {
	case MAP_FORWARD:
		return a / (1.0 + exp(-x)) + b;

	case MAP_BACKWARD:
		assert((x - b) / (x - b - a) > 0.0);
		return log((x - b) / (x - b - a));

	case MAP_DFORWARD:
		xx = exp(-x);
		return a * xx / SQR(1.0 + xx);

	case MAP_INCREASING:
		return (a > 0 ? 1 : 0);
	default:
		abort();
	}
	return NAN;
}

forceinline double link_special2(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	Link_param_tp *p;
	double beta, f;

	if (!cov) {
		char *msg;
		GMRFLib_sprintf(&msg, "You need to pass the covariate to the link.model[special2] in the inla()-argument 'link.covariates'");
		inla_error_general(msg);
		exit(1);
	}
	if (cov[0] <= 0.0 || cov[0] >= 1.0) {
		char *msg;
		GMRFLib_sprintf(&msg, "The covariate to link.model[special2] must be between 0 and 1. Your is [%g].", cov[0]);
		inla_error_general(msg);
		exit(1);
	}

	p = (Link_param_tp *) param;
	beta = p->beta[thread_id][0];
	f = (1.0 - cov[0] + cov[0] * exp(beta));

	switch (typ) {
	case MAP_FORWARD:
		return exp(x) * f;
	case MAP_BACKWARD:
		return log(x / f);
	case MAP_DFORWARD:
		return exp(x) * f;
	case MAP_INCREASING:
		return 1.0;
	default:
		abort();
	}
	return NAN;

}

double link_qpoisson(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	double shape, ret = 0.0;
	Link_param_tp *lparam = (Link_param_tp *) param;

	switch (typ) {
	case INVLINK:
	{
		shape = exp(x) + 1.0;
		if (shape > 400.0) {
			ret = SQR(sqrt(shape) + sqrt(0.25) * gsl_cdf_ugaussian_Qinv(lparam->quantile));
		} else {
			ret = gsl_cdf_gamma_Qinv(lparam->quantile, shape, 1.0);
		}
	}
		break;

	case LINK:
	{
		CODE_NEEDED;
	}
		break;

	case DINVLINK:
	{
		double dx = GMRFLib_eps(1.0 / 3.9134);	       // about 0.0001 on my laptop
		double wf[] = { 1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0 };
		double wf_sum = 0.0;
		int i, nwf = sizeof(wf) / sizeof(double), nwf2 = (nwf - 1) / 2;	/* gives 5 and 2 */

		for (i = 0; i < nwf; i++) {
			wf_sum += wf[i] * link_qpoisson(thread_id, x + (i - nwf2) * dx, INVLINK, param, cov);
		}
		ret = wf_sum / dx;
	}
		break;

	case LINKINCREASING:
	{
		return 1.0;
	}
		break;

	default:
	{
		assert(0 == 1);
	}
		break;

	}

	return (ret);
}

double link_qweibull(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	Link_param_tp *lparam = (Link_param_tp *) param;
	double alpha = map_alpha_weibull(lparam->alpha_intern[thread_id][0], MAP_FORWARD, NULL);
	double ret = 0.0;

	switch (typ) {
	case INVLINK:
	{
		switch (lparam->variant) {
		case 0:
		{
			ret = -1.0 / pow(exp(x), alpha) * LOG_ONE_MINUS(lparam->quantile);
		}
			break;
		case 1:
		{
			ret = 1.0 / exp(x) * pow(-LOG_ONE_MINUS(lparam->quantile), 1.0 / alpha);
		}
			break;
		default:
			assert(0 == 1);
		}
	}
		break;

	case LINK:
	{
		CODE_NEEDED;
	}
		break;

	case DINVLINK:
	{
		double dx = GMRFLib_eps(1.0 / 3.9134);	       // about 0.0001 on my laptop
		double wf[] = { 1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0 };
		double wf_sum = 0.0;
		int i, nwf = sizeof(wf) / sizeof(double), nwf2 = (nwf - 1) / 2;	/* gives 5 and 2 */

		for (i = 0; i < nwf; i++) {
			wf_sum += wf[i] * link_qweibull(thread_id, x + (i - nwf2) * dx, INVLINK, param, cov);
		}
		ret = wf_sum / dx;
	}
		break;

	case LINKINCREASING:
	{
		int ret_val = 0;
		static int do_check[2] = { 1, 1 };

		if (do_check[lparam->variant]) {
#pragma omp critical (Name_e77483d42a508f8162880242479cd58817992341)
			if (do_check[lparam->variant]) {
				if (ret_val !=
				    (link_qweibull(thread_id, x + 1.0, INVLINK, param, cov) >
				     link_qweibull(thread_id, x, INVLINK, param, cov) ? 1 : 0)) {
					FIXME("LINKINCREASING has error in link_qweibull");
					exit(EXIT_FAILURE);
				}
				do_check[lparam->variant] = 0;
			}
		}
		return (ret_val);
	}
		break;

	default:
	{
		assert(0 == 1);
	}
		break;

	}

	return (ret);
}

double link_qgamma(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	Link_param_tp *lparam = (Link_param_tp *) param;
	double s = lparam->scale[lparam->idx];
	double phi_param = map_exp(lparam->log_prec[thread_id][0], MAP_FORWARD, NULL);
	double shape = phi_param * s;
	double ret = 0.0;

	switch (typ) {
	case INVLINK:
	{
		// ret = exp(x) * shape / MATHLIB_FUN(qgamma) (lparam->quantile, shape, 1.0, 1, 0);
		ret = exp(x) * shape / inla_qgamma_cache(shape, lparam->quantile, 0);
	}
		break;

	case LINK:
	{
		CODE_NEEDED;
	}
		break;

	case DINVLINK:
	{
		double dx = GMRFLib_eps(1.0 / 3.9134);	       // about 0.0001 on my laptop
		double wf[] = { 1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0 };
		double wf_sum = 0.0;
		int i, nwf = sizeof(wf) / sizeof(double), nwf2 = (nwf - 1) / 2;	/* gives 5 and 2 */

		for (i = 0; i < nwf; i++) {
			wf_sum += wf[i] * link_qgamma(thread_id, x + (i - nwf2) * dx, INVLINK, param, cov);
		}
		ret = wf_sum / dx;
	}
		break;

	case LINKINCREASING:
	{
		ret = 1;
	}
		break;

	default:
	{
		assert(0 == 1);
	}
		break;

	}

	return (ret);
}

double link_qbinomial(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	// individual link
	Link_param_tp *lparam = (Link_param_tp *) param;
	double q, ret = 0.0;

	switch (typ) {
	case INVLINK:
	{
		q = 1.0 / (1.0 + exp(-x));
		ret = MATHLIB_FUN(qbeta) (lparam->quantile, q + 1.0, 1.0 - q, 0, 0);
	}
		break;

	case LINK:
	{
		CODE_NEEDED;
	}
		break;

	case DINVLINK:
	{
		double dx = GMRFLib_eps(1.0 / 3.9134);	       // about 0.0001 on my laptop
		double wf[] = { 1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0 };
		double wf_sum = 0.0;
		int i, nwf = sizeof(wf) / sizeof(double), nwf2 = (nwf - 1) / 2;	/* gives 5 and 2 */

		for (i = 0; i < nwf; i++) {
			wf_sum += wf[i] * link_qbinomial(thread_id, x + (i - nwf2) * dx, INVLINK, param, cov);
		}
		ret = wf_sum / dx;
	}
		break;

	case LINKINCREASING:
	{
		return 1.0;
	}
		break;

	default:
	{
		assert(0 == 1);
	}
		break;

	}

	return (ret);
}

double link_pqbinomial(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	// population link
	Link_param_tp *lparam = (Link_param_tp *) param;
	double q, ret = 0.0;

	switch (typ) {
	case INVLINK:
	{
		q = 1.0 / (1.0 + exp(-x));
		ret = MATHLIB_FUN(qbeta) (lparam->quantile, lparam->Ntrial * q + 1.0, lparam->Ntrial * (1.0 - q), 0, 0);
	}
		break;

	case LINK:
	{
		CODE_NEEDED;
	}
		break;

	case DINVLINK:
	{
		double dx = GMRFLib_eps(1.0 / 3.9134);	       // about 0.0001 on my laptop
		double wf[] = { 1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0 };
		double wf_sum = 0.0;
		int i, nwf = sizeof(wf) / sizeof(double), nwf2 = (nwf - 1) / 2;	/* gives 5 and 2 */

		for (i = 0; i < nwf; i++) {
			wf_sum += wf[i] * link_pqbinomial(thread_id, x + (i - nwf2) * dx, INVLINK, param, cov);
		}
		ret = wf_sum / dx;
	}
		break;

	case LINKINCREASING:
	{
		return 1.0;
	}
		break;

	default:
	{
		assert(0 == 1);
	}
		break;

	}

	return (ret);
}

forceinline double link_test1(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	/*
	 * the link-functions calls the inverse map-function 
	 */
	Link_param_tp *p;
	double beta;

	p = (Link_param_tp *) param;
	beta = p->beta[thread_id][0];

	return map_exp(x - beta * cov[0], typ, param);
}

forceinline double link_special1(int thread_id, double x, map_arg_tp typ, void *param, double *cov)
{
	Link_param_tp *p;
	int i;
	double covariate_contribution, h = 1.0E-4, prec;

	p = (Link_param_tp *) param;
	prec = map_precision(p->log_prec[thread_id][0], MAP_FORWARD, NULL);
	covariate_contribution = 0.0;
	for (i = 0; i < p->order; i++) {
		covariate_contribution += p->betas[i][thread_id][0] * cov[i];
	}
	assert(!ISNAN(covariate_contribution));

	switch (typ) {
	case MAP_FORWARD:
	{
		return gsl_cdf_lognormal_Pinv(inla_Phi(x), covariate_contribution - 0.5 / prec, 1.0 / sqrt(prec));
	}
		break;

	case MAP_BACKWARD:
	{
		return gsl_cdf_ugaussian_Pinv(gsl_cdf_lognormal_P(x, covariate_contribution - 0.5 / prec, 1.0 / sqrt(prec)));
	}
		break;

	case MAP_DFORWARD:
	{
		return (gsl_cdf_lognormal_Pinv(inla_Phi(x + h), covariate_contribution - 0.5 / prec, 1.0 / sqrt(prec)) -
			gsl_cdf_lognormal_Pinv(inla_Phi(x - h), covariate_contribution - 0.5 / prec, 1.0 / sqrt(prec))) / (2.0 * h);
	}
		break;

	case MAP_INCREASING:
	{
		return 1.0;
	}
		break;

	default:
		abort();
	}

	abort();
	return 0.0;
}

int inla_make_ar1c_graph(GMRFLib_graph_tp ** graph_out, inla_ar1c_arg_tp * def)
{
	int i, j;
	GMRFLib_ged_tp *ged = NULL;

	GMRFLib_ged_init(&ged, NULL);
	for (i = 0; i < def->n - 1; i++) {		       /* this is the AR1 part */
		GMRFLib_ged_add(ged, i, i + 1);		       /* diag is added in _ged_add() */
	}
	for (i = 0; i < def->m; i++) {			       /* fill the dense beta-block */
		for (j = i + 1; j < def->m; j++) {
			GMRFLib_ged_add(ged, def->n + i, def->n + j);
		}
	}
	for (i = 0; i < def->n; i++) {			       /* the interaction */
		for (j = 0; j < def->m; j++) {
			GMRFLib_ged_add(ged, i, def->n + j);
		}
	}
	assert(ged->n == def->N);
	GMRFLib_ged_build(graph_out, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

int inla_make_besag2_graph(GMRFLib_graph_tp ** graph_out, GMRFLib_graph_tp * graph)
{
	int i;
	GMRFLib_ged_tp *ged = NULL;

	GMRFLib_ged_init(&ged, graph);
	for (i = 0; i < graph->n; i++) {
		GMRFLib_ged_add(ged, i, i + graph->n);
	}
	GMRFLib_ged_build(graph_out, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

int inla_make_2diid_graph(GMRFLib_graph_tp ** graph, inla_2diid_arg_tp * arg)
{
	int i;
	GMRFLib_ged_tp *ged = NULL;

	GMRFLib_ged_init(&ged, NULL);
	for (i = 0; i < 2 * arg->n; i += 2) {
		GMRFLib_ged_add(ged, i, i + 1);
	}
	GMRFLib_ged_build(graph, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

int inla_make_2diid_wishart_graph(GMRFLib_graph_tp ** graph, inla_2diid_arg_tp * arg)
{
	int i;
	GMRFLib_ged_tp *ged = NULL;

	GMRFLib_ged_init(&ged, NULL);
	for (i = 0; i < arg->n; i++) {
		GMRFLib_ged_add(ged, i, i + arg->n);
	}
	GMRFLib_ged_build(graph, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

int inla_make_iid_wishart_graph(GMRFLib_graph_tp ** graph, inla_iid_wishart_arg_tp * arg)
{
	int i, j, k, n = arg->n, dim = arg->dim;

	GMRFLib_ged_tp *ged = NULL;

	GMRFLib_ged_init(&ged, NULL);
	for (i = 0; i < n; i++) {
		GMRFLib_ged_add(ged, i, i);
		for (j = 0; j < dim; j++) {
			for (k = j + 1; k < dim; k++) {
				GMRFLib_ged_add(ged, i + j * n, i + k * n);
			}
		}
	}
	GMRFLib_ged_build(graph, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

int inla_make_iid_wishartk_graph(GMRFLib_graph_tp ** graph, inla_iid_wishartk_arg_tp * arg)
{
	int i, j, k, n = arg->n, dim = arg->dim;
	GMRFLib_ged_tp *ged = NULL;

	GMRFLib_ged_init(&ged, NULL);
	for (i = 0; i < n; i++) {
		GMRFLib_ged_add(ged, i, i);
		for (j = 0; j < dim; j++) {
			for (k = j + 1; k < dim; k++) {
				GMRFLib_ged_add(ged, i + j * n, i + k * n);
			}
		}
	}
	GMRFLib_ged_build(graph, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

int inla_make_rw2diid_graph(GMRFLib_graph_tp ** graph, GMRFLib_rw2ddef_tp * def)
{
	int i, n;
	GMRFLib_ged_tp *ged = NULL;
	GMRFLib_graph_tp *g;

	n = def->nrow * def->ncol;
	GMRFLib_make_rw2d_graph(&g, def);
	GMRFLib_ged_init2(&ged, n);
	GMRFLib_ged_append_graph(ged, g);
	for (i = 0; i < n; i++) {
		GMRFLib_ged_add(ged, i, i + n);
	}
	GMRFLib_ged_build(graph, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

int inla_make_bym_graph(GMRFLib_graph_tp ** new_graph, GMRFLib_graph_tp * graph)
{
	/*
	 * for layout: see Qfunc_bym() 
	 */

	int i;
	int n = graph->n;
	GMRFLib_ged_tp *ged = NULL;

	GMRFLib_ged_init2(&ged, n);
	GMRFLib_ged_append_graph(ged, graph);
	for (i = 0; i < n; i++) {
		GMRFLib_ged_add(ged, i, i + n);
	}
	GMRFLib_ged_build(new_graph, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

double Qfunc_bym(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	/*
	 * the first half is the `linear predictor', the second half is the spatial term. x = [eta, z], eta|.. ~ N(z, prec*I), z ~ GMRF(prec) 
	 */

	inla_bym_Qfunc_arg_tp *a = (inla_bym_Qfunc_arg_tp *) arg;
	int n = a->n;
	double prec_iid = map_precision(a->log_prec_iid[thread_id][0], MAP_FORWARD, NULL);

	if (IMAX(i, j) < n) {
		/*
		 * the iid term 
		 */
		return prec_iid;
	}
	if (IMIN(i, j) >= n) {
		/*
		 * the spatial term + I*prec_iid 
		 */
		return (i == j ? prec_iid : 0.0) + Qfunc_besag(thread_id, i - n, j - n, NULL, a->besag_arg);
	} else {
		/*
		 * the cross-term which is -prec_iid 
		 */
		return -prec_iid;
	}

	/*
	 * should not happen 
	 */
	GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	return 0.0;
}

double Qfunc_bym2(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_bym2_Qfunc_arg_tp *a = (inla_bym2_Qfunc_arg_tp *) arg;
	int n = a->n;
	double prec = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	double phi = map_probability(a->logit_phi[thread_id][0], MAP_FORWARD, NULL);
	if (IMAX(i, j) < n) {
		return prec / (1.0 - phi);
	}
	if (IMIN(i, j) >= n) {
		return (i == j ? phi / (1.0 - phi) : 0.0) + Qfunc_besag(thread_id, i - n, j - n, NULL, a->besag_arg);
	}
	return -sqrt(phi * prec) / (1.0 - phi);
}

double Qfunc_rw2diid(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_rw2diid_Qfunc_arg_tp *a = (inla_rw2diid_Qfunc_arg_tp *) arg;
	int n = a->n;
	double prec = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	double phi = map_probability(a->logit_phi[thread_id][0], MAP_FORWARD, NULL);
	if (IMAX(i, j) < n) {
		return prec / (1.0 - phi);
	}
	if (IMIN(i, j) >= n) {
		return (i == j ? phi / (1.0 - phi) : 0.0) + GMRFLib_rw2d(thread_id, i - n, j - n, NULL, a->rw2ddef);
	}
	return -sqrt(phi * prec) / (1.0 - phi);
}

double Qfunc_group(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_group_def_tp *a = (inla_group_def_tp *) arg;
	ar_def_tp *ardef = NULL;
	double rho = 0, val, fac, ngroup, prec = 0;
	int igroup, irem, jgroup, jrem, n;

	switch (a->type) {
	case G_EXCHANGEABLE:
		rho = map_group_rho(a->group_rho_intern[thread_id][0], MAP_FORWARD, (void *) &(a->ngroup));
		break;

	case G_EXCHANGEABLE_POS:
		rho = map_probability(a->group_rho_intern[thread_id][0], MAP_FORWARD, (void *) &(a->ngroup));
		break;

	case G_AR1:
		rho = map_rho(a->group_rho_intern[thread_id][0], MAP_FORWARD, NULL);
		break;

	case G_AR:
		ardef = a->ardef;
		break;

	case G_IID:
	case G_RW1:
	case G_RW2:
	case G_BESAG:
		prec = map_precision(a->group_prec_intern[thread_id][0], MAP_FORWARD, NULL);
		break;

	default:
		inla_error_general("This should not happen.");
		abort();
	}

	n = a->N;					       /* this is the size before group */
	ngroup = a->ngroup;

	igroup = i / n;
	irem = i % n;
	jgroup = j / n;
	jrem = j % n;

	if (igroup == jgroup) {

		switch (a->type) {
		case G_EXCHANGEABLE:
		case G_EXCHANGEABLE_POS:
		{
			fac = -((ngroup - 2.0) * rho + 1.0) / ((rho - 1.0) * ((ngroup - 1.0) * rho + 1.0));
		}
			break;

		case G_AR1:
		{
			if (!(a->cyclic) && (igroup == 0 || igroup == ngroup - 1)) {
				fac = 1.0 / (1.0 - SQR(rho));
			} else {
				fac = (1.0 + SQR(rho)) / (1.0 - SQR(rho));
			}
		}
			break;

		case G_AR:
		{
			fac = Qfunc_ar(thread_id, igroup, jgroup, NULL, (void *) ardef);
		}
			break;

		case G_RW1:
		case G_RW2:
		{
			if (a->crwdef) {
				fac = prec * GMRFLib_crw(thread_id, igroup, jgroup, NULL, (void *) (a->crwdef));
			} else {
				fac = prec * GMRFLib_rw(thread_id, igroup, jgroup, NULL, (void *) (a->rwdef));
			}
		}
			break;

		case G_BESAG:
		{
			fac = prec * Qfunc_besag(thread_id, igroup, jgroup, NULL, (void *) (a->besagdef));
		}
			break;

		case G_IID:
		{
			fac = prec;
		}
			break;

		default:
			inla_error_general("This should not happen.");
			abort();
		}

		val = a->Qfunc(thread_id, irem, jrem, NULL, a->Qfunc_arg) * fac;
	} else {
		switch (a->type) {
		case G_EXCHANGEABLE:
		case G_EXCHANGEABLE_POS:
		{
			fac = rho / ((rho - 1.0) * ((ngroup - 1.0) * rho + 1.0));
		}
			break;

		case G_AR1:
		{
			fac = -rho / (1.0 - SQR(rho));
		}
			break;

		case G_AR:
		{
			fac = Qfunc_ar(thread_id, igroup, jgroup, NULL, (void *) ardef);
		}
			break;

		case G_RW1:
		case G_RW2:
		{
			if (a->crwdef) {
				fac = prec * GMRFLib_crw(thread_id, igroup, jgroup, NULL, (void *) (a->crwdef));
			} else {
				fac = prec * GMRFLib_rw(thread_id, igroup, jgroup, NULL, (void *) (a->rwdef));
			}
		}
			break;

		case G_BESAG:
		{
			fac = prec * Qfunc_besag(thread_id, igroup, jgroup, NULL, (void *) (a->besagdef));
		}
			break;

		case G_IID:
		{
			fac = prec * 0.0;
		}
			break;

		default:
			inla_error_general("This should not happen.");
			abort();
		}

		val = a->Qfunc(thread_id, irem, jrem, NULL, a->Qfunc_arg) * fac;
	}

	return val;
}

int inla_make_group_graph(GMRFLib_graph_tp ** new_graph, GMRFLib_graph_tp * graph, int ngroup, int type, int cyclic, int order,
			  GMRFLib_graph_tp * group_graph)
{
	int i, j, n = graph->n;
	const int debug = 0;
	GMRFLib_ged_tp *ged = NULL;

	GMRFLib_ged_init(&ged, NULL);
	for (i = 0; i < ngroup; i++) {
		GMRFLib_ged_append_graph(ged, graph);
	}

	if (debug) {
		P(n);
		P(ngroup);
		P(graph->n);
		P(group_graph->n);
		P(ged->n);
		P(n * ngroup - 1);
	}

	switch (type) {
	case G_EXCHANGEABLE:
	case G_EXCHANGEABLE_POS:
	{
		assert(cyclic == 0);
		for (i = 0; i < ngroup; i++) {
			for (j = i + 1; j < ngroup; j++) {
				GMRFLib_ged_insert_graph2(ged, graph, i * n, j * n);
			}
		}
	}
		break;

	case G_AR1:
	{
		assert(ngroup >= 2);
		for (i = 0; i < ngroup - 1; i++) {
			GMRFLib_ged_insert_graph2(ged, graph, i * n, (i + 1) * n);
		}
		if (cyclic) {
			GMRFLib_ged_insert_graph2(ged, graph, 0 * n, (ngroup - 1) * n);
		}
	}
		break;

	case G_AR:
	{
		assert(ngroup >= 2);
		for (i = 0; i < ngroup - 1; i++) {
			for (j = 1; j <= order; j++) {
				if (i + j < ngroup) {
					GMRFLib_ged_insert_graph2(ged, graph, i * n, (i + j) * n);
				}
			}
		}
	}
		break;

	case G_RW1:
	{
		assert(ngroup >= 2);
		for (i = 0; i < ngroup - 1; i++) {
			GMRFLib_ged_insert_graph2(ged, graph, i * n, (i + 1) * n);
		}
		if (cyclic) {
			GMRFLib_ged_insert_graph2(ged, graph, 0 * n, (ngroup - 1) * n);
		}
	}
		break;

	case G_RW2:
	{
		assert(ngroup >= 3);
		for (i = 0; i < ngroup - 2; i++) {
			GMRFLib_ged_insert_graph2(ged, graph, i * n, (i + 1) * n);
			GMRFLib_ged_insert_graph2(ged, graph, i * n, (i + 2) * n);
		}
		GMRFLib_ged_insert_graph2(ged, graph, (ngroup - 2) * n, (ngroup - 1) * n);
		if (cyclic) {
			GMRFLib_ged_insert_graph2(ged, graph, 0 * n, (ngroup - 1) * n);
			GMRFLib_ged_insert_graph2(ged, graph, 0 * n, (ngroup - 2) * n);
			GMRFLib_ged_insert_graph2(ged, graph, 1 * n, (ngroup - 1) * n);
		}
	}
		break;

	case G_BESAG:
	{
		assert(group_graph);
		for (i = 0; i < group_graph->n; i++) {
			int jj;
			for (jj = 0; jj < group_graph->lnnbs[i]; jj++) {
				j = group_graph->lnbs[i][jj];
				GMRFLib_ged_insert_graph2(ged, graph, i * n, j * n);
			}
		}
	}
		break;

	case G_IID:
	{
		assert(ngroup >= 1);
		for (i = 0; i < ngroup; i++) {
			GMRFLib_ged_insert_graph2(ged, graph, i * n, i * n);
		}
	}
		break;

	default:
		inla_error_general("This should not happen");
		abort();
	}

	if (0) {
		FILE *fp = fopen("g.dat", "w");
		GMRFLib_printf_graph(fp, new_graph[0]);
		fclose(fp);
	}

	assert(ged->n == n * ngroup);
	GMRFLib_ged_build(new_graph, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

double Qfunc_generic1(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_generic1_tp *a = (inla_generic1_tp *) arg;
	double beta = map_probability(a->beta[thread_id][0], MAP_FORWARD, NULL);
	double prec = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);

	return prec * ((i == j ? 1.0 : 0.0) - (beta / a->max_eigenvalue) * a->tab->Qfunc(thread_id, i, j, NULL, a->tab->Qfunc_arg));
}

double Qfunc_generic2(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	/*
	 * [u,v], where u = v + noise. h2 = 1/prec_v / (1/prec_v + 1/prev_u). h2 in (0,1). 
	 */

	inla_generic2_tp *a = (inla_generic2_tp *) arg;

	double prec_cmatrix = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL),
	    h2 = map_probability(a->h2_intern[thread_id][0], MAP_FORWARD, NULL), prec_unstruct;
	int n = a->n;

	prec_unstruct = h2 / (1.0 - h2) * prec_cmatrix;

	if (i == j) {

		if (i < n) {
			/*
			 * the sum 
			 */
			return prec_unstruct;
		} else {
			/*
			 * cmatrix 
			 */
			return prec_unstruct + prec_cmatrix * a->tab->Qfunc(thread_id, i - n, i - n, NULL, a->tab->Qfunc_arg);
		}
	} else {
		if (IMIN(i, j) >= n) {
			/*
			 * inside the Cmatrix 
			 */
			return prec_cmatrix * a->tab->Qfunc(thread_id, i - n, j - n, NULL, a->tab->Qfunc_arg);
		} else {
			/*
			 * cross term between cmatrix and the sum 
			 */
			return -prec_unstruct;
		}
	}
	GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	return 0.0;
}

double Qfunc_generic3(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_generic3_tp *a = (inla_generic3_tp *) arg;
	double prec_common, prec, val = 0.0;
	int k, same = (i == j);

	for (k = 0; k < a->m; k++) {
		if (same || GMRFLib_graph_is_nb(i, j, a->g[k])) {
			prec = map_precision(a->log_prec[k][thread_id][0], MAP_FORWARD, NULL);
			val += prec * a->tab[k]->Qfunc(thread_id, i, j, NULL, a->tab[k]->Qfunc_arg);
		}
	}
	prec_common = map_precision(a->log_prec[GENERIC3_MAXTHETA - 1][thread_id][0], MAP_FORWARD, NULL);
	val *= prec_common;

	return (val);
}

double Qfunc_replicate(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	int ii, jj;
	inla_replicate_tp *a = (inla_replicate_tp *) arg;

	ii = MOD(i, a->n);
	jj = MOD(j, a->n);

	return a->Qfunc(thread_id, ii, jj, NULL, a->Qfunc_arg);
}

int inla_replicate_graph(GMRFLib_graph_tp ** g, int replicate)
{
	/*
	 * replace the graph G, with on that is replicated REPLICATE times 
	 */
	int i;
	GMRFLib_ged_tp *ged;

	if (!g || !*g || replicate <= 1) {
		return GMRFLib_SUCCESS;
	}
	GMRFLib_ged_init(&ged, NULL);
	for (i = 0; i < replicate; i++) {
		GMRFLib_ged_append_graph(ged, *g);
	}
	GMRFLib_graph_free(*g);
	GMRFLib_ged_build(g, ged);
	GMRFLib_ged_free(ged);

	return GMRFLib_SUCCESS;
}

double Qfunc_z(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_z_arg_tp *a = (inla_z_arg_tp *) arg;
	double value = 0.0;

	if (i == j || GMRFLib_graph_is_nb(i, j, a->graph_A)) {
		value += a->Qfunc_A->Qfunc(thread_id, i, j, NULL, a->Qfunc_A->Qfunc_arg);
	}
	if (i == j || GMRFLib_graph_is_nb(i, j, a->graph_B)) {
		/*
		 * doit like this, as most of the elements in B are zero
		 */
		double q = a->Qfunc_B->Qfunc(thread_id, i, j, NULL, a->Qfunc_B->Qfunc_arg);
		if (q) {
			value += q * map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
		}
	}
	return value;
}

double Qfunc_slm(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_slm_arg_tp *a = (inla_slm_arg_tp *) arg;
	double value = 0.0, prec, rho, rho_std;

	prec = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	rho_std = map_probability(a->logit_rho[thread_id][0], MAP_FORWARD, NULL);
	rho = a->rho_min + rho_std * (a->rho_max - a->rho_min);

	if (0) {
		if (i == j && i == 0) {
			printf("log_prec %.12f  logit_rho %.12f\n", a->log_prec[thread_id][0], a->logit_rho[thread_id][0]);
		}
	}

	if (i == j || GMRFLib_graph_is_nb(i, j, a->graph_A1)) {
		value += prec * a->Qfunc_A1->Qfunc(thread_id, i, j, NULL, a->Qfunc_A1->Qfunc_arg);
	}
	if (i == j || GMRFLib_graph_is_nb(i, j, a->graph_A2)) {
		value += a->Qfunc_A2->Qfunc(thread_id, i, j, NULL, a->Qfunc_A2->Qfunc_arg);
	}
	if (i == j || GMRFLib_graph_is_nb(i, j, a->graph_B)) {
		value += prec * rho * a->Qfunc_B->Qfunc(thread_id, i, j, NULL, a->Qfunc_B->Qfunc_arg);
	}
	if (i == j || GMRFLib_graph_is_nb(i, j, a->graph_C)) {
		value += prec * SQR(rho) * a->Qfunc_C->Qfunc(thread_id, i, j, NULL, a->Qfunc_C->Qfunc_arg);
	}

	return value;
}

double Qfunc_rgeneric(int thread_id, int i, int j, double *values, void *arg)
{
	inla_rgeneric_tp *a = (inla_rgeneric_tp *) arg;
	int rebuild, ii, id = 0;
	const int debug = 0;

	GMRFLib_CACHE_SET_ID(id);

	// WHY IS THIS A GOOD IDEA?
	// reset cache once in a while. 
	if (0 && a->reset_cache >= 0) {
		if (a->reset_cache || (id == 0 && omp_get_level() == 0 && i == 0 && j <= 0)) {
			a->reset_cache = 1;
#pragma omp critical (Name_d9d5fe823d2b17d465f4c6c0d56442c45ef50e40)
			{
				if (a->reset_cache) {
					// yes, start loops at 1 to reset the rest of the cache, but not for id=0.
					for (int i = 1; i < GMRFLib_CACHE_LEN; i++) {
						if (a->Q[i]) {
							GMRFLib_free_tabulate_Qfunc(a->Q[i]);
							a->Q[i] = NULL;
						}
						if (a->ntheta && a->param && a->param[i]) {
							Free(a->param[i]);
						}
					}
				}
				a->reset_cache = 0;
			}
		}
	}

	rebuild = (a->param[id] == NULL || a->Q[id] == NULL);
	if (!rebuild) {
		for (ii = 0; ii < a->ntheta && !rebuild; ii++) {
			rebuild = (a->param[id][ii] != a->theta[ii][thread_id][0]);
		}
	}

	if (rebuild) {
		int *ilist = NULL, *jlist = NULL, n, len, k = 0, n_out, jj;
		double *Qijlist = NULL, *x_out = NULL;
#pragma omp critical (Name_297cd7aba8c5dafefcb1c93779913d23a945ce9e)
		{
			rebuild = (a->param[id] == NULL || a->Q[id] == NULL);
			if (!rebuild) {
				for (ii = 0; ii < a->ntheta && !rebuild; ii++) {
					rebuild = (a->param[id][ii] != a->theta[ii][thread_id][0]);
				}
			}

			if (rebuild) {
				if (debug) {
					printf("Qfunc_rgeneric: Rebuild Q-hash for id %d thread_id %d\n", id, thread_id);
				}
				if (a->Q[id]) {
					GMRFLib_free_tabulate_Qfunc(a->Q[id]);
				}
				double *a_tmp = Calloc(a->ntheta, double);
				for (jj = 0; jj < a->ntheta; jj++) {
					a_tmp[jj] = a->theta[jj][thread_id][0];
					if (debug) {
						printf("\ttheta[%1d] %.12f\n", jj, a_tmp[jj]);
					}
				}

				if (debug) {
					printf("\tCall rgeneric\n");
				}
				inla_R_rgeneric(&n_out, &x_out, R_GENERIC_Q, a->model, &(a->ntheta), a_tmp);
				if (debug) {
					printf("\tReturn from rgeneric with n_out= %1d\n", n_out);
				}
				assert(n_out >= 2);

				assert(a->graph);
				if ((int) x_out[0] == -1) {
					// optimized output
					k = 1;
					len = (int) x_out[k++];
					assert(len == a->len_list);
					n = a->graph->n;
					GMRFLib_tabulate_Qfunc_from_list2(&(a->Q[id]), a->graph, a->len_list, a->ilist, a->jlist, &(x_out[k]), n,
									  NULL);
				} else {
					n = (int) x_out[k++];
					len = (int) x_out[k++];

					// we can overlay these arrays to avoid allocating new ones, since x_out is double
					ilist = (int *) &(x_out[k]);
					jlist = (int *) &(x_out[k + len]);
					Qijlist = (double *) &(x_out[k + 2 * len]);
					for (jj = 0; jj < len; jj++) {
						ilist[jj] = (int) x_out[k + jj];
						jlist[jj] = (int) x_out[k + len + jj];
					}

					GMRFLib_tabulate_Qfunc_from_list2(&(a->Q[id]), a->graph, len, ilist, jlist, Qijlist, n, NULL);
					assert(a->graph->n == a->n);
				}
				Free(x_out);

				if (a->param[id]) {
					Memcpy(a->param[id], a_tmp, a->ntheta * sizeof(double));
					Free(a_tmp);
				} else {
					a->param[id] = a_tmp;
				}
				if (debug) {
					printf("\tRebuild for id %1d done\n", id);
				}
			}
		}
	}

	if (j >= 0) {
		return (a->Q[id]->Qfunc(thread_id, i, j, NULL, a->Q[id]->Qfunc_arg));
	} else {
		return (a->Q[id]->Qfunc(thread_id, i, j, values, a->Q[id]->Qfunc_arg));
	}
}

double Qfunc_cgeneric(int thread_id, int i, int j, double *values, void *arg)
{
	inla_cgeneric_tp *a = (inla_cgeneric_tp *) arg;
	int rebuild, ii, id = 0;
	const int debug = 0;

	GMRFLib_CACHE_SET_ID(id);
	rebuild = (a->param[id] == NULL || a->Q[id] == NULL);
	if (!rebuild) {
		for (ii = 0; ii < a->ntheta && !rebuild; ii++) {
			rebuild = (a->param[id][ii] != a->theta[ii][thread_id][0]);
		}
	}

	if (rebuild) {
		int *ilist = NULL, *jlist = NULL, n, len, k = 0, jj;
		double *Qijlist = NULL, *x_out = NULL;
		rebuild = (a->param[id] == NULL || a->Q[id] == NULL);
		if (!rebuild) {
			for (ii = 0; ii < a->ntheta && !rebuild; ii++) {
				rebuild = (a->param[id][ii] != a->theta[ii][thread_id][0]);
			}
		}

		if (rebuild) {
			if (debug) {
				printf("Qfunc_cgeneric: Rebuild Q-hash for id %d thread_id %d\n", id, thread_id);
			}
			if (a->Q[id]) {
				GMRFLib_free_tabulate_Qfunc(a->Q[id]);
			}
			double *a_tmp = Calloc(a->ntheta, double);
			for (jj = 0; jj < a->ntheta; jj++) {
				a_tmp[jj] = a->theta[jj][thread_id][0];
				if (debug) {
					printf("\ttheta[%1d] %.12f\n", jj, a_tmp[jj]);
				}
			}

			if (debug) {
				printf("\tCall cgeneric\n");
			}
			x_out = a->model_func(INLA_CGENERIC_Q, a_tmp, a->data);
			if (a->debug) {
				inla_cgeneric_debug(stdout, a->secname, INLA_CGENERIC_Q, x_out);
			}

			assert(a->graph);
			assert((int) x_out[0] == -1);	       /* ONLY SUPPORT THIS, as its the same in any case... */
			if ((int) x_out[0] == -1) {
				// optimized output
				k = 1;
				len = (int) x_out[k++];
				assert(len == a->len_list);
				n = a->graph->n;
				GMRFLib_tabulate_Qfunc_from_list2(&(a->Q[id]), a->graph, a->len_list, a->ilist, a->jlist, &(x_out[k]), n, NULL);
			} else {
				k = 0;
				n = (int) x_out[k++];
				len = (int) x_out[k++];

				// we can overlay these arrays to avoid allocating new ones, since x_out is double
				ilist = (int *) &(x_out[k]);
				jlist = (int *) &(x_out[k + len]);
				Qijlist = (double *) &(x_out[k + 2 * len]);
				for (jj = 0; jj < len; jj++) {
					ilist[jj] = (int) x_out[k + jj];
					jlist[jj] = (int) x_out[k + len + jj];
				}

				GMRFLib_tabulate_Qfunc_from_list2(&(a->Q[id]), a->graph, len, ilist, jlist, Qijlist, n, NULL);
				assert(a->graph->n == a->n);
			}
			Free(x_out);
			if (a->param[id]) {
				Memcpy(a->param[id], a_tmp, a->ntheta * sizeof(double));
				Free(a_tmp);
			} else {
				a->param[id] = a_tmp;
			}
			if (debug) {
				printf("\tRebuild for id %1d done\n", id);
			}
		}
	}

	if (j >= 0) {
		return (a->Q[id]->Qfunc(thread_id, i, j, NULL, a->Q[id]->Qfunc_arg));
	} else {
		return (a->Q[id]->Qfunc(thread_id, i, j, values, a->Q[id]->Qfunc_arg));
	}
}

double Qfunc_dmatern(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	dmatern_arg_tp *a = (dmatern_arg_tp *) arg;
	double prec = map_exp(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	int rebuild, id = 0;
	const int debug = 0;

	GMRFLib_CACHE_SET_ID(id);
	rebuild = (a->param[id] == NULL || a->Q[id] == NULL);
	if (!rebuild) {
		// yes, log_prec is ...[0], so we start at 1
		rebuild = (a->param[id][1] != a->log_range[thread_id][0]) || (a->param[id][2] != a->log_nu[thread_id][0]);
	}

	if (rebuild) {
#pragma omp critical (Name_8b586dffc9258cff507f5f6098e240cbacd2c571)
		{
			// yes, log_prec is ...[0], so we start at 1
			double range, nu;
			if (debug) {
				printf("Qfunc_dmatern: Rebuild Q-hash for id %d\n", id);
			}

			if (!(a->Q[id])) {
				a->Q[id] = gsl_matrix_calloc(a->n, a->n);
			}

			a->param[id][1] = a->log_range[thread_id][0];
			a->param[id][2] = a->log_nu[thread_id][0];
			range = map_exp(a->param[id][1], MAP_FORWARD, NULL);
			nu = map_exp(a->param[id][2], MAP_FORWARD, NULL);

			if (debug) {
				printf("\trange %.4f nu %.4f\n", range, nu);
			}

			for (int i = 0; i < a->n; i++) {
				for (int j = i; j < a->n; j++) {
					double dist, val;

					dist = gsl_matrix_get(a->dist, i, j);
					val = inla_dmatern_cf(dist, range, nu);
					gsl_matrix_set(a->Q[id], i, j, val);
					gsl_matrix_set(a->Q[id], j, i, val);
				}
			}
			if (0) {
				FILE *fp = fopen("Q.dat", "w");
				GMRFLib_printf_gsl_matrix(fp, a->Q[id], "%.16f ");
				fclose(fp);
			}
			GMRFLib_gsl_spd_inverse(a->Q[id]);
		}
	}

	return prec * gsl_matrix_get(a->Q[id], i, j);
}

double mfunc_ar1(int thread_id, int UNUSED(i), void *arg)
{
	inla_ar1_arg_tp *a = (inla_ar1_arg_tp *) arg;
	return (a->mean[thread_id][0]);
}

double mfunc_rgeneric(int thread_id, int i, void *arg)
{
	inla_rgeneric_tp *a = (inla_rgeneric_tp *) arg;
	int rebuild, ii, id = 0;
	const int debug = 0;

	// possible fast return ?
	if (a->mu_zero) {
		return 0.0;
	}

	GMRFLib_CACHE_SET_ID(id);
	rebuild = (a->mu_param[id] == NULL || a->mu[id] == NULL);
	for (ii = 0; ii < a->ntheta && !rebuild; ii++) {
		rebuild = (a->mu_param[id][ii] != a->theta[ii][thread_id][0]);
	}

	if (rebuild) {
#pragma omp critical (Name_a878b76a6db370a6183df8d897b3a03b15039501)
		{
			int n, n_out, jj;
			double *x_out = NULL;

			if (debug) {
				printf("Rebuild mu-hash for id %d\n", id);
			}
			if (!(a->mu_param[id])) {
				a->mu_param[id] = Calloc(a->ntheta, double);
			}
			for (jj = 0; jj < a->ntheta; jj++) {
				a->mu_param[id][jj] = a->theta[jj][thread_id][0];
				if (debug) {
					printf("\ttheta[%1d] %.20g\n", jj, a->mu_param[id][jj]);
				}
			}

			if (debug) {
				printf("Call rgeneric\n");
			}
			inla_R_rgeneric(&n_out, &x_out, R_GENERIC_MU, a->model, &(a->ntheta), a->mu_param[id]);
			if (debug) {
				printf("Return from rgeneric with n_out= %1d\n", n_out);
			}

			assert(n_out > 0);
			n = (int) x_out[0];
			if (n > 0) {
				assert(n == a->n);
				if (!(a->mu[id])) {
					a->mu[id] = Calloc(n, double);
				}
				Memcpy(a->mu[id], &(x_out[1]), n * sizeof(double));
				a->mu_zero = 0;
			} else {
				a->mu_zero = 1;
			}
			Free(x_out);
		}
		// do a fast return here, so we do not need to allocate the a->mu[id] above. 
		if (a->mu_zero) {
			return 0.0;
		}
	}

	return (a->mu[id][i]);
}

double mfunc_cgeneric(int thread_id, int i, void *arg)
{
	inla_cgeneric_tp *a = (inla_cgeneric_tp *) arg;
	int rebuild, ii, id = 0;
	const int debug = 0;

	// possible fast return ?
	if (a->mu_zero) {
		return 0.0;
	}

	GMRFLib_CACHE_SET_ID(id);
	rebuild = (a->mu_param[id] == NULL || a->mu[id] == NULL);
	for (ii = 0; ii < a->ntheta && !rebuild; ii++) {
		rebuild = (a->mu_param[id][ii] != a->theta[ii][thread_id][0]);
	}

	if (rebuild) {
		int n, jj;
		double *x_out = NULL;

		if (debug) {
			printf("Rebuild mu-hash for id %d\n", id);
		}
		if (!(a->mu_param[id])) {
			assert(a->ntheta >= 0 && a->ntheta < 1000000);
			a->mu_param[id] = Calloc(a->ntheta, double);
		}
		for (jj = 0; jj < a->ntheta; jj++) {
			a->mu_param[id][jj] = a->theta[jj][thread_id][0];
			if (debug) {
				printf("\ttheta[%1d] %.20g\n", jj, a->mu_param[id][jj]);
			}
		}

		if (debug) {
			printf("Call cgeneric\n");
		}
		x_out = a->model_func(INLA_CGENERIC_MU, a->mu_param[id], a->data);
		if (debug) {
			printf("Return from cgeneric with x_out[0]= %1d\n", (int) x_out[0]);
		}

		n = (int) x_out[0];
		if (n > 0) {
			assert(n == a->n);
			if (!(a->mu[id])) {
				a->mu[id] = Calloc(n, double);
			}
			Memcpy(a->mu[id], &(x_out[1]), n * sizeof(double));
			a->mu_zero = 0;
		} else {
			a->mu_zero = 1;
		}
		Free(x_out);

		// do a fast return here, so we do not need to allocate the a->mu[id] above. 
		if (a->mu_zero) {
			return 0.0;
		}
	}

	return (a->mu[id][i]);
}

double Qfunc_clinear(int UNUSED(thread_id), int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_clinear_tp *a = (inla_clinear_tp *) arg;
	assert(i == j);
	return (a->precision);
}

double Qfunc_sigm(int UNUSED(thread_id), int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_sigm_tp *a = (inla_sigm_tp *) arg;
	assert(i == j);
	return (a->precision);
}

double Qfunc_log1exp(int UNUSED(thread_id), int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_log1exp_tp *a = (inla_log1exp_tp *) arg;
	assert(i == j);
	return (a->precision);
}

double Qfunc_logdist(int UNUSED(thread_id), int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_log1exp_tp *a = (inla_log1exp_tp *) arg;
	assert(i == j);
	return (a->precision);
}

double mfunc_clinear(int thread_id, int i, void *arg)
{
	inla_clinear_tp *a = (inla_clinear_tp *) arg;
	double beta = map_beta(a->beta[thread_id][0], MAP_FORWARD, a->beta_arg);

	return beta * a->x[i];
}

double mfunc_sigm(int thread_id, int i, void *arg)
{
	inla_sigm_tp *a = (inla_sigm_tp *) arg;
	double beta, halflife, shape, x, xx;

	beta = a->beta[thread_id][0];
	halflife = map_precision(a->log_halflife[thread_id][0], MAP_FORWARD, NULL);
	shape = map_precision(a->log_shape[thread_id][0], MAP_FORWARD, NULL);
	x = a->x[i];
	assert(x >= 0.0);

	xx = pow(x / halflife, shape);
	return beta * xx / (1.0 + xx);
}

double mfunc_revsigm(int thread_id, int i, void *arg)
{
	inla_sigm_tp *a = (inla_sigm_tp *) arg;
	double beta, halflife, shape, x, xx;

	beta = a->beta[thread_id][0];
	halflife = map_precision(a->log_halflife[thread_id][0], MAP_FORWARD, NULL);
	shape = map_precision(a->log_shape[thread_id][0], MAP_FORWARD, NULL);
	x = a->x[i];
	assert(x >= 0.0);

	xx = pow(x / halflife, shape);
	return beta * 1.0 / (1.0 + xx);
}

double mfunc_log1exp(int thread_id, int i, void *arg)
{
	inla_log1exp_tp *a = (inla_log1exp_tp *) arg;
	double beta, alpha, gama, x;

	beta = a->beta[thread_id][0];
	alpha = a->alpha[thread_id][0];
	gama = a->gamma[thread_id][0];
	x = a->x[i];
	assert(x >= 0.0);

	return beta * log1p(exp(alpha - gama * x));
}

double mfunc_logdist(int thread_id, int i, void *arg)
{
	inla_logdist_tp *a = (inla_logdist_tp *) arg;
	double beta, alpha1, alpha2, x;

	beta = a->beta[thread_id][0];
	alpha1 = map_exp(a->alpha1[thread_id][0], MAP_FORWARD, NULL);
	alpha2 = map_exp(a->alpha2[thread_id][0], MAP_FORWARD, NULL);
	x = a->x[i];
	assert(x > 0.0);

	return beta * (1.0 + exp(alpha1 * log(x) - alpha2 * x));
}

double Qfunc_mec(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_mec_tp *a = (inla_mec_tp *) arg;
	double prec_x = map_precision(a->log_prec_x[thread_id][0], MAP_FORWARD, NULL);
	double prec_obs = map_precision(a->log_prec_obs[thread_id][0], MAP_FORWARD, NULL);
	double beta = map_beta(a->beta[thread_id][0], MAP_FORWARD, a->map_beta_arg);
	double *scale = a->scale;

	assert(i == j);
	return (prec_x + prec_obs * scale[i]) / SQR(beta);
}

double mfunc_mec(int thread_id, int i, void *arg)
{
	inla_mec_tp *a = (inla_mec_tp *) arg;
	double prec_x = map_precision(a->log_prec_x[thread_id][0], MAP_FORWARD, NULL);
	double prec_obs = map_precision(a->log_prec_obs[thread_id][0], MAP_FORWARD, NULL);
	double beta = map_beta(a->beta[thread_id][0], MAP_FORWARD, a->map_beta_arg);
	double mean_x = map_identity(a->mean_x[thread_id][0], MAP_FORWARD, NULL);
	double *x_obs = a->x_obs;
	double *scale = a->scale;

	return beta * (prec_obs * scale[i] * x_obs[i] + prec_x * mean_x) / (prec_obs * scale[i] + prec_x);
}

double Qfunc_meb(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_meb_tp *a = (inla_meb_tp *) arg;

	double prec = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	double beta = map_beta(a->beta[thread_id][0], MAP_FORWARD, a->map_beta_arg);
	double *scale = a->scale;

	assert(i == j);
	return prec * scale[i] / SQR(beta);
}

double mfunc_meb(int thread_id, int i, void *arg)
{
	inla_meb_tp *a = (inla_meb_tp *) arg;
	double beta = map_beta(a->beta[thread_id][0], MAP_FORWARD, a->map_beta_arg);

	return beta * a->x[i];
}

int inla_iid_wishart_nparam(int dim)
{
	/*
	 * return the number of theta parameters 
	 */
	return ((dim * (dim + 1)) / 2);
}

double Qfunc_iid_wishart(int thread_id, int node, int nnode, double *UNUSED(values), void *arg)
{
	if (nnode < 0) {
		return NAN;
	}

	/*
	 * This function returns the ij'th element of the precision matrix of the dim-dimensional iid. The parameterisation is given in the covariance matrix, so we
	 * need to compute the precision matrix. We store Q to avoid to compute it all the time.
	 */

	inla_iid_wishart_arg_tp *a = (inla_iid_wishart_arg_tp *) arg;
	int i, j, k, n_theta, dim, id = 0;
	const int debug = 0;
	double *vec = NULL;
	inla_wishart_hold_tp *hold = NULL;

	dim = a->dim;
	n_theta = inla_iid_wishart_nparam(a->dim);

	if (dim == 1) {
		/*
		 *  Fast return for the IID1D model; no need to do complicate things in this case
		 */
		return map_precision(a->log_prec[0][thread_id][0], MAP_FORWARD, NULL);
	}

	/*
	 * using this prevent us for using '#pragma omp critical' below, so its much quicker 
	 */
	GMRFLib_CACHE_SET_ID(id);
	assert(a->hold);
	hold = a->hold[id];
	if (hold == NULL) {
		a->hold[id] = Calloc(1, inla_wishart_hold_tp);
		a->hold[id]->vec = Calloc(n_theta, double);
		a->hold[id]->vec[0] = GMRFLib_uniform();
		a->hold[id]->Q = gsl_matrix_calloc(a->dim, a->dim);
		hold = a->hold[id];
	}

	vec = Calloc(n_theta, double);
	k = 0;
	for (i = 0; i < dim; i++) {
		vec[k] = map_precision(a->log_prec[i][thread_id][0], MAP_FORWARD, NULL);
		k++;
	}
	for (i = 0; i < n_theta - dim; i++) {
		vec[k] = map_rho(a->rho_intern[i][thread_id][0], MAP_FORWARD, NULL);
		k++;
	}
	assert(k == n_theta);

	if (memcmp((void *) vec, (void *) hold->vec, n_theta * sizeof(double))) {
		inla_iid_wishart_adjust(dim, vec);
		k = 0;
		for (i = 0; i < dim; i++) {
			gsl_matrix_set(hold->Q, i, i, 1.0 / vec[k]);
			k++;
		}
		for (i = 0; i < dim; i++) {
			for (j = i + 1; j < dim; j++) {
				double value = vec[k] / sqrt(vec[i] * vec[j]);
				gsl_matrix_set(hold->Q, i, j, value);
				gsl_matrix_set(hold->Q, j, i, value);
				k++;
			}
		}
		assert(k == n_theta);

		if (debug) {
			for (i = 0; i < n_theta; i++)
				printf("vec[%1d] = %.12f\n", i, vec[i]);
			GMRFLib_printf_gsl_matrix(stdout, hold->Q, " %.12f");
		}

		GMRFLib_gsl_spd_inverse(hold->Q);
		Memcpy((void *) hold->vec, (void *) vec, n_theta * sizeof(double));	/* YES! */
	}

	Free(vec);

	return gsl_matrix_get(hold->Q, node / a->n, nnode / a->n);
}

int inla_wishartk_build_Q(int dim, double *theta, gsl_matrix * Q, gsl_matrix * L)
{
	int i, j, k = 0, n_theta = INLA_WISHARTK_NTHETA(dim);
	const int debug = 0;
	gsl_matrix_set_zero(L);
	for (i = 0; i < dim; i++) {
		gsl_matrix_set(L, i, i, exp(theta[k++]));
	}
	for (j = 0; j < dim; j++) {
		for (i = j + 1; i < dim; i++) {
			gsl_matrix_set(L, i, j, theta[k++]);
		}
	}
	assert(k == n_theta);
	gsl_blas_dgemm(CblasNoTrans, CblasTrans, 1.0, L, L, 0.0, Q);
	if (debug) {
		for (i = 0; i < n_theta; i++) {
			printf("theta[%1d] = %.8f\n", i, theta[i]);
		}
		FIXME("L");
		GMRFLib_printf_gsl_matrix(stdout, L, " %.6f");
		FIXME("Q");
		GMRFLib_printf_gsl_matrix(stdout, Q, " %.6f");
	}
	return GMRFLib_SUCCESS;
}

double Qfunc_iid_wishartk(int thread_id, int node, int nnode, double *UNUSED(values), void *arg)
{
	if (nnode < 0) {
		return NAN;
	}

	inla_iid_wishartk_arg_tp *a = (inla_iid_wishartk_arg_tp *) arg;
	int i, n_theta, dim, id = 0;
	inla_wishartk_hold_tp *hold = NULL;
	double *vec = NULL;

	dim = a->dim;
	n_theta = a->ntheta;

	GMRFLib_CACHE_SET_ID(id);
	hold = a->hold[id];
	if (hold == NULL) {
		a->hold[id] = Calloc(1, inla_wishartk_hold_tp);
		a->hold[id]->vec = Calloc(n_theta, double);
		a->hold[id]->vec[0] = GMRFLib_uniform();
		a->hold[id]->L = gsl_matrix_calloc(a->dim, a->dim);
		a->hold[id]->Q = gsl_matrix_calloc(a->dim, a->dim);
		hold = a->hold[id];
	}

	vec = a->vec[id];
	for (i = 0; i < n_theta; i++) {
		vec[i] = a->theta[i][thread_id][0];
	}

	if (memcmp((void *) vec, (void *) hold->vec, n_theta * sizeof(double))) {
		inla_wishartk_build_Q(dim, vec, hold->Q, hold->L);
		Memcpy((void *) hold->vec, (void *) vec, n_theta * sizeof(double));	/* YES! */
	}

	return gsl_matrix_get(hold->Q, node / a->n, nnode / a->n);
}

double Qfunc_iid2d(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_iid2d_arg_tp *a = (inla_iid2d_arg_tp *) arg;
	double prec0, prec1, rho;

	prec0 = map_precision(a->log_prec0[thread_id][0], MAP_FORWARD, NULL);
	prec1 = map_precision(a->log_prec1[thread_id][0], MAP_FORWARD, NULL);
	rho = map_rho(a->rho_intern[thread_id][0], MAP_FORWARD, NULL);

	if (i == j) {
		if (i < a->n) {
			return prec0 / (1.0 - SQR(rho));
		} else {
			return prec1 / (1.0 - SQR(rho));
		}
	}

	return -rho * sqrt(prec0 * prec1) / (1.0 - SQR(rho));
}

double Qfunc_2diid(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_2diid_arg_tp *a = (inla_2diid_arg_tp *) arg;
	double prec0, prec1, rho;

	prec0 = map_precision(a->log_prec0[thread_id][0], MAP_FORWARD, NULL);
	prec1 = map_precision(a->log_prec1[thread_id][0], MAP_FORWARD, NULL);
	rho = map_rho(a->rho_intern[thread_id][0], MAP_FORWARD, NULL);

	if (i == j) {
		if (GSL_IS_EVEN(i)) {
			return prec0 / (1.0 - SQR(rho));
		} else {
			return prec1 / (1.0 - SQR(rho));
		}
	}

	return -rho * sqrt(prec0 * prec1) / (1.0 - SQR(rho));
}

double Qfunc_2diid_wishart(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_2diid_arg_tp *a = (inla_2diid_arg_tp *) arg;
	double prec0, prec1, rho;

	prec0 = map_precision(a->log_prec0[thread_id][0], MAP_FORWARD, NULL);
	prec1 = map_precision(a->log_prec1[thread_id][0], MAP_FORWARD, NULL);
	rho = map_rho(a->rho_intern[thread_id][0], MAP_FORWARD, NULL);

	if (i == j) {
		if (i < a->n) {
			return prec0 / (1.0 - SQR(rho));
		} else {
			return prec1 / (1.0 - SQR(rho));
		}
	}

	return -rho * sqrt(prec0 * prec1) / (1.0 - SQR(rho));
}

int inla_make_ar1_graph(GMRFLib_graph_tp ** graph, inla_ar1_arg_tp * arg)
{
	return GMRFLib_graph_mk_linear(graph, arg->n, 1, arg->cyclic);
}

int inla_make_ou_graph(GMRFLib_graph_tp ** graph, inla_ou_arg_tp * arg)
{
	return GMRFLib_graph_mk_linear(graph, arg->n, 1, 0);
}

double Qfunc_ar1(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_ar1_arg_tp *a = (inla_ar1_arg_tp *) arg;
	double phi, prec_marginal, prec, val;

	/*
	 * the log_prec is the log precision for the *marginal*; so we need to compute the log_prec for the innovation or conditional noise. 
	 */
	phi = map_phi(a->phi_intern[thread_id][0], MAP_FORWARD, NULL);
	prec_marginal = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	prec = prec_marginal / (1.0 - SQR(phi));

	if (a->cyclic) {
		if (i == j) {
			val = prec * (1.0 + SQR(phi));
		} else {
			val = -prec * phi;
		}
	} else {
		if (i != j) {
			val = -prec * phi;
		} else {
			if (i == 0 || i == a->n - 1) {
				val = prec;
			} else {
				val = prec * (1.0 + SQR(phi));
			}
		}
	}

	return val;
}

double Qfunc_ar1c(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_ar1c_arg_tp *a = (inla_ar1c_arg_tp *) arg;
	double phi, prec_marginal, prec, val;
	int ii, jj, m;

	/*
	 * the log_prec is the log precision for the *marginal*; so we need to compute the log_prec for the innovations
	 */
	phi = map_phi(a->phi_intern[thread_id][0], MAP_FORWARD, NULL);
	prec_marginal = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	prec = prec_marginal / (1.0 - SQR(phi));

	ii = IMIN(i, j);
	jj = IMAX(i, j);

	if (jj < a->n) {
		// the AR1 part
		if (ii != jj) {
			val = -prec * phi;
		} else {
			if (ii == 0 || ii == a->n - 1) {
				val = prec;
			} else {
				val = prec * (1.0 + SQR(phi));
			}
		}
	} else if (ii < a->n) {
		// the interaction
		m = jj - a->n;
		if (ii == 0) {
			val = prec * phi * GMRFLib_matrix_get(ii, m, a->Z);
		} else if (ii == a->n - 1) {
			val = -prec * GMRFLib_matrix_get(ii - 1, m, a->Z);
		} else {
			val = prec * (phi * GMRFLib_matrix_get(ii, m, a->Z) - GMRFLib_matrix_get(ii - 1, m, a->Z));
		}
	} else {
		// the beta-block
		int iii = ii - a->n, jjj = jj - a->n;
		val = GMRFLib_matrix_get(iii, jjj, a->Qbeta) + prec * GMRFLib_matrix_get(iii, jjj, a->ZZ);
	}

	return val;
}

double Qfunc_ou(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_ou_arg_tp *a = (inla_ou_arg_tp *) arg;
	double phi, prec, w, v, delta;

	phi = map_exp(a->phi_intern[thread_id][0], MAP_FORWARD, NULL);
	prec = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);

	if (i != j) {
		int ii = IMAX(i, j);
		delta = a->locations[ii] - a->locations[ii - 1];
		w = 1.0 / ONE_MINUS_EXP(-2.0 * phi * delta);
		v = exp(-phi * delta);

		return -prec * w * v;
	} else {
		if (i == 0) {
			delta = a->locations[i + 1] - a->locations[i];
			w = 1.0 / ONE_MINUS_EXP(-2.0 * phi * delta);
			v = exp(-phi * delta);

			return prec * (1.0 + w * SQR(v));
		} else if (i == a->n - 1) {
			delta = a->locations[i] - a->locations[i - 1];
			w = 1.0 / ONE_MINUS_EXP(-2.0 * phi * delta);

			return prec * w;
		} else {
			delta = a->locations[i + 1] - a->locations[i];
			w = 1.0 / ONE_MINUS_EXP(-2.0 * phi * delta);
			v = exp(-phi * delta);

			double ddelta = a->locations[i] - a->locations[i - 1];
			double ww = 1.0 / ONE_MINUS_EXP(-2.0 * phi * ddelta);

			return prec * (ww + w * SQR(v));
		}
	}
	abort();
	return 0.0;
}

double priorfunc_linksnintercept(double *x, double *parameters)
{
	// input is theta, need to find the corresponding mu.
	double theta = *x;
	double mu;
	double step = 1.0e-4;
	double theta_lim = 25.0;

	// we should not be outside the limits, really...
	if (ABS(theta) < theta_lim) {
		mu = gsl_cdf_ugaussian_Pinv(1.0 / (1.0 + exp(-theta)));
	} else if (theta >= theta_lim) {
		mu = gsl_cdf_ugaussian_Pinv(1.0 / (1.0 + exp(-theta_lim)));
	} else {
		mu = gsl_cdf_ugaussian_Pinv(1.0 / (1.0 + exp(-(-theta_lim))));
	}

	// d_mu/d_theta = 1 / (d_theta/d_mu) 
	double deriv = 1.0 / ((inla_logit_Phi(mu + step) - inla_logit_Phi(mu - step)) / (2.0 * step));
	return (log(ABS(deriv)) + priorfunc_normal(&mu, parameters));
}

double priorfunc_pc_gevtail(double *x, double *parameters)
{
#define DIST(_xi) ((_xi)*sqrt(2.0/(1.0-(_xi))))
	double lambda = parameters[0], low = parameters[1], high = parameters[2], xi, xi_deriv, p_low, p_high, ld, d, d_deriv;

	// the internal parameterisation is in the interval [low,high]
	xi = map_interval(*x, MAP_FORWARD, (void *) &(parameters[1]));
	xi_deriv = map_interval(*x, MAP_DFORWARD, (void *) &(parameters[1]));
	d = DIST(xi);
	d_deriv = (2.0 - xi) * sqrt(2.0) / 2.0 / sqrt(1.0 / (1.0 - xi)) / SQR(1.0 - xi);
	p_low = (low > 0.0 ? ONE_MINUS_EXP(-lambda * DIST(low)) : 0.0);
	p_high = (high < 1.0 ? ONE_MINUS_EXP(-lambda * DIST(high)) : 1.0);
	ld = -log(p_high - p_low) + log(lambda) - lambda * d + log(ABS(d_deriv)) + log(ABS(xi_deriv));

#undef DIST
	return ld;
}

double priorfunc_pc_spde_ga(double *x, double *parameters)
{
	double theta1 = x[0], theta2 = x[1], *par = parameters, ldens, lam1, lam2;
	const int debug = 0;

	lam1 = -par[0] * log(par[1]);
	lam2 = -log(par[3]) / par[2];
	ldens = (log(lam1) - theta1 - lam1 * exp(-theta1)) + (log(lam2) + theta2 - lam2 * exp(theta2));

	if (debug) {
		fprintf(stderr, "pc_spde_ga: x = %g %g\n", x[0], x[1]);
		fprintf(stderr, "            param = %g %g %g %g\n", par[0], par[1], par[2], par[3]);
		fprintf(stderr, "            lam1 = %g  lam2 = %g  ldens = %g\n", lam1, lam2, ldens);
	}

	return ldens;
}

double priorfunc_pc_matern(double *x, double *parameters)
{
	double theta1 = x[0], theta2 = x[1], *par = parameters, ldens, lam1, lam2, dHalf;
	const int debug = 0;

	lam1 = parameters[0];
	lam2 = parameters[1];
	dHalf = parameters[2] / 2.0;

	ldens = 0.0;

	// Check if range is fixed
	if (!ISNAN(theta1))
		ldens += log(lam1 * dHalf) - dHalf * theta1 - lam1 * exp(-dHalf * theta1);

	// Check if standard deviation is fixed
	if (!ISNAN(theta2))
		ldens += log(lam2) + theta2 - lam2 * exp(theta2);

	if (debug) {
		fprintf(stderr, "pc_matern: x = %g %g\n", x[0], x[1]);
		fprintf(stderr, "           param = %g %g %g\n", par[0], par[1], par[2]);
		fprintf(stderr, "           lam1 = %g  lam2 = %g  ldens = %g\n", lam1, lam2, ldens);
	}

	return ldens;
}

double priorfunc_pc_range(double *x, double *parameters)
{
	double theta1 = x[0], ldens, lam, dHalf;
	const int debug = 0;

	lam = parameters[0];
	dHalf = parameters[1] / 2.0;

	ldens = log(lam * dHalf) - dHalf * theta1 - lam * exp(-dHalf * theta1);

	if (debug) {
		fprintf(stderr, "pc_range: x = %g\n", x[0]);
		fprintf(stderr, "          param = %g %g\n", parameters[0], parameters[1]);
		fprintf(stderr, "          lam = %g  dHalf = %g  ldens = %g\n", lam, dHalf, ldens);
	}

	return ldens;
}

double priorfunc_pc_alphaw(double *x, double *parameters)
{
	// the inla.pc.alphaw prior. alpha = exp(sc * x), where sc is given
#define _GAM (0.577215664901532860606512090082)
#define KLD(_a) ((MATHLIB_FUN(gammafn)((1.0+(_a))/(_a)) * (_a) + (_a) * log((_a)) - (_a) * _GAM + _GAM - (_a))/(_a))
#define D(_a) sqrt(2.0*DMAX(0.0, KLD((_a))))

	double d0, ld, diff, h = 1.0E-06;
	double alpha = exp(INLA_WEIBULL_ALPHA_SCALE * x[0]), lambda = parameters[0];

	d0 = D(alpha);
	if (alpha >= 1.0) {
		diff = (D(alpha + h) - d0) / h;
	} else {
		diff = (d0 - D(alpha - h)) / h;
	}

	ld = log(0.5) + lambda - lambda * d0 + log(ABS(diff)) + log(alpha * INLA_WEIBULL_ALPHA_SCALE);
#undef _GAM
#undef KLD
#undef D
	return (ld);
}

double priorfunc_pc_gamma(double *x, double *parameters)
{
	// in Maple, this is
	// asympt(log(Psi(1, n)-1/n), n,4);
	// see also testing no 48 and 49
#define SPECIAL(x) ((x > 1.0E4 ?					\
		     -2.0 * log(x) - log(2.0) + 1.0/(3.0*(x)) - 1.0/(18.0*SQR(x)) - 22.0/(405.0 * gsl_pow_3(x)) : \
		     log(gsl_sf_psi_1(x) - 1.0/(x))))

	// the inla.pc.dgamma prior, which is the prior for 'a' in Gamma(1/a, 1/a) where a=0 is the base model. Here we have the
	// argument log(a). Almost the same function as priorfunc_pc_mgamma
	double ldens, d, a, a_inv, lambda;

	lambda = parameters[0];
	a = exp(x[0]);
	a_inv = 1.0 / a;
	d = sqrt(2.0 * (log(a_inv) - gsl_sf_psi(a_inv)));
	ldens = log(lambda) - lambda * d - 2.0 * log(a) - log(d) + SPECIAL(a_inv) + x[0];
#undef SPECIAL

	return ldens;
}

double priorfunc_pc_mgamma(double *x, double *parameters)
{
	// the inla.pc.dgamma prior, which is the prior for 'a' in Gamma(1/a, 1/a) where a=0 is the base model. Here we have the
	// argument log(a). this function is the pc_gamma prior for 'x' when a=exp(-x). Almost the same function as
	// priorfunc_pc_gamma
	double xx = -x[0];

	return (priorfunc_pc_gamma(&xx, parameters));
}

double priorfunc_pc_gammacount(double *x, double *parameters)
{
	// the inla.pc.dgammacount prior, which is the prior for 'a' in Gamma(a, 1) where a=1 is the base model.
	// argument is theta=log(a), so the its the density for log(a) and not a

	double lambda = parameters[0], xx, ldens, t1, t3, t4, t5, t8, t12, t14, t15, t16;

	if (ISZERO(x[0])) {
		xx = exp(INLA_REAL_SMALL);
	} else {
		xx = exp(x[0]);
	}
	t1 = log(lambda);
	t3 = gsl_sf_lngamma(xx);
	t4 = xx - 1.0;
	t5 = gsl_sf_psi(xx);
	t8 = sqrt(2.0) * sqrt(t5 * t4 - t3);
	t12 = gsl_sf_psi_1(xx);
	t14 = ABS(t12 * t4 / t8);
	t15 = log(t14);
	t16 = -t8 * lambda + t1 + t15;
	ldens = t16 - log(2.0) + log(xx);

	return ldens;
}

double priorfunc_pc_dof(double *x, double *parameters)
{
#define _NP 5
	int k;
	const int debug = 0;
	double u = parameters[0], alpha = parameters[1], lambda, dof, val, deriv;
	double wf[] = { 1.0 / 12.0, -2.0 / 3.0, 0.0, 2.0 / 3.0, -1.0 / 12.0 };
	double step, dofs[_NP], f[_NP];

	dof = map_dof(*x, MAP_FORWARD, NULL);
	lambda = -log(alpha) / inla_pcp_dof_d(u);
	// be somewhat careful evaluating the derivative
	step = sqrt(dof) * 1e-3;			       /* step-size is found empirically */
	if (dof - 2.0 * step < 2.003) {			       /* if we're to close to the lower limit */
		step = (dof - 2.003) / 2.0;
	}

	dofs[0] = dof - 2.0 * step;
	dofs[1] = dof - step;
	dofs[2] = dof;
	dofs[3] = dof + step;
	dofs[4] = dof + 2.0 * step;
	for (k = 0; k < _NP; k++) {
		f[k] = inla_pcp_dof_d(dofs[k]);
	}
	deriv = (wf[0] * f[0] + wf[1] * f[1] + wf[2] * f[2] + wf[3] * f[3] + wf[4] * f[4]) / step;
	val = log(lambda) - lambda * f[2] + log(ABS(deriv)) + log(ABS(map_dof(*x, MAP_DFORWARD, NULL)));

	if (debug) {
		P(dof);
		P(f[2]);
		P(deriv);
		P(lambda);
		P(val);
	}

	return val;
#undef _NP
}

double priorfunc_pc_sn(double *x, double *parameters)
{
	double lambda = parameters[0], val, dist, dist_max, deriv, xx, xxd, skew_max = GMRFLib_SN_SKEWMAX;

	xx = map_phi(*x, MAP_FORWARD, (void *) &skew_max);
	xxd = map_phi(*x, MAP_DFORWARD, (void *) &skew_max);
	dist = inla_pc_sn_d(xx, &deriv);
	dist_max = inla_pc_sn_d(skew_max, NULL);
	val = log(0.5) + log(lambda) - lambda * dist - LOG_ONE_MINUS(exp(-lambda * dist_max)) + log(ABS(deriv)) + log(ABS(xxd));

	return val;
}

double priorfunc_pc_prec(double *x, double *parameters)
{
	double u = parameters[0], alpha = parameters[1], theta, val, xx2;
	theta = -log(alpha) / u;
	xx2 = (*x) / 2.0;
	val = log(theta / 2.0) - theta * exp(-xx2) - xx2;

	return val;
}

double priorfunc_pc_cor0(double *x, double *parameters)
{
	// alpha = Prob(|rho| > u)
	const int debug = 0;
	double u = parameters[0], alpha = parameters[1];
	double rho = map_rho(*x, MAP_FORWARD, NULL);
	double ldens, lambda, ljac, val, mu;

	mu = sqrt(-LOG_ONE_MINUS(SQR(rho)));
	if (alpha <= 0 || alpha >= 1.0) {
		FIXME1("*****************************  USING lambda = u **********************************");
		lambda = u;
	} else {
		lambda = -log(alpha) / sqrt(-LOG_ONE_MINUS(SQR(u)));
	}
	// add the EPS to ensure its not INFINITY...
	ldens = log(lambda) - lambda * mu + log((ABS(rho) + INLA_REAL_SMALL) / (1.0 - SQR(rho))) - log(mu + INLA_REAL_SMALL);
	ljac = log(ABS(map_rho(*x, MAP_DFORWARD, NULL)));
	val = ldens + ljac;

	if (debug) {
		fprintf(stderr, "priorfunc_pc_cor0: mu %g lambda %g ldens %g ljac %g\n", mu, lambda, ldens, ljac);
		fprintf(stderr, "priorfunc_pc_cor0: theta %g val %g\n", *x, val);
	}

	return val;
}

double priorfunc_pc_cor1(double *x, double *parameters)
{
	// alpha = Prob(rho > u)
	const int debug = 0;
	double u = parameters[0], alpha = parameters[1];
	double lambda, rho, ljac, ldens, val, mu;

	// solve for lambda
#define _Fsolve(_lam) (((ONE_MINUS_EXP(-(_lam)*sqrt(1.0-u)))/(ONE_MINUS_EXP(-(_lam)*M_SQRT2))) - alpha)

	int count = 0, count_max = 1000;
	double lambda_initial = -1.0, lambda_step = 1.1, h = GMRFLib_eps(1. / 3.), eps_lambda = GMRFLib_eps(0.5), df;

	if (!(u > -1.0 && u < 1.0 && alpha > sqrt((1.0 - u) / 2.0) && alpha < 1.0)) {
		char *msg;
		GMRFLib_sprintf(&msg, "Wrong cor1 prior-parameters. We must have alpha > sqrt((1-u)/2); see the documentation.");
		inla_error_general(msg);
		exit(1);
	}

	lambda = 1.0;
	if (_Fsolve(lambda) > 0.0) {
		while (_Fsolve(lambda) > 0.0) {
			lambda /= lambda_step;
			assert(count++ < count_max);
		}
	} else {
		while (_Fsolve(lambda) < 0.0 && lambda >= eps_lambda) {
			lambda *= lambda_step;
			assert(count++ < count_max);
		}
	}

	if (debug) {
		printf("priorfunc_pc_cor1: u=%g alpha=%g  initial value for lambda=%g\n", u, alpha, lambda);
	}

	count = 0;
	while (ABS(lambda - lambda_initial) > eps_lambda) {
		lambda_initial = lambda;
		df = (_Fsolve(lambda_initial + h) - _Fsolve(lambda_initial - h)) / (2.0 * h);
		lambda = lambda_initial - _Fsolve(lambda) / df;
		if (debug) {
			printf("priorfunc_pc_cor1: iteration=%d lambda=%g\n", count, lambda);
		}
		assert(count++ < count_max);
	}
	if (debug)
		printf("priorfunc_pc_cor1: function value %g\n", _Fsolve(lambda));

#undef Fsolve
	rho = map_rho(*x, MAP_FORWARD, NULL);
	mu = sqrt(1.0 - rho);
	ldens = log(lambda) - lambda * mu - LOG_ONE_MINUS(exp(-lambda * M_SQRT2)) - log(2.0 * mu);
	ljac = log(ABS(map_rho(*x, MAP_DFORWARD, NULL)));
	val = ldens + ljac;

#undef _Fsolve
	return (val);
}

double priorfunc_jeffreys_df_student_t(double *x, double *UNUSED(parameters))
{
	double df = map_dof(x[0], MAP_FORWARD, NULL);
	double value, log_jacobian;

	if (1) {
#define _DIGAMMA(xx) gsl_sf_psi(xx)
#define _TRIGAMMA(xx) gsl_sf_psi_1(xx)

		value =
		    0.5 * log(df / (df + 3.0)) + 0.5 * log(_TRIGAMMA(df / 2.0) - _TRIGAMMA((df + 1.0) / 2.0) -
							   2.0 * (df + 3.0) / (df * SQR(df + 1.0)))
		    - log(0.7715233664);		       /* normalising constant: computed in R from 2 to infinity */

		log_jacobian = x[0];
		return value + log_jacobian;
#undef _DIGAMMA
#undef _TRIGAMMA
	} else {
		value = -log(df);
		log_jacobian = x[0];
		return value + log_jacobian;
	}
}

double priorfunc_bymjoint(double *logprec_besag, double *p_besag, double *logprec_iid, double *p_iid)
{
	/*
	 * This is the Jon Wakefield prior. Notation: U Spatial, V unstruct.  Conceptually, there is a prior for total variance (U + V) and a prior for the
	 * proportion of the total that is spatial. The spatial variance is approximated as the mean of the marginal spatial variances in an ICAR model.  This mean
	 * is a function of the (known) neighborhood structure and the conditional variance parameter.  Thus, the joint distribution is expressed of the conditional
	 * spatial variance parameter and the non-spatial parameter. The value returned, is the log of the joint for the log-precisions, (-\log Conditional.Var(U),
	 * -\log Var(V))
	 */

	double a, b, c, d, var_u, var_v, val, mean_ievalue;

	a = p_besag[0];					       /* Parameters for the IGamma(a,b) */
	b = p_besag[1];
	mean_ievalue = p_besag[2];			       /* mean(1/eigenvalues) for the reference precision matrix */
	c = p_iid[0];					       /* Parameters for the Beta(c,d) */
	d = p_iid[1];

	var_u = 1.0 / exp(*logprec_besag);		       /* var_u = Conditional.Var(U) i.e. Cond.var_u_i = var_u/n_i */
	var_v = 1.0 / exp(*logprec_iid);

	/*
	 * the log prior for Conditonal.Var(U) and Var(V) 
	 */
	val = a * log(b) + gsl_sf_lngamma(c + d) - gsl_sf_lngamma(a) - gsl_sf_lngamma(c) - gsl_sf_lngamma(d)
	    - (a + c + d) * log((var_u * mean_ievalue) + var_v) + (c - 1.0) * log(var_u * mean_ievalue)
	    + (d - 1.0) * log(var_v) - b / ((var_u * mean_ievalue) + var_v) + log(mean_ievalue);

	/*
	 * the Jacobian for converting to (-\log Conditional.Var(U), -\log Var(V)) 
	 */
	val += log(var_u) + log(var_v);

	return val;
}

double priorfunc_invalid(double *UNUSED(x), double *UNUSED(parameters))
{
	inla_error_general("Prior 'invalid' is used, but it is not ment to be.");
	exit(EXIT_FAILURE);
	return 0.0;
}

double priorfunc_betacorrelation(double *x, double *parameters)
{
	/*
	 * The prior for the correlation coefficient \rho is Beta(a,b), scaled so that it is defined on (-1,1)
	 * The function returns the log prior for \rho.intern = log((1 +\rho)/(1-\rho))
	 */
	double p = exp(*x) / (1.0 + exp(*x)), a = parameters[0], b = parameters[1];
	return log(gsl_ran_beta_pdf(p, a, b)) + (*x) - 2.0 * log1p(exp(*x));
}

double priorfunc_logitbeta(double *x, double *parameters)
{
	/*
	 * The prior for the the logit of a Beta(a,b), logit(p) = log(p/(1-p))
	 */
	double p = exp(*x) / (1.0 + exp(*x)), a = parameters[0], b = parameters[1];
	return log(gsl_ran_beta_pdf(p, a, b)) + (*x) - 2.0 * log1p(exp(*x));
}

double priorfunc_logflat(double *x, double *UNUSED(parameters))
{
	return exp(*x);
}

double priorfunc_logiflat(double *x, double *UNUSED(parameters))
{
	return exp(-*x);
}

double priorfunc_flat(double *UNUSED(x), double *UNUSED(parameters))
{
	return 0.0;
}

double priorfunc_minuslogsqrtruncnormal(double *x, double *parameters)
{
	/*
	 * Requested feature from Sophie Ancelet.
	 * 
	 * This is the prior for \sigma ~ TrucNormal(mean, 1/prior_prec), where \sigma > 0, and the internal parameter is \log\tau = \log(1/\sigma^2) = -\log
	 * \sigma^2, which explans the name.
	 */
	double sd = exp(-0.5 * (*x)), val;

	val = priorfunc_normal(&sd, parameters) - log(gsl_cdf_gaussian_Q(-parameters[0], 1.0 / sqrt(parameters[1]))) +
	    // log(Jacobian)
	    log(ABS(-0.5 * sd));

	return val;
}

double priorfunc_pc_ar(double *x, double *parameters)
{
	int i, p;
	double lambda, *b, *gamma, *pacf, ldens, logjac;

	p = (int) parameters[1];
	lambda = parameters[0];
	b = Calloc(3 * p, double);
	gamma = &(b[p]);
	pacf = &(b[2 * p]);

	for (i = 0, logjac = 0.0; i < p; i++) {
		b[i] = 0.5;
		// x is internal and this gives us the pacf. 
		pacf[i] = ar_map_pacf(x[i], MAP_FORWARD, NULL);
		// but the pc-simplex prior is given in terms of 'gamma'
		gamma[i] = -LOG_ONE_MINUS(SQR(pacf[i]));
		// hence we need two jacobians, one for x->pacf and one for pacf->gamma. recall that we have a singularity for
		// x[i]=0
		double xtmp = (ISZERO(pacf[i]) ? INLA_REAL_SMALL : pacf[i]);
		logjac += log(ABS(ar_map_pacf(x[i], MAP_DFORWARD, NULL))) + log(ABS(xtmp / (1.0 - SQR(pacf[i]))));
	}
	ldens = inla_pc_simplex_d(gamma, b, p, lambda) + logjac;

	Free(b);
	return (ldens);
}

double priorfunc_ref_ar(double *x, double *parameters)
{
	int i, p;
	double pacf[3], ldens;

	p = (int) parameters[0];
	assert(p >= 0 && p <= 3);
	for (i = 0; i < p; i++) {
		pacf[i] = map_phi(x[i], MAP_FORWARD, NULL);
	}

	switch (p) {
	case 0:
	{
		ldens = 0.0;
	}
		break;
	case 1:
	{
		ldens = -log(M_PI)
		    - 0.5 * LOG_ONE_MINUS(SQR(pacf[0]))
		    + log(ABS(map_phi(x[0], MAP_DFORWARD, NULL)));
	}
		break;
	case 2:
	{
		ldens = -2.0 * log(M_PI)
		    - 0.5 * LOG_ONE_MINUS(SQR(pacf[0]))
		    - 0.5 * LOG_ONE_MINUS(SQR(pacf[1]))
		    + log(ABS(map_phi(x[0], MAP_DFORWARD, NULL)))
		    + log(ABS(map_phi(x[1], MAP_DFORWARD, NULL)));
	}
		break;
	case 3:
	{
		ldens = -2.0 * log(M_PI)
		    - log(1.12)
		    - 0.5 * LOG_ONE_MINUS(SQR(pacf[0]))
		    - 0.5 * LOG_ONE_MINUS(SQR(pacf[1]))
		    - 0.5 * LOG_ONE_MINUS(SQR(pacf[2]))
		    - M_PI * SQR(pacf[2])
		    + log(ABS(map_phi(x[0], MAP_DFORWARD, NULL)))
		    + log(ABS(map_phi(x[1], MAP_DFORWARD, NULL)))
		    + log(ABS(map_phi(x[2], MAP_DFORWARD, NULL)));
	}
		break;
	default:
		ldens = NAN;
		GMRFLib_ASSERT(p <= 3 && p >= 0, GMRFLib_EPARAMETER);
	}

	return (ldens);
}

double priorfunc_beta(double *x, double *parameters)
{
	double xx = *x, a = parameters[0], b = parameters[1];

	return log(gsl_ran_beta_pdf(xx, a, b));
}

double priorfunc_loggamma(double *x, double *parameters)
{
	/*
	 * return log(loggamma(x,a,b)). NOTE: if y ~ gamma(a,b), then log(y) ~ loggamma(a,b). 
	 */
	double val = exp(*x);
	return priorfunc_gamma(&val, parameters) + (*x);
}

double priorfunc_dirichlet(double *x, double *parameters)
{
#define _F_logit(_x) (1.0/(1.0+exp(-(_x))))
#define _f_logit(_x) (exp(-(_x)) / SQR(1.0 + exp(-(_x))))

#define _F_probit(_x) inla_Phi(_x)
#define _f_probit(_x) (0.39894228040143270286 * exp(-0.5 * SQR(_x)))

#define _F(_x) (cdf_logit ? _F_logit(_x) : _F_probit(_x))
#define _f(_x) (cdf_logit ? _f_logit(_x) : _f_probit(_x))

	double alpha = parameters[0], nclasses = parameters[1], ld;
	int cdf_logit = ((inla_pom_cdf_tp) parameters[2] == POM_CDF_LOGIT);
	int K = (int) nclasses, k;
	const int debug = 0;
	double *work = Calloc(4 * K, double);
	double *xx = work, *alphas = work + K, *qs = work + 2 * K, *v = work + 3 * K;

	// from the internal representation, x, to cutpoints, xx 
	xx[0] = x[0];
	for (k = 1; k < K - 1; k++) {
		xx[k] = xx[k - 1] + exp(x[k]);
	}
	// from cutpoints, xx, to quantiles, qs

	for (k = 0; k < K - 1; k++) {
		qs[k] = _F(xx[k]);
	}

	// from quantiles, qs, to Dirichlet variables, v
	v[0] = qs[0];
	for (k = 1; k < K - 1; k++) {
		v[k] = qs[k] - qs[k - 1];
	}
	v[K - 1] = 1.0 - qs[K - 2];

	for (k = 0; k < K; k++) {			       /* also to provide this */
		alphas[k] = alpha;
	}
	ld = gsl_ran_dirichlet_lnpdf((size_t) K, alphas, v);

	// finally, add the log-jacobian of the transformation. This is approximately correct, as there are K variables and a
	// sum to 1 constr for the Dirichlet, but K-1 variables for the theta without the constr. Maybe look into this later

	ld += log(_f(xx[0]));
	for (k = 1; k < K - 1; k++) {
		ld += log(_f(xx[k])) + x[k];
	}

	if (debug) {
		printf("priorfunc_dirichlet: alpha = %g  K=%1d\n", alpha, K);
		for (int i = 0; i < K - 1; i++) {
			printf("input theta[%1d] = %g\n", i, x[i]);
		}
		for (int i = 0; i < K; i++) {
			printf("input v[%1d] = %g\n", i, v[i]);
		}
		P(ld);
	}

	Free(work);
#undef _F
#undef _f
#undef _F_logit
#undef _f_logit
#undef _F_probit
#undef _f_probit

	return (ld);
}

double priorfunc_gamma(double *x, double *parameters)
{
	/*
	 * return log(gamma(x, a, b))
	 *
	 * parametes (a,b) are such that E(x) = a/b and Var(x) = a/b^2
	 */
	double a = parameters[0], b = 1.0 / parameters[1];

	if (0) {
		/*
		 * this crash of'course for extreme values 
		 */
		return log(gsl_ran_gamma_pdf(*x, a, b));
	} else {
		/*
		 * while this is ok. (code copied from GSL...) 
		 */
		if (*x < 0.0) {
			assert(*x >= 0.0);
		} else if (*x == 0.0) {
			if (a == 1.0) {
				return 1.0 / b;
			} else {
				GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
			}
		} else if (a == 1.0) {
			return -(*x) / b - log(b);
		} else {
			return (a - 1.0) * log((*x) / b) - (*x) / b - gsl_sf_lngamma(a) - log(b);
		}
	}
	GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	return 0.0;
}

double priorfunc_gaussian(double *x, double *parameters)
{
	return priorfunc_normal(x, parameters);
}

double priorfunc_normal(double *x, double *parameters)
{
	/*
	 * return log(normal(x, mean, precision)) 
	 */
	if (ISZERO(parameters[1])) {
		return 0.0;				       // = log(1)
	} else {
		double mean = parameters[0], sigma = sqrt(1.0 / parameters[1]);
		return log(gsl_ran_gaussian_pdf((*x) - mean, sigma));
	}
}

double priorfunc_mvnorm(double *x, double *parameters)
{
	/*
	 * this is the multivariate normal 
	 */
	int n = (int) parameters[0], i, j;

	if (n == 0) {
		return 0.0;
	}

	double *mean, *Q, *chol, *xx, q = 0.0, logdet = 0.0;

	mean = &(parameters[1]);
	Q = &(parameters[1 + n]);
	chol = NULL;
	xx = Calloc(n, double);

	if (0) {
		for (i = 0; i < n; i++) {
			for (j = 0; j < n; j++)
				printf("%g ", Q[i + j * n]);
			printf("\n");
		}
		for (i = 0; i < n; i++)
			printf("%g\n", mean[i]);
	}

	GMRFLib_comp_chol_general(&chol, Q, n, &logdet, 0);
	for (i = 0; i < n; i++) {
		xx[i] = x[i] - mean[i];
	}

	/*
	 * q = xx^T * Q * xx. I dont have any easy function for matrix vector except the messy BLAS-FORTRAN-INTERFACE.... so I just do this manually now. FIXME
	 * later. 
	 */
	q = 0.0;
	for (i = 0; i < n; i++) {
		for (j = 0; j < n; j++) {
			q += xx[i] * Q[i + n * j] * xx[j];
		}
	}

	Free(xx);
	Free(chol);

	return (-n / 2.0 * log(2 * M_PI) + 0.5 * logdet - 0.5 * q);
}

int inla_iid_wishart_adjust(int dim, double *theta)
{
	/*
	 * adjust rho's in theta with factor f until the matrix is SPD. 
	 */
#define _IDX(_i, _j) ((_i) + (_j)*(dim))

	int i, j, k, ok = 0;
	const int debug = 0;
	int n_theta = inla_iid_wishart_nparam(dim);
	double f = 0.95, *S = NULL, *chol = NULL;

	S = Calloc(ISQR(dim), double);
	while (!ok) {
		k = 0;
		for (i = 0; i < dim; i++) {
			S[_IDX(i, i)] = 1.0 / theta[k];
			k++;
		}
		for (i = 0; i < dim; i++) {
			for (j = i + 1; j < dim; j++) {
				S[_IDX(i, j)] = S[_IDX(j, i)] = theta[k] / sqrt(theta[i] * theta[j]);
				k++;
			}
		}
		assert(k == n_theta);

		if (debug) {
			printf("\n");
			for (i = 0; i < dim; i++) {
				for (j = 0; j < dim; j++) {
					printf(" %.12f", S[_IDX(i, j)]);
				}
				printf("\n");
			}
			printf("\n");
		}

		if (GMRFLib_comp_chol_general(&chol, S, dim, NULL, !GMRFLib_SUCCESS) != GMRFLib_SUCCESS) {
			/*
			 * only adjust the rho's 
			 */
			if (debug) {
				printf("matrix is not spd, adjust with factor %f\n", f);
			}
			for (i = dim; i < n_theta; i++) {
				theta[i] *= f;
			}
		} else {
			ok = 1;
		}
	}
	Free(S);
	Free(chol);

#undef _IDX
	return (ok ? GMRFLib_SUCCESS : !GMRFLib_SUCCESS);
}

double priorfunc_wishart1d(double *x, double *parameters)
{
	// its the same and quicker

	// return priorfunc_wishart_generic(1, x, parameters);

	double p[2];
	p[0] = parameters[0] / 2.0;
	p[1] = parameters[1] / 2.0;

	return priorfunc_gamma(x, p);
}

double priorfunc_wishart2d(double *x, double *parameters)
{
	return priorfunc_wishart_generic(2, x, parameters);
}

double priorfunc_wishart3d(double *x, double *parameters)
{
	return priorfunc_wishart_generic(3, x, parameters);
}

double priorfunc_wishart4d(double *x, double *parameters)
{
	return priorfunc_wishart_generic(4, x, parameters);
}

double priorfunc_wishart5d(double *x, double *parameters)
{
	return priorfunc_wishart_generic(5, x, parameters);
}

double priorfunc_wishart_generic(int idim, double *x, double *parameters)
{
	/*
	 * 
	 * Q ~ Wishart(r, R^{-1} )
	 * 
	 * input is x = [ tau0, tau1, tau2, rho01, rho02, rho12 ] which parameterise Q.
	 * 
	 * prior parameters are p = [ r, R00, R11, R22, R12, R13, R23 ]
	 * 
	 * output is the logdensity for x!!!! (BE AWARE)
	 */
	gsl_matrix *R = NULL, *Q = NULL;
	double r, val;
	const int debug = 0;
	int fail;
	size_t i, ii, j, k, dim = (size_t) idim;

	size_t n_x = (size_t) inla_iid_wishart_nparam(idim);
	size_t n_param = n_x + 1;

	if (debug) {
		for (i = 0; i < n_param; i++) {
			printf("parameters[%d] = %g\n", (int) i, parameters[i]);
		}
		for (i = 0; i < n_x; i++) {
			printf("x[%d] = %g\n", (int) i, x[i]);
		}
	}

	r = parameters[0];
	R = gsl_matrix_calloc(dim, dim);
	Q = gsl_matrix_calloc(dim, dim);

	fail = inla_iid_wishart_adjust(idim, x);

	/*
	 * offset of 1, since parameters[0] = r
	 */
	k = 1;
	for (i = 0; i < dim; i++) {
		gsl_matrix_set(R, i, i, parameters[k]);
		k++;
	}
	for (i = 0; i < dim; i++) {
		for (j = i + 1; j < dim; j++) {
			gsl_matrix_set(R, i, j, parameters[k]);
			gsl_matrix_set(R, j, i, parameters[k]);
			k++;
		}
	}
	assert(k == n_param);

#define COMPUTE_Q(Q_)							\
	if (1) {							\
		k = 0;							\
		for(i = 0; i<dim; i++) {				\
			gsl_matrix_set(Q_, i, i, 1/x[k]);		\
			k++;						\
		}							\
		for(i=0; i<dim; i++) {					\
			for(j=i+1; j < dim; j++) {			\
				double value = x[k] / sqrt(x[i] * x[j]); \
				gsl_matrix_set(Q_, i, j, value);	\
				gsl_matrix_set(Q_, j, i, value);	\
				k++;					\
			}						\
		}							\
		assert(k == n_x);					\
		if (debug) printf("Covmatrix:\n");			\
		if (debug) GMRFLib_printf_gsl_matrix(stdout, Q_, NULL); \
		if (debug) printf("Precision:\n");			\
		if (debug) GMRFLib_printf_gsl_matrix(stdout, Q_, NULL); \
		GMRFLib_gsl_spd_inverse(Q_);				\
	}

	COMPUTE_Q(Q);
	val = GMRFLib_Wishart_logdens(Q, r, R) + (fail ? PENALTY : 0.0);

	/*
	 * tau1 and tau1 are the *MARGINAL* precisions, which it should be.  The jacobian is computed like this:
	 * 
	 * with(LinearAlgebra); with(Student[VectorCalculus]); S := matrix(3,3, [ 1/tau0, rho01/sqrt(tau0*tau1), rho02/sqrt(tau0*tau2), rho01/sqrt(tau0*tau1),
	 * 1/tau1, rho12/sqrt(tau1*tau2), rho02/sqrt(tau0*tau2), rho12/sqrt(tau1*tau2), 1/tau2]); Q := inverse(S); simplify(Determinant(Jacobian([Q[1,1], Q[2,2],
	 * Q[3,3], Q[1,2], Q[1,3],Q[2,3]], [tau0,tau1,tau2,rho01,rho02,rho12])));
	 * 
	 * this gives a very long answer of'course; so we have to do this numerically 
	 */
	gsl_matrix *QQ = NULL, *J = NULL;
	double f, save;

	/*
	 * for the numerical derivatives: compute the `population' variance: Det(Sigma), and set f = (Det(Sigma))^1/dim. 
	 */
	f = 1.0e-6 * pow(exp(-GMRFLib_gsl_spd_logdet(Q)), 1.0 / (double) idim);	/* Yes, its a minus... */
	QQ = GMRFLib_gsl_duplicate_matrix(Q);
	J = gsl_matrix_calloc(n_x, n_x);

	/*
	 * the precision terms *can* get negative since we're using a central estimate, so we need to check the step-size 
	 */
	for (ii = 0; ii < dim; ii++) {
		f = DMIN(f, 0.5 * x[ii]);
	}

	for (ii = 0; ii < n_x; ii++) {
		save = x[ii];

		x[ii] += f;
		COMPUTE_Q(Q);
		x[ii] = save;

		x[ii] -= f;
		COMPUTE_Q(QQ);
		x[ii] = save;

		k = 0;
		for (i = 0; i < dim; i++) {
			gsl_matrix_set(J, ii, k, (gsl_matrix_get(Q, k, k) - gsl_matrix_get(QQ, k, k)) / (2.0 * f));
			assert(k == i);
			k++;
		}
		for (i = 0; i < dim; i++) {
			for (j = i + 1; j < dim; j++) {
				gsl_matrix_set(J, ii, k, (gsl_matrix_get(Q, i, j) - gsl_matrix_get(QQ, i, j)) / (2.0 * f));
				k++;
			}
		}
	}
	assert(k == n_x);

	gsl_permutation *p;
	int signum;
	double logdet;

	p = gsl_permutation_alloc(n_x);
	gsl_linalg_LU_decomp(J, p, &signum);
	logdet = gsl_linalg_LU_lndet(J);		       /* log(abs|J|) */

	if (debug) {
		P(logdet);
	}

	gsl_matrix_free(R);
	gsl_matrix_free(Q);
	gsl_matrix_free(QQ);
	gsl_matrix_free(J);
	gsl_permutation_free(p);

	val += logdet;

#undef COMPUTE_Q

	return val;
}

double priorfunc_wishartk_2d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(2, x, parameters);
}

double priorfunc_wishartk_3d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(3, x, parameters);
}

double priorfunc_wishartk_4d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(4, x, parameters);
}

double priorfunc_wishartk_5d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(5, x, parameters);
}

double priorfunc_wishartk_6d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(6, x, parameters);
}

double priorfunc_wishartk_7d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(7, x, parameters);
}

double priorfunc_wishartk_8d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(8, x, parameters);
}

double priorfunc_wishartk_9d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(9, x, parameters);
}

double priorfunc_wishartk_10d(double *x, double *parameters)
{
	return priorfunc_wishartk_generic(10, x, parameters);
}

double priorfunc_wishartk_generic(int idim, double *x, double *parameters)
{
	/*
	 * 
	 * Q ~ Wishart(r, R^{-1} )
	 * 
	 * output is the logdensity for x!!!! 
	 */
	gsl_matrix *R = NULL, *Q = NULL, *QQ, *L = NULL;
	double r, val;
	const int debug = 0;
	size_t i, ii, j, k, dim = (size_t) idim;

	size_t n_x = (size_t) INLA_WISHARTK_NTHETA(idim);
	size_t n_param = n_x + 1;

	if (debug) {
		for (i = 0; i < n_param; i++) {
			printf("parameters[%d] = %g\n", (int) i, parameters[i]);
		}
		for (i = 0; i < n_x; i++) {
			printf("x[%d] = %g\n", (int) i, x[i]);
		}
	}

	r = parameters[0];
	R = gsl_matrix_calloc(dim, dim);
	L = gsl_matrix_calloc(dim, dim);
	Q = gsl_matrix_calloc(dim, dim);
	QQ = gsl_matrix_calloc(dim, dim);

	/*
	 * offset of 1, since parameters[0] = r
	 */
	k = 1;
	for (i = 0; i < dim; i++) {
		gsl_matrix_set(R, i, i, parameters[k]);
		k++;
	}
	for (i = 0; i < dim; i++) {
		for (j = i + 1; j < dim; j++) {
			gsl_matrix_set(R, i, j, parameters[k]);
			gsl_matrix_set(R, j, i, parameters[k]);
			k++;
		}
	}
	assert(k == n_param);

	inla_wishartk_build_Q(idim, x, Q, L);
	val = GMRFLib_Wishart_logdens(Q, r, R);

	gsl_matrix *J = NULL;
	double h, save, *xx = NULL;

	xx = Calloc(n_x, double);
	Memcpy(xx, x, n_x * sizeof(double));

	h = 0.005;
	J = gsl_matrix_calloc(n_x, n_x);
	// do not need for h=0 as the weight is zero
	double wf[] = { 1.0 / 12.0, -2.0 / 3.0, 2.0 / 3.0, -1.0 / 12.0 };
	double hh[] = { -2.0 * h, -h, h, 2.0 * h };

	gsl_matrix_set_zero(QQ);
	for (ii = 0; ii < n_x; ii++) {

		for (size_t ih = 0; ih < sizeof(hh) / sizeof(double); ih++) {
			save = xx[ii];
			xx[ii] += hh[ih] * h;
			inla_wishartk_build_Q(idim, xx, Q, L);
			xx[ii] = save;
			for (i = 0; i < dim; i++) {
				for (j = 0; j < dim; j++) {
					gsl_matrix_set(QQ, i, j, gsl_matrix_get(QQ, i, j) + gsl_matrix_get(Q, i, j) * wf[ih]);
				}
			}
		}

		k = 0;
		for (i = 0; i < dim; i++) {
			gsl_matrix_set(J, ii, k, gsl_matrix_get(QQ, k, k) / SQR(h));
			k++;
		}
		for (j = 0; j < dim; j++) {
			for (i = j + 1; i < dim; i++) {
				gsl_matrix_set(J, ii, k, gsl_matrix_get(QQ, i, j) / SQR(h));
				k++;
			}
		}
		assert(k == n_x);
	}

	gsl_permutation *p = NULL;
	int signum;
	double logdet;

	p = gsl_permutation_alloc(n_x);
	gsl_linalg_LU_decomp(J, p, &signum);
	logdet = gsl_linalg_LU_lndet(J);		       /* log(abs|J|) */
	val += logdet;

	if (debug) {
		P(logdet);
	}

	Free(xx);
	gsl_matrix_free(R);
	gsl_matrix_free(Q);
	gsl_matrix_free(QQ);
	gsl_matrix_free(L);
	gsl_matrix_free(J);
	gsl_permutation_free(p);

	return val;
}

double Qfunc_besag(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_besag_Qfunc_arg_tp *a;
	double prec;

	a = (inla_besag_Qfunc_arg_tp *) arg;
	prec = (a->log_prec ? map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL) : 1.0);

	if (a->prec_scale) {
		if (a->prec_scale[i] > 0.0) {
			prec *= a->prec_scale[i];
			// normal return
			return prec * (i == j ? a->graph->nnbs[i] : -1.0);
		} else if (a->prec_scale[i] < 0.0) {
			// node with no neibours and marg variance = 1
			assert((i == j) && a->graph->nnbs[i] == 0);
			return (prec);
		} else if (a->prec_scale[i] == 0.0) {
			// uniform
			return 0.0;
		} else {
			assert(0 == 1);
		}
	}
	// ``classical model''
	return prec * (i == j ? a->graph->nnbs[i] : -1.0);
}

double Qfunc_besag2(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_besag2_Qfunc_arg_tp *aa;
	double a;

	aa = (inla_besag2_Qfunc_arg_tp *) arg;
	if (aa->log_a) {
		a = map_exp(aa->log_a[thread_id][0], MAP_FORWARD, NULL);
	} else {
		a = 1.0;
	}

	if (IMAX(i, j) < aa->besag_arg->graph->n) {
		if (i == j) {
			return (Qfunc_besag(thread_id, i, j, NULL, (void *) aa->besag_arg) + aa->precision / SQR(a)) / SQR(a) + aa->diag;
		} else {
			return Qfunc_besag(thread_id, i, j, NULL, (void *) aa->besag_arg) / SQR(a);
		}
	} else if (IMIN(i, j) >= aa->besag_arg->graph->n) {
		return aa->precision;
	} else {
		return -aa->precision / SQR(a);
	}
}

double Qfunc_besagproper(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_besag_proper_Qfunc_arg_tp *a;
	double prec;

	a = (inla_besag_proper_Qfunc_arg_tp *) arg;
	prec = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	if (i == j) {
		double diag = map_exp(a->log_diag[thread_id][0], MAP_FORWARD, NULL);
		return prec * (diag + a->graph->nnbs[i]);
	} else {
		return -prec;
	}
}

double Qfunc_besagproper2(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_besag_proper2_Qfunc_arg_tp *a;
	double prec;
	double lambda;

	a = (inla_besag_proper2_Qfunc_arg_tp *) arg;
	prec = map_precision(a->log_prec[thread_id][0], MAP_FORWARD, NULL);
	lambda = map_probability(a->logit_lambda[thread_id][0], MAP_FORWARD, NULL);
	if (i == j) {
		return prec * ((1.0 - lambda) + lambda * a->graph->nnbs[i]);
	} else {
		return -prec * lambda;
	}
}

int inla_read_data_all(double **x, int *n, const char *filename, int *ncol_data_all)
{
	if (ncol_data_all)
		*ncol_data_all = -1;			       /* say that it is not defined */

	if (!filename) {
		/*
		 * useful for ini-files with no weight file. (backward compatability...)
		 */
		*n = 0;
		*x = NULL;
		return GMRFLib_SUCCESS;
	}

	int count = 0, err, len = 1000;
	double *c = Calloc(len, double);
	GMRFLib_io_tp *io = NULL;

	if (GMRFLib_is_fmesher_file(filename, (long int) 0, -1) == GMRFLib_SUCCESS) {
		/*
		 * This is the binary-file interface 
		 */
		GMRFLib_matrix_tp *M = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);
		assert(M->elems == M->nrow * M->ncol);	       /* no sparse matrix! */

		*n = M->nrow * M->ncol;
		*x = Calloc(*n, double);

		int i, j, k;
		for (i = k = 0; i < M->nrow; i++) {
			for (j = 0; j < M->ncol; j++) {
				(*x)[k++] = M->A[i + j * M->nrow];
			}
		}

		if (ncol_data_all)
			*ncol_data_all = M->ncol;

		GMRFLib_matrix_free(M);

		return INLA_OK;
	} else {
		GMRFLib_EWRAP0(GMRFLib_io_open(&io, filename, "r"));
		{
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();

			while (1) {
				err = GMRFLib_io_read_next(io, &c[count], "%lf");
				if (err == GMRFLib_SUCCESS) {
					count++;
					if (count >= len) {
						len += 1000;
						c = Realloc(c, len, double);
					}
				} else {
					break;
				}
			}
			GMRFLib_set_error_handler(old_handler);
		}
		GMRFLib_EWRAP0(GMRFLib_io_close(io));

		*n = count;
		if (count == 0) {
			Free(c);
			*x = NULL;
		} else {
			*x = c;
		}

		return INLA_OK;
	}
}

int inla_read_data_likelihood(inla_tp * mb, dictionary * UNUSED(ini), int UNUSED(sec))
{
	/*
	 * read data from file 
	 */
#define _DIM_A  (4096L)

	double *x = NULL, *a[_DIM_A];
	int n, na, i, j, ii, idiv = 0, k, ncol_data_all = -1;
	Data_section_tp *ds = &(mb->data_sections[mb->nds - 1]);

	/*
	 * first read all entries in the file 
	 */
	inla_read_data_all(&x, &n, ds->data_file.name, &ncol_data_all);
	if (mb->verbose) {
		printf("\t\tread n=[%1d] entries from file=[%s]\n", n, ds->data_file.name);
	}
	switch (ds->data_id) {
	case L_GAUSSIAN:
	case L_LOGNORMAL:
	{
		idiv = 3;
		a[0] = ds->data_observations.weight_gaussian = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_SIMPLEX:
	{
		idiv = 3;
		a[0] = ds->data_observations.weight_simplex = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_IID_GAMMA:
	{
		idiv = 3;
		a[0] = ds->data_observations.iid_gamma_scale = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_LOGISTIC:
	{
		idiv = 3;
		a[0] = ds->data_observations.weight_logistic = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_SKEWNORMAL:
	{
		idiv = 3;
		a[0] = ds->data_observations.sn_scale = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_GEV:
	{
		idiv = 3;
		a[0] = ds->data_observations.weight_gev = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_T:
	{
		idiv = 3;
		a[0] = ds->data_observations.weight_t = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_TSTRATA:
	{
		idiv = 4;
		a[0] = ds->data_observations.weight_tstrata = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.strata_tstrata = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_CENPOISSON:
	case L_CONTPOISSON:
	case L_GAMMACOUNT:
	case L_GPOISSON:
	case L_POISSON:
	case L_QCONTPOISSON:
	case L_XPOISSON:
	case L_ZEROINFLATEDCENPOISSON0:
	case L_ZEROINFLATEDCENPOISSON1:
	case L_ZEROINFLATEDNBINOMIAL0:
	case L_ZEROINFLATEDNBINOMIAL1:
	case L_ZEROINFLATEDNBINOMIAL2:
	case L_ZEROINFLATEDPOISSON0:
	case L_ZEROINFLATEDPOISSON1:
	case L_ZEROINFLATEDPOISSON2:
	case L_POISSON_SPECIAL1:
	{
		idiv = 3;
		a[0] = ds->data_observations.E = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_NBINOMIAL:
	{
		idiv = 4;
		a[0] = ds->data_observations.E = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.S = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_CENPOISSON2:
	{
		idiv = 5;
		a[0] = ds->data_observations.E = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.cen_low = Calloc(mb->predictor_ndata, double);
		a[2] = ds->data_observations.cen_high = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_CENNBINOMIAL2:
	{
		idiv = 6;
		a[0] = ds->data_observations.E = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.S = Calloc(mb->predictor_ndata, double);
		a[2] = ds->data_observations.cen_low = Calloc(mb->predictor_ndata, double);
		a[3] = ds->data_observations.cen_high = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_CBINOMIAL:
	{
		idiv = 4;
		a[0] = ds->data_observations.cbinomial_k = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.cbinomial_n = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_GAUSSIANJW:
	{
		idiv = 5;
		a[0] = ds->data_observations.gjw_n = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.gjw_df = Calloc(mb->predictor_ndata, double);
		a[2] = ds->data_observations.gjw_var = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_GAMMA:
	{
		idiv = 3;
		a[0] = ds->data_observations.gamma_scale = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_GAMMAJW:
	{
		idiv = 2;
		a[0] = NULL;
	}
		break;

	case L_DGP:
	case L_EXPONENTIAL:
	case L_GP:
	case L_IID_LOGITBETA:
	case L_LOGGAMMA_FRAILTY:
	case L_LOGLOGISTIC:
	case L_LOGPERIODOGRAM:
	case L_POM:
	case L_QKUMAR:
	case L_QLOGLOGISTIC:
	case L_STOCHVOL:
	case L_STOCHVOL_SN:
	case L_STOCHVOL_NIG:
	case L_STOCHVOL_T:
	case L_WEIBULL:
	case L_GOMPERTZ:
	{
		idiv = 2;
		a[0] = NULL;
	}
		break;

	case L_BETA:
	{
		idiv = 3;
		a[0] = ds->data_observations.beta_weight = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_BETABINOMIALNA:
	{
		idiv = 4;
		a[0] = ds->data_observations.nb = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.betabinomialnb_scale = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_XBINOMIAL:
	{
		idiv = 4;
		a[0] = ds->data_observations.nb = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.p_scale = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_BETABINOMIAL:
	case L_BINOMIAL:
	case L_NBINOMIAL2:
	case L_ZEROINFLATEDBETABINOMIAL0:
	case L_ZEROINFLATEDBETABINOMIAL1:
	case L_ZEROINFLATEDBETABINOMIAL2:
	case L_ZEROINFLATEDBINOMIAL0:
	case L_ZEROINFLATEDBINOMIAL1:
	case L_ZEROINFLATEDBINOMIAL2:
	case L_ZERO_N_INFLATEDBINOMIAL2:
	case L_ZERO_N_INFLATEDBINOMIAL3:
	{
		idiv = 3;
		a[0] = ds->data_observations.nb = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_ZEROINFLATEDNBINOMIAL1STRATA2:
	case L_ZEROINFLATEDNBINOMIAL1STRATA3:
	{
		idiv = 4;
		a[0] = ds->data_observations.E = Calloc(mb->predictor_ndata, double);
		a[1] = ds->data_observations.strata = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_EXPONENTIALSURV:
	case L_GAMMASURV:
	case L_GAMMAJWSURV:
	case L_LOGLOGISTICSURV:
	case L_LOGNORMALSURV:
	case L_QLOGLOGISTICSURV:
	case L_WEIBULLSURV:
	case L_WEIBULL_CURE:
	case L_FMRISURV:
	case L_GOMPERTZSURV:
	{
		idiv = 6;
		a[0] = ds->data_observations.event = Calloc(mb->predictor_ndata, double);	/* the failure code */
		a[1] = ds->data_observations.truncation = Calloc(mb->predictor_ndata, double);
		a[2] = ds->data_observations.lower = Calloc(mb->predictor_ndata, double);
		a[3] = ds->data_observations.upper = Calloc(mb->predictor_ndata, double);
		ds->data_observations.weight_gaussian = NULL;
		ds->data_observations.fmri_scale = NULL;
	}
		break;

	case L_CIRCULAR_NORMAL:
	{
		idiv = 3;
		a[0] = ds->data_observations.weight_circular_normal = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_WRAPPED_CAUCHY:
	{
		idiv = 3;
		a[0] = ds->data_observations.weight_wrapped_cauchy = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_TWEEDIE:
	{
		idiv = 3;
		a[0] = ds->data_observations.tweedie_w = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_FMRI:
	{
		idiv = 3;
		a[0] = ds->data_observations.fmri_scale = Calloc(mb->predictor_ndata, double);
	}
		break;

	case L_NMIX:
	case L_NMIXNB:
	{
		int dim_y;
		// this case is a bit special, as the real data 'y' is fake, and the list
		// of replicated data is in the 'a' below.
		assert(ncol_data_all >= 3L + NMIX_MMAX && ncol_data_all < _DIM_A);
		idiv = ncol_data_all;
		ds->data_observations.nmix_x = Calloc(NMIX_MMAX, double *);
		dim_y = ncol_data_all - NMIX_MMAX - 2L;
		ds->data_observations.nmix_y = Calloc(dim_y + 1, double *);	/* yes, its +1 */
		for (i = 0; i < NMIX_MMAX; i++) {
			a[i] = ds->data_observations.nmix_x[i] = Calloc(mb->predictor_ndata, double);
		}
		for (i = 0; i < dim_y; i++) {
			a[i + NMIX_MMAX] = ds->data_observations.nmix_y[i] = Calloc(mb->predictor_ndata, double);
		}
		// fill the fake column of NA's so we know when to stop
		ds->data_observations.nmix_y[dim_y] = Calloc(mb->predictor_ndata, double);
		for (i = 0; i < mb->predictor_ndata; i++) {
			ds->data_observations.nmix_y[dim_y][i] = NAN;
		}
	}
		break;

	case L_BGEV:
	{
		int na;
		assert(ncol_data_all <= 3 + BGEV_MAXTHETA && ncol_data_all >= 3);
		idiv = ncol_data_all;
		na = ncol_data_all - 2;
		ds->data_observations.bgev_x = Calloc(na, double *);
		a[0] = ds->data_observations.bgev_scale = Calloc(mb->predictor_ndata, double);
		for (i = 1; i < na; i++) {
			a[i] = ds->data_observations.bgev_x[i - 1] = Calloc(mb->predictor_ndata, double);
		}
	}
		break;

	case L_AGAUSSIAN:
	{
		int four = 4;
		assert(ncol_data_all == four + 2);
		idiv = ncol_data_all;
		ds->data_observations.agaussian = Calloc(four, double *);
		for (i = 0; i < four; i++) {
			ds->data_observations.agaussian[i] = Calloc(mb->predictor_ndata, double);
			a[i] = ds->data_observations.agaussian[i];
		}
	}
		break;

	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	na = idiv - 2;
	if (!inla_divisible(n, idiv)) {
		inla_error_file_numelm(__GMRFLib_FuncName, ds->data_file.name, n, idiv);
	}
	ds->data_observations.ndata = n / idiv;
	ds->data_observations.y = Calloc(mb->predictor_ndata, double);
	ds->data_observations.d = Calloc(mb->predictor_ndata, double);

	double *attr = NULL;
	int n_attr = 0;
	inla_read_data_all(&attr, &n_attr, ds->attr_file.name, NULL);
	assert(n_attr >= 1);
	n_attr--;					       /* do not need the first entry */
	if (n_attr > 0) {
		attr++;
	} else {
		attr = NULL;
	}
	ds->data_observations.attr = attr;
	ds->data_observations.n_attr = n_attr;

	if (mb->verbose) {
		printf("\t\tmdata.nattributes = %d\n", n_attr);
		for (i = 0; i < n_attr; i++) {
			printf("\t\tmdata.attribute[%1d] = %g\n", i, attr[i]);
		}
	}

	double *w = NULL;
	int nw = 0;
	inla_read_data_all(&w, &nw, ds->weight_file.name, NULL);
	if (nw) {
		// P(nw); P(ds->data_observations.ndata); P(mb->predictor_ndata);
		assert(nw == mb->predictor_ndata);
	}

	double *lp_scale = NULL;
	int n_lp_scale = 0;
	inla_read_data_all(&lp_scale, &n_lp_scale, ds->lp_scale_file.name, NULL);
	if (n_lp_scale) {
		assert(n_lp_scale == mb->predictor_ndata);
	}
	for (i = 0; i < n_lp_scale; i++) {
		lp_scale[i] = (int) (lp_scale[i] - 1.0);
	}
	mb->data_sections[0].lp_scale = lp_scale;

	for (i = j = 0; i < n; i += idiv, j++) {
		ii = (int) x[i];
		if (!LEGAL(ii, mb->predictor_ndata)) {
			inla_error_file_error(__GMRFLib_FuncName, ds->data_file.name, n, i, x[i]);
		}
		for (k = 0; k < na; k++) {
			a[k][ii] = x[i + k + 1];
		}
		ds->data_observations.y[ii] = x[i + idiv - 1];
		if (w) {
			ds->data_observations.d[ii] = w[ii];
		} else {
			ds->data_observations.d[ii] = 1.0;
		}
		if (mb->verbose && j < PREVIEW) {
			switch (na) {
			case 0:
			{
				printf("\t\t\t%1d/%1d  (idx,y,d) = (%1d, %g, %g)\n", j, ds->data_observations.ndata, ii,
				       ds->data_observations.y[ii], ds->data_observations.d[ii]);
			}
				break;

			case 1:
			{
				printf("\t\t\t%1d/%1d  (idx,a,y,d) = (%1d, %g, %g, %g)\n", j,
				       ds->data_observations.ndata, ii, a[0][ii], ds->data_observations.y[ii], ds->data_observations.d[ii]);
			}
				break;

			case 2:
			{
				printf("\t\t\t%1d/%1d (idx,a[0],a[1],y,d) = (%1d, %g, %g, %g, %g)\n", j,
				       ds->data_observations.ndata, ii, a[0][ii], a[1][ii], ds->data_observations.y[ii],
				       ds->data_observations.d[ii]);
			}
				break;

			case 3:
			{
				printf("\t\t\t%1d/%1d (idx,a[0],a[1],a[2],y,d) = (%1d, %g, %g, %g, %g, %g)\n", j,
				       ds->data_observations.ndata, ii, a[0][ii], a[1][ii], a[2][ii], ds->data_observations.y[ii],
				       ds->data_observations.d[ii]);
			}
				break;

			case 4:
			{
				printf("\t\t\t%1d/%1d (idx,a[0],a[1],a[2],a[3],y,d) = (%1d, %g, %g, %g, %g, %g, %g)\n", j,
				       ds->data_observations.ndata, ii, a[0][ii], a[1][ii], a[2][ii], a[3][ii],
				       ds->data_observations.y[ii], ds->data_observations.d[ii]);
			}
				break;

			case 5:
			{
				printf("\t\t\t%1d/%1d (idx,a[0],a[1],a[2],a[3],a[4],y,d) = (%1d, %g, %g, %g, %g, %g, %g, %g)\n", j,
				       ds->data_observations.ndata, ii, a[0][ii], a[1][ii], a[2][ii], a[3][ii], a[4][ii],
				       ds->data_observations.y[ii], ds->data_observations.d[ii]);
			}
				break;

			default:
				printf("\t\t\t%1d/%1d (idx,a[],y,d) = (%1d, ", j, ds->data_observations.ndata, ii);
				for (k = 0; k < na; k++) {
					printf("%g, ", a[k][ii]);
				}
				printf("%g, %g)\n", ds->data_observations.y[ii], ds->data_observations.d[ii]);
				break;
			}
		}
	}

	Free(w);
	Free(x);
#undef _DIM_A

	return INLA_OK;
}

int inla_read_data_general(double **xx, int **ix, int *nndata, const char *filename, int n, int column, int n_columns, int verbose,
			   double default_value)
{
	/*
	 * read a column from file. the first (or first two) columns are indices and these are not counted.
	 *
	 * counting starts from 0. unread values are default set to DEFAULT_VALUE. n_columns is the total number of columns
	 * (except the indices).
	 *
	 * if xx exists, then read into xx. otherwise, read into ix. return number of reads, in *nx
	 */
	int nx = 0, ndata, i, j, ii, ncol_true;
	double *x = NULL;

	assert(xx || ix);
	/*
	 * first read all entries in the file 
	 */
	inla_read_data_all(&x, &nx, filename, NULL);
	if (nx) {
		assert(x);
	}
	if (verbose) {
		printf("\t\tread n=[%1d] entries from file=[%s]\n", nx, filename);
	}
	ncol_true = n_columns + 1;
	if (!inla_divisible(nx, ncol_true)) {
		inla_error_file_numelm(__GMRFLib_FuncName, filename, nx, ncol_true);
	}
	ndata = nx / ncol_true;
	if (xx) {
		*xx = Calloc(n, double);
		for (i = 0; i < n; i++) {
			(*xx)[i] = default_value;
		}
	} else {
		*ix = Calloc(n, int);
		for (i = 0; i < n; i++) {
			(*ix)[i] = (int) default_value;
		}
	}
	for (i = j = 0; i < nx; i += ncol_true, j++) {
		ii = (int) x[i];
		if (!LEGAL(ii, n)) {
			inla_error_file_error(__GMRFLib_FuncName, filename, nx, i, x[i]);
		}
		if (xx) {
			(*xx)[ii] = x[i + column + 1];
		} else {
			(*ix)[ii] = (int) x[i + column + 1];
		}
		if (verbose && j < PREVIEW) {
			printf("\t\tfile=[%s] %1d/%1d  (idx,y) = (%1d, %g)\n", filename, j, ndata, ii, x[i + column + 1]);
		}
	}
	if (nndata) {
		*nndata = ndata;
	}
	return INLA_OK;
}

int loglikelihood_inla(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	inla_tp *a = (inla_tp *) arg;
	return a->loglikelihood[idx] (thread_id, logll, x, m, idx, x_vec, y_cdf, a->loglikelihood_arg[idx]);
}

double inla_dnchisq(double x, double df, double ncp)
{
	// code provided by L.Starke

	double ldens = 0.0;
	if (ISZERO(ncp)) {
		// besselI is not defined for x = 0
		ldens = MATHLIB_FUN(dnchisq) (x, df, ncp, 1);
	} else if (sqrt(ncp * x) < 8.0E4) {
		// the cutoff is due to besselI
		// see xlrg_IJ at https://github.com/atks/Rmath/blob/master/bessel.h
		// 
		// alternative form of pdf is used
		// https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution
		// 
		// note for C implementation with Rmath: 
		// besselI(..., ..., TRUE) -> bessel_i(..., ..., 2)
		double c1 = sqrt(x * ncp);
		ldens = -M_LN2 - (x + ncp) / 2.0 + (df / 4.0 - 0.5) * log(x / ncp) + c1 + log(MATHLIB_FUN(bessel_i) (c1, df / 2.0 - 1.0, 2.0));
	} else {
		// Approximation of Fraser (is perfect on right tail)
		double c1 = log(x / ncp);
		double c2 = sqrt(x) - sqrt(ncp);
		ldens = -0.5 * log(8.0 * M_PI * x) -
		    0.5 * SQR(c2 - (df - 1.0) / 4.0 * c1 / c2) + LOG_ONE_MINUS((df - 1.0) / (2.0 * c2) * (1.0 / sqrt(x) - 0.5 * c1 / c2));
	}

	return (ldens);
}

double inla_Phi(double x)
{
	/*
	 * the un-log version of inla_log_Phi 
	 */
	if (ABS(x) < 7.0) {
		return gsl_cdf_ugaussian_P(x);
	} else {
		return exp(inla_log_Phi(x));
	}
}

double inla_logit_Phi(double x)
{
	// return log(Phi(x)/(1-Phi(x)))

	if (ABS(x) < 7.0) {
		double y = inla_Phi(x);
		return (log(y / (1.0 - y)));
	} else {
		// > asympt(log(Phi(x)/(1-Phi(x))), x, 16); 
		// 2
		// x 1/2 1/2 1
		// ---- + ln(x) + ln(2 Pi ) + O(----)
		// 2 2
		// 

		double val = (SQR(x) / 2.0 + log(x) + M_LN_SQRT_2PI);
		return (x > 0.0 ? val : -val);
	}
}

double inla_log_Phi(double x)
{
	// return the log of the cummulative distribution function for a standard normal.
	// This version is ok for all x 
	if (ABS(x) <= 7.0) {
		return (log(gsl_cdf_ugaussian_P(x)));
	} else {
		double t1, t4, t3, t8, t9, t13, t27, t28, t31, t47;

		if (x > 7.0) {
			t1 = 1.77245385090551602729816748334;
			t3 = M_SQRT2;
			t4 = t3 / t1;
			t8 = x * x;
			t9 = t8 * x;
			t13 = t8 * t8;
			t27 = exp(t8);
			t28 = sqrt(t27);
			t31 = 0.1e1 / M_PI;
			t47 =
			    0.1e1 / t28 * (-0.1e1 / x * t4 / 0.2e1 + 0.1e1 / t9 * t4 / 0.2e1 - 0.3e1 / 0.2e1 / t13 / x * t4 +
					   0.15e2 / 0.2e1 / t13 / t9 * t4)
			    + 0.1e1 / t27 * (-0.1e1 / t8 * t31 / 0.4e1 + 0.1e1 / t13 * t31 / 0.2e1 - 0.7e1 / 0.4e1 / t13 / t8 * t31);
			return t47;
		} else {
			// x < -7.0
			double xx = -x, cg1;
			cg1 =
			    -(pow(xx, 0.6e1) + log(0.2e1) * pow(xx, 0.4e1) + log(0.3141592653589793e1) * pow(xx, 0.4e1) +
			      0.2e1 * log(xx) * pow(xx, 0.4e1)
			      - 0.5e1 + 0.2e1 * xx * xx) * pow(xx, -0.4e1) / 0.2e1;
			return (cg1);
		}
	}
	abort();
	return 0;
}

double inla_Phi_fast(double x)
{
	// a faster approximation, see misc/doc/doc/approximate-cdf-normal.pdf
	if (ABS(x) <= 7.0) {
		// see misc/doc/doc/approximate-cdf-normal.pdf
		// sqrt(M_PI / 8.0) = 0.6266570686577502....
		if (x > 0.0) {
			return (0.5 + 0.5 * sqrt(ONE_MINUS_EXP(-0.6266570686577502 * SQR(x))));
		} else {
			return (1.0 - (0.5 + 0.5 * sqrt(ONE_MINUS_EXP(-0.6266570686577502 * SQR(x)))));
		}
		abort();
		return (0.5 + 0.5 * sqrt(ONE_MINUS_EXP(-0.6266570686577502 * SQR(x))));
	} else {
		return inla_Phi(x);
	}
}

double inla_log_Phi_fast(double x)
{
	// a faster approximation, see misc/doc/doc/approximate-cdf-normal.pdf
	// sqrt(M_PI / 8.0) = 0.6266570686577502....
	// log(1.0/4.0) = -1.386294361119891...
	if (ABS(x) < 7.0) {
		return (log(inla_Phi_fast(x)));
	} else {
		if (x > 7.0) {
			return (-0.25 * exp(-0.6266570686577502 * SQR(x)));
		} else {
			// return (log(1.0 / 4.0) - 0.6266570686577502 * SQR(x));
			return (-1.386294361119891 - 0.6266570686577502 * SQR(x));
		}
	}
}

double inla_lgamma_fast(double x)
{
	// this is the Gergo Nemes (2007) approximation from
	// https://en.wikipedia.org/wiki/Stirling's_approximation

	if (round(x) == x) {
		return (my_gsl_sf_lngamma(x));
	}

	double val;
	if (x < 1.0) {
		val = gsl_sf_lngamma(x);
	} else {
		double lx = log(x), l2pi = 1.837877066409345;  // ln 2\pi
		val = 0.5 * (l2pi - lx) + x * (log(x + 1.0 / (12.0 * x - 0.1 / x)) - 1.0);
	}
	return (val);
}

int loglikelihood_gaussian(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ Normal(x, stdev)
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, lprec, prec, w;
	static double log_prec_limit = 0.0;
	y = ds->data_observations.y[idx];
	w = ds->data_observations.weight_gaussian[idx];

	if (log_prec_limit == 0.0) {
		log_prec_limit = -log(INLA_REAL_SMALL);
	}

	if (ds->data_observations.log_prec_gaussian_offset[thread_id][0] > log_prec_limit) {
		lprec = ds->data_observations.log_prec_gaussian[thread_id][0] + log(w);
		prec = map_precision(ds->data_observations.log_prec_gaussian[thread_id][0], MAP_FORWARD, NULL) * w;
	} else {
		double prec_offset = map_precision(ds->data_observations.log_prec_gaussian_offset[thread_id][0], MAP_FORWARD, NULL);
		double prec_var = map_precision(ds->data_observations.log_prec_gaussian[thread_id][0], MAP_FORWARD, NULL);
		double prec_tmp = 1.0 / (1.0 / prec_offset + 1.0 / prec_var);
		prec = prec_tmp * w;
		lprec = log(prec);
	}

	LINK_INIT;
	if (m > 0) {
		if (PREDICTOR_LINK_EQ(link_identity)) {
			double off = OFFSET(idx);
#pragma GCC ivdep
			for (int i = 0; i < m; i++) {
				double ypred = PREDICTOR_INVERSE_IDENTITY_LINK(x[i] + off);
				logll[i] = LOG_NORMC_GAUSSIAN + 0.5 * (lprec - (SQR(ypred - y) * prec));
			}
		} else {
#pragma GCC ivdep
			for (int i = 0; i < m; i++) {
				double ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = LOG_NORMC_GAUSSIAN + 0.5 * (lprec - (SQR(ypred - y) * prec));
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (int i = 0; i < -m; i++) {
			double ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = inla_Phi((y - ypred) * sqrt(prec));
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_gaussianjw(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}
	Data_section_tp *ds = (Data_section_tp *) arg;

	double y = ds->data_observations.y[idx];
	double var_obs = ds->data_observations.gjw_var[idx];
	double log_n = log(ds->data_observations.gjw_n[idx]);
	double df = ds->data_observations.gjw_df[idx];
	double df2 = df / 2.0;
	double beta_0 = ds->data_observations.gjw_beta[0][thread_id][0];
	double beta_1 = ds->data_observations.gjw_beta[1][thread_id][0];
	double beta_2 = ds->data_observations.gjw_beta[2][thread_id][0];

	if (G_norm_const_compute[idx]) {
		G_norm_const[idx] = LOG_NORMC_GAUSSIAN - df2 * M_LN2 - gsl_sf_lngamma(df2);
		G_norm_const_compute[idx] = 0;
	}
	double normc = G_norm_const[idx];

	LINK_INIT;
	if (m > 0) {
#pragma GCC ivdep
		for (int i = 0; i < m; i++) {
			double p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			double var = exp(beta_0 + beta_1 * log(p * (1.0 - p)) + beta_2 * log_n);
			double prec = 1.0 / var;
			logll[i] = normc + 0.5 * (log(prec) - (SQR(p - y) * prec));

			double chi_sqr = df * var_obs * prec;
			logll[i] += (df2 - 1.0) * log(chi_sqr) - chi_sqr / 2.0;
		}
	} else {
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_agaussian(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * aggregated Gaussian
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double lprec, prec, ypred;
	double y, v, ldet_s, mm, nn;

	lprec = ds->data_observations.log_prec_gaussian[thread_id][0];
	prec = map_precision(ds->data_observations.log_prec_gaussian[thread_id][0], MAP_FORWARD, NULL);
	y = ds->data_observations.y[idx];
	v = ds->data_observations.agaussian[0][idx];
	ldet_s = ds->data_observations.agaussian[1][idx];
	mm = ds->data_observations.agaussian[2][idx];
	nn = ds->data_observations.agaussian[3][idx];

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = nn * LOG_NORMC_GAUSSIAN + nn / 2.0 * lprec + ldet_s - 0.5 * mm * prec * (SQR(y - ypred) + v);
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = inla_Phi((y - ypred) * mm * prec);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_lognormal(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ LogNormal. This is similar to the normal
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double ly, lprec, prec, w, lw, lypred;

	double *cache = NULL;
	if (G_norm_const_compute[idx]) {
		cache = Calloc(3, double);
		G_norm_const_v[idx] = (void *) cache;
		G_norm_const_compute[idx] = 0;

		// log(y)
		cache[0] = log(ds->data_observations.y[idx]);
		// w
		cache[1] = (ds->data_observations.weight_gaussian ? ds->data_observations.weight_gaussian[idx] : 1.0);
		// log(w)
		cache[2] = log(cache[1]);
	}
	cache = (double *) G_norm_const_v[idx];
	ly = cache[0];
	w = cache[1];
	lw = cache[2];

	lprec = ds->data_observations.log_prec_gaussian[thread_id][0] + lw;
	prec = map_precision(ds->data_observations.log_prec_gaussian[thread_id][0], MAP_FORWARD, NULL) * w;

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			lypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = LOG_NORMC_GAUSSIAN + 0.5 * (lprec - (SQR(lypred - ly) * prec)) - ly;
		}
	} else {
		if (y_cdf)
			ly = log(*y_cdf);
		for (i = 0; i < -m; i++) {
			lypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = inla_Phi((ly - lypred) * sqrt(prec));
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_lognormalsurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_lognormal));
}

int loglikelihood_simplex(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y ~ simplex
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, yy, ypyp, lprec, prec, w, ypred;

	y = ds->data_observations.y[idx];
	w = ds->data_observations.weight_simplex[idx];
	lprec = ds->data_observations.log_prec_simplex[thread_id][0] + log(w);
	prec = map_precision(ds->data_observations.log_prec_simplex[thread_id][0], MAP_FORWARD, NULL) * w;

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			yy = y * (1.0 - y);
			ypyp = ypred * (1.0 - ypred);
			logll[i] = 0.5 * lprec - 0.5 * (log(2.0 * M_PI) + 3.0 * log(yy))
			    - prec * SQR(y - ypred) / (2.0 * yy * SQR(ypyp));
		}
	} else {
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);

	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_circular_normal(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y ~ circular normal
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, prec, w, ypred;

	LINK_INIT;
	y = ds->data_observations.y[idx];
	w = ds->data_observations.weight_circular_normal[idx];
	prec = map_precision(ds->data_observations.log_prec_circular_normal[thread_id][0], MAP_FORWARD, NULL) * w;

	/*
	 * store the normalising constant as it involves bessel_I0: -log(2 Pi BesselI0(kappa)),
	 * which is ok as long as the scalings 'w' do not change to often.
	 */
	double log_norm_const = 0.0, log_norm_const_arg = INLA_REAL_BIG;
	if (!ISEQUAL(prec, log_norm_const_arg)) {
		log_norm_const_arg = prec;
		log_norm_const = -log(2.0 * M_PI * gsl_sf_bessel_I0(prec));
	}

	for (i = 0; i < m; i++) {
		ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));

		/*
		 * we need |y-ypred| <= Pi, but this might not be the case...  so we add a penalty if this condition is not met
		 */
		if (ABS(y - ypred) <= M_PI) {
			logll[i] = log_norm_const + prec * cos(y - ypred);
		} else {
			double penalty = 1.0e8 * prec;
			if (y - ypred > M_PI) {
				logll[i] = log_norm_const + prec * cos(M_PI) - penalty / 2.0 * SQR(y - ypred - M_PI);
			} else {
				logll[i] = log_norm_const + prec * cos(-M_PI) - penalty / 2.0 * SQR(y - ypred + M_PI);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_wrapped_cauchy(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y ~ wrapped cauchy. DOES NOT WORK WELL OF'COURSE...
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, rho, rho2, w, ypred;
	double mlog2pi = -1.8378770664093454836;	       /* -log(2*pi) */

	LINK_INIT;
	y = ds->data_observations.y[idx];
	w = ds->data_observations.weight_wrapped_cauchy[idx];
	rho = map_probability(ds->data_observations.log_prec_wrapped_cauchy[thread_id][0], MAP_FORWARD, NULL) * w;
	rho2 = SQR(rho);

	for (i = 0; i < m; i++) {
		ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));

		/*
		 * we need |y-ypred| <= Pi, but this might not be the case...  so we add a penalty if this condition is not met
		 */
		if (ABS(y - ypred) <= M_PI) {
			logll[i] = mlog2pi + LOG_ONE_MINUS(rho2) - log1p(rho2 - 2.0 * rho * cos(y - ypred));
		} else {
			double penalty = 1.0e6 * (2.0 * rho / SQR(1.0 - rho));	/* The -Hessian in the mode... */
			if (y - ypred > M_PI) {
				logll[i] = mlog2pi + LOG_ONE_MINUS(rho2) - log1p(rho2 - 2.0 * rho * cos(M_PI))
				    - penalty / 2.0 * SQR(y - ypred - M_PI);
			} else {
				logll[i] = mlog2pi + LOG_ONE_MINUS(rho2) - log1p(rho2 - 2.0 * rho * cos(-M_PI))
				    - penalty / 2.0 * SQR(y - ypred + M_PI);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_stochvol(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ N(0, var = exp(x) + 1/tau) 
	 */
	int i;

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], var;
	double tau = map_precision(ds->data_observations.log_offset_prec[thread_id][0], MAP_FORWARD, NULL);
	double var_offset;

	LINK_INIT;
	var_offset = ((ISINF(tau) || ISNAN(tau)) ? 0.0 : 1.0 / tau);
	if (m > 0) {
		for (i = 0; i < m; i++) {
			var = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx)) + var_offset;
			logll[i] = LOG_NORMC_GAUSSIAN - 0.5 * log(var) - 0.5 * SQR(y) / var;
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			var = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx)) + var_offset;
			logll[i] = 1.0 - 2.0 * (1.0 - inla_Phi(ABS(y) / sqrt(var)));
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_stochvol_t(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y / exp(x/2)  ~ Student-t_dof(0, ***var = 1***)
	 *
	 * Note that Student-t_dof has variance dof/(dof-2), so we need to scale it.
	 */
	int i;
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	Data_section_tp *ds = (Data_section_tp *) arg;
	double dof, y, sd, sd2, obs, var_u;

	dof = map_dof(ds->data_observations.dof_intern_svt[thread_id][0], MAP_FORWARD, NULL);
	y = ds->data_observations.y[idx];
	sd2 = dof / (dof - 2.0);
	sd = sqrt(sd2);
	LINK_INIT;
	if (m > 0) {
		double lg1, lg2, f;

		lg1 = gsl_sf_lngamma(dof / 2.0);
		lg2 = gsl_sf_lngamma((dof + 1.0) / 2.0);
		for (i = 0; i < m; i++) {
			var_u = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			f = sqrt(var_u) / sd;
			obs = y / f;
			logll[i] = lg2 - lg1 - 0.5 * log(M_PI * dof) - (dof + 1.0) / 2.0 * log1p(SQR(obs) / dof) - log(f);
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			var_u = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = 1.0 - 2.0 * gsl_cdf_tdist_Q(ABS(y) * sd / sqrt(var_u), dof);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_stochvol_nig(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y / exp(x/2)  ~ NIG with skew and shape parameter. beta = skew, psi = shape. Note that E=1 and Var=1.
	 *
	 *
	 * density: gamma
	 *          * exp[ psi^2 + beta*(gamma*x + beta) ]
	 *          * K_1[sqrt(beta^2+psi^2)*sqrt((gamma*x+beta)^2 + psi^2)]
	 *
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double skew, skew2, shape, shape2, y, gam, gam2, tmp, obs, a, var_u;

	skew = ds->data_observations.skew_intern_svnig[thread_id][0];
	skew2 = SQR(skew);
	shape = map_shape_svnig(ds->data_observations.shape_intern_svnig[thread_id][0], MAP_FORWARD, NULL);
	shape2 = SQR(shape);
	gam2 = 1.0 + SQR(skew) / SQR(shape);
	gam = sqrt(gam2);
	y = ds->data_observations.y[idx];
	a = log(gam * shape / M_PI) + 0.5 * log(skew2 + shape2) + shape2;

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			var_u = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			obs = y / sqrt(var_u);
			tmp = SQR(gam * obs + skew) + shape2;
			logll[i] = a - 0.5 * log(tmp) + skew * (gam * obs + skew)
			    + gsl_sf_bessel_lnKnu(1.0, sqrt((skew2 + shape2) * tmp)) - log(var_u) / 2.0;
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_iid_gamma(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y ~ iid_gamma
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double shape, rate, w, xx, penalty = 1.0 / INLA_REAL_SMALL, cons;

	LINK_INIT;
	w = ds->data_observations.iid_gamma_scale[idx];
	shape = map_exp(ds->data_observations.iid_gamma_log_shape[thread_id][0], MAP_FORWARD, NULL);
	rate = map_exp(ds->data_observations.iid_gamma_log_rate[thread_id][0], MAP_FORWARD, NULL) * w;
	cons = -shape * log(rate) - gsl_sf_lngamma(shape);

	if (m > 0) {
		for (i = 0; i < m; i++) {
			xx = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			if (xx > INLA_REAL_SMALL) {
				logll[i] = cons + (shape - 1.0) * log(xx) - rate * xx;
			} else {
				/*
				 * this is the penalty, and should not happen in the end... 
				 */
				logll[i] =
				    cons + (shape - 1.0) * log(INLA_REAL_SMALL) - rate * INLA_REAL_SMALL - penalty * SQR(INLA_REAL_SMALL - xx);
			}
		}
	}
	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_iid_logitbeta(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y ~ iid_logitbeta
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double a, b, cons;

	LINK_INIT;
	a = map_exp(ds->data_observations.iid_logitbeta_log_a[thread_id][0], MAP_FORWARD, NULL);
	b = map_exp(ds->data_observations.iid_logitbeta_log_b[thread_id][0], MAP_FORWARD, NULL);
	cons = gsl_sf_lngamma(a + b) - (gsl_sf_lngamma(a) + gsl_sf_lngamma(b));

	if (m > 0) {
		for (i = 0; i < m; i++) {
			double eta = PREDICTOR_INVERSE_IDENTITY_LINK(x[i] + OFFSET(idx));
			double xx = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = cons + (a - 1.0) * log(xx) + (b - 1.0) * LOG_ONE_MINUS(xx) + PREDICTOR_INVERSE_LINK_LOGJACOBIAN(eta);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_loggamma_frailty(int thread_id, double *logll, double *x, int m, int UNUSED(idx), double *UNUSED(x_vec), double *UNUSED(y_cdf),
				   void *arg)
{
	/*
	 * Log-gamma frailty Gamma(a,a), a = exp(log_prec...)
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double lprec, prec;
	double log_gamma;

	// LINK_INIT;
	lprec = ds->data_observations.log_prec_loggamma_frailty[thread_id][0];
	prec = map_precision(lprec, MAP_FORWARD, NULL);
	log_gamma = gsl_sf_lngamma(prec);

	if (m > 0) {
		for (i = 0; i < m; i++) {
			logll[i] = -log_gamma + prec * (lprec + x[i] - exp(x[i]));
		}
	}
	// LINK_END;

	return GMRFLib_SUCCESS;
}

int loglikelihood_logistic(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ Logisistc. scaled so that prec = 1 gives variance = 1
	 *
	 * A := Pi/sqrt(3)
	 *
	 * > F(x);             
	 *                                                     1
	 *                                          ------------------------
	 *                                          1 + exp(-tau A (x - mu))
	 *
	 *
	 * > solve(F(x) = p,x);
	 *                                                         -1 + p
	 *                                           tau A mu - ln(- ------)
	 *                                                             p
	 *                                           -----------------------
	 *                                                    tau A
	 * > diff(F(x),x);
	 *                                          tau A exp(-tau A (x - mu))
	 *                                         ---------------------------
	 *                                                                   2
	 *                                         (1 + exp(-tau A (x - mu)))
	 *
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, prec, w, A = M_PI / sqrt(3.0), precA, lprecA, eta;

	LINK_INIT;
	y = ds->data_observations.y[idx];
	w = ds->data_observations.weight_logistic[idx];
	prec = map_precision(ds->data_observations.log_prec_logistic[thread_id][0], MAP_FORWARD, NULL) * w;
	precA = prec * A;
	lprecA = log(precA);

	if (m > 0) {
		for (i = 0; i < m; i++) {
			eta = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = lprecA - precA * (y - eta) - 2.0 * log1p(exp(-precA * (y - eta)));
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			eta = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = 1.0 / (1.0 + exp(-precA * (y - eta)));
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_sn(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ Skew_Normal(x, stdev)
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, lprec, sprec, w, xarg, ypred, *param[2], nan = NAN;
	inla_sn_arg_tp sn_arg;

	LINK_INIT;
	y = ds->data_observations.y[idx];
	w = ds->data_observations.sn_scale[idx];
	lprec = ds->data_observations.sn_lprec[thread_id][0] + log(w);
	sprec = exp(lprec / 2.0);

	param[0] = ds->data_observations.sn_skew[thread_id];
	param[1] = &nan;
	inla_get_sn_param(&sn_arg, param);
	assert(sn_arg.intercept == 0);

	if (m > 0) {
		for (i = 0; i < m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			xarg = ((y - ypred - sn_arg.intercept) * sprec - sn_arg.xi) / sn_arg.omega;
			logll[i] =
			    LOG_NORMC_GAUSSIAN + M_LN2 + 0.5 * lprec - log(sn_arg.omega) - 0.5 * SQR(xarg) + inla_log_Phi_fast(sn_arg.alpha * xarg);
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y), nan = NAN;
		param[1] = &nan;			       /* this will remove the internal intercept */
		for (i = 0; i < -m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			xarg = (yy - ypred - sn_arg.intercept) * sprec;
			logll[i] = map_invsn_core(xarg, MAP_FORWARD, param, NULL);
		}
	}
	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_stochvol_sn(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y ~ Skew_Normal(0, var= exp(x)+offset, skew)
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, sprec, xarg, *param[2], nan = NAN, var_offset, var, lomega;
	inla_sn_arg_tp sn_arg;

	LINK_INIT;
	y = ds->data_observations.y[idx];
	var_offset = 1.0 / map_precision(ds->data_observations.log_offset_prec[thread_id][0], MAP_FORWARD, NULL);
	param[0] = ds->data_observations.sn_skew[thread_id];
	param[1] = &nan;
	inla_get_sn_param(&sn_arg, param);
	assert(sn_arg.intercept == 0.0);
	lomega = log(sn_arg.omega);

	if (m > 0) {
		for (i = 0; i < m; i++) {
			var = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx)) + var_offset;
			sprec = sqrt(1.0 / var);
			xarg = (y * sprec - sn_arg.xi) / sn_arg.omega;
			logll[i] = LOG_NORMC_GAUSSIAN + M_LN2 + log(sprec) - lomega - 0.5 * SQR(xarg) + inla_log_Phi_fast(sn_arg.alpha * xarg);
		}
	}
	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_gev(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ GEV
	 */
	int i;
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, sprec, w, xi, xx, ypred;

	LINK_INIT;
	y = ds->data_observations.y[idx];
	w = ds->data_observations.weight_gev[idx];
	sprec = sqrt(map_precision(ds->data_observations.log_prec_gev[thread_id][0], MAP_FORWARD, NULL) * w);
	/*
	 * map_identity_scale(theta, MAP_FORWARD, arg...);
	 */
	xi = ds->data_observations.gev_scale_xi * ds->data_observations.xi_gev[thread_id][0];

	if (m > 0) {
		if (ISZERO(xi)) {
			for (i = 0; i < m; i++) {
				ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				xx = sprec * (y - ypred);
				logll[i] = -xx - exp(-xx) + log(sprec);
			}
		} else {
			for (i = 0; i < m; i++) {
				ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				xx = 1.0 + xi * sprec * (y - ypred);
				if (xx > INLA_REAL_SMALL) {
					logll[i] = (-1.0 / xi - 1.0) * log(xx) - pow(xx, -1.0 / xi) + log(sprec);
				} else {
					logll[i] =
					    (-1.0 / xi - 1.0) * log(INLA_REAL_SMALL) - pow(INLA_REAL_SMALL,
											   -1.0 / xi) + log(sprec) -
					    1e6 * SQR(sprec * (INLA_REAL_SMALL - xx));
				}
			}
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		if (ISZERO(xi)) {
			for (i = 0; i < -m; i++) {
				ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				xx = sprec * (yy - ypred);
				logll[i] = exp(-exp(-xx));
			}
		} else {
			for (i = 0; i < -m; i++) {
				ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				xx = sprec * (yy - ypred);
				double a = 1.0 + xi * xx;
				if (a > 0.0) {
					logll[i] = exp(-pow(a, -1.0 / xi));
				} else {
					logll[i] = (xi > 0.0 ? 0.0 : 1.0);
				}
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_bgev(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
#define f3_BETA_STD(_x) (30.0 * SQR(_x) * SQR(1.0-(_x)))
#define F3_BETA_STD(_x) (gsl_pow_3(_x) * (10.0 + (-15.0 + 6.0 * (_x)) * (_x)))
#define f3_BETA(_x, _a, _b) (f3_BETA_STD((((_x) - (_a)) / ((_b) - (_a)))) / ((_b) - (_a)))
#define F3_BETA(_x, _a, _b) F3_BETA_STD((((_x) - (_a)) / ((_b) - (_a))))
#define f4_BETA_STD(_x) (140.0 * gsl_pow_3(_x) * gsl_pow_3(1.0 - (_x)))
#define F4_BETA_STD(_x) (gsl_pow_4(_x) * (35.0 + (-84.0 + (70.0 - 20.0 * (_x)) * (_x)) * (_x)))
#define f4_BETA(_x, _a, _b) (f4_BETA_STD(((_x) - (_a)) / ((_b) - (_a))) / ((_b) - (_a)))
#define F4_BETA(_x, _a, _b) F4_BETA_STD((((_x) - (_a)) / ((_b) - (_a))))
#define f5_BETA_STD(_x) (630.0 * gsl_pow_4(_x) * gsl_pow_4(1.0 - (_x)))
#define F5_BETA_STD(_x) (gsl_pow_5(_x) * ((_x) * ((_x) * ((_x) * ((_x) * 70.0 - 315.0) + 540.0) - 420.0) + 126.0))
#define f5_BETA(_x, _a, _b) (f5_BETA_STD((((_x) - (_a)) / ((_b) - (_a)))) / ((_b) - (_a)))
#define F5_BETA(_x, _a, _b) F5_BETA_STD((((_x) - (_a)) / ((_b) - (_a))))
#define f6_BETA_STD(_x) (2772.0 * gsl_pow_5(_x) * gsl_pow_5(1.0 - (_x)))
#define F6_BETA_STD(_x) (gsl_pow_6(_x) * ((_x) * ((_x) * ((_x) * ((_x) * ((_x) * (-252.0) + 1386.0) - 3080.0) + 3465.0) - 1980.0) + 462.0))
#define f6_BETA(_x, _a, _b) (f6_BETA_STD((((_x) - (_a)) / ((_b) - (_a)))) / ((_b) - (_a)))
#define F6_BETA(_x, _a, _b) F6_BETA_STD((((_x) - (_a)) / ((_b) - (_a))))
#define f_BETA(_x, _a, _b) f5_BETA(_x, _a, _b)
#define F_BETA(_x, _a, _b) F5_BETA(_x, _a, _b)
#define p(_x, _a, _b) F_BETA(_x, _a, _b)
#define p_deriv(_x, _a, _b) f_BETA(_x, _a, _b)
#define T1_SCALED_M1(_x, _xi) pow( 1.0 + (_xi) * (_x), -1.0 / (_xi) - 1.0)
#define T1_SCALED(_x, _xi) pow( 1.0 + (_xi) * (_x), -1.0 / (_xi))
#define T1(_x, _loc, _scale, _xi) T1_SCALED((((_x) - (_loc)) / (_scale)), _xi)
#define T2_SCALED(_x) exp(-(_x))
#define T2(_x, _loc, _scale) T2_SCALED((((_x) - (_loc)) / (_scale)))
#define log_G(_x, _loc, _scale, _xi) (-T1(_x, _loc, _scale, _xi))
#define G(_x, _loc, _scale, _xi) exp(log_G(_x, _loc, _scale, _xi))
#define log_H(_x, _loc, _scale)	(-T2(_x, _loc, _scale))
#define H(_x, _loc, _scale) exp(log_H(_x, _loc, _scale))
#define h(_x, _loc, _scale) (H(_x, _loc, _scale) * T2(_x, _loc, _scale) / (_scale))
#define log_h(_x, _loc, _scale) (log_H(_x, _loc, _scale) + log(T2(_x, _loc, _scale)) - log(_scale))
#define g(_x, _loc, _scale, _xi) (G(_x, _loc, _scale, _xi) * T1_SCALED_M1(((_x) - (_loc))/(_scale), _xi) / (_scale))
#define log_g(_x, _loc, _scale, _xi) (log_G(_x, _loc, _scale, _xi) + log(T1_SCALED_M1(((_x) - (_loc))/(_scale), _xi)) - log(_scale))

	if (0) {
		double loc = 1.2, scale = 1.5, xi = 0.5, _x;
		FILE *fp = fopen("out.txt", "w");
		for (_x = 0.001 + loc - scale / xi; _x <= loc + 4.0 * scale / xi; _x += 0.01)
			fprintf(fp, "%g %g %g %g %g %g %g\n", _x, H(_x, loc, scale), h(_x, loc, scale), exp(log_h(_x, loc, scale)),
				G(_x, loc, scale, xi), g(_x, loc, scale, xi), exp(log_g(_x, loc, scale, xi)));
		fclose(fp);
		exit(0);
	}

	if (0) {
		double a = 1.2, b = 2.5, _x;
		FILE *fp = fopen("out.txt", "w");
		for (_x = a; _x <= b; _x += (b - a) / 1000)
			fprintf(fp, "%f %g %g %g %g %g %g %g %g\n", _x,
				f3_BETA(_x, a, b), F3_BETA(_x, a, b), f4_BETA(_x, a, b),
				F4_BETA(_x, a, b), f5_BETA(_x, a, b), F5_BETA(_x, a, b), f6_BETA(_x, a, b), F6_BETA(_x, a, b));
		fclose(fp);
		exit(1);
	}

	/*
	 * y ~ GEV
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	int i, off;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double location, spread, log_spread, log_xi, xi, sigma, sigmaH, d, mu, muH, sprec, ypred, xx, y, w, ld;
	double qlocation = ds->data_observations.bgev_qlocation;
	double qspread = ds->data_observations.bgev_qspread;
	double mix_a, qmix_a = ds->data_observations.bgev_qmix[0];
	double mix_b, qmix_b = ds->data_observations.bgev_qmix[1];

	double ab = ds->data_observations.bgev_beta_ab;
	static double count[3] = { 0.0, 0.0, 0.0 };

	if (ab != 5.0) {
		static char first = 1;
		if (first) {
			fprintf(stderr, "*** Warning ***: loglikelihood_bgev: argument beta_ab=[%.2f] is not used\n", ab);
			fprintf(stdout, "*** Warning ***: loglikelihood_bgev: argument beta_ab=[%.2f] is not used\n", ab);
		}
		first = 0;
	}

	LINK_INIT;
	y = ds->data_observations.y[idx];
	w = ds->data_observations.bgev_scale[idx];

	off = 0;
	log_spread = ds->data_observations.bgev_log_spread[thread_id][0];
	for (i = 0; i < ds->data_observations.bgev_nbetas[0]; i++) {
		log_spread += ds->data_observations.bgev_betas[i + off][thread_id][0] * ds->data_observations.bgev_x[i + off][idx];
	}
	spread = map_exp(log_spread, MAP_FORWARD, NULL) / sqrt(w);

	off = ds->data_observations.bgev_nbetas[0];
	log_xi = ds->data_observations.bgev_intern_tail[thread_id][0];
	if (ISINF(log_xi) == -1) {
		xi = 0.0;
		assert(ds->data_observations.bgev_nbetas[1] == 0);
	} else {
		for (i = 0; i < ds->data_observations.bgev_nbetas[1]; i++) {
			log_xi += ds->data_observations.bgev_betas[i + off][thread_id][0] * ds->data_observations.bgev_x[i + off][idx];
		}
		xi = map_interval(log_xi, MAP_FORWARD, (void *) (ds->data_observations.bgev_tail_interval));
	}

	if (m > 0) {
		if (ISZERO(xi)) {
			d = log(-log(qspread / 2.0)) - log(-LOG_ONE_MINUS(qspread / 2.0));
			for (i = 0; i < m; i++) {
				location = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				sigma = spread / d;
				mu = location + sigma * log(-log(qlocation));
				sprec = 1.0 / sigma;
				ypred = mu;
				xx = sprec * (y - ypred);
				logll[i] = -xx - exp(-xx) + log(sprec);
			}
		} else {
			int left = 0;

			d = (pow(-LOG_ONE_MINUS(qspread / 2.0), -xi) - pow(-log(qspread / 2.0), -xi)) / xi;
			for (i = 0; i < m; i++) {
				sigma = spread / d;
				location = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = location - sigma * ((pow(-log(qlocation), -xi) - 1.0) / xi);
				mix_a = (pow(-log(qmix_a), -xi) - 1.0) / xi * sigma + mu;
				mix_b = (pow(-log(qmix_b), -xi) - 1.0) / xi * sigma + mu;
				sigmaH = (mix_b - mix_a) / log(log(qmix_a) / log(qmix_b));
				muH = mix_a + sigmaH * log(-log(qmix_a));

				if (y >= mix_b) {
					count[0]++;
					ld = log_g(y, mu, sigma, xi);
				} else if (y <= mix_a) {
					left = 1;
					count[1]++;
					ld = log_h(y, muH, sigmaH);
				} else {
					double value_p, value_p_deriv, value_g, value_log_G, value_h, value_log_H;
					count[2]++;

					value_p = p(y, mix_a, mix_b);
					value_p_deriv = p_deriv(y, mix_a, mix_b);
					value_g = g(y, mu, sigma, xi);
					value_log_G = log_G(y, mu, sigma, xi);
					value_h = h(y, muH, sigmaH);
					value_log_H = log_H(y, muH, sigmaH);

					ld = (value_p * value_log_G + (1.0 - value_p) * value_log_H) +
					    log(value_p_deriv * value_log_G + value_p * value_g / exp(value_log_G)
						- value_p_deriv * value_log_H + (1.0 - value_p) * value_h / exp(value_log_H));
				}
				if (ISNAN(ld) || ISINF(ld))
					printf("bgev: idx x ld y %d %g %g %g\n", idx, x[i], logll[i], y);

				logll[i] = ld;
			}

			if (0 && left)
				printf("right %.3g left %.3g mix %.3g\n",
				       count[0] / (count[0] + count[1] + count[2]),
				       count[1] / (count[0] + count[1] + count[2]), count[2] / (count[0] + count[1] + count[2]));
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		if (ISZERO(xi)) {
			d = log(-log(qspread / 2.0)) - log(-LOG_ONE_MINUS(qspread / 2.0));
			for (i = 0; i < -m; i++) {
				location = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				sigma = spread / d;
				mu = location + sigma * log(-log(qlocation));
				sprec = 1.0 / sigma;
				ypred = mu;
				xx = sprec * (yy - ypred);
				logll[i] = exp(-exp(-xx));
			}
		} else {
			d = (pow(-LOG_ONE_MINUS(qspread / 2.0), -xi) - pow(-log(qspread / 2.0), -xi)) / xi;
			for (i = 0; i < -m; i++) {
				sigma = spread / d;
				location = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = location - sigma * ((pow(-log(qlocation), -xi) - 1.0) / xi);
				mix_a = (pow(-log(qmix_a), -xi) - 1.0) / xi * sigma + mu;
				mix_b = (pow(-log(qmix_b), -xi) - 1.0) / xi * sigma + mu;
				sigmaH = (mix_b - mix_a) / log(log(qmix_a) / log(qmix_b));
				muH = mix_a + sigmaH * log(-log(qmix_a));

				if (yy >= mix_b) {
					ld = log_G(yy, mu, sigma, xi);
				} else if (yy <= mix_a) {
					ld = log_H(yy, muH, sigmaH);
				} else {
					double value_p = p(yy, mix_a, mix_b);
					ld = value_p * log_G(yy, mu, sigma, xi) + (1.0 - value_p) * log_H(yy, muH, sigmaH);
				}
				logll[i] = exp(ld);
			}
		}
	}

#undef f3_BETA_STD
#undef F3_BETA_STD
#undef f3_BETA
#undef F3_BETA
#undef f4_BETA_STD
#undef F4_BETA_STD
#undef f4_BETA
#undef F4_BETA
#undef f5_BETA_STD
#undef F5_BETA_STD
#undef f5_BETA
#undef F5_BETA
#undef f6_BETA_STD
#undef F6_BETA_STD
#undef f6_BETA
#undef F6_BETA
#undef f_BETA
#undef F_BETA
#undef p
#undef p_deriv
#undef T1_SCALED
#undef T1
#undef T2_SCALED
#undef T2
#undef logG
#undef G
#undef logH
#undef H
#undef h
#undef log_h
#undef g
#undef log_g

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_t(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y -x ~ (Student_t with variance 1) times 1/sqrt(precision * weight)
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, prec, w, dof, y_std, fac, ypred;

	LINK_INIT;
	dof = map_dof(ds->data_observations.dof_intern_t[thread_id][0], MAP_FORWARD, NULL);
	y = ds->data_observations.y[idx];
	w = ds->data_observations.weight_t[idx];
	prec = map_precision(ds->data_observations.log_prec_t[thread_id][0], MAP_FORWARD, NULL) * w;
	fac = sqrt((dof / (dof - 2.0)) * prec);

	double lg1 = 0.0, lg2 = 0.0;
	lg1 = gsl_sf_lngamma(dof / 2.0);
	lg2 = gsl_sf_lngamma((dof + 1.0) / 2.0);

	if (m > 0) {
		for (i = 0; i < m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			y_std = (y - ypred) * fac;
			logll[i] = lg2 - lg1 - 0.5 * log(M_PI * dof) - (dof + 1.0) / 2.0 * log1p(SQR(y_std) / dof) + log(fac);
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = gsl_cdf_tdist_P((y - ypred) * fac, dof);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_tstrata(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y -x ~ (Student_t with variance 1) times 1/sqrt(precision * weight)
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_DERIVATIES_AND_CDF;
	}

	int i, dcode, strata;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, prec, w, dof, y_std, fac, ypred;

	int bit_fac = GMRFLib_getbit((GMRFLib_uchar) ds->variant, (unsigned int) 0);
	int bit_tail = GMRFLib_getbit((GMRFLib_uchar) ds->variant, (unsigned int) 1);

	LINK_INIT;
	dof = map_dof(ds->data_observations.dof_intern_tstrata[thread_id][0], MAP_FORWARD, NULL);
	y = ds->data_observations.y[idx];
	w = ds->data_observations.weight_tstrata[idx];
	strata = (int) (ds->data_observations.strata_tstrata[idx] + INLA_REAL_SMALL);
	prec = map_precision(ds->data_observations.log_prec_tstrata[strata][thread_id][0], MAP_FORWARD, NULL) * w;

	// printf("idx y x strata prec %d %g %g %d %g\n", idx, y, x[0], strata, prec);

	switch (bit_fac) {
	case 0:
	{
		fac = sqrt(prec);
	}
		break;

	case 1:
	{
		fac = sqrt((dof / (dof - 2.0)) * prec);
	}
		break;

	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	double lg1 = 0.0, lg2 = 0.0;
	lg1 = gsl_sf_lngamma(dof / 2.0);
	lg2 = gsl_sf_lngamma((dof + 1.0) / 2.0);

	int use_tail_correction;

	switch (bit_tail) {
	case 0:
	{
		use_tail_correction = GMRFLib_FALSE;
	}
		break;

	case 1:
	{
		use_tail_correction = GMRFLib_TRUE;
	}
		break;

	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	double tail_factor = 0.98;
	double tail_start = tail_factor * sqrt(dof);
	double tail_prec = (dof + 1.0) * (dof - SQR(tail_start)) / SQR(dof + SQR(tail_start));
	double diff = -(dof + 1) * tail_start / (dof + SQR(tail_start));
	double dev, log_normc, normc1, log_normc2, eff, ef;

	if (m > 0) {
		if (use_tail_correction) {
			normc1 = 2.0 * gsl_cdf_tdist_P(tail_start, dof) - 1.0;
			log_normc2 = lg2 - lg1 - 0.5 * log(M_PI * dof) - (dof + 1.0) / 2.0 * log1p(SQR(tail_start) / dof) + log(fac)
			    - 0.5 * log(2.0) + 0.5 * log(M_PI / tail_prec)
			    + 0.5 * SQR(diff) / tail_prec;
			eff = diff / sqrt(2.0 * tail_prec);
			ef = gsl_sf_erf(eff);
			if (ef == -1.0) {
				/*
				 * asymptotic expansion 
				 */
				log_normc2 += -SQR(eff) - 0.5 * log(M_PI) - log(-eff) - 1.0 / (2.0 * SQR(eff));
			} else if (ef == 1.0) {
				/*
				 * asymptotic expansion 
				 */
				log_normc2 += log(2.0) - 1.0 / (2.0 * sqrt(M_PI) * eff) * exp(-SQR(eff));
			} else {
				log_normc2 += log(ef + 1.0);
			}
			log_normc = log(normc1 + 2.0 * exp(log_normc2));
		} else {
			log_normc = 0.0;
		}

		if (m > 0) {
			/*
			 * assume this for the moment, otherwise we have to add new code...
			 */
			assert(ds->predictor_invlinkfunc == link_identity);

			for (i = 0; i < m; i++) {
				ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				y_std = (y - ypred) * fac;
				dcode = (m <= 3 ? i : 0);      /* if m > 3 we should not compute deriviaties... */

				if (ABS(y_std) > tail_start && use_tail_correction) {
					if (y_std > tail_start) {
						dev = y_std - tail_start;
					} else {
						dev = y_std + tail_start;
						diff *= -1.0;  /* swap sign */
					}

					switch (dcode) {
					case 0:
					{
						logll[i] =
						    lg2 - lg1 - 0.5 * log(M_PI * dof) - (dof + 1.0) / 2.0 * log1p(SQR(tail_start) / dof) + log(fac);
						logll[i] += -0.5 * tail_prec * SQR(dev) + diff * dev;
						logll[i] -= log_normc;
					}
						break;

					case 1:
					{
						if (y_std > tail_start) {
							logll[i] = tail_prec * dev * fac - diff * fac;
						} else {
							logll[i] = tail_prec * dev * fac + diff * fac;
						}
					}
						break;

					case 2:
					{
						logll[i] = -tail_prec * SQR(fac);
					}
						break;

					default:
						GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
					}
				} else {
					switch (dcode) {
					case 0:
					{
						logll[i] =
						    lg2 - lg1 - 0.5 * log(M_PI * dof) - (dof + 1.0) / 2.0 * log1p(SQR(y_std) / dof) + log(fac);
						logll[i] -= log_normc;
					}
						break;

					case 1:
					{
						logll[i] = (dof + 1.0) * fac * y_std / (dof + SQR(y_std));
					}
						break;

					case 2:
					{
						logll[i] = -(dof + 1.0) * SQR(fac) * (dof - SQR(y_std)) / SQR(dof + SQR(y_std));
					}
						break;

					default:
						GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
					}
				}

			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < (-m); i++) {
				ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				y_std = (y - ypred) * fac;
				if (ABS(y_std) > tail_start && use_tail_correction) {
					if (y_std > tail_start) {
						dev = y_std - tail_start;
					} else {
						dev = y_std + tail_start;
						diff *= -1.0;  /* swap sign */
					}
					logll[i] = lg2 - lg1 - 0.5 * log(M_PI * dof) - (dof + 1.0) / 2.0 * log1p(SQR(tail_start) / dof) + log(fac);
					logll[i] += -0.5 * tail_prec * SQR(dev) + diff * dev;
				} else {
					logll[i] = lg2 - lg1 - 0.5 * log(M_PI * dof) - (dof + 1.0) / 2.0 * log1p(SQR(y_std) / dof) + log(fac);
				}
				logll[i] -= log_normc;
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		FIXME1("PIT-VALUES ARE NOT YET CORRECT AND ASSUME T.");
		for (i = 0; i < -m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = gsl_cdf_tdist_P((y - ypred) * fac, dof);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_gpoisson(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ GPoisson(E*exp(x))
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i, yy;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double phi = map_exp(ds->data_observations.gpoisson_overdispersion[thread_id][0], MAP_FORWARD, NULL);
	double p = map_identity(ds->data_observations.gpoisson_p[thread_id][0], MAP_FORWARD, NULL);
	double E = ds->data_observations.E[idx];
	double a, b, lambda, mu;

	if (G_norm_const_compute[idx]) {
		G_norm_const[idx] = my_gsl_sf_lnfact(y);
		G_norm_const_compute[idx] = 0;
	}
	double log_y_fact = G_norm_const[idx];

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			a = mu + phi * pow(mu, p - 1.0) * y;
			b = 1 + phi * pow(mu, p - 1.0);
			logll[i] = log(mu) + (y - 1.0) * log(a) - y * log(b) - log_y_fact - a / b;
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			b = 1 + phi * pow(mu, p - 1.0);
			logll[i] = 0.0;
			for (yy = 0; yy <= (int) y; yy++) {
				a = mu + phi * pow(mu, p - 1.0) * yy;
				logll[i] += exp(log(mu) + (yy - 1.0) * log(a) - yy * log(b) - my_gsl_sf_lnfact(yy) - a / b);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_poisson(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
#define _logE(E_) (E_ > 0.0 ? log(E_) : 0.0)

	/*
	 * y ~ Poisson(E*exp(x)), also accept E=0, giving the likelihood y * x.
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx];
	double normc;

	if (G_norm_const_compute[idx]) {
		G_norm_const[idx] = y * _logE(E) - my_gsl_sf_lnfact(y);
		G_norm_const_compute[idx] = 0;
	}
	normc = G_norm_const[idx];

	LINK_INIT;
	if (m > 0) {
		double ylEmn = normc;
		if (PREDICTOR_LINK_EQ(link_log)) {
			double off = OFFSET(idx);
#pragma GCC ivdep
			for (int i = 0; i < m; i++) {
				double log_lambda = PREDICTOR_INVERSE_IDENTITY_LINK(x[i] + off);
				logll[i] = y * log_lambda + ylEmn - E * exp(log_lambda);
			}
		} else {
#pragma GCC ivdep
			for (int i = 0; i < m; i++) {
				double lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = y * log(lambda) + ylEmn - E * lambda;
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (int i = 0; i < -m; i++) {
			double lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			if (ISZERO(E * lambda)) {
				if (ISZERO(y)) {
					logll[i] = 1.0;
				} else {
					assert(!ISZERO(y));
				}
			} else {
				double m = E * lambda;
				if (m > 10000.0) {
					logll[i] = gsl_cdf_ugaussian_P((y + 0.5 - m) / sqrt(m));
				} else {
					logll[i] = gsl_cdf_poisson_P((unsigned int) y, E * lambda);
				}
			}
		}
	}

	LINK_END;
#undef _logE

	return GMRFLib_SUCCESS;
}

double eval_log_contpoisson(double y, double lambda)
{
	// use that f.cont(x+1/2) approx f.poisson(x) for integer x's. I wasn't able to get the incomplete_gamma version
	// accurate enough to work. maybe the connection with the Gamma-distribution is a nice way to go?
#define _R 2
#define _L 3
#define _LEN (_R + _L + 2)
	int i, istart, iy, low, high, len;
	double work[2 * _LEN], *xx, *yy, lval;
	GMRFLib_spline_tp *spline;

	low = IMAX(0, (int) y - _L);
	high = (int) y + _R;
	len = high - low + 1;
	xx = work;
	yy = work + _LEN;

	if (low == 0) {
		xx[0] = 0.0;
		yy[0] = log(INLA_REAL_SMALL);
		istart = 1;
		len++;
	} else {
		istart = 0;
	}

	for (iy = low, i = istart; iy <= high; iy++, i++) {
		xx[i] = iy + 0.5;
		yy[i] = iy * log(lambda) - lambda - my_gsl_sf_lnfact(iy);
	}
	spline = GMRFLib_spline_create(xx, yy, len);
	lval = GMRFLib_spline_eval(y, spline);
	GMRFLib_spline_free(spline);
#undef _L
#undef _R
#undef _LEN

	return (lval);
}

int loglikelihood_contpoisson(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	// this model is disabled
	assert(0 == 1);

	/*
	 * y ~ ContPoisson(E*exp(x))
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], lambda;

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			lambda = E * PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = eval_log_contpoisson(y + 1.0, lambda);
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);

		// slight inconsistency, as we use the 'exact' expression here, and an (good) approximation above.
		double normc = exp(gsl_sf_lngamma(y + 1.0));
		for (i = 0; i < -m; i++) {
			lambda = E * PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = gsl_sf_gamma_inc(y + 1.0, lambda) / normc;
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_qcontpoisson(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	// this model is disabled
	assert(0 == 1);

	/*
	 * y ~ ContPoisson(E*exp(x)), also accept E=0, giving the likelihood y * x.  quantile version
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i, id = 0;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], lambda, q;

	GMRFLib_CACHE_SET_ID(id);
	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			q = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			lambda = E * exp(GMRFLib_spline_eval(log(q), ds->data_observations.qcontpoisson_func[id]));
			logll[i] = eval_log_contpoisson(y + 1.0, lambda);
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);

		// slight inconsistency, as we use the 'exact' expression here, and an (good) approximation above.
		double normc = exp(gsl_sf_lngamma(y + 1.0));
		for (i = 0; i < -m; i++) {
			q = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			lambda = E * exp(GMRFLib_spline_eval(log(q), ds->data_observations.qcontpoisson_func[id]));
			logll[i] = gsl_sf_gamma_inc(y + 1.0, lambda) / normc;
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

double inla_poisson_interval(double mean, int ifrom, int ito)
{
	// Compute Prob(y_from <= Y <= y_to) for the poisson with given mean.
	// NOTE1: Both ends of the interval are included.
	// NOTE2: if ito < 0, then 'ito' is interpreted as INFINITY
	// NOTE3: if ifrom < 0, then 'ifrom' is interpreted as INFINITY

	double prob, prob_sum = 0.0;

	if (ifrom < 0) {
		// ifrom=INFINITE
	} else if (ito < 0) {
		if (ifrom == 0) {
			prob_sum = 1.0;
		} else {
			prob_sum = 1.0 - gsl_cdf_poisson_P((unsigned int) (ifrom - 1), mean);
		}
	} else {
		assert(ito >= ifrom);
		prob_sum = prob = pow(mean, (double) ifrom) * exp(-mean) / exp(my_gsl_sf_lnfact(ifrom));
		for (int y = ifrom + 1; y <= ito; y++) {
			prob *= mean / (double) y;
			prob_sum += prob;
		}
	}
	return (prob_sum);
}

double inla_negative_binomial_interval(double size, double mu, int y_from, int y_to)
{
	// Compute Prob(y_from <= Y <= y_to) for nbinomial(size,prob).
	// NOTE1: Both ends of the interval are included.
	// NOTE2: if y_to < 0, then 'y_to' is interpreted as INFINITY
	// NOTE3: if y_from < 0, then 'y_from' is interpreted as INFINITY

	double prob = size / (size + mu);
	double p, p_sum = 0.0;

	if (y_from < 0) {
		p_sum = 0.0;
	} else if (y_to < 0) {
		if (y_from == 0) {
			p_sum = 1.0;
		} else {
			p_sum = 1.0 - gsl_cdf_negative_binomial_P((unsigned int) (y_from - 1), prob, size);
		}
	} else {
		assert(y_to >= y_from);
		p = p_sum = gsl_ran_negative_binomial_pdf((unsigned int) y_from, prob, size);
		double pp = 1.0 - prob;
		for (int y = y_from + 1; y <= y_to; y++) {
			double yy = (double) y;
			p *= (yy + size - 1.0) / yy * pp;
			p_sum += p;
		}
	}
	return (p_sum);
}

int loglikelihood_cenpoisson2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ Poisson(E*exp(x)), [cen_low,cen_high] is cencored. cen_high<0 means Inf
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double mu;
	double lambda;
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double cen_low = ds->data_observations.cen_low[idx];
	double cen_high = ds->data_observations.cen_high[idx];
	double normc = my_gsl_sf_lnfact(y);
	int int_low = (int) cen_low;
	int int_high = (int) cen_high;

	LINK_INIT;
	if (m > 0) {
		if (int_low < 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				logll[i] = y * log(mu) - mu - normc;
			}
		} else if (y >= int_low && (int_high < 0 || y <= int_high)) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				logll[i] = log(inla_poisson_interval(mu, int_low, int_high));
			}
		} else {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				logll[i] = y * log(mu) - mu - normc;
			}
		}
	} else {
		double *yy = (y_cdf ? y_cdf : &y);
		int iy = (int) (*yy);

		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (ISZERO(mu)) {
				if (ISZERO(iy)) {
					logll[i] = 1.0;
				} else {
					assert(!ISZERO(iy));
				}
			} else {
				if (int_low < 0) {
					logll[i] = gsl_cdf_poisson_P((unsigned int) iy, mu);
				} else if (iy < int_low || (int_high >= 0 && iy > int_high)) {
					logll[i] = gsl_cdf_poisson_P((unsigned int) iy, mu);
				} else {
					if (int_low > 0) {
						logll[i] = gsl_cdf_poisson_P((unsigned int) (int_low - 1), mu);
					} else {
						logll[i] = 0.0;
					}
					logll[i] += 0.5 * inla_poisson_interval(mu, int_low, int_high);
				}
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_cenpoisson(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ Poisson(E*exp(x)), also accept E=0, giving the likelihood y * x. values in CENINTERVAL is cencored
	 *
	 * interval[1] < 0 means infinity
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double *interval = ds->data_observations.cenpoisson_interval, mu;
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], normc = my_gsl_sf_lnfact(y), lambda;
	int int_low = (int) interval[0], int_high = (int) interval[1];

	// must use 'double' to store an INF
	if (ISINF(interval[1]) || interval[1] < 0) {
		int_high = -1;
	}

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (y >= int_low && (int_high < 0 || y <= int_high)) {
				logll[i] = log(inla_poisson_interval(mu, int_low, int_high));
			} else {
				logll[i] = y * log(mu) - mu - normc;
			}
		}
	} else {
		double *yy = (y_cdf ? y_cdf : &y);
		int iy = (int) (*yy);

		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (ISZERO(mu)) {
				if (ISZERO(iy)) {
					logll[i] = 1.0;
				} else {
					assert(!ISZERO(iy));
				}
			} else {
				if (iy < int_low || (int_high >= 0 && iy > int_high)) {
					logll[i] = gsl_cdf_poisson_P((unsigned int) iy, mu);
				} else {
					if (int_low > 0) {
						logll[i] = gsl_cdf_poisson_P((unsigned int) (int_low - 1), mu);
					} else {
						logll[i] = 0.0;
					}
					logll[i] += 0.5 * inla_poisson_interval(mu, int_low, int_high);
				}
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_cenpoisson0(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double *interval = ds->data_observations.cenpoisson_interval;
	double mu, p0, fac, p = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL);
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], normc = my_gsl_sf_lnfact(y), lambda;

	LINK_INIT;
	/*
	 * '|y>0', and Prob(y=0) = exp(-mean) 
	 */

	if (m > 0) {
		if ((int) y == 0) {
			for (i = 0; i < m; i++) {
				logll[i] = log(p);
			}
		} else {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				p0 = exp(-mu);
				fac = (1.0 - p) / (1.0 - p0);
				if (y >= interval[0] && y <= interval[1]) {
					logll[i] = log(fac) + log(gsl_cdf_poisson_P((unsigned int) interval[1], mu)
								  - gsl_cdf_poisson_P((unsigned int) (interval[0] - 1L), mu));
				} else {
					logll[i] = log(fac) + y * log(mu) - mu - normc;
				}
			}
		}

	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		int iy = (int) y;

		if ((int) iy == 0) {
			for (i = 0; i < -m; i++) {
				logll[i] = p;
			}
		} else {
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				p0 = exp(-mu);
				fac = (1.0 - p) / (1.0 - p0);
				if (iy == 0) {
					logll[i] = p;
				} else if (iy < interval[0] || iy > interval[1]) {
					// not censored
					logll[i] = p + fac * gsl_cdf_poisson_P((unsigned int) iy, E * lambda);
				} else {
					int ii;
					double sum = 0.0, prob, one = 0.0;
					for (ii = interval[0]; ii <= interval[1]; ii++) {
						prob = gsl_ran_poisson_pdf((unsigned int) ii, mu);
						sum += prob * (p + fac * gsl_cdf_poisson_P((unsigned int) ii, mu));
						one += prob;
					}
					logll[i] = sum / one;
				}
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_cenpoisson1(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double *interval = ds->data_observations.cenpoisson_interval;
	double mu, p = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL);
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], normc = my_gsl_sf_lnfact(y), lambda;

	LINK_INIT;
	/*
	 * '|y>0', and Prob(y=0) = exp(-mean) 
	 */

	if (m > 0) {
		for (i = 0; i < m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if ((int) y == 0) {
				logll[i] = log(p + (1.0 - p) * gsl_ran_poisson_pdf((unsigned int) y, mu));
			} else if (y >= interval[0] && y <= interval[1]) {
				logll[i] = log((1.0 - p) * (gsl_cdf_poisson_P((unsigned int) interval[1], mu)
							    - gsl_cdf_poisson_P((unsigned int) (interval[0] - 1L), mu)));
			} else {
				logll[i] = LOG_ONE_MINUS(p) + y * log(mu) - mu - normc;
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		int iy = (int) y;

		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (iy < interval[0] || iy > interval[1]) {
				// not censored
				logll[i] = p + (1.0 - p) * gsl_cdf_poisson_P((unsigned int) iy, mu);
			} else {
				int ii;
				double sum = 0.0, prob, one = 0.0;
				for (ii = interval[0]; ii <= interval[1]; ii++) {
					prob = gsl_ran_poisson_pdf((unsigned int) ii, mu);
					sum += prob * (p + (1.0 - p) * gsl_cdf_poisson_P((unsigned int) ii, mu));
					one += prob;
				}
				logll[i] = sum / one;
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_pom(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
#define _F_CORE_LOGIT(_x) (1.0/(1.0 + exp(-(_x))))
#define _P_LOGIT(_class, _eta) ((_class) == 1 ? _F_CORE_LOGIT(alpha[(_class)] - (_eta)) : \
				((_class) == nclasses ? (1.0 - _F_CORE_LOGIT(alpha[(_class) -1] - (_eta))) : \
				 (_F_CORE_LOGIT(alpha[(_class)] - (_eta)) - _F_CORE_LOGIT(alpha[(_class) -1] - (_eta)))))
#define _F_CORE_PROBIT(_x) inla_Phi(_x)
#define _P_PROBIT(_class, _eta) ((_class) == 1 ? _F_CORE_PROBIT(alpha[(_class)] - (_eta)) : \
				 ((_class) == nclasses ? (1.0 - _F_CORE_PROBIT(alpha[(_class) -1] - (_eta))) : \
				  (_F_CORE_PROBIT(alpha[(_class)] - (_eta)) - _F_CORE_PROBIT(alpha[(_class) -1] - (_eta)))))

#define _F_CORE_PROBIT_FAST(_x) inla_Phi_fast(_x)
#define _P_PROBIT_FAST(_class, _eta) ((_class) == 1 ? _F_CORE_PROBIT_FAST(alpha[(_class)] - (_eta)) : \
				      ((_class) == nclasses ? (1.0 - _F_CORE_PROBIT_FAST(alpha[(_class) -1] - (_eta))) : \
				       (_F_CORE_PROBIT_FAST(alpha[(_class)] - (_eta)) - _F_CORE_PROBIT_FAST(alpha[(_class) -1] - (_eta)))))

	/*
	 * y ~ POM(alpha_k + eta)
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	double eta, theta, *alpha = NULL;
	Data_section_tp *ds = (Data_section_tp *) arg;
	int i, k, iy = (int) ds->data_observations.y[idx], nclasses = ds->data_observations.pom_nclasses;
	int use_logit = (ds->data_observations.pom_cdf == POM_CDF_LOGIT);
	int fast_probit = ds->data_observations.pom_fast_probit;

	static double **calpha = NULL;
	static int *nclass = NULL;

	if (!calpha) {
#pragma omp critical (Name_0e94df4562241e37d016a0edfddb0588df8765f1)
		{
			if (!calpha) {
				nclass = Calloc(GMRFLib_CACHE_LEN, int);
				calpha = Calloc(GMRFLib_CACHE_LEN, double *);
				for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
					nclass[i] = 4;
					calpha[i] = Calloc(nclass[i], double);
				}
			}
		}
	}

	int id = 0;
	GMRFLib_CACHE_SET_ID(id);

	if (nclasses > nclass[id]) {
		nclass[id] = nclasses;
		calpha[id] = Realloc(calpha[id], nclass[id], double);
	}
	alpha = calpha[id];

	for (i = 0; i < nclasses - 1; i++) {
		k = 1 + i;
		theta = map_identity(ds->data_observations.pom_theta[i][thread_id][0], MAP_FORWARD, NULL);
		alpha[k] = (k == 1 ? theta : alpha[k - 1] + exp(theta));
	}

	LINK_INIT;
	if (m > 0) {
		if (use_logit) {
			for (i = 0; i < m; i++) {
				eta = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = log(_P_LOGIT(iy, eta));
			}
		} else {
			if (fast_probit) {
				for (i = 0; i < m; i++) {
					eta = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
					logll[i] = log(_P_PROBIT_FAST(iy, eta));
				}
			} else {
				for (i = 0; i < m; i++) {
					eta = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
					logll[i] = log(_P_PROBIT(iy, eta));
				}
			}
		}
	} else {
		assert(0 == 1);
	}

	LINK_END;
#undef _P_LOGIT
#undef _P_PROBIT
#undef _P_PROBIT_FAST
#undef _F_CORE_LOGIT
#undef _F_CORE_PROBIT
#undef _F_CORE_PROBIT_FAST

	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_poisson0(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * zeroinflated Poission: y ~ p*1[y=0] + (1-p)*Poisson(E*exp(x) | y > 0)
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], normc = my_gsl_sf_lnfact(y),
	    p = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL), mu, lambda;

	LINK_INIT;
	if ((int) y == 0) {
		/*
		 * this is just the point-mass at zero 
		 */
		if (m > 0) {
			for (i = 0; i < m; i++) {
				logll[i] = log(p);
			}
		} else {
			for (i = 0; i < -m; i++) {
				logll[i] = p;
			}
		}
	} else {
		/*
		 * As for the Poisson but '|y>0', and Prob(y=0) = exp(-mean) 
		 */
		double p0;
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		if (m > 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				p0 = exp(-mu);
				logll[i] = LOG_ONE_MINUS(p) + y * log(mu) - mu - normc - LOG_ONE_MINUS(p0);
			}

		} else {
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				p0 = exp(-mu);
				logll[i] = p + (1.0 - p) * (gsl_cdf_poisson_P((unsigned int) y, mu) - p0) / (1.0 - p0);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_poisson1(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * zeroinflated Poission: y ~ p*1[y=0] + (1-p)*Poisson(E*exp(x))
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], normc = my_gsl_sf_lnfact(y),
	    p = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL), mu, lambda, logA, logB;

	LINK_INIT;
	if ((int) y == 0) {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				logA = log(p);
				logB = LOG_ONE_MINUS(p) + y * log(mu) - mu - normc;
				// logll[i] = log(p + (1.0 - p) * gsl_ran_poisson_pdf((unsigned int) y, mu));
				logll[i] = eval_logsum_safe(logA, logB);
			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				logll[i] = p + (1.0 - p) * gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	} else {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				logll[i] = LOG_ONE_MINUS(p) + y * log(mu) - mu - normc;
			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				logll[i] = p + (1.0 - p) * gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_poisson2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * zeroinflated Poission: y ~ p*1[y=0] + (1-p)*Poisson(E*exp(x)), where p=p(x; alpha)
	 */

#define _PROB(xx, EE) (1.0-pow(EE*exp(xx)/(1.0+EE*exp(xx)), alpha))

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], normc = my_gsl_sf_lnfact(y),
	    alpha = map_exp(ds->data_observations.zeroinflated_alpha_intern[thread_id][0], MAP_FORWARD, NULL), mu, log_mu, p, lambda;

	LINK_INIT;
	if ((int) y == 0) {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				p = _PROB(x[i] + OFFSET(idx), E);
				if (gsl_isnan(p)) {
					// P(p);
					// P(x[i]+OFFSET(idx));
					logll[i] = 0.0;
				} else {
					lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
					mu = E * lambda;
					log_mu = log(mu);

					// better expression I hope

					if (ISEQUAL(p, 1.0)) {
						logll[i] = 0.0;
					} else if (p < 1e-10) {
						logll[i] = 0 * log_mu - mu - normc;
					} else {
						logll[i] =
						    0 * log_mu - mu - normc + log(p / (gsl_ran_poisson_pdf((unsigned int) y, mu)) + (1.0 - p));
					}
					// logll[i] = log(p + (1.0 - p) * gsl_ran_poisson_pdf((unsigned int) y, mu));

					/*
					 * if all fails... 
					 */
					if (gsl_isnan(logll[i])) {
						P(p);
						P(logll[i]);
						P(x[i] + OFFSET(idx));
						fprintf(stderr, "inla.c: Don't know what to do. Please report problem...");
						exit(EXIT_FAILURE);
					}
				}
			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				p = _PROB(x[i] + OFFSET(idx), E);
				logll[i] = p + (1.0 - p) * gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	} else {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				p = _PROB(x[i] + OFFSET(idx), E);
				if (gsl_isnan(p)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
					mu = E * lambda;
					log_mu = log(mu);
					logll[i] = LOG_ONE_MINUS(p) + y * log_mu - mu - normc;
				}
			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				p = _PROB(x[i] + OFFSET(idx), E);
				logll[i] = p + (1.0 - p) * gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	}

	for (i = 0; i < IABS(m); i++) {
		if (gsl_isinf(logll[i]))
			logll[i] = ((double) INLA_REAL_BIG) * gsl_isinf(logll[i]);
	}

	LINK_END;
#undef _PROB
	return GMRFLib_SUCCESS;
}

int loglikelihood_poisson_special1(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * poisson special 1 : y ~ p*1[y=1] + (1-p)*Poisson(E*exp(x) | y > 0)
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], E = ds->data_observations.E[idx], normc = my_gsl_sf_lnfact(y),
	    p = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL), mu, p0, pp0;

	LINK_INIT;

	if (m > 0) {
		if (y == 1.0) {
			for (i = 0; i < m; i++) {
				mu = E * PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				p0 = exp(-mu);
				pp0 = 1.0 - p0;
				logll[i] = log(p + (1.0 - p) / pp0 * exp(y * log(mu) - mu - normc));
			}
		} else {
			for (i = 0; i < m; i++) {
				mu = E * PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				p0 = exp(-mu);
				pp0 = 1.0 - p0;
				logll[i] = log((1.0 - p) / pp0) + (y * log(mu) - mu - normc);
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		if (y < 1.0) {
			for (i = 0; i < -m; i++) {
				logll[i] = 0.0;
			}
		} else {
			for (i = 0; i < -m; i++) {
				mu = E * PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				p0 = exp(-mu);
				pp0 = 1.0 - p0;
				logll[i] = p + (1.0 - p) * (gsl_cdf_poisson_P((unsigned int) y, mu) - p0) / pp0;
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

double exp_taylor(double x, double x0, int order)
{
	int i;
	double val = 1.0, xx = x - x0;

	assert(order > 0);
	for (i = order; i >= 1; i--) {
		val = 1.0 + val * xx / (double) i;
	}
	val *= exp(x0);
	return val;
}

double dexp_taylor(double x, double x0, int order)
{
	return exp_taylor(x, x0, order - 1);
}

double ddexp_taylor(double x, double x0, int order)
{
	return exp_taylor(x, x0, order - 2);
}

int loglikelihood_logperiodogram(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y = x -log(2) + log\chi^2
	 *
	 * use the exact expression or a taylor-series for the exp-term of a given order ??
	 */
	int i;

	if (m == 0) {
		return 0;
	}
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], v, ypred;

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			ypred = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			v = y - ypred + M_LN2;
			logll[i] = -M_LN2 + v - 0.5 * exp(v);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_negative_binomial(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ NegativeBinomial(size, p) where E(y) = E*exp(x); same definition as in R and GSL, similar parameterisation as for the Poisson.
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double size;
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double S = ds->data_observations.S[idx];
	double lnorm, mu, p, lambda;
	double cutoff = 1.0e-4;				       /* switch to Poisson if mu/size < cutoff */

	switch (ds->variant) {
	case 0:
	{
		size = exp(ds->data_observations.log_size[thread_id][0]);
	}
		break;
	case 1:
	{
		size = E * exp(ds->data_observations.log_size[thread_id][0]);
	}
		break;
	case 2:
	{
		size = S * exp(ds->data_observations.log_size[thread_id][0]);
	}
		break;
	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	LINK_INIT;
	if (m > 0) {
		lnorm = gsl_sf_lngamma(y + size) - gsl_sf_lngamma(size) - gsl_sf_lngamma(y + 1.0);	/* near always the case we'll need this one 
													 */
		for (i = 0; i < m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (mu / size > cutoff) {
				/*
				 * NegativeBinomial 
				 */
				p = size / (size + mu);
				logll[i] = lnorm + size * log(p) + y * LOG_ONE_MINUS(p);
			} else {
				/*
				 * 
				 * * the Poission limit 
				 */
				logll[i] = y * log(mu) - mu - my_gsl_sf_lnfact(y);
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (mu / size > cutoff) {
				/*
				 * NegativeBinomial 
				 */
				p = size / (size + mu);
				logll[i] = gsl_cdf_negative_binomial_P((unsigned int) y, p, size);
			} else {
				/*
				 * The Poission limit 
				 */
				logll[i] = gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_negative_binomial_cen2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ NegativeBinomial(size, p) where E(y) = E*exp(x); same definition as in R and GSL, similar parameterisation as for the Poisson.
	 *
	 * this version allow for cencoring in the interval cen_low, cen_high, like 'cenpoisson2'
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	Data_section_tp *ds = (Data_section_tp *) arg;
	double size = 0.0;
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double S = ds->data_observations.S[idx];
	double cen_low = ds->data_observations.cen_low[idx];
	double cen_high = ds->data_observations.cen_high[idx];
	int int_low = (int) cen_low;
	int int_high = (int) cen_high;

	switch (ds->variant) {
	case 0:
	{
		size = exp(ds->data_observations.log_size[thread_id][0]);
	}
		break;
	case 1:
	{
		size = E * exp(ds->data_observations.log_size[thread_id][0]);
	}
		break;
	case 2:
	{
		size = S * exp(ds->data_observations.log_size[thread_id][0]);
	}
		break;
	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	LINK_INIT;
	if (m > 0) {
		double lnorm = gsl_sf_lngamma(y + size) - gsl_sf_lngamma(size) - gsl_sf_lngamma(y + 1.0);
		if ((y >= int_low && int_low >= 0) && (int_high < 0 || y <= int_high)) {
			for (int i = 0; i < m; i++) {
				double lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				double mu = E * lambda;
				logll[i] = log(inla_negative_binomial_interval(size, mu, int_low, int_high));
			}
		} else {
			for (int i = 0; i < m; i++) {
				double lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				double mu = E * lambda;
				double p = size / (size + mu);
				logll[i] = lnorm + size * log(p) + y * LOG_ONE_MINUS(p);
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (int i = 0; i < -m; i++) {
			double lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			double mu = E * lambda;
			double p = size / (size + mu);
			logll[i] = gsl_cdf_negative_binomial_P((unsigned int) y, p, size);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_negative_binomial0(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf,
						  void *arg)
{
	/*
	 * y ~ NegativeBinomial(size, p) where E(y) = E*exp(x); same definition as in R and GSL, similar parameterisation as for the Poisson.  This version is
	 * zeroinflated type 0.
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double size = exp(ds->data_observations.log_size[thread_id][0]);
	double p_zeroinflated = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL);
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double lnorm, mu, p, prob_y_is_zero, lambda;
	double cutoff = 1.0e-4;				       /* switch to Poisson if mu/size < cutoff */

	LINK_INIT;
	if (m > 0) {
		if ((int) y == 0) {
			for (i = 0; i < m; i++) {
				logll[i] = log(p_zeroinflated);
			}
		} else {
			/*
			 * this is constant for the NegativeBinomial 
			 */
			lnorm = gsl_sf_lngamma(y + size) - gsl_sf_lngamma(size) - gsl_sf_lngamma(y + 1.0);

			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				if (mu / size > cutoff) {
					/*
					 * NegativeBinomial 
					 */
					p = size / (size + mu);
					prob_y_is_zero = gsl_ran_negative_binomial_pdf((unsigned int) 0, p, size);

					logll[i] = log((1.0 - p_zeroinflated) / (1.0 - prob_y_is_zero))
					    + lnorm + size * log(p) + y * LOG_ONE_MINUS(p);
				} else {
					/*
					 * the Poission limit 
					 */
					prob_y_is_zero = gsl_ran_poisson_pdf((unsigned int) 0, mu);
					logll[i] = log((1.0 - p_zeroinflated) / (1.0 - prob_y_is_zero))
					    + y * log(mu) - mu - my_gsl_sf_lnfact(y);
				}
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		double p0;
		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (mu / size > cutoff) {
				/*
				 * NegativeBinomial 
				 */
				p = size / (size + mu);
				p0 = gsl_cdf_negative_binomial_P((unsigned int) 0, p, size);
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) *
				    (gsl_cdf_negative_binomial_P((unsigned int) y, p, size) - p0) / (1.0 - p0);
			} else {
				/*
				 * The Poission limit 
				 */
				p0 = gsl_cdf_poisson_P((unsigned int) 0, mu);
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * (gsl_cdf_poisson_P((unsigned int) y, mu) - p0) / (1.0 - p0);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_negative_binomial1(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf,
						  void *arg)
{
	/*
	 * y ~ NegativeBinomial(size, p) where E(y) = E*exp(x); same definition as in R and GSL, similar parameterisation as for the Poisson.  This version is
	 * zeroinflated type 1.
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double size = exp(ds->data_observations.log_size[thread_id][0]);
	double p_zeroinflated = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL);
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double lnorm, mu, p, lambda;
	double cutoff = 1.0e-4;				       /* switch to Poisson if mu/size < cutoff */

	LINK_INIT;
	if (m > 0) {
		/*
		 * this is constant for the NegativeBinomial 
		 */
		lnorm = gsl_sf_lngamma(y + size) - gsl_sf_lngamma(size) - gsl_sf_lngamma(y + 1.0);

		if ((int) y == 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				if (mu / size > cutoff) {
					/*
					 * NegativeBinomial 
					 */
					p = size / (size + mu);
					logll[i] =
					    log(p_zeroinflated + (1.0 - p_zeroinflated) * gsl_ran_negative_binomial_pdf((unsigned int) y, p, size));
				} else {
					/*
					 * the Poission limit 
					 */
					logll[i] = log(p_zeroinflated + (1.0 - p_zeroinflated) * gsl_ran_poisson_pdf((unsigned int) y, mu));
				}
			}
		} else {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				if (mu / size > cutoff) {
					/*
					 * NegativeBinomial 
					 */
					p = size / (size + mu);
					logll[i] = LOG_ONE_MINUS(p_zeroinflated) + lnorm + size * log(p) + y * LOG_ONE_MINUS(p);
				} else {
					/*
					 * the Poission limit 
					 */
					logll[i] = LOG_ONE_MINUS(p_zeroinflated) + y * log(mu) - mu - my_gsl_sf_lnfact(y);
				}
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (mu / size > cutoff) {
				/*
				 * NegativeBinomial 
				 */
				p = size / (size + mu);
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * gsl_cdf_negative_binomial_P((unsigned int) y, p, size);
			} else {
				/*
				 * The Poission limit 
				 */
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_negative_binomial1_strata2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec),
							  double *y_cdf, void *arg)
{
	/*
	 * y ~ NegativeBinomial(size, p) where E(y) = E*exp(x); same definition as in R and GSL, similar parameterisation as for the Poisson.  This version is
	 * zeroinflated type 1.
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	Data_section_tp *ds = (Data_section_tp *) arg;
	int i, strata = (int) ds->data_observations.strata[idx];
	double size = exp(ds->data_observations.log_size[thread_id][0]);
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double lnorm, mu, p, lambda;
	double cutoff = 1.0e-4;				       /* switch to Poisson if mu/size < cutoff */
	double p_zeroinflated;

	p_zeroinflated = map_probability(ds->data_observations.probN_intern[strata][thread_id][0], MAP_FORWARD, NULL);

	LINK_INIT;
	if (m > 0) {
		/*
		 * this is constant for the NegativeBinomial 
		 */
		lnorm = gsl_sf_lngamma(y + size) - gsl_sf_lngamma(size) - gsl_sf_lngamma(y + 1.0);

		if ((int) y == 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				if (mu / size > cutoff) {
					/*
					 * NegativeBinomial 
					 */
					p = size / (size + mu);
					logll[i] =
					    log(p_zeroinflated + (1.0 - p_zeroinflated) * gsl_ran_negative_binomial_pdf((unsigned int) y, p, size));
				} else {
					/*
					 * the Poission limit 
					 */
					logll[i] = log(p_zeroinflated + (1.0 - p_zeroinflated) * gsl_ran_poisson_pdf((unsigned int) y, mu));
				}
			}
		} else {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				if (mu / size > cutoff) {
					/*
					 * NegativeBinomial 
					 */
					p = size / (size + mu);
					logll[i] = LOG_ONE_MINUS(p_zeroinflated) + lnorm + size * log(p) + y * LOG_ONE_MINUS(p);
				} else {
					/*
					 * the Poission limit 
					 */
					logll[i] = LOG_ONE_MINUS(p_zeroinflated) + y * log(mu) - mu - my_gsl_sf_lnfact(y);
				}
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (mu / size > cutoff) {
				/*
				 * NegativeBinomial 
				 */
				p = size / (size + mu);
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * gsl_cdf_negative_binomial_P((unsigned int) y, p, size);
			} else {
				/*
				 * The Poission limit 
				 */
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_negative_binomial1_strata3(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec),
							  double *y_cdf, void *arg)
{
	/*
	 * y ~ NegativeBinomial(size, p) where E(y) = E*exp(x); same definition as in R and GSL, similar parameterisation as for the Poisson.  This version is
	 * zeroinflated type 1.
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	Data_section_tp *ds = (Data_section_tp *) arg;
	int i, strata = (int) ds->data_observations.strata[idx];
	double size;
	double p_zeroinflated;
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double lnorm, mu, p, lambda;
	double cutoff = 1.0e-4;				       /* switch to Poisson if mu/size < cutoff */

	p_zeroinflated = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL);
	size = exp(ds->data_observations.log_sizes[strata][thread_id][0]);

	LINK_INIT;
	if (m > 0) {
		/*
		 * this is constant for the NegativeBinomial 
		 */
		lnorm = gsl_sf_lngamma(y + size) - gsl_sf_lngamma(size) - gsl_sf_lngamma(y + 1.0);

		if ((int) y == 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				if (mu / size > cutoff) {
					/*
					 * NegativeBinomial 
					 */
					p = size / (size + mu);
					logll[i] =
					    log(p_zeroinflated + (1.0 - p_zeroinflated) * gsl_ran_negative_binomial_pdf((unsigned int) y, p, size));
				} else {
					/*
					 * the Poission limit 
					 */
					logll[i] = log(p_zeroinflated + (1.0 - p_zeroinflated) * gsl_ran_poisson_pdf((unsigned int) y, mu));
				}
			}
		} else {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				if (mu / size > cutoff) {
					/*
					 * NegativeBinomial 
					 */
					p = size / (size + mu);
					logll[i] = LOG_ONE_MINUS(p_zeroinflated) + lnorm + size * log(p) + y * LOG_ONE_MINUS(p);
				} else {
					/*
					 * the Poission limit 
					 */
					logll[i] = LOG_ONE_MINUS(p_zeroinflated) + y * log(mu) - mu - my_gsl_sf_lnfact(y);
				}
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			if (mu / size > cutoff) {
				/*
				 * NegativeBinomial 
				 */
				p = size / (size + mu);
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * gsl_cdf_negative_binomial_P((unsigned int) y, p, size);
			} else {
				/*
				 * The Poission limit 
				 */
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_negative_binomial2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf,
						  void *arg)
{
	/*
	 * y ~ NegativeBinomial(size, p) where E(y) = E*exp(x); same definition as in R and GSL, similar parameterisation as for the Poisson.  This version is
	 * zeroinflated type 3.
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double size = exp(ds->data_observations.log_size[thread_id][0]);
	double alpha = map_exp(ds->data_observations.zeroinflated_alpha_intern[thread_id][0], MAP_FORWARD, NULL);
	double p_zeroinflated = 0.0;
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double lnorm, mu, p, lambda;
	double cutoff = 1.0e-4;				       /* switch to Poisson if mu/size < cutoff */
	double normc = my_gsl_sf_lnfact(y);

	LINK_INIT;
	if (m > 0) {
		/*
		 * this is constant for the NegativeBinomial 
		 */
		lnorm = gsl_sf_lngamma(y + size) - gsl_sf_lngamma(size) - gsl_sf_lngamma(y + 1.0);

		if ((int) y == 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				p_zeroinflated = 1.0 - pow(mu / (1.0 + mu), alpha);

				if (gsl_isnan(p_zeroinflated)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					if (mu / size > cutoff) {
						/*
						 * NegativeBinomial 
						 */
						p = size / (size + mu);
						logll[i] =
						    log(p_zeroinflated +
							(1.0 - p_zeroinflated) * gsl_ran_negative_binomial_pdf((unsigned int) y, p, size));
					} else {
						/*
						 * the Poission limit 
						 */
						logll[i] = log(p_zeroinflated + (1.0 - p_zeroinflated) * gsl_ran_poisson_pdf((unsigned int) y, mu));
					}
				}
			}
		} else {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				mu = E * lambda;
				p_zeroinflated = 1.0 - pow(mu / (1.0 + mu), alpha);
				if (gsl_isnan(p_zeroinflated)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					if (mu / size > cutoff) {
						/*
						 * NegativeBinomial 
						 */
						p = size / (size + mu);
						logll[i] = LOG_ONE_MINUS(p_zeroinflated) + lnorm + size * log(p) + y * LOG_ONE_MINUS(p);
					} else {
						/*
						 * the Poission limit 
						 */
						logll[i] = LOG_ONE_MINUS(p_zeroinflated) + y * log(mu) - mu - normc;
					}
				}
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			mu = E * lambda;
			p_zeroinflated = 1.0 - pow(mu / (1.0 + mu), alpha);
			if (mu / size > cutoff) {
				/*
				 * NegativeBinomial 
				 */
				p = size / (size + mu);
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * gsl_cdf_negative_binomial_P((unsigned int) y, p, size);
			} else {
				/*
				 * The Poission limit 
				 */
				logll[i] = p_zeroinflated + (1.0 - p_zeroinflated) * gsl_cdf_poisson_P((unsigned int) y, mu);
			}
		}
	}

	for (i = 0; i < IABS(m); i++) {
		if (gsl_isinf(logll[i]))
			logll[i] = ((double) INLA_REAL_BIG) * gsl_isinf(logll[i]);
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_binomial(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ Binomial(n, p)
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int status;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double n = ds->data_observations.nb[idx];
	double ny = n - y;
	/*
	 * this is a special case that should just return 0 or 1
	 */
	if (ISZERO(y) && ISZERO(n)) {
		if (m > 0) {
			for (int i = 0; i < m; i++) {
				logll[i] = 0.0;		       /* log(1) = 0 */
			}
		} else {
			for (int i = 0; i < -m; i++) {
				logll[i] = 1.0;
			}
		}
		return GMRFLib_SUCCESS;
	}

	/*
	 * this is the normal case...
	 */
	LINK_INIT;
	if (m > 0) {
		gsl_sf_result res;
		if (G_norm_const_compute[idx]) {
			if (ds->variant == 0) {
				// binomial
				status = gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y, &res);
			} else {
				// neg binomial
				status = gsl_sf_lnchoose_e((unsigned int) (n - 1.0), (unsigned int) (y - 1.0), &res);
			}
			assert(status == GSL_SUCCESS);
			G_norm_const[idx] = res.val;
			G_norm_const_compute[idx] = 0;
		}
		res.val = G_norm_const[idx];

		if (PREDICTOR_LINK_EQ(link_logit)) {
			double off = OFFSET(idx);
#pragma GCC ivdep
			for (int i = 0; i < m; i++) {
				double eta = PREDICTOR_INVERSE_IDENTITY_LINK(x[i] + off);
				double ee = exp(eta);
				double log_1mp = -log1p(ee);
				double log_p = -log1p(1.0 / ee);
				logll[i] = res.val + y * log_p + ny * log_1mp;
			}
		} else {
#pragma GCC ivdep
			for (int i = 0; i < m; i++) {
				double p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = res.val + y * log(p) + ny * LOG_ONE_MINUS(p);
			}
		}

		int limiting_case = 0;
		for (int i = 0; i < m; i++) {
			if (ISINF(logll[i]) || ISNAN(logll[i])) {
				limiting_case = 1;
				break;
			}
		}

		if (limiting_case) {
			// doit again
			for (int i = 0; i < m; i++) {
				double p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				double eta = PREDICTOR_INVERSE_IDENTITY_LINK(x[i] + OFFSET(idx));
				p = TRUNCATE(p, 0.0, 1.0);
				if (ISEQUAL(p, 1.0)) {	       /* yes, this happens... */
					if (PREDICTOR_LINK_EQ(link_probit)) {
						logll[i] = res.val + y * (-1.0 / sqrt(2.0 * M_PI) / eta) / exp(SQR(eta) / 2.0);
					} else if (1 || PREDICTOR_LINK_EQ(link_logit)) {
						// I need to do something with other links...
						logll[i] = res.val + y * (-1.0 / exp(eta));
					}
				} else if (ISZERO(p)) {	       /* yes, this happens... */
					eta = -eta;	       /* so we can just copy the code */
					if (PREDICTOR_LINK_EQ(link_probit)) {
						logll[i] = res.val + ny * (-1.0 / sqrt(2.0 * M_PI) / eta) / exp(SQR(eta) / 2.0);
					} else if (1 || PREDICTOR_LINK_EQ(link_logit)) {
						// I need to do something with other links...
						logll[i] = res.val + ny * (-1.0 / exp(eta));
					}
				} else {
					logll[i] = res.val + y * log(p) + ny * LOG_ONE_MINUS(p);
				}
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (int i = 0; i < -m; i++) {
			double p = PREDICTOR_INVERSE_LINK((x[i] + OFFSET(idx)));
			p = DMIN(1.0, p);
			if (ds->variant == 0) {
				logll[i] = gsl_cdf_binomial_P((unsigned int) y, p, (unsigned int) n);
			} else {
				logll[i] = gsl_cdf_negative_binomial_P((unsigned int) ny, p, y);
			}
		}

	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_xbinomial(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ xBinomial(n, p)
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int status, i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double n = ds->data_observations.nb[idx], p;
	double p_scale = ds->data_observations.p_scale[idx];

	/*
	 * this is a special case that should just return 0 or 1
	 */
	if (ISZERO(y) && ISZERO(n)) {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				logll[i] = 0.0;		       /* log(1) = 0 */
			}
		} else {
			for (i = 0; i < -m; i++) {
				logll[i] = 1.0;
			}
		}
		return GMRFLib_SUCCESS;
	}

	LINK_INIT;
	if (m > 0) {
		gsl_sf_result res;
		if (G_norm_const_compute[idx]) {
			if (ds->variant == 0) {
				// binomial
				status = gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y, &res);
			} else {
				// neg binomial
				status = gsl_sf_lnchoose_e((unsigned int) (n - 1.0), (unsigned int) (y - 1.0), &res);
			}
			assert(status == GSL_SUCCESS);
			G_norm_const[idx] = res.val;
			G_norm_const_compute[idx] = 0;
		}
		res.val = G_norm_const[idx];

		for (i = 0; i < m; i++) {
			p = p_scale * PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			p = DMIN(1.0 - FLT_EPSILON, p);
			logll[i] = res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			p = p_scale * PREDICTOR_INVERSE_LINK((x[i] + OFFSET(idx)));
			p = DMIN(1.0 - FLT_EPSILON, p);
			if (ds->variant == 0) {
				logll[i] = gsl_cdf_binomial_P((unsigned int) y, p, (unsigned int) n);
			} else {
				logll[i] = gsl_cdf_negative_binomial_P((unsigned int) (n - y), p, y);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_nbinomial2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ nBinomial2. y is the number of failures to get n successes with a success in the last trial
	 */
	int i;

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	int status;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double n = ds->data_observations.nb[idx], p;

	/*
	 * this is the normal case...
	 */
	LINK_INIT;
	if (m > 0) {
		gsl_sf_result res;
		if (G_norm_const_compute[idx]) {
			status = gsl_sf_lnchoose_e((unsigned int) (y + n - 1.0), (unsigned int) (n - 1.0), &res);
			assert(status == GSL_SUCCESS);
			G_norm_const[idx] = res.val;
			G_norm_const_compute[idx] = 0;
		}
		res.val = G_norm_const[idx];

		for (i = 0; i < m; i++) {
			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			p = TRUNCATE(p, 0.0, 1.0);
			logll[i] = res.val + y * LOG_ONE_MINUS(p) + n * log(p);
		}
	} else {
		double *yy = (y_cdf ? y_cdf : &y);
		for (i = 0; i < -m; i++) {
			p = PREDICTOR_INVERSE_LINK((x[i] + OFFSET(idx)));
			p = TRUNCATE(p, 0.0, 1.0);
			logll[i] = gsl_cdf_negative_binomial_P((unsigned int) *yy, p, n);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_nmix(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y ~ Binomial(n, p) * poisson(n, lambda), log(lambda) = X'beta
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	int i, j, k;
	Data_section_tp *ds = (Data_section_tp *) arg;
	int n, nmax, ny;
	double *y, log_lambda, lambda, normc_poisson, fac, tt, tmp, p;

	assert(ds->data_observations.nmix_m > 0);
	for (i = 0, log_lambda = 0.0; i < ds->data_observations.nmix_m; i++) {
		log_lambda += ds->data_observations.nmix_beta[i][thread_id][0] * ds->data_observations.nmix_x[i][idx];
	}
	lambda = exp(log_lambda);

	LINK_INIT;

	static double **cy = NULL;
	static int *ncy = NULL;

	if (!cy) {
#pragma omp critical (Name_1d71960e99b4e67a36228891d1af914edbfd3dc3)
		{
			if (!cy) {
				ncy = Calloc(GMRFLib_CACHE_LEN, int);
				cy = Calloc(GMRFLib_CACHE_LEN, double *);
				for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
					ncy[i] = 8;
					cy[i] = Calloc(ncy[i], double);
				}
			}
		}
	}

	int id = 0;
	GMRFLib_CACHE_SET_ID(id);

	if (m > 0) {
		n = ds->data_observations.nmix_y[0][idx];
		assert(!gsl_isnan(ds->data_observations.nmix_y[0][idx]));
		ny = 1;
		for (i = 1; i > -1; i++) {
			if (gsl_isnan(ds->data_observations.nmix_y[i][idx]))
				break;
			ny++;
			n = IMAX(n, ds->data_observations.nmix_y[i][idx]);
		}
		normc_poisson = my_gsl_sf_lnfact(n);

		if (ny > ncy[id]) {
			ncy[id] = ny;
			cy[id] = Realloc(cy[id], ncy[id], double);
		}
		y = cy[id];

		for (i = 0; i < ny; i++) {
			y[i] = ds->data_observations.nmix_y[i][idx];
		}

		for (i = 0; i < m; i++) {
			gsl_sf_result res;

			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			p = TRUNCATE(p, 0.0, 1.0);
			logll[i] = n * log_lambda - lambda - normc_poisson;
			for (j = 0; j < ny; j++) {
				gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y[j], &res);
				logll[i] += res.val + y[j] * log(p) + (n - y[j]) * LOG_ONE_MINUS(p);
			}
			tt = lambda * pow(1.0 - p, (double) ny);
			nmax = (int) DMAX(n + 50.0, DMIN(n + tt / 0.01, n + 500.0));	/* just to be sure */
			for (k = nmax, fac = 1.0; k > n; k--) {
				double kd = (double) k;
				for (j = 0, tmp = 1.0; j < ny; j++) {
					tmp *= kd / (kd - y[j]);
				}
				fac = 1.0 + fac * tt * tmp / kd;
			}
			logll[i] += log(fac);
		}
	} else {
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_nmixnb(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * y ~ Binomial(n, p) * NegBinom(n, mu=lambda, size=1/overdispersion), log(lambda) = X'beta
	 */
	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	int i, j, k;
	Data_section_tp *ds = (Data_section_tp *) arg;
	int n, nmax, ny;
	double *y, log_lambda, lambda, normc_nb, fac, tt, tmp, p, q, size;

	assert(ds->data_observations.nmix_m > 0);
	for (i = 0, log_lambda = 0.0; i < ds->data_observations.nmix_m; i++) {
		log_lambda += ds->data_observations.nmix_beta[i][thread_id][0] * ds->data_observations.nmix_x[i][idx];
	}
	lambda = exp(log_lambda);
	size = 1.0 / map_exp(ds->data_observations.nmix_log_overdispersion[thread_id][0], MAP_FORWARD, NULL);

	LINK_INIT;

	static double **cy = NULL;
	static int *ncy = NULL;

	if (!cy) {
#pragma omp critical (Name_0b245bce3bb8f2007cc26fbbb141a5a0c7559165)
		{
			if (!cy) {
				ncy = Calloc(GMRFLib_CACHE_LEN, int);
				cy = Calloc(GMRFLib_CACHE_LEN, double *);
				for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
					ncy[i] = 8;
					cy[i] = Calloc(ncy[i], double);
				}
			}
		}
	}

	int id = 0;
	GMRFLib_CACHE_SET_ID(id);

	if (m > 0) {
		n = ds->data_observations.nmix_y[0][idx];
		assert(!gsl_isnan(ds->data_observations.nmix_y[0][idx]));
		ny = 1;
		for (i = 1; i > -1; i++) {
			if (gsl_isnan(ds->data_observations.nmix_y[i][idx]))
				break;
			ny++;
			n = IMAX(n, ds->data_observations.nmix_y[i][idx]);
		}
		normc_nb = gsl_sf_lngamma(n + size) - gsl_sf_lngamma(size) - my_gsl_sf_lnfact(n);

		if (ny > ncy[id]) {
			ncy[id] = ny;
			cy[id] = Realloc(cy[id], ncy[id], double);
		}
		y = cy[id];

		for (i = 0; i < ny; i++) {
			y[i] = ds->data_observations.nmix_y[i][idx];
		}

		for (i = 0; i < m; i++) {
			gsl_sf_result res;

			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			p = TRUNCATE(p, 0.0, 1.0);
			q = size / (size + lambda);
			logll[i] = normc_nb + size * log(q) + n * LOG_ONE_MINUS(q);
			for (j = 0; j < ny; j++) {
				gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y[j], &res);
				logll[i] += res.val + y[j] * log(p) + (n - y[j]) * LOG_ONE_MINUS(p);
			}
			tt = lambda * sqrt(1.0 + lambda / size) * pow(1.0 - p, (double) ny);
			nmax = (int) DMAX(n + 50.0, DMIN(n + tt / 0.01, n + 500.0));	/* just to be sure */
			tt = (1.0 - q) * pow(1.0 - p, ny);
			for (k = nmax, fac = 1.0; k > n; k--) {
				double kd = (double) k;
				for (j = 0, tmp = 1.0; j < ny; j++) {
					tmp *= kd / (kd - y[j]);
				}
				fac = 1.0 + fac * (kd + size - 1.0) * tt * tmp / kd;
			}
			logll[i] += log(fac);
		}
	} else {
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int inla_mix_int_quadrature_gaussian(int thread_id, double **x, double **w, int *n, void *arg)
{
	Data_section_tp *ds = (Data_section_tp *) arg;
	double prec = map_precision(ds->data_observations.mix_log_prec_gaussian[thread_id][0], MAP_FORWARD, NULL);
	double sd = sqrt(1.0 / prec);
	double *xx = NULL, *ww = NULL, wmin;
	int i, j;
	GMRFLib_ghq(&xx, &ww, *n);

	wmin = MIX_INT_EPS * GMRFLib_max_value(ww, *n, NULL);
	*x = Calloc(*n, double);
	*w = Calloc(*n, double);
	for (i = j = 0; i < *n; i++) {
		if (ww[i] > wmin) {			       /* avoid to small weights */
			(*x)[j] = sd * xx[i];
			(*w)[j] = ww[i];
			j++;
		}
	}
	*n = j;

	return GMRFLib_SUCCESS;
}

int inla_mix_int_quadrature_loggamma(int UNUSED(thread_id), double **UNUSED(x), double **UNUSED(w), int *UNUSED(n), void *UNUSED(arg))
{
	char *msg = GMRFLib_strdup("This function is not yet implemented.");
	inla_error_general(msg);
	exit(1);
	return GMRFLib_SUCCESS;
}

int inla_mix_int_quadrature_mloggamma(int UNUSED(thread_id), double **UNUSED(x), double **UNUSED(w), int *UNUSED(n), void *UNUSED(arg))
{
	char *msg = GMRFLib_strdup("This function is not yet implemented.");
	inla_error_general(msg);
	exit(1);
	return GMRFLib_SUCCESS;
}

int inla_mix_int_simpson_gaussian(int thread_id, double **x, double **w, int *n, void *arg)
{
#define DENS(_x) exp(-0.5 * SQR(_x))
	Data_section_tp *ds = (Data_section_tp *) arg;
	double prec = map_precision(ds->data_observations.mix_log_prec_gaussian[thread_id][0], MAP_FORWARD, NULL);
	double sd = sqrt(1.0 / prec);

	typedef struct {
		int n;					       /* is the requested length */
		int np;					       /* is the pruned length */
		double *x, *w;
	} lcache_t;

	static lcache_t **llcache = NULL;

	if (!llcache) {
#pragma omp critical (Name_f0fed30114239788701d492c4202a46b68cc060a)
		{
			if (!llcache) {
				llcache = Calloc(GMRFLib_CACHE_LEN, lcache_t *);
			}
		}
	}
	int idx = 0;
	GMRFLib_CACHE_SET_ID(idx);
	if (!llcache) {
		llcache[idx] = Calloc(1, lcache_t);
	}

	lcache_t *lcache = llcache[idx];

	if (lcache->n != *n) {

		if (lcache->n > 0) {
			inla_error_general("Ask <help@r-inla.org> to rewrite inla_mix_int_simpson_gaussian()");
			exit(1);
		}

		Free(lcache->x);
		Free(lcache->w);
		lcache->n = *n;

		double *xx = Calloc(*n, double), *ww = Calloc(*n, double);
		double weight[2] = { 4.0, 2.0 }, limit = sqrt(-2.0 * log(MIX_INT_EPS)), dx = 2.0 * limit / (*n - 1.0), wmin;
		int i, j, np;

		xx[0] = -limit;
		xx[*n - 1] = limit;
		ww[0] = ww[*n - 1] = DENS(xx[0]);
		for (i = 1, j = 0; i < *n - 1; i++, j = (j + 1) % 2L) {
			xx[i] = xx[i - 1] + dx;
			ww[i] = weight[j] * DENS(xx[i]);
		}

		wmin = MIX_INT_EPS * GMRFLib_max_value(ww, *n, NULL);
		for (i = j = 0; i < *n; i++) {
			if (ww[i] > wmin) {
				xx[j] = xx[i];
				ww[j] = ww[i];
				j++;
			}
		}
		np = j;

		// make sure that integral(1) = 1 
		double corr = 0.0;
		for (i = 0; i < np; i++) {
			corr += ww[i];
		}
		corr = 1.0 / corr;
		for (i = 0; i < np; i++) {
			ww[i] *= corr;
		}

		lcache->x = xx;
		lcache->w = ww;
		lcache->np = np;
	}

	int i, np;

	np = lcache->np;
	*x = Calloc(np, double);
	*w = Calloc(np, double);
	for (i = 0; i < np; i++) {
		(*x)[i] = sd * lcache->x[i];
	}
	Memcpy(*w, lcache->w, np * sizeof(double));
	*n = np;

#undef DENS
	return GMRFLib_SUCCESS;
}

int inla_mix_int_simpson_loggamma(int thread_id, double **x, double **w, int *n, void *arg)
{
// Gamma(a,a) propto x^(a-1) * exp(-a*x). The density is normalized in any case, so we do not need to add the normalizing
// constant. z = log(x), so its the density for log(Gamma(a,a)). The '+1.0' is to stabilize it, so the modal value is around 0.
// shape = precision
#define DENS(_z, _a) exp( (_a)*((_z) -exp(_z) + 1.0) )

	Data_section_tp *ds = (Data_section_tp *) arg;
	double shape = map_precision(ds->data_observations.mix_log_prec_loggamma[thread_id][0], MAP_FORWARD, NULL);

	typedef struct {
		int n, np;				       /* 'n' is the requested length and 'np' is the pruned length */
		double shape, *x, *w;
	} lcache_t;

	static lcache_t **llcache = NULL;

	if (!llcache) {
#pragma omp critical (Name_ba31fe1f20db2ec14750ea49f488e614a1920cb7)
		{
			if (!llcache) {
				llcache = Calloc(GMRFLib_CACHE_LEN, lcache_t *);
			}
		}
	}
	int idx = 0;
	GMRFLib_CACHE_SET_ID(idx);

	if (!llcache[idx]) {
		llcache[idx] = Calloc(1, lcache_t);
	}
	lcache_t *lcache = llcache[idx];

	if (lcache->n != *n || lcache->shape != shape) {
		Free(lcache->x);
		double *work = Calloc(2 * *n, double);
		double *xx, *ww, weight[2] = { 4.0, 2.0 }, alpha = 0.001, low_limit, high_limit, dx, wmin;
		int i, j, np;

		low_limit = log(MATHLIB_FUN(qgamma) (alpha / 2.0, shape, 1.0 / shape, 1, 0));
		high_limit = log(MATHLIB_FUN(qgamma) (1.0 - alpha / 2.0, shape, 1.0 / shape, 1, 0));
		dx = (high_limit - low_limit) / (*n - 1.0);
		xx = work;				       /* use same storage */
		ww = work + *n;
		xx[0] = low_limit;
		ww[0] = DENS(low_limit, shape);
		xx[*n - 1] = high_limit;
		ww[*n - 1] = DENS(high_limit, shape);
		for (i = 1, j = 0; i < *n - 1; i++, j = (j + 1) % 2L) {
			xx[i] = xx[i - 1] + dx;
			ww[i] = weight[j] * DENS(xx[i], shape);
		}

		wmin = MIX_INT_EPS * GMRFLib_max_value(ww, *n, NULL);
		for (i = j = 0; i < *n; i++) {
			if (ww[i] > wmin) {
				xx[j] = xx[i];
				ww[j] = ww[i];
				j++;
			}
		}
		np = j;

		// make sure that integral(1) = 1 
		double corr = 0.0;
		for (i = 0; i < np; i++) {
			corr += ww[i];
		}
		corr = 1.0 / corr;
		for (i = 0; i < np; i++) {
			ww[i] *= corr;
		}

		lcache->n = *n;
		lcache->np = np;
		lcache->shape = shape;
		lcache->x = xx;
		lcache->w = ww;
	}

	*n = lcache->np;
	*x = Calloc(*n, double);
	*w = Calloc(*n, double);
	Memcpy(*x, lcache->x, *n * sizeof(double));
	Memcpy(*w, lcache->w, *n * sizeof(double));

#undef DENS
	return GMRFLib_SUCCESS;
}

int inla_mix_int_simpson_mloggamma(int thread_id, double **x, double **w, int *n, void *arg)
{
	inla_mix_int_simpson_loggamma(thread_id, x, w, n, arg);
	for (int i = 0; i < *n; i++) {
		/*
		 * just swap the sign
		 */
		(*x)[i] = -(*x)[i];
	}
	return GMRFLib_SUCCESS;
}

int loglikelihood_mix_loggamma(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (loglikelihood_mix_core
		(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, inla_mix_int_quadrature_loggamma, inla_mix_int_simpson_loggamma));
}

int loglikelihood_mix_mloggamma(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (loglikelihood_mix_core
		(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, inla_mix_int_quadrature_mloggamma, inla_mix_int_simpson_mloggamma));
}

int loglikelihood_mix_gaussian(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (loglikelihood_mix_core
		(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, inla_mix_int_quadrature_gaussian, inla_mix_int_simpson_gaussian));
}

int loglikelihood_mix_core(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg,
			   int (*func_quadrature)(int, double **, double **, int *, void *arg),
			   int(*func_simpson)(int, double **, double **, int *, void *arg))
{
	Data_section_tp *ds =(Data_section_tp *) arg;
	if (m == 0) {
		if (arg) {
			return (ds->mix_loglikelihood(thread_id, NULL, NULL, 0, 0, NULL, NULL, arg));
		} else {
			return (GMRFLib_LOGL_COMPUTE_CDF);
		}
	}

	int i, k, kk, mm, np;
	double *val = NULL, val_max, sum, *xx = NULL, *ll = NULL, *storage = NULL, *points = NULL, *weights = NULL;

	np = ds->mix_npoints;				       /* 'np' is the maximum number of points */
	switch (ds->mix_integrator) {
	case MIX_INT_QUADRATURE:
	{
		if (func_quadrature) {
			/*
			 * we can get back few points, as small weights are removed
			 */
			func_quadrature(thread_id, &points, &weights, &np, arg);
		} else {
			assert(0 == 1);
		}
	}
		break;
	case MIX_INT_DEFAULT:
	case MIX_INT_SIMPSON:
	{
		if (func_simpson) {
			/*
			 * we can get back few points, as small weights are removed
			 */
			func_simpson(thread_id, &points, &weights, &np, arg);
		} else {
			assert(0 == 1);
		}
	}
		break;
	default:
		assert(0 == 1);
	}

	mm = np * IABS(m);
	storage = Calloc(np + 2 * mm, double);		       /* use just one longer vector */
	val = storage;
	xx = storage + np;
	ll = storage + np + mm;

	if (m > 0) {
		for (i = 0, kk = 0; i < m; i++) {
			for (k = 0; k < np; k++) {
				xx[kk++] = x[i] + points[k];
			}
		}
		assert(kk == mm);
		ds->mix_loglikelihood(thread_id, ll, xx, mm, idx, x_vec, NULL, arg);
		for (i = 0, kk = 0; i < m; i++) {
			for (k = 0; k < np; k++) {
				val[k] = log(weights[k]) + ll[kk++];
			}
			val_max = GMRFLib_max_value(val, np, NULL);
			for (k = 0, sum = 0.0; k < np; k++) {
				if (!ISNAN(val[k])) {
					sum += exp(val[k] - val_max);
				}
			}
			assert(sum > 0.0);
			logll[i] = log(sum) + val_max;
		}
		assert(kk == mm);
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0, kk = 0; i < -m; i++) {
			for (k = 0; k < np; k++) {
				xx[kk++] = x[i] + points[k];
			}
		}
		assert(kk == mm);
		ds->mix_loglikelihood(thread_id, ll, xx, mm, idx, x_vec, NULL, arg);
		for (i = 0, kk = 0; i < -m; i++) {
			for (k = 0, sum = 0.0; k < np; k++) {
				sum += weights[k] * ll[kk++];
			}
			logll[i] = sum;
		}
		assert(kk == mm);
	}

	Free(storage);
	Free(points);
	Free(weights);

	return GMRFLib_SUCCESS;
}

int loglikelihood_cbinomial(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * z ~ CBinomial(k, n, p) == Binomial(k, 1-(1-p)^n)
	 */
	int i;

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	int status;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], k = ds->data_observations.cbinomial_k[idx], n = ds->data_observations.cbinomial_n[idx], p;

	LINK_INIT;
	if (m > 0) {
		gsl_sf_result res;
		status = gsl_sf_lnchoose_e((unsigned int) k, (unsigned int) y, &res);	/* Yes, its 'k' */
		assert(status == GSL_SUCCESS);
		for (i = 0; i < m; i++) {
			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			p = 1.0 - pow(1.0 - p, n);
			p = TRUNCATE(p, 0.0, 1.0);
			if (ISEQUAL(p, 1.0)) {
				/*
				 * this is ok if we get a 0*log(0) expression for the reminder 
				 */
				if (k == (int) y) {
					logll[i] = res.val + y * log(p);
				} else {
					logll[i] = -INLA_REAL_BIG;
				}
			} else if (ISZERO(p)) {
				/*
				 * this is ok if we get a 0*log(0) expression for the reminder 
				 */
				if ((int) y == 0) {
					logll[i] = res.val + (k - y) * LOG_ONE_MINUS(p);
				} else {
					logll[i] = -INLA_REAL_BIG;
				}
			} else {
				logll[i] = res.val + y * log(p) + (k - y) * LOG_ONE_MINUS(p);
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			p = PREDICTOR_INVERSE_LINK((x[i] + OFFSET(idx)));
			p = 1.0 - pow(1.0 - p, n);
			p = TRUNCATE(p, 0.0, 1.0);
			logll[i] = gsl_cdf_binomial_P((unsigned int) y, p, (unsigned int) k);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_binomial0(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * zeroinflated Binomial : y ~ p*1[y=0] + (1-p) Binomial(n, p | y > 0), where logit(p) = x. 
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], n = ds->data_observations.nb[idx],
	    p = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL), prob = 0.0;

	LINK_INIT;
	if ((int) y == 0) {
		/*
		 * this is just the point-mass at zero 
		 */
		if (m > 0) {
			for (i = 0; i < m; i++) {
				logll[i] = log(p);
			}
		} else {
			for (i = 0; i < -m; i++) {
				logll[i] = p;
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);

		gsl_sf_result res;
		gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y, &res);
		double p0;
		if (m > 0) {
			for (i = 0; i < m; i++) {
				prob = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				p0 = gsl_cdf_binomial_P((unsigned int) 0, prob, (unsigned int) n);
				logll[i] = LOG_ONE_MINUS(p) + res.val + y * log(prob) + (n - y) * LOG_ONE_MINUS(prob) - LOG_ONE_MINUS(p0);
			}
		} else {
			for (i = 0; i < -m; i++) {
				prob = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				p0 = gsl_cdf_binomial_P((unsigned int) 0, prob, (unsigned int) n);
				logll[i] = p + (1.0 - p) * (gsl_cdf_binomial_P((unsigned int) y, prob, (unsigned int) n) - p0) / (1.0 - p0);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_binomial1(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * zeroinflated Binomial : y ~ p*1[y=0] + (1-p)*Binomial(n, p), where logit(p) = x. 
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], n = ds->data_observations.nb[idx],
	    p = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL), prob = 0.0, logA, logB;

	gsl_sf_result res;
	gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y, &res);

	LINK_INIT;
	if ((int) y == 0) {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				prob = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logA = log(p);
				logB = LOG_ONE_MINUS(p) + res.val + y * log(prob) + (n - y) * LOG_ONE_MINUS(prob);
				// logll[i] = log(p + (1.0 - p) * gsl_ran_binomial_pdf((unsigned int) y, prob, (unsigned int) n));
				logll[i] = eval_logsum_safe(logA, logB);
			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < -m; i++) {
				prob = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = p + (1.0 - p) * gsl_cdf_binomial_P((unsigned int) y, prob, (unsigned int) n);
			}
		}
	} else {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				prob = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = LOG_ONE_MINUS(p) + res.val + y * log(prob) + (n - y) * LOG_ONE_MINUS(prob);
			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < -m; i++) {
				prob = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = p + (1.0 - p) * gsl_cdf_binomial_P((unsigned int) y, prob, (unsigned int) n);
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_binomial2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * zeroinflated Binomial : y ~ prob*1[y=0] + (1-prob)*Binomial(n, p), where logit(p) = x, and prob = 1-p^alpha.
	 */
#define _PROB(xx) (exp(xx)/(1.0+exp(xx)))
#define _PROBZERO(xx) (1.0-pow(_PROB(xx), alpha))

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], n = ds->data_observations.nb[idx], pzero, p,
	    alpha = map_exp(ds->data_observations.zeroinflated_alpha_intern[thread_id][0], MAP_FORWARD, NULL), logA, logB;

	gsl_sf_result res;
	gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y, &res);

	LINK_INIT;
	if ((int) y == 0) {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				pzero = _PROBZERO(x[i] + OFFSET(idx));
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				if (gsl_isinf(pzero) || gsl_isinf(p)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					if (ISZERO(pzero)) {
						logll[i] = res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
					} else {
						logA = log(pzero);
						logB = LOG_ONE_MINUS(pzero) + res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
						// logll[i] = log(pzero + (1.0 - pzero) * gsl_ran_binomial_pdf((unsigned int) y, p, 
						// 
						// 
						// 
						// 
						// (unsigned int) n));
						logll[i] = eval_logsum_safe(logA, logB);
					}
				}
			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < -m; i++) {
				pzero = _PROBZERO(x[i] + OFFSET(idx));
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				if (gsl_isinf(pzero) || gsl_isinf(p)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					logll[i] = pzero + (1.0 - pzero) * gsl_cdf_binomial_P((unsigned int) y, p, (unsigned int) n);
				}
			}
		}
	} else {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				pzero = _PROBZERO(x[i] + OFFSET(idx));
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				if (gsl_isinf(pzero) || gsl_isinf(p)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					logll[i] = LOG_ONE_MINUS(pzero) + res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
				}
			}
		} else {
			GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
			for (i = 0; i < -m; i++) {
				pzero = _PROBZERO(x[i] + OFFSET(idx));
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				if (gsl_isinf(pzero) || gsl_isinf(p)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					logll[i] = pzero + (1.0 - pzero) * gsl_cdf_binomial_P((unsigned int) y, p, (unsigned int) n);
				}
			}
		}
	}

	LINK_END;
#undef _PROB
#undef _PROBZERO
	return GMRFLib_SUCCESS;
}

double eval_logsum_safe(double lA, double lB)
{
	/*
	 * evaluate log( exp(lA) + exp(lB) ) in a safe way 
	 */

	if (lA > lB) {
		return lA + log1p(exp(lB - lA));
	} else {
		return lB + log1p(exp(lA - lB));
	}
}

int loglikelihood_zero_n_inflated_binomial2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf),
					    void *arg)
{
	/*
	 * zeroNinflated Binomial : see doc from JS.
	 */
#define _P1(xx_) pow(1.0/(1.0+exp(-(xx_))), alpha1)
#define _P2(xx_) pow(1.0 - 1.0/(1.0+exp(-(xx_))), alpha2)

	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], n = ds->data_observations.nb[idx],
	    alpha1 = map_exp(ds->data_observations.zero_n_inflated_alpha1_intern[thread_id][0], MAP_FORWARD, NULL),
	    alpha2 = map_exp(ds->data_observations.zero_n_inflated_alpha2_intern[thread_id][0], MAP_FORWARD, NULL), p, p1, p2, logA, logB;

	gsl_sf_result res;
	gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y, &res);

	LINK_INIT;
	if ((int) y == 0) {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				p1 = _P1(x[i] + OFFSET(idx));
				p2 = _P2(x[i] + OFFSET(idx));
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				if (ISINF(p1) || ISINF(p2) || ISINF(p)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					if (ISZERO(1.0 - p1)) {
						logll[i] = log(p2) + res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
					} else {
						logA = log((1.0 - p1)) + log(p2);
						logB = log(p1) + log(p2) + res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
						// logll[i] = log((1.0 - p1) * p2 + p1 * p2 * gsl_ran_binomial_pdf((unsigned int)
						// y, p, (unsigned int) n));
						logll[i] = eval_logsum_safe(logA, logB);
					}
				}
			}
		} else {
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}
	} else if ((int) y == (int) n) {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				p1 = _P1(x[i] + OFFSET(idx));
				p2 = _P2(x[i] + OFFSET(idx));
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				if (ISINF(p1) || ISINF(p2) || ISINF(p)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					if (ISZERO(1.0 - p2)) {
						logll[i] = log(p1) + res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
					} else {
						logA = log((1.0 - p2)) + log(p1);
						logB = log(p1) + log(p2) + res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
						// logll[i] = log((1.0 - p2) * p1 + p1 * p2 * gsl_ran_binomial_pdf((unsigned int)
						// y, p, (unsigned int) n));
						logll[i] = eval_logsum_safe(logA, logB);
					}
				}
			}
		} else {
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}
	} else {
		if (m > 0) {
			for (i = 0; i < m; i++) {
				p1 = _P1(x[i] + OFFSET(idx));
				p2 = _P2(x[i] + OFFSET(idx));
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				if (ISINF(p1) || ISINF(p2) || ISINF(p)) {
					logll[i] = -INLA_REAL_BIG;
				} else {
					logll[i] = log(p1) + log(p2) + res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
				}
			}
		} else {
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}
	}

	LINK_END;
#undef _P1
#undef _P2
	return GMRFLib_SUCCESS;
}

int loglikelihood_zero_n_inflated_binomial3(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf),
					    void *arg)
{
	/*
	 * zeroNinflated Binomial : see doc from JS.
	 */
#define _P0(_p) (pow(_p,        alpha0)/(1.0 + pow((_p), alpha0) + pow(1.0- (_p), alphaN)))
#define _PN(_p) (pow(1.0- (_p), alphaN)/(1.0 + pow((_p), alpha0) + pow(1.0- (_p), alphaN)))

	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx], n = ds->data_observations.nb[idx],
	    alpha0 = map_exp(ds->data_observations.zero_n_inflated_alpha0_intern[thread_id][0], MAP_FORWARD, NULL),
	    alphaN = map_exp(ds->data_observations.zero_n_inflated_alphaN_intern[thread_id][0], MAP_FORWARD, NULL), p, p0, pN, logA, logB;

	gsl_sf_result res;
	gsl_sf_lnchoose_e((unsigned int) n, (unsigned int) y, &res);

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			p0 = _P0(p);
			pN = _PN(p);
			if (ISINF(p)) {
				logll[i] = -INLA_REAL_BIG;
			} else {
				logB = LOG_ONE_MINUS((p0 + pN)) + res.val + y * log(p) + (n - y) * LOG_ONE_MINUS(p);
				if ((int) y == 0) {
					logA = log(p0);
					logll[i] = eval_logsum_safe(logA, logB);
				} else if ((int) y == (int) n) {
					logA = log(pN);
					logll[i] = eval_logsum_safe(logA, logB);
				} else {
					logll[i] = logB;
				}
			}
		}
	} else {
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	LINK_END;
#undef _P0
#undef _PN
	return GMRFLib_SUCCESS;
}

int loglikelihood_gamma(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * Gamma
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	// 'scale' is not used for the survival version
	double s = (ds->data_observations.gamma_scale ? ds->data_observations.gamma_scale[idx] : 1.0);
	double phi_param = map_exp(ds->data_observations.gamma_log_prec[thread_id][0], MAP_FORWARD, NULL);
	double phi, mu, a, b, c;

	phi = phi_param * s;
	c = -gsl_sf_lngamma(phi) + (phi - 1.0) * log(y) + phi * log(phi);
	LINK_INIT;

	if (m > 0) {
		for (i = 0; i < m; i++) {
			mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = c - phi * (log(mu) + y / mu);
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			a = phi;
			b = mu / phi;
			logll[i] = gsl_cdf_gamma_P(yy, a, b);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_gammasurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_gamma));
}

int loglikelihood_gammajw(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * Gammajw
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double ly = log(y);
	double mu;

	LINK_INIT;

	if (m > 0) {
		for (i = 0; i < m; i++) {
			mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = -gsl_sf_lngamma(mu) + (mu - 1.0) * ly - y;
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = gsl_cdf_gamma_P(yy, mu, 1.0);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_gammajwsurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_gammajw));
}

int loglikelihood_gammacount(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * Gammacount
	 */
#define _G(_alpha, _beta) gsl_cdf_gamma_P((_beta), (_alpha), 1.0)

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double E = ds->data_observations.E[idx];
	double alpha = map_exp(ds->data_observations.gammacount_log_alpha[thread_id][0], MAP_FORWARD, NULL);
	double beta, mu, p, logp;

	LINK_INIT;

	if (m > 0) {
		for (i = 0; i < m; i++) {
			mu = E * PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			beta = alpha * mu;
			p = _G(y * alpha, beta) - _G((y + 1.0) * alpha, beta);
			logp = log(p);
			// this can go in over/underflow...
			if (ISINF(logp) || ISNAN(logp)) {
				logll[i] = log(GMRFLib_eps(1.0)) + PENALTY * SQR(x[i] + OFFSET(idx));
			} else {
				logll[i] = logp;
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			mu = E * PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			beta = alpha * mu;
			logll[i] = _G((y + 1.0) * alpha, beta);
		}
	}

	LINK_END;
#undef _G
	return GMRFLib_SUCCESS;
}

int loglikelihood_qkumar(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * qKumar-distr
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double phi = map_prec_qkumar(ds->data_observations.qkumar_log_prec[thread_id][0], MAP_FORWARD, NULL);
	double q = ds->data_observations.quantile;
	double alpha, beta, kappa, mu;

	beta = LOG_ONE_MINUS(q) / LOG_ONE_MINUS(exp(-phi));
	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			kappa = mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			alpha = LOG_ONE_MINUS(pow(1.0 - q, 1.0 / beta)) / log(kappa);
			logll[i] = log(alpha) + log(beta) + (alpha - 1.0) * log(y) + (beta - 1.0) * LOG_ONE_MINUS(pow(y, alpha));
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);
		for (i = 0; i < -m; i++) {
			kappa = mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			alpha = LOG_ONE_MINUS(pow(1.0 - q, 1.0 / beta)) / log(kappa);
			logll[i] = 1.0 - pow(1.0 - pow(y, alpha), beta);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_gp(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * genPareto
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double xi = map_interval(ds->data_observations.gp_intern_tail[thread_id][0], MAP_FORWARD,
				 (void *) (ds->data_observations.gp_tail_interval));
	double alpha = ds->data_observations.quantile;
	double q, sigma, fac;

	fac = xi / (pow(1.0 - alpha, -xi) - 1.0);

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			q = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			sigma = q * fac;
			logll[i] = -log(sigma) - (1.0 / xi + 1.0) * log1p(xi * y / sigma);
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			q = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			sigma = q * fac;
			logll[i] = 1.0 - pow(1.0 + xi * yy / sigma, -1.0 / xi);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_dgp(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
#define F(_y, _sigma, _xi) (1.0 - pow(1.0 + (_xi) * ((_y) + 1.0)/(_sigma), -1.0/(_xi)))
	/*
	 * discrete genPareto
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double xi = map_interval(ds->data_observations.gp_intern_tail[thread_id][0], MAP_FORWARD,
				 (void *) (ds->data_observations.gp_tail_interval));
	double alpha = ds->data_observations.quantile;
	double q, sigma, fac;

	fac = xi / (pow(1.0 - alpha, -xi) - 1.0);

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			q = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			sigma = q * fac;
			logll[i] = log(F(y, sigma, xi) - F(y - 1.01, sigma, xi));
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			q = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			sigma = q * fac;
			logll[i] = F(yy, sigma, xi);
		}
	}
	LINK_END;

#undef F
	return GMRFLib_SUCCESS;
}

int loglikelihood_beta(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * Beta : y ~ Beta(y; a, b) = BetaFunction(a,b)^{-1} y^{a-1} (1-y)^{b-1}. mu = a/(a+b), phi = a+b = exp(theta).
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double w = ds->data_observations.beta_weight[idx];
	double phi = map_exp(ds->data_observations.beta_precision_intern[thread_id][0], MAP_FORWARD, NULL) * w;
	double a, b, mu, lbeta;
	double censor_value = ds->data_observations.beta_censor_value;
	int no_censoring = (censor_value <= 0.0 || censor_value >= 0.5);

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			a = mu * phi;
			b = -mu * phi + phi;
			// If y is close to 0 then 'b' is tiny. Use the asymptotic expansion from `asympt(log(Beta(a,1/bb)), bb,
			// 1)'. If y is close to 1 then 'a'
			// is
			// tiny, do similarly
			if (DMIN(a, b) < INLA_REAL_SMALL) {
				lbeta = -log(DMIN(a, b));
			} else {
				lbeta = gsl_sf_lnbeta(a, b);
			}

			if (no_censoring) {
				// in most cases, we'll be here
				logll[i] = -lbeta + (a - 1.0) * log(y) + (b - 1.0) * LOG_ONE_MINUS(y);
			} else {
				// if we have censoring, we have to be more careful
				if (y <= censor_value) {
					logll[i] = MATHLIB_FUN(pbeta) (censor_value, a, b, 1, 1);
				} else if (y < 1.0 - censor_value) {
					logll[i] = -lbeta + (a - 1.0) * log(y) + (b - 1.0) * LOG_ONE_MINUS(y);
				} else {
					logll[i] = MATHLIB_FUN(pbeta) (1.0 - censor_value, a, b, 0, 1);
				}
			}
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			a = mu * phi;
			b = -mu * phi + phi;
			if (no_censoring) {
				logll[i] = gsl_cdf_beta_P(yy, a, b);
			} else {
				if (yy <= censor_value) {
					// use the expected prob instead
					logll[i] = MATHLIB_FUN(pbeta) (censor_value, a, b, 1, 0) / 2.0;
				} else if (yy < 1.0 - censor_value) {
					logll[i] = gsl_cdf_beta_P(yy, a, b);
				} else {
					// ... and also here
					logll[i] = 1.0 - MATHLIB_FUN(pbeta) (1.0 - censor_value, a, b, 0, 0) / 2.0;
				}
			}
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_betabinomial(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * BetaBinomial : y ~ BetaBinomial(n, a, b), where logit(p) = a/(a+b), overdispertsion = 1/(a+b+1)
	 */
#define _LOGGAMMA_INT(xx) my_gsl_sf_lnfact(((xx) - 1))

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	int y = (int) ds->data_observations.y[idx];
	int n = (int) ds->data_observations.nb[idx];

	double rho = map_probability(ds->data_observations.betabinomial_overdispersion_intern[thread_id][0], MAP_FORWARD, NULL);
	double p, a, b;
	double normc;

	if (G_norm_const_compute[idx]) {
		G_norm_const[idx] = _LOGGAMMA_INT(n + 1) - _LOGGAMMA_INT(y + 1) - _LOGGAMMA_INT(n - y + 1);
		G_norm_const_compute[idx] = 0;
	}
	normc = G_norm_const[idx];

	LINK_INIT;
	if (m > 0) {
		// issues occur when x[i] is to large
		double p_upper = 0.999, xmax;
		xmax = GMRFLib_max_value(x, m, NULL) + OFFSET(idx);
		p = PREDICTOR_INVERSE_LINK(xmax);
		if (p < p_upper) {
			for (i = 0; i < m; i++) {
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				a = p * (1.0 - rho) / rho;
				b = (p * rho - p - rho + 1.0) / rho;
				logll[i] = normc + gsl_sf_lnbeta(y + a, n - y + b) - gsl_sf_lnbeta(a, b);
			}
		} else {
			// extrapolate linearly
			double xx[3], ll[3], h = 1.0E-4, diff, ddiff, dx;
			xx[1] = PREDICTOR_LINK(p_upper);
			xx[0] = xx[1] - h;
			xx[2] = xx[1] + h;
			for (i = 0; i < 3; i++) {
				p = PREDICTOR_INVERSE_LINK(xx[i]);
				a = p * (1.0 - rho) / rho;
				b = (p * rho - p - rho + 1.0) / rho;
				ll[i] = normc + gsl_sf_lnbeta(y + a, n - y + b) - gsl_sf_lnbeta(a, b);
			}
			diff = (ll[2] - ll[0]) / (2.0 * h);
			ddiff = (ll[2] - 2.0 * ll[1] + ll[0]) / SQR(h);
			diff = DMIN(0.0, diff);		       /* must have */
			ddiff = DMIN(0.0, ddiff);	       /* must have */
			for (i = 0; i < m; i++) {
				dx = (x[i] + OFFSET(idx)) - xx[1];
				logll[i] = ll[1] + dx * diff + 0.5 * SQR(dx) * ddiff;
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);

		for (i = 0; i < -m; i++) {
			/*
			 * if 'n' is ``large'', then we need to do something approximate here... I guess we get the question back if so is the case. So we issue a
			 * warning for the ``extreme case'' only.
			 */
			static char give_warning = 1;
			if (n > 500 && give_warning) {
				give_warning = 0;
				printf("\n*** Warning ***  Version [%s]", GitID);
				printf("\n*** Warning ***  The PIT calculations for the BetaBinomial can be time-consuming when Ntrials is large.");
				printf("\n*** Warning ***  Please contact <help@r-inla.org> if this becomes an issue.\n");
			}

			int yy;
			double normc2;

			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			a = p * (1.0 - rho) / rho;
			b = (p * rho - p - rho + 1.0) / rho;
			normc2 = _LOGGAMMA_INT(n + 1) - gsl_sf_lnbeta(a, b);
			logll[i] = 0.0;

			if (y <= n / 2) {		       /* integer arithmetic is ok */
				for (yy = y; yy >= 0; yy--) {
					logll[i] +=
					    exp(normc2 - _LOGGAMMA_INT(yy + 1) - _LOGGAMMA_INT(n - yy + 1) + gsl_sf_lnbeta(yy + a, n - yy + b));
				}
			} else {
				for (yy = y + 1; yy <= n; yy++) {
					logll[i] +=
					    exp(normc2 - _LOGGAMMA_INT(yy + 1) - _LOGGAMMA_INT(n - yy + 1) + gsl_sf_lnbeta(yy + a, n - yy + b));
				}
				logll[i] = 1.0 - logll[i];
			}
		}
	}

	LINK_END;
#undef _LOGGAMMA_INT
	return GMRFLib_SUCCESS;
}

int loglikelihood_betabinomialna(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * BetaBinomialNA : y ~ BetaBinomial(n, a, b), where logit(p) = a/(a+b), overdispertsion = 1/(a+b+1), and use the normal
	 * approximation to it
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double n = ds->data_observations.nb[idx];
	double s = ds->data_observations.betabinomialnb_scale[idx];
	double rho = map_probability(ds->data_observations.betabinomial_overdispersion_intern[thread_id][0], MAP_FORWARD, NULL);
	double p, prec, lprec, ypred;

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			ypred = n * p;
			prec = 1.0 / (n * p * (1.0 - p) * (1.0 + s * (n - 1.0) * rho));
			lprec = log(prec);
			logll[i] = LOG_NORMC_GAUSSIAN + 0.5 * (lprec - (SQR(ypred - y) * prec));
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			ypred = n * p;
			prec = 1.0 / (n * p * (1.0 - p) * (1.0 + s * (n - 1.0) * rho));
			logll[i] = inla_Phi((yy - ypred) * sqrt(prec));
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_tweedie(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * Tweedie
	 */

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y = ds->data_observations.y[idx];
	double w = (ds->data_observations.tweedie_w ? ds->data_observations.tweedie_w[idx] : 1.0);
	double interval[2] = { 1.0, 2.0 };
	double p = map_interval(ds->data_observations.tweedie_p_intern[thread_id][0], MAP_FORWARD, (void *) interval);
	double phi = map_exp(ds->data_observations.tweedie_phi_intern[thread_id][0], MAP_FORWARD, NULL);

	phi /= w;
	LINK_INIT;

	static double **cmu = NULL;
	static int *ncmu = NULL;

	if (!cmu) {
#pragma omp critical (Name_f541b1464beaa9132d8c3f70fc8dc2de724ab8a5)
		{
			if (!cmu) {
				ncmu = Calloc(GMRFLib_CACHE_LEN, int);
				cmu = Calloc(GMRFLib_CACHE_LEN, double *);
				for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
					ncmu[i] = 8;
					cmu[i] = Calloc(ncmu[i], double);
				}
			}
		}
	}

	int id = 0;
	GMRFLib_CACHE_SET_ID(id);

	if (m > 0) {
		if (m > ncmu[id]) {
			ncmu[id] = m;
			cmu[id] = Realloc(cmu[id], ncmu[id], double);
		}
		double *mu = cmu[id];

		for (i = 0; i < m; i++) {
			mu[i] = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
		}
		dtweedie(m, y, mu, phi, p, logll);
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			double mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = ptweedie(yy, mu, phi, p);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_betabinomial0(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf,
					     void *arg)
{
	/*
	 * zeroinflated BetaBinomial : y ~ BetaBinomial(n, a, b), where logit(p) = a/(a+b), overdispertsion = 1/(a+b+1)
	 */
#define _LOGGAMMA_INT(xx) my_gsl_sf_lnfact(((xx) - 1))

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i, yzero = 0;
	Data_section_tp *ds = (Data_section_tp *) arg;
	int y = (int) ds->data_observations.y[idx];
	int n = (int) ds->data_observations.nb[idx];

	double rho = map_probability(ds->data_observations.zeroinflated_rho_intern[thread_id][0], MAP_FORWARD, NULL);
	double pzero = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL);
	double p, a, b, prob_zero;
	double normc = _LOGGAMMA_INT(n + 1) - _LOGGAMMA_INT(y + 1) - _LOGGAMMA_INT(n - y + 1);
	double normc_zero = _LOGGAMMA_INT(n + 1) - _LOGGAMMA_INT(yzero + 1) - _LOGGAMMA_INT(n - yzero + 1);

	LINK_INIT;
	if (m > 0) {
		if (y == 0) {
			for (i = 0; i < m; i++) {
				logll[i] = log(pzero);
			}
		} else {
			for (i = 0; i < m; i++) {
				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				a = p * (1.0 - rho) / rho;
				b = (p * rho - p - rho + 1.0) / rho;
				prob_zero = exp(normc_zero + gsl_sf_lnbeta(yzero + a, n - yzero + b) - gsl_sf_lnbeta(a, b));
				logll[i] =
				    LOG_ONE_MINUS(pzero) + normc + gsl_sf_lnbeta(y + a, n - y + b) - gsl_sf_lnbeta(a, b) - LOG_ONE_MINUS(prob_zero);
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);

		for (i = 0; i < -m; i++) {
			if (y == 0) {
				logll[i] = pzero;
			} else {
				int yy;
				double normc2;

				p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				a = p * (1.0 - rho) / rho;
				b = (p * rho - p - rho + 1.0) / rho;
				normc2 = _LOGGAMMA_INT(n + 1) - gsl_sf_lnbeta(a, b);
				prob_zero = normc + gsl_sf_lnbeta(yzero + a, n - yzero + b) - gsl_sf_lnbeta(a, b);
				logll[i] = 0.0;
				for (yy = y; yy > 0; yy--) {
					logll[i] +=
					    exp(normc2 - _LOGGAMMA_INT(yy + 1) - _LOGGAMMA_INT(n - yy + 1) + gsl_sf_lnbeta(yy + a, n - yy + b));
				}
				logll[i] = pzero + (1.0 - pzero) * logll[i] / (1.0 - prob_zero);
			}
		}
	}

	LINK_END;
#undef _LOGGAMMA_INT
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_betabinomial1(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf,
					     void *arg)
{
	/*
	 * zeroinflated BetaBinomial : y ~ BetaBinomial(n, a, b), where logit(p) = a/(a+b), overdispertsion = 1/(a+b+1)
	 */
#define _LOGGAMMA_INT(xx) my_gsl_sf_lnfact(((xx) - 1))

	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	int y = (int) ds->data_observations.y[idx];
	int n = (int) ds->data_observations.nb[idx];

	double rho = map_probability(ds->data_observations.zeroinflated_rho_intern[thread_id][0], MAP_FORWARD, NULL);
	double pzero = map_probability(ds->data_observations.prob_intern[thread_id][0], MAP_FORWARD, NULL);
	double p, a, b, tmp;
	double normc = _LOGGAMMA_INT(n + 1) - _LOGGAMMA_INT(y + 1) - _LOGGAMMA_INT(n - y + 1);

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			a = p * (1.0 - rho) / rho;
			b = (p * rho - p - rho + 1.0) / rho;
			tmp = LOG_ONE_MINUS(pzero) + normc + gsl_sf_lnbeta(y + a, n - y + b) - gsl_sf_lnbeta(a, b);
			if (y == 0) {
				logll[i] = GMRFLib_log_apbex(pzero, tmp);
			} else {
				logll[i] = tmp;
			}
		}
	} else {
		GMRFLib_ASSERT(y_cdf == NULL, GMRFLib_ESNH);

		for (i = 0; i < -m; i++) {
			int yy;
			double normc2;

			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			a = p * (1.0 - rho) / rho;
			b = (p * rho - p - rho + 1.0) / rho;
			normc2 = _LOGGAMMA_INT(n + 1) - gsl_sf_lnbeta(a, b);
			logll[i] = 0.0;
			for (yy = y; yy >= 0; yy--) {
				logll[i] += exp(normc2 - _LOGGAMMA_INT(yy + 1) - _LOGGAMMA_INT(n - yy + 1) + gsl_sf_lnbeta(yy + a, n - yy + b));
			}
			logll[i] = pzero + (1.0 - pzero) * logll[i];
		}
	}

	LINK_END;
#undef _LOGGAMMA_INT
	return GMRFLib_SUCCESS;
}

int loglikelihood_zeroinflated_betabinomial2(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf),
					     void *arg)
{
	/*
	 * zeroinflated BetaBinomial : y ~ prob*1[y=0] + (1-prob)*BetaBinomial(n, p, delta), where logit(p) = x, and prob = 1-p^alpha.
	 */
#define _PROB(xx)         (exp(xx)/(1.0+exp(xx)))
#define _PROBZERO(xx)     (1.0-pow(_PROB(xx), alpha))
#define _LOGGAMMA(xx)     gsl_sf_lngamma(xx)
#define _LOGGAMMA_INT(xx) my_gsl_sf_lnfact(((xx) - 1))

	if (m == 0) {
		return 0;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	int y = (int) ds->data_observations.y[idx];
	int n = (int) ds->data_observations.nb[idx];
	double pzero, p;
	double alpha = map_exp(ds->data_observations.zeroinflated_alpha_intern[thread_id][0], MAP_FORWARD, NULL);
	double delta = map_exp(ds->data_observations.zeroinflated_delta_intern[thread_id][0], MAP_FORWARD, NULL);
	double logA, logB;

	LINK_INIT;
	if ((int) y == 0) {
		for (i = 0; i < m; i++) {
			pzero = _PROBZERO(x[i] + OFFSET(idx));
			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			if (gsl_isinf(pzero) || gsl_isinf(p)) {
				logll[i] = -INLA_REAL_BIG;
			} else {

				logA = log(pzero);
				logB = LOG_ONE_MINUS(pzero) + (_LOGGAMMA_INT(n + 1) - _LOGGAMMA_INT(y + 1) - _LOGGAMMA_INT(n - y + 1)
							       + _LOGGAMMA(delta * p + y) + _LOGGAMMA(n + delta * (1.0 - p) - y) - _LOGGAMMA(delta +
																	     n)
							       + _LOGGAMMA(delta) - _LOGGAMMA(delta * p) - _LOGGAMMA(delta * (1.0 - p)));
				logll[i] = eval_logsum_safe(logA, logB);
			}
		}
	} else {
		for (i = 0; i < m; i++) {
			pzero = _PROBZERO(x[i] + OFFSET(idx));
			p = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			if (gsl_isinf(pzero) || gsl_isinf(p)) {
				logll[i] = -INLA_REAL_BIG;
			} else {
				logll[i] = LOG_ONE_MINUS(pzero) + (_LOGGAMMA_INT(n + 1) - _LOGGAMMA_INT(y + 1) - _LOGGAMMA_INT(n - y + 1)
								   + _LOGGAMMA(delta * p + y) + _LOGGAMMA(n + delta * (1.0 - p) - y) -
								   _LOGGAMMA(delta + n)
								   + _LOGGAMMA(delta) - _LOGGAMMA(delta * p) - _LOGGAMMA(delta * (1.0 - p)));
			}
		}
	}

	LINK_END;
#undef _PROB
#undef _PROBZERO
#undef _LOGGAMMA
#undef _LOGGAMMA_INT

	return GMRFLib_SUCCESS;
}

int loglikelihood_exp(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ Exponential
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	Data_section_tp *ds = (Data_section_tp *) arg;
	int i;
	double y, lambda;

	y = ds->data_observations.y[idx];

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = log(lambda) - lambda * y;
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			// logll[i] = 1.0 - exp(-lambda * yy);
			logll[i] = ONE_MINUS_EXP(-lambda * yy);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_expsurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_exp));
}

int loglikelihood_generic_surv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg,
			       GMRFLib_logl_tp * loglfun)
{
	// this function makes a survival likelihood out of a regression likelihood

	// this safeguard computed CDF's that should not be exactly 0 or 1
#define SAFEGUARD(value_, m_) for(int i_ = 0; i_ < (m_); i_++) value_[i_] = TRUNCATE(value_[i_], 0.0, 1.0 - p_min)

	static double p_min = -1.0;
	Data_section_tp *ds = (Data_section_tp *) arg;
	int i, ievent;
	double event, truncation, lower, upper;

	assert(y_cdf == NULL);				       // I do not think this should be used. 

	if (p_min < 0.0) {
		p_min = GMRFLib_eps(0.8943652563);	       // about 1e-14
	}

	event = ds->data_observations.event[idx];
	ievent = (int) event;
	truncation = ds->data_observations.truncation[idx];
	lower = ds->data_observations.lower[idx];
	upper = ds->data_observations.upper[idx];

	if (m > 0) {
		// by default, all these are set to zero due to Calloc
		Calloc_init(4 * m, 4);
		double *log_dens = Calloc_get(m);
		double *prob_lower = Calloc_get(m);
		double *prob_upper = Calloc_get(m);
		double *prob_truncation = Calloc_get(m);

		for (i = 0; i < m; i++) {
			prob_upper[i] = 1.0;
		}
		if (!ISZERO(truncation)) {
			loglfun(thread_id, prob_truncation, x, -m, idx, x_vec, &truncation, arg);
			for (i = 0; i < m; i++) {
				prob_truncation[i] = TRUNCATE(prob_truncation[i], 0.0, 1.0 - p_min);
			}
		}

		switch (ievent) {
		case SURV_EVENT_FAILURE:
		{
			loglfun(thread_id, log_dens, x, m, idx, x_vec, NULL, arg);
			for (i = 0; i < m; i++) {
				logll[i] = log_dens[i] - LOG_ONE_MINUS(prob_truncation[i]);
			}
		}
			break;

		case SURV_EVENT_RIGHT:
		{
			if (!ISZERO(lower)) {
				loglfun(thread_id, prob_lower, x, -m, idx, x_vec, &lower, arg);
				SAFEGUARD(prob_lower, m);
			}
			for (i = 0; i < m; i++) {
				// logll[i] = log(1.0 - (prob_lower[i] - prob_truncation[i]) / (1.0 - prob_truncation[i]));
				logll[i] = LOG_ONE_MINUS(prob_lower[i]) - LOG_ONE_MINUS(prob_truncation[i]);
			}

		}
			break;

		case SURV_EVENT_LEFT:
		{
			if (!ISINF(upper)) {
				loglfun(thread_id, prob_upper, x, -m, idx, x_vec, &upper, arg);
				SAFEGUARD(prob_upper, m);
			}
			for (i = 0; i < m; i++) {
				// logll[i] = log((prob_upper[i] - prob_truncation[i]) / (1.0 - prob_truncation[i]));
				logll[i] =
				    log(prob_upper[i]) + LOG_ONE_MINUS(prob_truncation[i] / prob_upper[i]) - LOG_ONE_MINUS(prob_truncation[i]);
			}
		}
			break;

		case SURV_EVENT_INTERVAL:
		{
			if (!ISZERO(lower)) {
				loglfun(thread_id, prob_lower, x, -m, idx, x_vec, &lower, arg);
				SAFEGUARD(prob_lower, m);
			}
			if (!ISINF(upper)) {
				loglfun(thread_id, prob_upper, x, -m, idx, x_vec, &upper, arg);
				SAFEGUARD(prob_upper, m);
			}
			for (i = 0; i < m; i++) {
				// logll[i] = log(((prob_upper[i] - prob_truncation[i]) / (1.0 - prob_truncation[i]))
				// - ((prob_lower[i] - prob_truncation[i]) / (1.0 - prob_truncation[i])));
				logll[i] = log(prob_upper[i]) + LOG_ONE_MINUS(prob_lower[i] / prob_upper[i]) - LOG_ONE_MINUS(prob_truncation[i]);
			}
		}
			break;

		case SURV_EVENT_ININTERVAL:
		{
			if (!ISZERO(lower)) {
				loglfun(thread_id, prob_lower, x, -m, idx, x_vec, &lower, arg);
				SAFEGUARD(prob_lower, m);
			}
			if (!ISINF(upper)) {
				loglfun(thread_id, prob_upper, x, -m, idx, x_vec, &upper, arg);
				SAFEGUARD(prob_upper, m);
			}
			loglfun(thread_id, log_dens, x, m, idx, x_vec, NULL, arg);
			for (i = 0; i < m; i++) {
				// logll[i] = log_dens[i] - log(prob_upper[i] - prob_lower[i]);
				logll[i] = log_dens[i] - (log(prob_upper[i]) + LOG_ONE_MINUS(prob_lower[i] / prob_upper[i]));
			}
		}
			break;

		default:
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}

		Calloc_free();
		return GMRFLib_SUCCESS;
	} else {
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
#undef SAFEGUARD
	return GMRFLib_SUCCESS;
}

int loglikelihood_weibull(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ Weibull.
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	Data_section_tp *ds = (Data_section_tp *) arg;
	int i;
	double y, alpha, lalpha, lambda, ypow, ly;

	y = ds->data_observations.y[idx];
	ly = log(y);
	alpha = map_alpha_weibull(ds->data_observations.alpha_intern[thread_id][0], MAP_FORWARD, NULL);
	lalpha = log(alpha);

	LINK_INIT;
	switch (ds->variant) {
	case 0:
	{
		if (m > 0) {
			ypow = pow(y, alpha);
			lalpha = log(alpha);
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = log(lambda) + lalpha + (alpha - 1.0) * ly - lambda * ypow;
			}
		} else {
			ypow = pow((y_cdf ? *y_cdf : y), alpha);
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				// logll[i] = 1.0 - exp(-lambda * ypow);
				logll[i] = ONE_MINUS_EXP(-lambda * ypow);
			}

		}
	}
		break;
	case 1:
	{
		if (m > 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				ypow = pow(lambda * y, alpha);
				logll[i] = log(ypow) + lalpha - ly - ypow;
			}
		} else {
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				ypow = pow(lambda * (y_cdf ? *y_cdf : y), alpha);
				// logll[i] = 1.0 - exp(-ypow);
				logll[i] = ONE_MINUS_EXP(-ypow);
			}
		}
	}
		break;
	default:
		assert(0 == 1);
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_weibullsurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_weibull));
}

int loglikelihood_gompertz(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ gompertz
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}
	Data_section_tp *ds = (Data_section_tp *) arg;
	int i;
	double y, alpha, mu;

	y = ds->data_observations.y[idx];
	// yes, use the same mapping as weibull
	alpha = map_alpha_gompertz(ds->data_observations.alpha_intern[thread_id][0], MAP_FORWARD, NULL);

	LINK_INIT;
	if (m > 0) {
		for (i = 0; i < m; i++) {
			mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			logll[i] = log(mu) + alpha * y - mu * (exp(alpha * y) - 1.0) / alpha;
			// if (i == 0)printf("idx %d x %f mu %f logll %f y %f alpha %f\n", idx, x[i], mu, logll[i], y, alpha);
		}
	} else {
		double yy = (y_cdf ? *y_cdf : y);
		for (i = 0; i < -m; i++) {
			mu = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			// logll[i] = 1.0 - exp(-mu * (exp(alpha * yy) - 1.0) / alpha);
			logll[i] = ONE_MINUS_EXP(-mu * (exp(alpha * yy) - 1.0) / alpha);
		}
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_gompertzsurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_gompertz));
}

int loglikelihood_loglogistic(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	Data_section_tp *ds = (Data_section_tp *) arg;
	int i;
	double y, ly = 0, lambda, alpha, lalpha = 0;

	y = ds->data_observations.y[idx];
	alpha = map_exp(ds->data_observations.alpha_intern[thread_id][0], MAP_FORWARD, NULL);
	LINK_INIT;

	if (m > 0) {
		ly = log(y);
		lalpha = log(alpha);
	}

	switch (ds->variant) {
	case 0:
	{
		if (m > 0) {
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = log(lambda) + (-alpha - 1.0) * ly + lalpha - 2.0 * log1p(lambda * pow(y, -alpha));
			}
		} else {
			double yy = (y_cdf ? *y_cdf : y);
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = 1.0 / (1.0 + lambda * pow(yy, -alpha));
			}
		}
	}
		break;

	case 1:
	{
		if (m > 0) {
			double lam_y;
			for (i = 0; i < m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				lam_y = lambda * y;
				logll[i] = -alpha * log(lam_y) + lalpha - ly - 2.0 * log1p(pow(lam_y, -alpha));
			}
		} else {
			double yy = (y_cdf ? *y_cdf : y);
			for (i = 0; i < -m; i++) {
				lambda = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = 1.0 / (1.0 + pow(lambda * yy, -alpha));
			}
		}
	}
		break;

	default:
		assert(0 == 1);
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_loglogisticsurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_loglogistic));
}

int loglikelihood_qloglogistic(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double y, yq, ly = NAN, lambda, alpha, lalpha = NAN, q, qq;

	y = ds->data_observations.y[idx];
	alpha = map_exp(ds->data_observations.alpha_intern[thread_id][0], MAP_FORWARD, NULL);
	q = ds->data_observations.quantile;
	qq = 1.0 / q - 1.0;
	LINK_INIT;

	if (m > 0) {
		ly = log(y);
		lalpha = log(alpha);
	}

	switch (ds->variant) {
	case 0:
	{
		if (m > 0) {
			for (i = 0; i < m; i++) {
				yq = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				lambda = qq * pow(yq, alpha);
				logll[i] = log(lambda) + (-alpha - 1.0) * ly + lalpha - 2.0 * log1p(lambda * pow(y, -alpha));
			}
		} else {
			double yy = (y_cdf ? *y_cdf : y);
			for (i = 0; i < -m; i++) {
				yq = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				lambda = qq * pow(yq, alpha);
				logll[i] = 1.0 / (1.0 + lambda * pow(yy, -alpha));
			}
		}
	}
		break;

	case 1:
	{
		if (m > 0) {
			double lam_y, qqinv = 1.0 / qq;
			for (i = 0; i < m; i++) {
				yq = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				lambda = 1.0 / yq * pow(qqinv, 1.0 / alpha);
				lam_y = lambda * y;
				logll[i] = -alpha * log(lam_y) + lalpha - ly - 2.0 * log1p(pow(lam_y, -alpha));
			}
		} else {
			double yy = (y_cdf ? *y_cdf : y), qqinv = 1.0 / qq;
			for (i = 0; i < -m; i++) {
				yq = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				lambda = 1.0 / yq * pow(qqinv, 1.0 / alpha);
				logll[i] = 1.0 / (1.0 + pow(lambda * yy, -alpha));
			}
		}
	}
		break;

	default:
		assert(0 == 1);
	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_qloglogisticsurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_qloglogistic));
}

int loglikelihood_weibull_cure(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *UNUSED(y_cdf), void *arg)
{
	/*
	 * Likelihood model for Patrick's and Silvia's model. (Internal use only.)
	 *
	 * y ~ Weibull with unknown entry point and 'zero-inflation'; see note from Patrick.B.
	 *
	 * event can be FAILURE, LEFT, RIGHT or INTERVAL
	 */

	if (m == 0) {
		return GMRFLib_SUCCESS;
	}

	Data_section_tp *ds = (Data_section_tp *) arg;
	int i, ievent;
	double y, event, truncation, lower, upper, alpha, gama, ypow, lowerpow, upperpow, truncationpow, p, onemp, podds;

	y = ds->data_observations.y[idx];
	event = ds->data_observations.event[idx];
	ievent = (int) event;
	truncation = ds->data_observations.truncation[idx];
	lower = ds->data_observations.lower[idx];
	upper = ds->data_observations.upper[idx];
	alpha = map_alpha_weibull(ds->data_observations.alpha_intern[thread_id][0], MAP_FORWARD, NULL);
	p = map_p_weibull_cure(ds->data_observations.p_intern[thread_id][0], MAP_FORWARD, NULL);
	truncationpow = pow(truncation, alpha);
	onemp = 1.0 - p;
	podds = p / onemp;
	LINK_INIT;

	if (m > 0) {
		switch (ievent) {
		case SURV_EVENT_FAILURE:
		{
			ypow = pow(y, alpha);
			for (i = 0; i < m; i++) {
				gama = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = log(gama) + log(alpha) + (alpha - 1.0) * log(y) - gama * ypow - log(podds + exp(-gama * truncationpow)
				    );
			}
		}
			break;

		case SURV_EVENT_RIGHT:
		{
			lowerpow = pow(lower, alpha);
			for (i = 0; i < m; i++) {
				gama = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = log(p + onemp * exp(-gama * lowerpow)) - log(p + onemp * exp(-gama * truncationpow));
			}
		}
			break;

		case SURV_EVENT_LEFT:
		{
			upperpow = pow(upper, alpha);
			for (i = 0; i < m; i++) {
				gama = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = log(onemp) - gama * (upperpow - truncationpow) - LOG_ONE_MINUS(onemp * exp(-gama * truncationpow));
			}
		}
			break;

		case SURV_EVENT_INTERVAL:
		{
			lowerpow = pow(lower, alpha);
			upperpow = pow(upper, alpha);
			for (i = 0; i < m; i++) {
				gama = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
				logll[i] = log(onemp) - gama * (upperpow - lowerpow) - LOG_ONE_MINUS(onemp * exp(-gama * truncationpow));
			}
		}
			break;
		default:
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}
		return GMRFLib_SUCCESS;
	} else {
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
	LINK_END;
	return GMRFLib_SUCCESS;
}

int loglikelihood_fmrisurv(int thread_id, double *logll, double *x, int m, int idx, double *x_vec, double *y_cdf, void *arg)
{
	return (m == 0 ? GMRFLib_SUCCESS : loglikelihood_generic_surv(thread_id, logll, x, m, idx, x_vec, y_cdf, arg, loglikelihood_fmri));
}

int loglikelihood_fmri(int thread_id, double *logll, double *x, int m, int idx, double *UNUSED(x_vec), double *y_cdf, void *arg)
{
	/*
	 * y ~ fmri (noncentral-chi distribution).
	 */
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	Data_section_tp *ds = (Data_section_tp *) arg;
	double eta, y, yy, prec, dof, ncp, scale, l2y, y2, yy2;

	y = ds->data_observations.y[idx];
	prec = map_exp(ds->data_observations.fmri_lprec[thread_id][0], MAP_FORWARD, NULL);
	dof = map_identity(ds->data_observations.fmri_ldof[thread_id][0], MAP_FORWARD, NULL);
	scale = (ds->data_observations.fmri_scale ? ds->data_observations.fmri_scale[idx] : 1.0);

	prec *= scale;
	LINK_INIT;

	if (m > 0) {
		y2 = prec * SQR(y);
		l2y = log(2.0 * prec * y);
		for (i = 0; i < m; i++) {
			eta = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			ncp = prec * SQR(eta);
			// more robust implementation provided by L.Starke
			// logll[i] = l2y + MATHLIB_FUN(dnchisq) (y2, dof, ncp, 1);
			logll[i] = l2y + inla_dnchisq(y2, dof, ncp);
		}
	} else {
		yy = (y_cdf ? *y_cdf : y);
		yy2 = prec * SQR(yy);
		for (i = 0; i < -m; i++) {
			eta = PREDICTOR_INVERSE_LINK(x[i] + OFFSET(idx));
			ncp = prec * SQR(eta);
			logll[i] = MATHLIB_FUN(pnchisq) (yy2, dof, ncp, 1, 0);
		}

	}

	LINK_END;
	return GMRFLib_SUCCESS;
}

int inla_sread_colon_ints(int *i, int *j, const char *str)
{
	/*
	 * read integer I and J from STR using format I:J, I,J or I J
	 */
	if (sscanf(str, "%d:%d", i, j) == 2) {
		return INLA_OK;
	} else if (sscanf(str, "%d,%d", i, j) == 2) {
		return INLA_OK;
	} else if (sscanf(str, "%d %d", i, j) == 2) {
		return INLA_OK;
	} else {
		return INLA_FAIL;
	}
}

int inla_sread(void *x, int nx, const char *str, int code)
{
	/*
	 * code = 0: int. code = 1: double 
	 */

	char *strtok_ptr = NULL, *token, *p;
	const char *delim = " \t";
	double *dx = (double *) x;
	int *ix = (int *) x;
	int count = 0;
	const int debug = 0;
	int ok;

	if (debug)
		printf("read %d entries from %s\n", nx, str);

	assert(code == 0 || code == 1);
	p = GMRFLib_strdup(str);
	while ((token = GMRFLib_strtok_r(p, delim, &strtok_ptr))) {
		p = NULL;
		ok = 1;
		if (debug) {
			printf("strip [%s] into [%s]\n", str, token);
		}

		if (code == 0) {
			if (sscanf(token, "%d", &ix[count]) == 0) {
				ok = 0;
			}
		} else if (code == 1) {
			if (sscanf(token, "%lf", &dx[count]) == 0) {
				ok = 0;
			}
		}
		if (ok)
			count++;

		if (count == nx) {
			break;
		}
	}

	if (count != nx) {
		return INLA_FAIL;
	}
	Free(p);

	return INLA_OK;
}

int inla_sread_q(void **x, int *nx, const char *str, int code)
{
	/*
	 * code = 0: int. code = 1: double
	 * 
	 * this return the number of `ints' read in nx and in x 
	 */

	char *strtok_ptr = NULL, *token, *p;
	const char *delim = " \t";
	double *dx = NULL;
	double dx_try;
	int *ix = NULL;
	int count = 0;
	const int debug = 0;
	int ix_try;
	int ok;

	assert(code == 0 || code == 1);
	p = GMRFLib_strdup(str);

	while ((token = GMRFLib_strtok_r(p, delim, &strtok_ptr))) {
		p = NULL;
		ok = 0;
		if (debug) {
			printf("strip [%s] into [%s]\n", str, token);
		}
		if (code == 0) {
			if (sscanf(token, "%d", &ix_try) == 1)
				ok = 1;
		} else {
			if (sscanf(token, "%lf", &dx_try) == 1)
				ok = 1;
		}
		if (ok) {
			if (code == 0) {
				ix = Realloc(ix, count + 1, int);
				ix[count++] = ix_try;
			} else {
				dx = Realloc(dx, count + 1, double);
				dx[count++] = dx_try;
			}
		}
	}

	*nx = count;
	if (count == 0) {
		*x = NULL;
	} else {
		if (code == 0) {
			*x = (void *) ix;
		} else {
			*x = (void *) dx;
		}
	}

	if (debug) {
		int i;
		for (i = 0; i < *nx; i++) {
			if (code == 0) {
				printf("%s : %d %d\n", str, i, ix[i]);
			} else {
				printf("%s : %d %g\n", str, i, dx[i]);
			}
		}
	}

	Free(p);

	return INLA_OK;
}

int inla_sread_ints(int *x, int nx, const char *str)
{
	// read a fixed number of ints from str
	return inla_sread((void *) x, nx, str, 0);
}

int inla_sread_doubles(double *x, int nx, const char *str)
{
	// read a fixed number of doubles from str
	return inla_sread((void *) x, nx, str, 1);
}

int inla_sread_ints_q(int **x, int *nx, const char *str)
{
	// read an unknown number of ints from str
	return inla_sread_q((void **) x, nx, str, 0);
}

int inla_sread_doubles_q(double **x, int *nx, const char *str)
{
	// read an unknown number of doubles from str
	return inla_sread_q((void **) x, nx, str, 1);
}

int inla_is_NAs(int nx, const char *string)
{
	/*
	 * return GMRFLib_SUCCESS is string consists of nx NA's + whitespace separation 
	 */
	char *scopy, *p;
	const char *sep = " \t", *NA = "NA";
	int k = 0, nna = 0;
	const int debug = 0;

	if (debug) {
		printf("call inla_is_NAs: nx %d string %s\n", nx, string);
	}

	if (!string && nx)
		return !GMRFLib_SUCCESS;
	if (!string && !nx)
		return GMRFLib_SUCCESS;

	scopy = GMRFLib_strdup(string);
	p = strtok(scopy, sep);
	nna += (p && !strcmp(p, NA));

	if (debug)
		printf("get token %d : %s\n", k++, p);

	while (p) {
		p = strtok(NULL, sep);
		nna += (p && !strcmp(p, NA));

		if (debug)
			printf("get token %d : %s\n", k++, p);
	}

	Free(scopy);
	return (nna == nx ? GMRFLib_SUCCESS : !GMRFLib_SUCCESS);
}

const char *inla_string_join(const char *a, const char *b)
{
	/*
	 * join strings A and B into A:B. 
	 */
	char *ans = NULL;

	assert((a ? strlen(a) + 1 : 0) + (b ? strlen(b) + 1 : 0) < 1025);
	GMRFLib_sprintf(&ans, "%s%c%s", (a ? a : ""), INIPARSER_SEP, (b ? b : ""));
	return ans;
}

int inla_error_missing_required_field(const char *funcname, const char *secname, const char *field)
{
	fprintf(stderr, "\n\n*** ERROR *** \t%s: section [%s]: missing required field [%s]\n\n", funcname, secname, field);
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_open_file(const char *msg)
{
	fprintf(stderr, "\n\n*** ERROR *** \tfail to open file[%s] for writing. Exit...\n\n", msg);
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_general(const char *msg)
{
	fprintf(stderr, "\n\n*** ERROR *** \t%s\n\n", msg);
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_general2(const char *msg, const char *msg2)
{
	fprintf(stderr, "\n\n*** ERROR *** \t%s: %s\n\n", msg, msg2);
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_field_is_void(const char *funcname, const char *secname, const char *field, const char *value)
{
	fprintf(stderr, "\n\n*** ERROR *** \t%s: section [%s]: field [%s] is void: [%s]\n\n", funcname, secname, field, value);
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_file_numelm(const char *funcname, const char *filename, int n, int idiv)
{
	fprintf(stderr, "\n\n*** ERROR *** \t%s: file [%s] contains [%1d] elements, which is not a multiple of [%1d]\n\n", funcname,
		filename, n, idiv);
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_file_totnumelm(const char *funcname, const char *filename, int n, int total)
{
	fprintf(stderr, "\n\n*** ERROR *** \t%s: file [%s] contains [%1d] elements, which is different from [n] = [%1d]\n\n",
		funcname, filename, n, total);
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_file_error_sorted(const char *funcname, const char *filename, int n, int element_number, double val)
{
	fprintf(stderr,
		"\n\n*** ERROR *** \t%s: file [%s] contains [%1d] elements, but element [%1d] = [%g] is void. The 'values' needs to be increasing!\n\n",
		funcname, filename, n, element_number, val);
	abort();
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_file_error(const char *funcname, const char *filename, int n, int element_number, double val)
{
	fprintf(stderr, "\n\n*** ERROR *** \t%s: file [%s] contains [%1d] elements, but element [%1d] = [%g] is void.\n\n",
		funcname, filename, n, element_number, val);
	abort();
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_error_file_error2(const char *funcname, const char *filename, int n, int element_number, double val, int element_number2, double val2)
{
	fprintf(stderr,
		"\n\n*** ERROR *** \t%s: file [%s] contains [%1d] elements, but element [%1d] = [%g] or [%1d] = [%g] is void.\n\n",
		funcname, filename, n, element_number, val, element_number2, val2);
	exit(EXIT_FAILURE);
	return INLA_OK;
}

int inla_read_fileinfo(inla_tp * mb, dictionary * ini, int sec, File_tp * file, const char *FILENAME)
{
	char *tag = (FILENAME ? GMRFLib_strdup(FILENAME) : GMRFLib_strdup("FILENAME"));
	char *secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));

	file->name = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, tag), NULL));

	/*
	 * Only signal error if FILENAME is NULL. 
	 */
	if (!file->name && !FILENAME) {
		inla_error_missing_required_field(__GMRFLib_FuncName, secname, tag);
	}
	if (mb->verbose) {
		printf("\t\tfile->name=[%s]\n", file->name);
	}
	Free(tag);

	return INLA_OK;
}

int inla_read_weightsinfo(inla_tp * mb, dictionary * ini, int sec, File_tp * file)
{
	char *secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));

	file->name = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "FILENAME"), NULL));
	if (!file->name) {
		inla_error_missing_required_field(__GMRFLib_FuncName, secname, "filename");
	}
	if (mb->verbose) {
		printf("\t\tfile->name=[%s]\n", file->name);
	}
	return INLA_OK;
}

int inla_read_prior(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "PRIOR", "PARAMETERS", "FROM.THETA", "TO.THETA", "HYPERID", default_prior, args);
}

int inla_read_prior_mix(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "MIX.PRIOR", "MIX.PARAMETERS", "MIX.FROM.THETA", "MIX.TO.THETA",
				       "MIX.HYPERID", default_prior, args);
}

int inla_read_prior_link(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "LINK.PRIOR", "LINK.PARAMETERS", "LINK.FROM.THETA", "LINK.TO.THETA",
				       "LINK.HYPERID", default_prior, args);
}

int inla_read_prior_link0(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "LINK.PRIOR0", "LINK.PARAMETERS0", "LINK.FROM.THETA0", "LINK.TO.THETA0",
				       "LINK.HYPERID0", default_prior, args);
}

int inla_read_prior_link1(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "LINK.PRIOR1", "LINK.PARAMETERS1", "LINK.FROM.THETA1", "LINK.TO.THETA1",
				       "LINK.HYPERID1", default_prior, args);
}

int inla_read_prior_link2(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "LINK.PRIOR2", "LINK.PARAMETERS2", "LINK.FROM.THETA2", "LINK.TO.THETA2",
				       "LINK.HYPERID2", default_prior, args);
}

int inla_read_prior_group(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR", "GROUP.PARAMETERS", "GROUP.FROM.THETA", "GROUP.TO.THETA",
				       "GROUP.HYPERID", default_prior, args);
}

int inla_read_prior_group0(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR0", "GROUP.PARAMETERS0", "GROUP.FROM.THETA0",
				       "GROUP.TO.THETA0", "GROUP.HYPERID0", default_prior, args);
}

int inla_read_prior_group1(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR1", "GROUP.PARAMETERS1", "GROUP.FROM.THETA1",
				       "GROUP.TO.THETA1", "GROUP.HYPERID1", default_prior, args);
}

int inla_read_prior_group2(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR2", "GROUP.PARAMETERS2", "GROUP.FROM.THETA2",
				       "GROUP.TO.THETA2", "GROUP.HYPERID2", default_prior, args);
}

int inla_read_prior_group3(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR3", "GROUP.PARAMETERS3", "GROUP.FROM.THETA3",
				       "GROUP.TO.THETA3", "GROUP.HYPERID3", default_prior, args);
}

int inla_read_prior_group4(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR4", "GROUP.PARAMETERS4", "GROUP.FROM.THETA4",
				       "GROUP.TO.THETA4", "GROUP.HYPERID4", default_prior, args);
}

int inla_read_prior_group5(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR5", "GROUP.PARAMETERS5", "GROUP.FROM.THETA5",
				       "GROUP.TO.THETA5", "GROUP.HYPERID5", default_prior, args);
}

int inla_read_prior_group6(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR6", "GROUP.PARAMETERS6", "GROUP.FROM.THETA6",
				       "GROUP.TO.THETA6", "GROUP.HYPERID6", default_prior, args);
}

int inla_read_prior_group7(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR7", "GROUP.PARAMETERS7", "GROUP.FROM.THETA7",
				       "GROUP.TO.THETA7", "GROUP.HYPERID7", default_prior, args);
}

int inla_read_prior_group8(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR8", "GROUP.PARAMETERS8", "GROUP.FROM.THETA8",
				       "GROUP.TO.THETA8", "GROUP.HYPERID8", default_prior, args);
}

int inla_read_prior_group9(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR9", "GROUP.PARAMETERS9", "GROUP.FROM.THETA9",
				       "GROUP.TO.THETA9", "GROUP.HYPERID9", default_prior, args);
}

int inla_read_prior_group10(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_prior_generic(mb, ini, sec, prior, "GROUP.PRIOR10", "GROUP.PARAMETERS10", "GROUP.FROM.THETA10",
				       "GROUP.TO.THETA10", "GROUP.HYPERID10", default_prior, args);
}

int inla_read_prior0(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 0, args);
}

int inla_read_prior1(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 1, args);
}

int inla_read_prior2(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 2, args);
}

int inla_read_prior3(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 3, args);
}

int inla_read_prior4(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 4, args);
}

int inla_read_prior5(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 5, args);
}

int inla_read_prior6(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 6, args);
}

int inla_read_prior7(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 7, args);
}

int inla_read_prior8(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 8, args);
}

int inla_read_prior9(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 9, args);
}

int inla_read_prior10(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, void *args)
{
	return inla_read_priorN(mb, ini, sec, prior, default_prior, 10, args);
}

int inla_read_priorN(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *default_prior, int N, void *args)
{
	int val;
	char *a = NULL, *b = NULL, *c = NULL, *d = NULL, *e = NULL;

	GMRFLib_sprintf(&a, "PRIOR%1d", N);
	GMRFLib_sprintf(&b, "PARAMETERS%1d", N);
	GMRFLib_sprintf(&c, "FROM.THETA%1d", N);
	GMRFLib_sprintf(&d, "TO.THETA%1d", N);
	GMRFLib_sprintf(&e, "HYPERID%1d", N);
	val =
	    inla_read_prior_generic(mb, ini, sec, prior, (const char *) a, (const char *) b, (const char *) c, (const char *) d,
				    (const char *) e, default_prior, args);
	Free(a);
	Free(b);
	Free(c);
	Free(d);
	Free(e);

	return val;
}

int inla_read_prior_generic(inla_tp * mb, dictionary * ini, int sec, Prior_tp * prior, const char *prior_tag,
			    const char *param_tag, const char *from_theta, const char *to_theta, const char *hyperid, const char *default_prior,
			    void *UNUSED(args))
{
	char *secname = NULL, *param = NULL;
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	prior->name = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, prior_tag), GMRFLib_strdup(default_prior)));

	if (!prior->name) {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, prior_tag, NULL);
	}

	prior->priorfunc = NULL;
	prior->expression = NULL;

	if (mb->verbose) {
		/*
		 * remove trailing -[a-zA-Z]*$ 
		 */
		char *p, *new_name;
		new_name = GMRFLib_strdup(prior->name);
		p = GMRFLib_rindex((const char *) new_name, '-');
		if (p) {
			*p = '\0';
		}
		p = GMRFLib_rindex((const char *) new_name, ':');
		if (p) {
			*p = '\0';
		}
		printf("\t\t%s->name=[%s]\n", prior_tag, new_name);
		Free(new_name);
	}

	prior->hyperid = inla_create_hyperid(iniparser_getint(ini, inla_string_join(secname, hyperid), 0), secname);
	prior->from_theta = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, from_theta), NULL));
	prior->to_theta = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, to_theta), NULL));
	if (mb->verbose) {
		printf("\t\thyperid=[%s]\n", prior->hyperid);
		printf("\t\t%s->from_theta=[%s]\n", prior_tag, prior->from_theta);
		printf("\t\t%s->to_theta = [%s]\n", prior_tag, prior->to_theta);
	}

	// this is special
	if (!strcasecmp(prior->name, "WISHARTKD")) {
		prior->name = GMRFLib_strdup(default_prior);
	}

	param = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, param_tag), NULL));
	if (!strcasecmp(prior->name, "GAMMA")) {
		prior->id = P_GAMMA;
		prior->priorfunc = priorfunc_gamma;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = DEFAULT_GAMMA_PRIOR_A;
			prior->parameters[1] = DEFAULT_GAMMA_PRIOR_B;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "LOGGAMMA")) {
		prior->id = P_LOGGAMMA;
		prior->priorfunc = priorfunc_loggamma;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = DEFAULT_GAMMA_PRIOR_A;
			prior->parameters[1] = DEFAULT_GAMMA_PRIOR_B;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "LOGGAMMA-ALPHA")) {
		prior->id = P_LOGGAMMA;
		prior->priorfunc = priorfunc_loggamma;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 25.0;
			prior->parameters[1] = 25.0;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "GAUSSIAN") || !strcasecmp(prior->name, "NORMAL")) {
		prior->id = P_GAUSSIAN;
		prior->priorfunc = priorfunc_gaussian;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.0;	       /* mean */
			prior->parameters[1] = DEFAULT_NORMAL_PRIOR_PRECISION;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "GAUSSIAN-1") || !strcasecmp(prior->name, "NORMAL-1")) {
		prior->id = P_GAUSSIAN;
		prior->priorfunc = priorfunc_gaussian;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 1.0;	       /* mean */
			prior->parameters[1] = 1.0;	       /* precision */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "GAUSSIAN-a") || !strcasecmp(prior->name, "NORMAL-a")) {
		prior->id = P_GAUSSIAN;
		prior->priorfunc = priorfunc_gaussian;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.0;	       /* mean */
			prior->parameters[1] = 6.25;	       /* precision */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "GAUSSIAN-std") || !strcasecmp(prior->name, "NORMAL-std")) {
		prior->id = P_GAUSSIAN;
		prior->priorfunc = priorfunc_gaussian;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.0;	       /* mean */
			prior->parameters[1] = 1.0;	       /* precision */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "GAUSSIAN-rho") || !strcasecmp(prior->name, "NORMAL-rho")) {
		prior->id = P_GAUSSIAN;
		prior->priorfunc = priorfunc_gaussian;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.0;	       /* mean */
			prior->parameters[1] = 0.2;	       /* precision */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "GAUSSIAN-group") || !strcasecmp(prior->name, "NORMAL-group")) {
		prior->id = P_GAUSSIAN;
		prior->priorfunc = priorfunc_gaussian;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.0;	       /* mean */
			prior->parameters[1] = 0.2;	       /* precision */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g, %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "MVNORM") || !strcasecmp(prior->name, "MVGAUSSIAN")) {
		int nparam, i, dim;
		double *tmp;

		prior->id = P_MVNORM;
		prior->priorfunc = priorfunc_mvnorm;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
		/*
		 * add the dimension of the mvgaussian as the first argument of the parameter 
		 */
		dim = -1;
		for (i = 0;; i++) {			       /* yes, an infinite loop */
			if (nparam == i + ISQR(i)) {
				dim = i;
				break;
			}
			if (nparam < i + ISQR(i)) {
				inla_error_general("nparam does not match with any dimension of the mvnorm");
				exit(EXIT_FAILURE);
			}
		}
		tmp = Calloc(nparam + 1, double);
		tmp[0] = dim;
		Memcpy(&(tmp[1]), prior->parameters, nparam * sizeof(double));
		Free(prior->parameters);
		prior->parameters = tmp;
	} else if (!strcasecmp(prior->name, "PCSPDEGA")) {
		int nparam, i;

		prior->id = P_PC_SPDE_GA;
		prior->priorfunc = priorfunc_pc_spde_ga;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		assert(nparam == 4);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
	} else if (!strcasecmp(prior->name, "PCMATERN")) {
		int nparam, i;

		prior->id = P_PC_MATERN;
		prior->priorfunc = priorfunc_pc_matern;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		assert(nparam == 3);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
	} else if (!strcasecmp(prior->name, "PCRANGE")) {
		int nparam, i;

		prior->id = P_PC_RANGE;
		prior->priorfunc = priorfunc_pc_range;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		assert(nparam == 2);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
	} else if (!strcasecmp(prior->name, "PCGEVTAIL")) {
		int nparam, i;

		prior->id = P_PC_GEVTAIL;
		prior->priorfunc = priorfunc_pc_gevtail;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		assert(nparam == 3);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
	} else if (!strcasecmp(prior->name, "PCGAMMA")) {
		int nparam, i;

		prior->id = P_PC_GAMMA;
		prior->priorfunc = priorfunc_pc_gamma;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		assert(nparam == 1);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
	} else if (!strcasecmp(prior->name, "PCALPHAW")) {
		int nparam, i;

		prior->id = P_PC_ALPHAW;
		prior->priorfunc = priorfunc_pc_alphaw;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		assert(nparam == 1);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
	} else if (!strcasecmp(prior->name, "PCMGAMMA")) {
		int nparam, i;

		prior->id = P_PC_MGAMMA;
		prior->priorfunc = priorfunc_pc_mgamma;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		assert(nparam == 1);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
	} else if (!strcasecmp(prior->name, "PCGAMMACOUNT")) {
		int nparam, i;

		prior->id = P_PC_GAMMACOUNT;
		prior->priorfunc = priorfunc_pc_gammacount;
		inla_sread_doubles_q(&(prior->parameters), &nparam, param);
		assert(nparam == 1);
		if (mb->verbose) {
			for (i = 0; i < nparam; i++) {
				printf("\t\t%s->%s[%1d]=[%g]\n", prior_tag, param_tag, i, prior->parameters[i]);
			}
		}
	} else if (!strcasecmp(prior->name, "MINUSLOGSQRTRUNCNORMAL") || !strcasecmp(prior->name, "MINUSLOGSQRTRUNCGAUSSIAN") ||
		   // easier names...
		   !strcasecmp(prior->name, "LOGTNORMAL") || !strcasecmp(prior->name, "LOGTGAUSSIAN")) {
		prior->id = P_MINUSLOGSQRTRUNCGAUSSIAN;
		prior->priorfunc = priorfunc_minuslogsqrtruncnormal;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.0;
			prior->parameters[1] = DEFAULT_NORMAL_PRIOR_PRECISION;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "FLAT") || !strcasecmp(prior->name, "UNIFORM")) {
		/*
		 * do not care about the range for the FLAT/UNI prior, as the parameters are already transformed to R. 
		 */
		prior->id = P_FLAT;
		prior->priorfunc = priorfunc_flat;
		prior->parameters = NULL;
	} else if (!strcasecmp(prior->name, "INVALID")) {
		prior->id = P_INVALID;
		prior->priorfunc = priorfunc_invalid;
		prior->parameters = NULL;
	} else if (!strcasecmp(prior->name, "WISHART1D") ||
		   !strcasecmp(prior->name, "WISHART2D") || !strcasecmp(prior->name, "WISHART3D") || !strcasecmp(prior->name, "WISHART4D")
		   || !strcasecmp(prior->name, "WISHART5D")) {

		if (!strcasecmp(prior->name, "WISHART1D")) {
			prior->id = P_WISHART1D;
			prior->priorfunc = priorfunc_wishart1d;
		} else if (!strcasecmp(prior->name, "WISHART2D")) {
			prior->id = P_WISHART2D;
			prior->priorfunc = priorfunc_wishart2d;
		} else if (!strcasecmp(prior->name, "WISHART3D")) {
			prior->id = P_WISHART3D;
			prior->priorfunc = priorfunc_wishart3d;
		} else if (!strcasecmp(prior->name, "WISHART4D")) {
			prior->id = P_WISHART4D;
			prior->priorfunc = priorfunc_wishart4d;
		} else if (!strcasecmp(prior->name, "WISHART5D")) {
			prior->id = P_WISHART5D;
			prior->priorfunc = priorfunc_wishart5d;
		} else {
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}

		double *xx = NULL;
		int nxx;
		int idim = (!strcasecmp(prior->name, "WISHART1D") ? 1 :
			    (!strcasecmp(prior->name, "WISHART2D") ? 2 :
			     (!strcasecmp(prior->name, "WISHART3D") ? 3 :
			      (!strcasecmp(prior->name, "WISHART4D") ? 4 : (!strcasecmp(prior->name, "WISHART5D") ? 5 : -1)))));
		assert(idim > 0);

		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx == inla_iid_wishart_nparam(idim) + 1);	/* this must be TRUE */

		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK2D")) {
		prior->id = P_WISHARTK_2D;
		prior->priorfunc = priorfunc_wishartk_2d;

		double *xx = NULL;
		int nxx;
		int idim = 2;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK3D")) {
		prior->id = P_WISHARTK_3D;
		prior->priorfunc = priorfunc_wishartk_3d;

		double *xx = NULL;
		int nxx;
		int idim = 3;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK4D")) {
		prior->id = P_WISHARTK_4D;
		prior->priorfunc = priorfunc_wishartk_4d;

		double *xx = NULL;
		int nxx;
		int idim = 4;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK5D")) {
		prior->id = P_WISHARTK_5D;
		prior->priorfunc = priorfunc_wishartk_5d;

		double *xx = NULL;
		int nxx;
		int idim = 5;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK6D")) {
		prior->id = P_WISHARTK_6D;
		prior->priorfunc = priorfunc_wishartk_6d;

		double *xx = NULL;
		int nxx;
		int idim = 6;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK7D")) {
		prior->id = P_WISHARTK_7D;
		prior->priorfunc = priorfunc_wishartk_7d;

		double *xx = NULL;
		int nxx;
		int idim = 7;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK8D")) {
		prior->id = P_WISHARTK_8D;
		prior->priorfunc = priorfunc_wishartk_8d;

		double *xx = NULL;
		int nxx;
		int idim = 8;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK9D")) {
		prior->id = P_WISHARTK_9D;
		prior->priorfunc = priorfunc_wishartk_9d;

		double *xx = NULL;
		int nxx;
		int idim = 9;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "WISHARTK10D")) {
		prior->id = P_WISHARTK_10D;
		prior->priorfunc = priorfunc_wishartk_10d;

		double *xx = NULL;
		int nxx;
		int idim = 10;
		inla_sread_doubles_q(&xx, &nxx, param);
		assert(xx);
		prior->parameters = xx;
		assert(nxx >= INLA_WISHARTK_NPARAM(idim));
		nxx = INLA_WISHARTK_NPARAM(idim);
		for (int j = 1; j < nxx; j++) {
			if (INLA_IS_SPECIAL(xx[j])) {
				if (j < idim + 1) {
					xx[j] = 1.0;
				} else {
					xx[j] = 0.0;
				}
			}
		}
		if (mb->verbose) {
			int ii;
			for (ii = 0; ii < nxx; ii++) {
				printf("\t\t%s->%s prior_parameter[%1d] = %g\n", prior_tag, param_tag, ii, prior->parameters[ii]);
			}
		}
	} else if (!strcasecmp(prior->name, "LOGFLAT")) {
		prior->id = P_LOGFLAT;
		prior->priorfunc = priorfunc_logflat;
		prior->parameters = NULL;
		if (mb->verbose) {
			printf("\t\t%s->%s=[]\n", prior_tag, param_tag);
		}
	} else if (!strcasecmp(prior->name, "LOGIFLAT")) {
		prior->id = P_LOGIFLAT;
		prior->priorfunc = priorfunc_logiflat;
		prior->parameters = NULL;
		if (mb->verbose) {
			printf("\t\t%s->%s=[]\n", prior_tag, param_tag);
		}
	} else if (!strcasecmp(prior->name, "NONE")) {
		prior->id = P_NONE;
		prior->priorfunc = NULL;
		prior->parameters = NULL;
		if (mb->verbose) {
			printf("\t\t%s->%s=[]\n", prior_tag, param_tag);
		}
	} else if (!strcasecmp(prior->name, "PCFGNH")) {
		prior->id = P_PC_FGN_H;
		prior->priorfunc = priorfunc_fgn_priorH;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.9;
			prior->parameters[1] = 0.1;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "BETACORRELATION")) {
		prior->id = P_BETACORRELATION;
		prior->priorfunc = priorfunc_betacorrelation;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 5.0;
			prior->parameters[1] = 5.0;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "LOGITBETA")) {
		prior->id = P_LOGITBETA;
		prior->priorfunc = priorfunc_betacorrelation;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 1.0;
			prior->parameters[1] = 1.0;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "PCPREC")) {
		prior->id = P_PC_PREC;
		prior->priorfunc = priorfunc_pc_prec;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.1;	       /* u */
			prior->parameters[1] = 0.001;	       /* alpha */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "PCDOF")) {
		prior->id = P_PC_DOF;
		prior->priorfunc = priorfunc_pc_dof;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double); /* Prob(dof < u) = alpha */
			prior->parameters[0] = 10.0;	       /* u */
			prior->parameters[1] = 0.5;	       /* alpha */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "PCSN")) {
		prior->id = P_PC_SN;
		prior->priorfunc = priorfunc_pc_sn;
		if (param && inla_is_NAs(1, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(1, double);
			if (inla_sread_doubles(prior->parameters, 1, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(1, double);
			prior->parameters[0] = 10.0;	       /* lambda */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g]\n", prior_tag, param_tag, prior->parameters[0]);
		}
	} else if (!strcasecmp(prior->name, "LINKSNINTERCEPT")) {
		prior->id = P_SN_INTERCEPT;
		prior->priorfunc = priorfunc_linksnintercept;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.0;
			prior->parameters[1] = 0.0;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "LOGITBETA")) {
		prior->id = P_LOGITBETA;
		prior->priorfunc = priorfunc_logitbeta;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 5.0;
			prior->parameters[1] = 5.0;
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "PCCOR0")) {
		prior->id = P_PC_COR0;
		prior->priorfunc = priorfunc_pc_cor0;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.5;	       /* u */
			prior->parameters[1] = 0.5;	       /* alpha */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "PCCOR1")) {
		prior->id = P_PC_COR1;
		prior->priorfunc = priorfunc_pc_cor1;
		if (param && inla_is_NAs(2, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			if (inla_sread_doubles(prior->parameters, 2, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 0.5;	       /* u */
			prior->parameters[1] = 0.5;	       /* alpha */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g %g]\n", prior_tag, param_tag, prior->parameters[0], prior->parameters[1]);
		}
	} else if (!strcasecmp(prior->name, "PCAR")) {
		prior->id = P_PC_AR;
		prior->priorfunc = priorfunc_pc_ar;
		if (param && inla_is_NAs(1, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(2, double);
			double tmp;
			if (inla_sread_doubles(&tmp, 1, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
			prior->parameters[0] = tmp;	       /* lambda */
			prior->parameters[1] = -1;	       /* ORDER: to be decided */
		} else {
			prior->parameters = Calloc(2, double);
			prior->parameters[0] = 1.0;	       /* lambda */
			prior->parameters[1] = -1;	       /* ORDER: to be decided */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g]\n", prior_tag, param_tag, prior->parameters[0]);
		}
	} else if (!strcasecmp(prior->name, "DIRICHLET")) {
		prior->id = P_DIRICHLET;
		prior->priorfunc = priorfunc_dirichlet;
		if (param && inla_is_NAs(1, param) != GMRFLib_SUCCESS) {
			prior->parameters = Calloc(3, double); /* yes, 3 */
			if (inla_sread_doubles(prior->parameters, 1, param) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, param_tag, param);
			}
			prior->parameters[1] = NAN;	       /* number of classes, added later */
			prior->parameters[2] = NAN;	       /* cdf, added later */
		} else {
			prior->parameters = Calloc(3, double);
			prior->parameters[0] = 0.5;	       /* alpha */
			prior->parameters[1] = NAN;	       /* number of classes, added later */
			prior->parameters[2] = NAN;	       /* number of classes, added later */
		}
		if (mb->verbose) {
			printf("\t\t%s->%s=[%g]\n", prior_tag, param_tag, prior->parameters[0]);
		}
	} else if (!strcasecmp(prior->name, "REFAR")) {
		prior->id = P_REF_AR;
		prior->priorfunc = priorfunc_ref_ar;
		prior->parameters = Calloc(1, double);
		prior->parameters[0] = -1;		       /* ORDER: to be decided */
		if (mb->verbose) {
			printf("\t\t%s->%s=[NULL]\n", prior_tag, param_tag);
		}
	} else if (!strncasecmp(prior->name, "EXPRESSION:", strlen("EXPRESSION:"))) {
		prior->id = P_EXPRESSION;
		prior->expression = GMRFLib_strdup(prior->name);
		prior->name[strlen("EXPRESSION")] = '\0';
		prior->parameters = NULL;

		if (mb->verbose) {
			printf("\t\t%s->%s=[%s]\n", prior_tag, prior->name, prior->expression);
		}
	} else if (!strncasecmp(prior->name, "TABLE:", strlen("TABLE:"))) {
		prior->id = P_TABLE;
		prior->expression = GMRFLib_strdup(prior->name);	/* yes, use the same storage */
		prior->name[strlen("TABLE")] = '\0';
		prior->parameters = NULL;

		if (mb->verbose) {
			printf("\t\t%s->%s=[%s]\n", prior_tag, prior->name, prior->expression);
		}

	} else if (!strcasecmp(prior->name, "JEFFREYSTDF")) {
		prior->id = P_JEFFREYS_T_DF;
		prior->priorfunc = priorfunc_jeffreys_df_student_t;
		prior->parameters = NULL;
		if (mb->verbose) {
			printf("\t\t%s->%s=[NULL]\n", prior_tag, param_tag);
		}
	} else {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, prior_tag, prior->name);
	}
	return INLA_OK;
}

inla_tp *inla_build(const char *dict_filename, int verbose, int make_dir)
{
	/*
	 * This function builds the model from the contents in INI 
	 */
	int found, sec, nsec, count, len, i, idx, j, k = -1;
	char *secname = NULL, *sectype = NULL, *sec_read = NULL, *msg = NULL;
	dictionary *ini = NULL;
	inla_tp *mb = NULL;

	if (verbose) {
		printf("%s...\n", __GMRFLib_FuncName);
	}
	mb = Calloc(1, inla_tp);
	mb->verbose = verbose;
	mb->reuse_mode = 0;				       /* disable this feature. creates more trouble than it solves. */
	if (mb->verbose && mb->reuse_mode) {
		printf("Reuse stored mode in [%s]\n", MODEFILENAME);
	}

	ini = iniparser_load(dict_filename);
	if (!ini) {
		GMRFLib_sprintf(&msg, "Fail to parse ini-file[%s]....", dict_filename);
		inla_error_general(msg);
	}
	nsec = iniparser_getnsec(ini);
	if (mb->verbose) {
		printf("\tnumber of sections=[%1d]\n", nsec);
	}
	/*
	 * first check that "type" is present in each section 
	 */
	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "type"), NULL)));
		if (!sectype) {
			inla_error_missing_required_field(__GMRFLib_FuncName, secname, "type");
		}
		Free(secname);
		Free(sectype);
	}
	sec_read = Calloc(nsec, char);

	/*
	 * default: gaussian data is on, then its turned off... unless we chose to disable the check
	 */
	if (mb->expert_disable_gaussian_check) {
		mb->gaussian_data = GMRFLib_FALSE;
	} else {
		mb->gaussian_data = GMRFLib_TRUE;
	}

	/*
	 * ...then parse the sections in this order: RLIB, EXPERT, MODE, PROBLEM, PREDICTOR, DATA, FFIELD, LINEAR, INLA, UPDATE, LINCOMB, OUTPUT
	 * 
	 * it is easier to do it like this, instead of insisting the user to write the section in a spesific order.
	 * 
	 */
	for (sec = found = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "LIBR")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[LIBR]\n", sec, iniparser_getsecname(ini, sec));
			}
			if (found++) {
				GMRFLib_sprintf(&msg, "%s: two or more sections of type = [LIBR]. Exit.\n", __GMRFLib_FuncName);
				inla_error_general(msg);
			}
			sec_read[sec] = 1;
			inla_parse_libR(mb, ini, sec);
		}
		Free(secname);
		Free(sectype);
	}

	for (sec = found = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "EXPERT")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[EXPERT]\n", sec, iniparser_getsecname(ini, sec));
			}
			if (found++) {
				GMRFLib_sprintf(&msg, "%s: two or more sections of type = [EXPERT]. Exit.\n", __GMRFLib_FuncName);
				inla_error_general(msg);
			}
			sec_read[sec] = 1;
			inla_parse_expert(mb, ini, sec);
		}
		Free(secname);
		Free(sectype);
	}

	for (sec = found = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "MODE")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[MODE]\n", sec, iniparser_getsecname(ini, sec));
			}
			if (found++) {
				GMRFLib_sprintf(&msg, "%s: two or more sections of type = [MODE]. Exit.\n", __GMRFLib_FuncName);
				inla_error_general(msg);
			}
			sec_read[sec] = 1;
			inla_parse_mode(mb, ini, sec);
		}
		Free(secname);
		Free(sectype);
	}

	for (sec = found = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "PROBLEM")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[PROBLEM]\n", sec, iniparser_getsecname(ini, sec));
			}
			if (found++) {
				GMRFLib_sprintf(&msg, "%s: two or more sections of type = [PROBLEM]. Exit.\n", __GMRFLib_FuncName);
				inla_error_general(msg);
			}
			sec_read[sec] = 1;
			inla_parse_problem(mb, ini, sec, make_dir);
		}
		Free(secname);
		Free(sectype);
	}
	if (!found) {
		GMRFLib_sprintf(&msg, "%s: no section of type = [PROBLEM]", __GMRFLib_FuncName);
		inla_error_general(msg);
	}

	/*
	 * type = predictor 
	 */
	for (sec = found = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "PREDICTOR")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[PREDICTOR]\n", sec, iniparser_getsecname(ini, sec));
			}
			if (found++) {
				GMRFLib_sprintf(&msg, "%s: two or more sections of type = [PREDICTOR]. Exit.\n", __GMRFLib_FuncName);
				inla_error_general(msg);
			}
			sec_read[sec] = 1;
			inla_parse_predictor(mb, ini, sec);
		}
		Free(secname);
		Free(sectype);
	}
	if (!found) {
		GMRFLib_sprintf(&msg, "%s: no section of type = [PREDICTOR]", __GMRFLib_FuncName);
		inla_error_general(msg);
	}

	/*
	 * type = DATA 
	 */
	mb->ds = 0;
	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "DATA")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[DATA]\n", sec, iniparser_getsecname(ini, sec));
			}
			sec_read[sec] = 1;
			inla_parse_data(mb, ini, sec);
			mb->ds++;
		}
		Free(secname);
		Free(sectype);
	}
	if (!found) {
		GMRFLib_sprintf(&msg, "%s: no section of type [DATA] found", __GMRFLib_FuncName);
		inla_error_general(msg);
	}

	found = 0;
	/*
	 * type = ffield 
	 */
	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "FFIELD")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[FFIELD]\n", sec, iniparser_getsecname(ini, sec));
			}
			found++;
			sec_read[sec] = 1;
			inla_parse_ffield(mb, ini, sec);
		}
		Free(secname);
		Free(sectype);
	}

	inla_add_copyof(mb);

	/*
	 * type = linear 
	 */
	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "LINEAR")) {
			if (mb->verbose) {
				printf("\tsection=[%1d] name=[%s] type=[LINEAR]\n", sec, iniparser_getsecname(ini, sec));
			}
			found++;
			sec_read[sec] = 1;
			inla_parse_linear(mb, ini, sec);
		}
		Free(secname);
		Free(sectype);
	}

	/*
	 * type = UPDATE
	 */
	inla_setup_ai_par_default(mb);			       /* need this if there is no INLA section */
	mb->ai_par->fixed_mode = mb->fixed_mode;	       /* need to pass this one as well */

	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "UPDATE")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[UPDATE]\n", sec, iniparser_getsecname(ini, sec));
			}
			sec_read[sec] = 1;
			inla_parse_update(mb, ini, sec, make_dir);
		}
		Free(secname);
		Free(sectype);
	}

	/*
	 * type = PARDISO
	 */
	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "PARDISO")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[PARDISO]\n", sec, iniparser_getsecname(ini, sec));
			}
			sec_read[sec] = 1;
			inla_parse_pardiso(mb, ini, sec, make_dir);
		}
		Free(secname);
		Free(sectype);
	}

	/*
	 * type = LPSCALE
	 */
	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "LP.SCALE")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[LP.SCALE]\n", sec, iniparser_getsecname(ini, sec));
			}
			sec_read[sec] = 1;
			inla_parse_lp_scale(mb, ini, sec, make_dir);
		}
		Free(secname);
		Free(sectype);
	}

	/*
	 * build the index table and the hash; need this before reading the lincomb sections
	 */
	len = 1 + (mb->predictor_m > 0 ? 1 : 0) + mb->nf + mb->nlinear;
	mb->idx_tag = Calloc(len, char *);
	mb->idx_start = Calloc(len, int);
	mb->idx_n = Calloc(len, int);

	j = idx = 0;
	if (mb->predictor_m > 0) {
		mb->idx_tag[j] = GMRFLib_strdup(mb->Apredictor_tag);
		mb->idx_start[j] = idx;
		mb->idx_n[j] = mb->predictor_m;
		idx += mb->idx_n[j++];
	}
	mb->idx_tag[j] = GMRFLib_strdup(mb->predictor_tag);
	mb->idx_start[j] = idx;
	mb->idx_n[j] = mb->predictor_n;
	idx += mb->idx_n[j++];
	for (i = 0; i < mb->nf; i++) {
		mb->idx_tag[j] = GMRFLib_strdup(mb->f_tag[i]);
		mb->idx_start[j] = idx;
		mb->idx_n[j] = mb->f_Ntotal[i];
		idx += mb->idx_n[j++];
	}
	for (i = 0; i < mb->nlinear; i++) {
		mb->idx_tag[j] = GMRFLib_strdup(mb->linear_tag[i]);
		mb->idx_start[j] = idx;
		mb->idx_n[j] = 1;
		idx += mb->idx_n[j++];
	}
	mb->idx_tot = j;
	mb->idx_ntot = idx;

	map_stri_init_hint(&(mb->idx_hash), mb->idx_tot);
	for (i = 0; i < mb->idx_tot; i++) {
		map_stri_set(&(mb->idx_hash), GMRFLib_strdup(mb->idx_tag[i]), i);
	}

	if (mb->verbose) {
		printf("\tIndex table: number of entries[%1d], total length[%1d]\n", mb->idx_tot, mb->idx_ntot);
		printf("\t\t%-30s %10s %10s\n", "tag", "start-index", "length");
		for (i = 0; i < mb->idx_tot; i++) {
			printf("\t\t%-30s %10d %10d\n", mb->idx_tag[i], mb->idx_start[i], mb->idx_n[i]);
		}
	}

	// copy ptr to these, in case we need to correct in strategy="prior" later with gcpo
	if (mb->gcpo_param) {
		mb->gcpo_param->idx_tot = mb->idx_tot;
		mb->gcpo_param->idx_tag = mb->idx_tag;
		mb->gcpo_param->idx_start = mb->idx_start;
		mb->gcpo_param->idx_n = mb->idx_n;
	}

	/*
	 * type = INLA 
	 */
	inla_setup_ai_par_default(mb);			       /* need this if there is no INLA section */
	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "INLA")) {
			if (mb->verbose) {
				printf("\tparse section=[%1d] name=[%s] type=[INLA]\n", sec, iniparser_getsecname(ini, sec));
			}
			sec_read[sec] = 1;
			inla_parse_INLA(mb, ini, sec, make_dir);
		}
		Free(secname);
		Free(sectype);
	}

	/*
	 * type = lincomb
	 */
	int numsec = 0, *secmap = NULL, isec = -1;

	/*
	 * first we count them
	 */
	for (sec = 0; sec < nsec; sec++) {
		secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
		sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
		if (!strcmp(sectype, "LINCOMB")) {
			numsec++;
		}
	}
	if (numsec > 0) {
		/*
		 * then we find out which order to read them using 'LINCOMB.ORDER'
		 */
		secmap = Calloc(numsec, int);
		for (sec = 0; sec < nsec; sec++) {
			secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
			sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
			if (!strcmp(sectype, "LINCOMB")) {
				int ordering;
				ordering = (int) iniparser_getdouble(ini, inla_string_join((const char *) secname, "LINCOMB.ORDER"), -1);
				GMRFLib_ASSERT_RETVAL(ordering > 0, GMRFLib_ESNH, (inla_tp *) NULL);
				secmap[ordering - 1] = sec;    /* ordering in the Model.ini is from 1...n */
			}
		}

		/*
		 * then we read them
		 */
		for (isec = 0; isec < numsec; isec++) {
			sec = secmap[isec];
			secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
			sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
			if (!strcmp(sectype, "LINCOMB")) {
				/*
				 * we need to implement this here, as the number of linear combinations can get really huge and we need to surpress the verbose mode just
				 * for these sections. 
				 */
				int verbose_save = mb->verbose;

				// This option can surpress mb->verbose locally, but not the other way around.
				mb->verbose = iniparser_getint(ini, inla_string_join(secname, "VERBOSE"), mb->verbose)
				    && mb->verbose;

				if (mb->verbose) {
					printf("\tsection=[%1d] name=[%s] type=[LINCOMB]\n", sec, iniparser_getsecname(ini, sec));
				}
				found++;
				sec_read[sec] = 1;
				inla_parse_lincomb(mb, ini, sec);

				mb->verbose = verbose_save;    /* set it back */
			} else {
				/*
				 * should not happen
				 */
				GMRFLib_ASSERT_RETVAL(0 == 1, GMRFLib_ESNH, NULL);
			}
			Free(secname);
			Free(sectype);
		}
	}
	if (mb->verbose) {
		if (numsec) {
			printf("\tRead [%1d] sections with mode=[LINCOMB]\n", numsec);
		}
	}
	Free(secmap);

	/*
	 * check that all sections are read 
	 */
	for (sec = 0; sec < nsec; sec++) {
		if (!sec_read[sec]) {
			secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
			sectype = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join((const char *) secname, "TYPE"), NULL)));
			GMRFLib_sprintf(&msg, "%s: section=[%s] is not used; please check its type=[%s]", __GMRFLib_FuncName, secname, sectype);
			inla_error_general(msg);
		}
	}
	if (mb->verbose) {
		printf("%s: check for unused entries in[%s]\n", __GMRFLib_FuncName, dict_filename);
	}
	if ((count = dictionary_dump_unused(ini, stderr))) {
		fprintf(stderr, "\n\ninla_build: [%s] contain[%1d] unused entries. PLEASE CHECK\n", dict_filename, count);
		exit(EXIT_FAILURE);
	}

	if (0) {
		dictionary_dump(ini, stdout);
		exit(0);
	}

	if (mb->reuse_mode) {
		/*
		 * if the test fail, its a good idea to provide some debug information which might be helpful to help what is wrong in the spesification. 
		 */
		if (mb->theta_counter_file != mb->ntheta_file) {
			char *ctmp = NULL;
			GMRFLib_sprintf(&ctmp,
					"Your model has %1d hyperparameter(s) which is different from the %1d hyperparameter(s) given in 'control.mode'",
					mb->theta_counter_file, mb->ntheta_file);
			inla_error_general(ctmp);
			assert(mb->theta_counter_file == mb->ntheta_file);
		}
	}

	/*
	 * make the final likelihood from all the data-sections 
	 */
	mb->loglikelihood = Calloc(mb->predictor_ndata, GMRFLib_logl_tp *);
	mb->loglikelihood_arg = Calloc(mb->predictor_ndata, void *);
	mb->d = Calloc(mb->predictor_ndata, double);
	mb->family_idx = Calloc(mb->predictor_ndata, double);
	mb->len_family_idx = mb->predictor_ndata;

	for (i = 0; i < mb->predictor_ndata; i++) {
		for (j = found = 0; j < mb->nds; j++) {
			if (mb->data_sections[j].data_observations.d[i]) {
				k = j;
				found++;
			}
		}
		if (found > 1) {
			GMRFLib_sprintf(&msg, "Observation %d occurs in more than one data-section\n", i);
			inla_error_general(msg);
			exit(EXIT_FAILURE);
		}

		if (found) {
			mb->family_idx[i] = k;
			mb->loglikelihood[i] = mb->data_sections[k].loglikelihood;
			mb->loglikelihood_arg[i] = (void *) &(mb->data_sections[k]);
			mb->d[i] = mb->data_sections[k].data_observations.d[i];
		} else {
			mb->family_idx[i] = NAN;
			mb->loglikelihood[i] = NULL;
			mb->loglikelihood_arg[i] = NULL;
			mb->d[i] = 0.0;
		}
	}
	mb->data_ntheta_all = 0;
	for (j = 0; j < mb->nds; j++) {
		mb->data_ntheta_all += mb->data_sections[j].data_ntheta + mb->data_sections[j].mix_ntheta + mb->data_sections[j].link_ntheta;
		mb->data_sections[j].offset = mb->offset;      /* just a copy */
		mb->data_sections[j].mb = mb;		       /* just a copy */
	}

	/*
	 * make the final predictor_... from all the data-sections 
	 */
	int need_link = 0;
	mb->predictor_invlinkfunc = Calloc(mb->predictor_n + mb->predictor_m, link_func_tp *);
	mb->predictor_invlinkfunc_arg = Calloc(mb->predictor_n + mb->predictor_m, void *);
	mb->predictor_invlinkfunc_covariates = Calloc(mb->predictor_n + mb->predictor_m, GMRFLib_matrix_tp *);
	mb->predictor_family = Calloc(mb->predictor_n + mb->predictor_m, double);	/* as we use NAN */
	for (i = 0; i < mb->predictor_ndata; i++) {
		for (j = found = 0; j < mb->nds; j++) {
			if (mb->data_sections[j].data_observations.d[i]) {
				k = j;
				found++;
			}
		}
		if (found > 1) {
			GMRFLib_sprintf(&msg, "Observation %d occurs in more than one data-section\n", i);
			inla_error_general(msg);
			exit(EXIT_FAILURE);
		}
		mb->predictor_family[i] = (found == 1 ? (double) k :
					   ((mb->link_fitted_values && !gsl_isnan(mb->link_fitted_values[i])) ? mb->link_fitted_values[i] : NAN));
		mb->predictor_invlinkfunc[i] = (found == 1 ? mb->data_sections[k].predictor_invlinkfunc :
						((mb->link_fitted_values && !gsl_isnan(mb->link_fitted_values[i])) ?
						 mb->data_sections[(int) (mb->link_fitted_values[i])].predictor_invlinkfunc : NULL));
		mb->predictor_invlinkfunc_arg[i] = (found == 1 ? mb->data_sections[k].predictor_invlinkfunc_arg[i] :
						    ((mb->link_fitted_values && !gsl_isnan(mb->link_fitted_values[i])) ?
						     mb->data_sections[(int) (mb->link_fitted_values[i])].predictor_invlinkfunc_arg[i] : NULL));
		mb->predictor_invlinkfunc_covariates[i] = (found == 1 ? mb->data_sections[k].link_covariates :
							   ((mb->link_fitted_values && !gsl_isnan(mb->link_fitted_values[i])) ?
							    mb->data_sections[(int) (mb->link_fitted_values[i])].link_covariates : NULL));
		if (found == 0 && mb->predictor_invlinkfunc[i] == NULL)
			need_link++;
	}

	// fprintf(stderr, "%d\n", mb->gaussian_data);
	if (need_link && !mb->gaussian_data) {
		fprintf(stderr, "\n\n*** Warning *** You might want to consider to setting ``control.predictor=list(link=...)''\n");
		fprintf(stderr, "*** Warning *** otherwise the identity link will be used to compute the fitted values for NA data\n\n\n");
	}

	iniparser_freedict(ini);
	return mb;
}

int inla_tolower(char *string)
{
	if (string) {
		int i;
		for (i = 0; i < (int) strlen(string); i++) {
			string[i] = (char) tolower((int) string[i]);
		}
	}
	return GMRFLib_SUCCESS;
}

int inla_parse_lincomb(inla_tp * mb, dictionary * ini, int sec)
{
	/*
	 * parse section = LINCOMB. Here we assume the binary files are written by Rinla, so they are index-1 based!!!!!
	 */
	int *ip = NULL, num_sections, sec_no, n, npairs, offset, i;
	const int debug = 0;
	size_t fileoffset = 0;
	char *filename = NULL, *secname = NULL, *ptr = NULL, *msg = NULL;
	GMRFLib_io_tp *io = NULL;
	GMRFLib_lc_tp *lc = NULL;

	mb->lc_tag = Realloc(mb->lc_tag, mb->nlc + 1, char *);
	mb->lc_output = Realloc(mb->lc_output, mb->nlc + 1, Output_tp *);
	mb->lc_dir = Realloc(mb->lc_dir, mb->nlc + 1, char *);
	mb->lc_order = Realloc(mb->lc_order, mb->nlc + 1, double);
	mb->lc_tag[mb->nlc] = secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	mb->lc_dir[mb->nlc] = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "DIR"), GMRFLib_strdup(mb->lc_tag[mb->nlc])));

	if (mb->verbose) {
		printf("\tinla_parse_lincomb...\n\t\tsecname = [%s]\n", mb->lc_tag[mb->nlc]);
	}

	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "FILENAME"), NULL));
	if (!filename) {
		inla_error_missing_required_field(__GMRFLib_FuncName, secname, "filename");
	}
	fileoffset = (size_t) iniparser_getdouble(ini, inla_string_join(secname, "FILE.OFFSET"), 0.0);

	if (mb->verbose) {
		printf("\t\tfilename [%s]\n", filename);
		printf("\t\tfile.offset [%zu]\n", fileoffset);
	}

	mb->lc_order[mb->nlc] = iniparser_getdouble(ini, inla_string_join(secname, "LINCOMB.ORDER"), -1.0);
	assert(mb->lc_order[mb->nlc] >= 0);

	// FORMAT:: se section.R in Rinla...

	GMRFLib_io_open(&io, filename, "rb");
	if (fileoffset > 0)
		GMRFLib_io_seek(io, fileoffset, SEEK_SET);

	if (mb->verbose) {
		printf("\t\tOpen file [%s] at location [%zu]\n", filename, fileoffset);
	}

	GMRFLib_io_read(io, &num_sections, sizeof(int));
	if (mb->verbose) {
		printf("\t\tNumber of sections [%d]\n", num_sections);
	}

	lc = Calloc(1, GMRFLib_lc_tp);
	lc->n = 0;
	lc->idx = NULL;
	lc->weight = NULL;
	lc->tinfo = Calloc(GMRFLib_CACHE_LEN, GMRFLib_lc_tinfo_tp);
	for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
		lc->tinfo[i].first_nonzero = -1;
		lc->tinfo[i].last_nonzero = -1;
		lc->tinfo[i].first_nonzero_mapped = -1;
		lc->tinfo[i].last_nonzero_mapped = -1;
	}

	int all_weights_are_zero = 1;
	for (sec_no = 0; sec_no < num_sections; sec_no++) {

		int len;

		GMRFLib_io_read(io, &len, sizeof(int));
		ptr = Calloc(len + 1, char);
		GMRFLib_io_read(io, ptr, len + 1);	       /* includes trailing \0 */
		if (mb->verbose) {
			printf("\t\t\tSection [%1d] is named [%s]\n", sec_no, ptr);
		}
		ip = map_stri_ptr(&(mb->idx_hash), ptr);
		if (!ip) {
			GMRFLib_sprintf(&msg, "Section no [%1d] named [%s] in file [%1d] offset[%16.0g] is unknown.", sec_no, ptr,
					filename, (double) fileoffset);
			GMRFLib_io_close(io);
			inla_error_general(msg);
		}

		offset = mb->idx_start[*ip];
		n = mb->idx_n[*ip];

		if (mb->verbose)
			printf("\t\t\tSection has offset=[%1d] and n=[%1d]\n", offset, n);

		GMRFLib_io_read(io, &npairs, sizeof(int));
		assert(npairs >= 0);

		if (mb->verbose) {
			printf("\t\t\tnpairs=[%1d]\n", npairs);
		}

		int *idx = Calloc(npairs, int);
		double *w = Calloc(npairs, double);

		GMRFLib_io_read(io, idx, npairs * sizeof(int));
		lc->idx = Realloc(lc->idx, lc->n + npairs, int);
		for (i = 0; i < npairs; i++) {
			lc->idx[lc->n + i] = (idx[i] - 1) + offset;	/* `-1': convert to C-indexing */

			/*
			 * check that the index is legal
			 */
			if (!LEGAL(idx[i] - 1, n)) {
				fprintf(stderr, "\n\n");
				fprintf(stderr, "*** ERROR ***\tLincomb error for section[%s]\n", secname);
				fprintf(stderr, "*** ERROR ***\t[%s] has length %1d, but idx=%1d (R-style index) is given\n", ptr, n, idx[i]);
				GMRFLib_ASSERT(0 == 1, GMRFLib_EPARAMETER);
			}
		}

		GMRFLib_io_read(io, w, npairs * sizeof(double));
		lc->weight = Realloc(lc->weight, lc->n + npairs, double);
		for (i = 0; i < npairs; i++) {
			lc->weight[lc->n + i] = w[i];
			all_weights_are_zero &= (w[i] == 0.0);
		}

		Free(idx);
		Free(w);
		Free(ptr);

		if (debug) {
			for (i = 0; i < npairs; i++) {
				printf("\t\t\t\tC.idx+offset [%1d] weight [%g]\n", lc->idx[lc->n + i], lc->weight[lc->n + i]);
			}
		}

		lc->n += npairs;
	}
	GMRFLib_io_close(io);

	if (all_weights_are_zero) {
		fprintf(stderr, "\n\n");
		fprintf(stderr, "*** ERROR ***\tLincomb error for section[%s]\n", secname);
		fprintf(stderr, "*** ERROR ***\tAll weights are zero.\n");
		GMRFLib_ASSERT(0 == 1, GMRFLib_EPARAMETER);
	}

	/*
	 * sort them with increasing idx's (and carry the weights along) to speed things up later on. 
	 */
	GMRFLib_qsorts((void *) lc->idx, (size_t) lc->n, sizeof(int), (void *) lc->weight, sizeof(double), NULL, 0, GMRFLib_icmp);
	if (mb->verbose) {
		printf("\t\tNumber of non-zero weights [%1d]\n", lc->n);
		printf("\t\tLincomb = \tidx \tweight\n");
		for (i = 0; i < IMIN(lc->n, PREVIEW); i++) {
			printf("\t\t\t%6d \t\t%.10f\n", lc->idx[i], lc->weight[i]);
		}
	}
	mb->lc_lc = Realloc(mb->lc_lc, (mb->nlc + 1), GMRFLib_lc_tp *);
	mb->lc_lc[mb->nlc] = lc;
	inla_parse_output(mb, ini, sec, &(mb->lc_output[mb->nlc]));
	mb->nlc++;

	return INLA_OK;
}

int inla_parse_mode(inla_tp * mb, dictionary * ini, int sec)
{
	/*
	 * parse section = MODE
	 */
	int nt = 0, i;
	char *tmp, *secname;
	double *t = NULL;
	FILE *fp;
	size_t nread;

	if (mb->verbose) {
		printf("\tinla_parse_mode...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	tmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "THETA"), NULL));

	/*
	 * first try if 'tmp' is a filename, is so, read (using binary format) from that. format: NTHETA theta[0] theta[1] .... theta[ NTHETA-1 ] 
	 */

	if (tmp) {
		fp = fopen(tmp, "rb");
		if (fp) {
			nread = fread(&(mb->ntheta_file), sizeof(int), 1, fp);
			assert(nread == 1);
			mb->theta_file = Calloc(mb->ntheta_file, double);
			nread = fread(mb->theta_file, sizeof(double), mb->ntheta_file, fp);
			assert(nread == (size_t) mb->ntheta_file);
			fclose(fp);

			mb->reuse_mode = 1;
		} else {
			inla_sread_doubles_q(&t, &nt, tmp);
			if (nt) {
				mb->ntheta_file = nt;
				mb->theta_file = t;
				mb->reuse_mode = 1;
			} else {
				mb->ntheta_file = 0;
				mb->theta_file = NULL;
				mb->reuse_mode = 0;
				Free(t);
			}
		}
	} else {
		mb->ntheta_file = 0;
		mb->theta_file = NULL;
		mb->reuse_mode = 0;
	}

	if (mb->verbose) {
		if (mb->ntheta_file) {
			printf("\tUse mode in section[%s]\n", secname);
			printf("\t\ttheta = ");
			for (i = 0; i < mb->ntheta_file; i++) {
				printf(" %.4g", mb->theta_file[i]);
			}
			printf("\n");
		} else {
			printf("\tDid not find any mode in section[%s]\n", secname);
		}
	}

	tmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "X"), NULL));
	if (tmp) {
		/*
		 * this is new code that use binary i/o 
		 */
		// format: NX x[0] x[1] .... x[ NX-1 ]
		fp = fopen(tmp, "rb");
		nread = fread(&(mb->nx_file), sizeof(int), 1, fp);
		assert(nread == 1);
		mb->x_file = Calloc(mb->nx_file, double);
		nread = fread(mb->x_file, sizeof(double), mb->nx_file, fp);
		assert(nread == (size_t) mb->nx_file);
		fclose(fp);

		if (mb->verbose) {
			printf("\t\tx = ");
			for (i = 0; i < IMIN(mb->nx_file, PREVIEW); i++) {
				printf(" %.4g", mb->x_file[i]);
			}
			printf(" ...\n");
		}
	}

	mb->reuse_mode_but_restart = iniparser_getboolean(ini, inla_string_join(secname, "RESTART"), 0);
	if (mb->verbose) {
		printf("\t\tRestart = %1d\n", mb->reuse_mode_but_restart);
	}

	mb->fixed_mode = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
	if (mb->verbose) {
		printf("\t\tFixed mode= %1d\n", mb->fixed_mode);
	}

	return INLA_OK;
}

int inla_parse_problem(inla_tp * mb, dictionary * ini, int sec, int make_dir)
{
	/*
	 * parse section = PROBLEM
	 */
	int i, ok;
	char *secname = NULL, *tmp = NULL, *tmpp = NULL, *smtp = NULL, *openmp_strategy = NULL, *rinla_version = NULL, *build_date = NULL;

	if (mb->verbose) {
		printf("\tinla_parse_problem...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	mb->name = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "NAME"), NULL));
	if (!mb->name) {
		mb->name = GMRFLib_strdup(secname);
	}
	if (mb->verbose) {
		printf("\t\tname=[%s]\n", mb->name);
	}

	rinla_version = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "RINLA.VERSION"), GMRFLib_strdup("UNKNOWN")));
	build_date = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "RINLA.BDATE"), GMRFLib_strdup("UNKNOWN")));
	if (mb->verbose) {
		printf("\t\tR-INLA version = [%s]\n", rinla_version);
		printf("\t\tR-INLA build date = [%s]\n", build_date);
		printf("\t\tBuild tag = [%s]\n", INLA_TAG);
		printf("\t\tSystem memory = [%.1fGb]\n", ((double) getTotalSystemMemory()) / 1024.0);
		printf("\t\tCores = (Physical= %1d, Logical= %1d)\n", UTIL_countPhysicalCores(), UTIL_countLogicalCores());
	}

	openmp_strategy = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "OPENMP.STRATEGY"), GMRFLib_strdup("DEFAULT")));
	if (mb->verbose) {
		printf("\t\topenmp.strategy=[%s]\n", openmp_strategy);
	}

	if (!strcasecmp(openmp_strategy, "DEFAULT")) {
		/*
		 * this option means that it will be determined later on. 
		 */
		mb->strategy = GMRFLib_OPENMP_STRATEGY_DEFAULT;
	} else if (!strcasecmp(openmp_strategy, "SMALL")) {
		mb->strategy = GMRFLib_OPENMP_STRATEGY_SMALL;
	} else if (!strcasecmp(openmp_strategy, "MEDIUM")) {
		mb->strategy = GMRFLib_OPENMP_STRATEGY_MEDIUM;
	} else if (!strcasecmp(openmp_strategy, "LARGE")) {
		mb->strategy = GMRFLib_OPENMP_STRATEGY_LARGE;
	} else if (!strcasecmp(openmp_strategy, "HUGE")) {
		mb->strategy = GMRFLib_OPENMP_STRATEGY_HUGE;
	} else if (!strcasecmp(openmp_strategy, "PARDISO.SERIAL")) {
		mb->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
	} else if (!strcasecmp(openmp_strategy, "PARDISO.PARALLEL")) {
		mb->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
	} else if (!strcasecmp(openmp_strategy, "PARDISO.NESTED")) {
		mb->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
	} else if (!strcasecmp(openmp_strategy, "PARDISO")) {
		mb->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
	} else {
		GMRFLib_sprintf(&tmp, "Unknown openmp.strategy [%s]\n", openmp_strategy);
		inla_error_general(tmp);
		exit(EXIT_FAILURE);
	}

	smtp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "SMTP"),
						  (GMRFLib_openmp->strategy == GMRFLib_OPENMP_STRATEGY_PARDISO ?
						   GMRFLib_strdup("PARDISO") : GMRFLib_strdup("DEFAULT"))));
	if (smtp) {
		if (!strcasecmp(smtp, "BAND")) {
			GMRFLib_smtp = GMRFLib_SMTP_BAND;
		} else if (!strcasecmp(smtp, "TAUCS")) {
			GMRFLib_smtp = GMRFLib_SMTP_TAUCS;
		} else if (!strcasecmp(smtp, "PARDISO")) {
			GMRFLib_smtp = GMRFLib_SMTP_PARDISO;
			mb->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
		} else if (!strcasecmp(smtp, "DEFAULT")) {
			if (GMRFLib_pardiso_ok < 0) {
				GMRFLib_pardiso_ok = (GMRFLib_pardiso_check_install(0, 1) == GMRFLib_SUCCESS ? 1 : 0);
			}
			if (GMRFLib_pardiso_ok) {
				if (mb->verbose) {
					printf("\t\tpardiso-library installed and working? = [%s]\n", "yes");
				}
				mb->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
				openmp_strategy = GMRFLib_strdup("pardiso");
				GMRFLib_smtp = GMRFLib_SMTP_PARDISO;
				smtp = GMRFLib_strdup("pardiso");
			} else {
				if (mb->verbose) {
					printf("\t\tpardiso-library installed and working? = [%s]\n", "no");
				}
				if (mb->strategy == GMRFLib_OPENMP_STRATEGY_PARDISO) {
					mb->strategy = GMRFLib_OPENMP_STRATEGY_DEFAULT;
					openmp_strategy = GMRFLib_strdup("default");
				}

				GMRFLib_smtp = GMRFLib_SMTP_TAUCS;
				smtp = GMRFLib_strdup("taucs");
			}
		} else {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "smtp", smtp);
		}
	}
	if (GMRFLib_smtp == GMRFLib_SMTP_PARDISO) {
		GMRFLib_reorder = GMRFLib_REORDER_PARDISO;
		GMRFLib_pardiso_set_parallel_reordering(1);
	}
	mb->smtp = GMRFLib_strdup(GMRFLib_SMTP_NAME(GMRFLib_smtp));
	if (mb->verbose) {
		printf("\t\tsmtp = [%s]\n\t\tstrategy = [%s]\n", smtp, openmp_strategy);
	}
	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_PARSE_MODEL, NULL, &GMRFLib_smtp);

	mb->dir = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "DIR"), GMRFLib_strdup("results-%1d")));
	ok = 0;
	int accept_argument = 0;

	if (make_dir) {
		GMRFLib_sprintf(&tmp, mb->dir, 0);
		GMRFLib_sprintf(&tmpp, mb->dir, 99);
		accept_argument = (strcmp(tmp, tmpp) == 0 ? 0 : 1);
		Free(tmp);
		Free(tmpp);
		for (i = 0; i < 9999; i++) {
			GMRFLib_sprintf(&tmp, mb->dir, i);
			if (inla_mkdir(tmp) != 0) {
				if (mb->verbose) {
					printf("\t\tfail to create directory [%s]: %s\n", tmp, strerror(errno));
				}
				if (!accept_argument) {
					fprintf(stderr, "\n\t\tFail to create directory [%s]: %s\n", tmp, strerror(errno));
					fprintf(stderr, "\t\tmb->dir=[%s] does not accept integer arguments. Cannot proceed.\n\n", mb->dir);
					exit(EXIT_FAILURE);
				}
			} else {
				if (mb->verbose) {
					printf("\t\tstore results in directory=[%s]\n", tmp);
				}
				mb->dir = tmp;
				ok = 1;
				break;
			}
			Free(tmp);
		}
		if (!ok) {
			inla_error_general("Fail to create directory. I give up.");
		}
	}
	inla_parse_output(mb, ini, sec, &(mb->output));
	return INLA_OK;
}

int inla_parse_predictor(inla_tp * mb, dictionary * ini, int sec)
{
	/*
	 * parse section = PREDICTOR 
	 */
	char *secname = NULL, *msg = NULL, *filename;
	int i, noffsets, nlinks_fitted_values;
	double tmp;

	if (mb->verbose) {
		printf("\tinla_parse_predictor ...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	mb->predictor_tag = GMRFLib_strdup("Predictor");
	GMRFLib_sprintf(&(mb->Apredictor_tag), "A%s", mb->predictor_tag);

	if (mb->verbose) {
		printf("\t\tsection=[%s]\n", secname);
	}
	mb->predictor_dir = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "DIR"), GMRFLib_strdup(mb->predictor_tag)));
	if (mb->verbose) {
		printf("\t\tdir=[%s]\n", mb->predictor_dir);
	}

	inla_read_prior(mb, ini, sec, &(mb->predictor_prior), "LOGGAMMA", NULL);

	tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
	mb->predictor_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
	if (!mb->predictor_fixed && mb->reuse_mode) {
		tmp = mb->theta_file[mb->theta_counter_file++];
	}
	HYPER_NEW(mb->predictor_log_prec, tmp);
	if (mb->verbose) {
		printf("\t\tinitialise log_precision[%g]\n", mb->predictor_log_prec[0][0]);
		printf("\t\tfixed=[%1d]\n", mb->predictor_fixed);
	}

	if (!mb->predictor_fixed) {
		mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
		mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
		mb->theta_hyperid[mb->ntheta] = mb->predictor_prior.hyperid;
		mb->theta[mb->ntheta] = mb->predictor_log_prec;
		mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
		mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
		mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

		mb->theta_tag[mb->ntheta] = GMRFLib_strdup("Log precision for the linear predictor");
		mb->theta_tag_userscale[mb->ntheta] = GMRFLib_strdup("Precision for the linear predictor");
		mb->theta_dir[mb->ntheta] = GMRFLib_strdup(mb->predictor_dir);

		mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
		mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
		mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->predictor_prior.from_theta);
		mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->predictor_prior.to_theta);

		mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
		mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
		mb->theta_map_arg[mb->ntheta] = NULL;
		mb->theta_map[mb->ntheta] = map_precision;
		mb->ntheta++;
	}
	mb->predictor_user_scale = iniparser_getboolean(ini, inla_string_join(secname, "USER.SCALE"), 1);
	if (mb->verbose) {
		printf("\t\tuser.scale=[%1d]\n", mb->predictor_user_scale);
	}

	mb->predictor_n = iniparser_getint(ini, inla_string_join(secname, "N"), -1);
	assert(mb->predictor_n > 0);
	if (mb->verbose) {
		printf("\t\tn=[%1d]\n", mb->predictor_n);
	}
	mb->predictor_m = iniparser_getint(ini, inla_string_join(secname, "M"), 0);
	assert(mb->predictor_m >= 0);
	if (mb->verbose) {
		printf("\t\tm=[%1d]\n", mb->predictor_m);
	}

	if (mb->predictor_m == 0) {
		mb->predictor_ndata = mb->predictor_n;
	} else {
		mb->predictor_ndata = mb->predictor_m;
	}
	if (mb->verbose) {
		printf("\t\tndata=[%1d]\n", mb->predictor_ndata);
	}

	mb->predictor_compute = iniparser_getboolean(ini, inla_string_join(secname, "COMPUTE"), 1);	// mb->output->cpo ||
	// mb->output->dic
	if (G.mode == INLA_MODE_HYPER) {
		if (mb->predictor_compute) {
			fprintf(stderr, "*** Warning: HYPER_MODE require predictor_compute = 0\n");
		}
		mb->predictor_compute = 0;
	}
	if (mb->verbose) {
		printf("\t\tcompute=[%1d]\n", mb->predictor_compute);
	}
	if ((mb->output->cpo || mb->output->dic) && !mb->predictor_compute) {
		GMRFLib_sprintf(&msg, "Illegal combination: output->cpo or dic = 1, require predictor->compute = 1, but predictor->compute = 0");
		inla_error_general(msg);
	}

	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "OFFSET"), NULL));
	if (filename) {
		if (mb->verbose) {
			printf("\t\tread offsets from file=[%s]\n", filename);
		}
		inla_read_data_general(&(mb->offset), NULL, &noffsets, filename, mb->predictor_n + mb->predictor_m, 0, 1, mb->verbose, 0.0);
	} else {
		mb->offset = Calloc(mb->predictor_n + mb->predictor_m, double);
	}

	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "LINK.FITTED.VALUES"), NULL));
	if (filename) {
		if (mb->verbose) {
			printf("\t\tread link.fitted.values from file=[%s]\n", filename);
		}
		inla_read_data_general(&(mb->link_fitted_values), NULL, &nlinks_fitted_values, filename,
				       mb->predictor_n + mb->predictor_m, 0, 1, mb->verbose, 0.0);
	} else {
		mb->link_fitted_values = NULL;
	}

	if (0) {
		if (mb->link_fitted_values) {
			for (i = 0; i < mb->predictor_n + mb->predictor_m; i++)
				if (gsl_isnan(mb->link_fitted_values[i]))
					fprintf(stderr, "link[%d] = NAN\n", i);
				else
					fprintf(stderr, "link[%d] = %g (%g)\n", i, mb->link_fitted_values[i], GSL_NAN);
		}
	}

	mb->predictor_cross_sumzero = NULL;
	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CROSS_CONSTRAINT"), NULL));
	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CROSS.CONSTRAINT"), filename));
	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CROSSCONSTRAINT"), filename));

	double *dcross = NULL;
	int *icross = NULL, len_cross = 0, nu = 0;

	if (filename) {
		inla_read_data_all(&dcross, &len_cross, filename, NULL);
		if (len_cross > 0) {
			if (len_cross != mb->predictor_n + mb->predictor_m) {
				GMRFLib_sprintf(&msg,
						"Length of cross-sum-to-zero is not equal to the TOTAL length of linear predictor: %1d != %1d\n",
						len_cross, mb->predictor_n + mb->predictor_m);
			}
			icross = Calloc(len_cross, int);
			for (i = 0; i < len_cross; i++)
				icross[i] = (int) dcross[i];
			Free(dcross);
			mb->predictor_cross_sumzero = icross;
		}
	}
	if (mb->verbose && mb->predictor_cross_sumzero) {
		GMRFLib_iuniques(&nu, NULL, mb->predictor_cross_sumzero, mb->predictor_n);
		printf("\t\tread cross-sum-to-zero from file[%s]: %1d constraints\n", filename, nu);
		for (i = 0; i < IMIN(PREVIEW, mb->predictor_n + mb->predictor_m); i++) {
			printf("\t\t\t%1d %1d\n", i, mb->predictor_cross_sumzero[i]);
		}
	}

	/*
	 * these are for the extended observational model. only valid if predictor_m > 0.
	 */
	mb->predictor_A_fnm = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "A"), NULL));
	mb->predictor_Aext_fnm = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "AEXT"), NULL));
	mb->predictor_Aext_precision = iniparser_getdouble(ini, inla_string_join(secname, "AEXTPRECISION"), 1.0e8);

	if (mb->verbose) {
		printf("\t\tA=[%s]\n", mb->predictor_A_fnm);
		printf("\t\tAext=[%s]\n", mb->predictor_Aext_fnm);
		printf("\t\tAextPrecision=[%.4g]\n", mb->predictor_Aext_precision);
	}
	if (mb->predictor_m > 0) {
		assert(mb->predictor_Aext_fnm != NULL);
	}
	if (mb->predictor_m == 0) {
		assert(mb->predictor_Aext_fnm == NULL);
	}

	inla_parse_output(mb, ini, sec, &(mb->predictor_output));

	return INLA_OK;
}

int inla_trim_family(char *family)
{
	size_t i, j = 0;

	assert(family);
	for (i = 0, j = 0; i < strlen(family); i++) {
		if (family[i] != '.' && family[i] != '_' && family[i] != ' ' && family[i] != '\t') {
			family[j] = family[i];
			j++;
		}
	}
	family[j] = '\0';
	return GMRFLib_SUCCESS;
}

char *inla_make_tag(const char *string, int ds)
{
	return (inla_make_tag2(string, ds, NULL));
}

char *inla_make_tag2(const char *string, int ds, const char *estr)
{
	char *res;

	if (ds > 0) {
		GMRFLib_sprintf(&res, "%s%s[%1d]", string, (estr ? estr : ""), ds + 1);	/* yes, number these from 1...nds */
	} else {
		GMRFLib_sprintf(&res, "%s%s", string, (estr ? estr : ""));
	}

	return res;
}

int inla_parse_data(inla_tp * mb, dictionary * ini, int sec)
{
	/*
	 * parse section = DATA 
	 */

	char *secname = NULL, *msg = NULL, *ctmp = NULL;
	int i, j, found = 0, n_data = (mb->predictor_m > 0 ? mb->predictor_m : mb->predictor_n), discrete_data = 0;
	int beta_delayed_error = 0;
	double tmp;
	Data_section_tp *ds;

	mb->nds++;
	mb->data_sections = Realloc(mb->data_sections, mb->nds, Data_section_tp);
	ds = &(mb->data_sections[mb->nds - 1]);		       /* shorthand */
	Memset(ds, 0, sizeof(Data_section_tp));

	if (mb->verbose) {
		printf("\tinla_parse_data [section %1d]...\n", mb->nds);
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\ttag=[%s]\n", secname);
	}
	ds->data_likelihood = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join(secname, "LIKELIHOOD"), NULL)));
	inla_trim_family(ds->data_likelihood);

	if (mb->verbose) {
		printf("\t\tfamily=[%s]\n", ds->data_likelihood);
	}

	if (!(ds->data_likelihood)) {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, "LIKELIHOOD", ds->data_likelihood);
	}
	if (!strcasecmp(ds->data_likelihood, "GAUSSIAN") || !strcasecmp(ds->data_likelihood, "NORMAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gaussian;
		ds->data_id = L_GAUSSIAN;
	} else if (!strcasecmp(ds->data_likelihood, "SIMPLEX")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_simplex;
		ds->data_id = L_SIMPLEX;
	} else if (!strcasecmp(ds->data_likelihood, "IIDGAMMA")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_iid_gamma;
		ds->data_id = L_IID_GAMMA;
	} else if (!strcasecmp(ds->data_likelihood, "IIDLOGITBETA")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_iid_logitbeta;
		ds->data_id = L_IID_LOGITBETA;
	} else if (!strcasecmp(ds->data_likelihood, "LOGGAMMAFRAILTY")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_loggamma_frailty;
		ds->data_id = L_LOGGAMMA_FRAILTY;
	} else if (!strcasecmp(ds->data_likelihood, "LOGISTIC")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_logistic;
		ds->data_id = L_LOGISTIC;
	} else if (!strcasecmp(ds->data_likelihood, "SKEWNORMAL") || !strcasecmp(ds->data_likelihood, "SN")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_sn;
		ds->data_id = L_SKEWNORMAL;
	} else if (!strcasecmp(ds->data_likelihood, "GEV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gev;
		ds->data_id = L_GEV;
	} else if (!strcasecmp(ds->data_likelihood, "BGEV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_bgev;
		ds->data_id = L_BGEV;
	} else if (!strcasecmp(ds->data_likelihood, "AGAUSSIAN")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_agaussian;
		ds->data_id = L_AGAUSSIAN;
	} else if (!strcasecmp(ds->data_likelihood, "T")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_t;
		ds->data_id = L_T;
	} else if (!strcasecmp(ds->data_likelihood, "TSTRATA")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_tstrata;
		ds->data_id = L_TSTRATA;
	} else if (!strcasecmp(ds->data_likelihood, "POISSON")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_poisson;
		ds->data_id = L_POISSON;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "XPOISSON")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_poisson;
		ds->data_id = L_XPOISSON;
		discrete_data = 0;			       /* disable any check. Yes, this is what this one does. */
	} else if (!strcasecmp(ds->data_likelihood, "QCONTPOISSON")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_qcontpoisson;
		ds->data_id = L_QCONTPOISSON;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "CONTPOISSON")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_contpoisson;
		ds->data_id = L_CONTPOISSON;
	} else if (!strcasecmp(ds->data_likelihood, "CENPOISSON")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_cenpoisson;
		ds->data_id = L_CENPOISSON;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "CENPOISSON2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_cenpoisson2;
		ds->data_id = L_CENPOISSON2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "CENNBINOMIAL2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_negative_binomial_cen2;
		ds->data_id = L_CENNBINOMIAL2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "GAUSSIANJW")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gaussianjw;
		ds->data_id = L_GAUSSIANJW;
		discrete_data = 0;
	} else if (!strcasecmp(ds->data_likelihood, "GPOISSON")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gpoisson;
		ds->data_id = L_GPOISSON;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "POISSONSPECIAL1")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_poisson_special1;
		ds->data_id = L_POISSON_SPECIAL1;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDPOISSON0")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_poisson0;
		ds->data_id = L_ZEROINFLATEDPOISSON0;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDPOISSON1")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_poisson1;
		ds->data_id = L_ZEROINFLATEDPOISSON1;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDPOISSON2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_poisson2;
		ds->data_id = L_ZEROINFLATEDPOISSON2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDCENPOISSON0")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_cenpoisson0;
		ds->data_id = L_ZEROINFLATEDCENPOISSON0;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDCENPOISSON1")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_cenpoisson1;
		ds->data_id = L_ZEROINFLATEDCENPOISSON1;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "BINOMIAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_binomial;
		ds->data_id = L_BINOMIAL;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "XBINOMIAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_xbinomial;
		ds->data_id = L_XBINOMIAL;
		discrete_data = 0;
	} else if (!strcasecmp(ds->data_likelihood, "NBINOMIAL2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_nbinomial2;
		ds->data_id = L_NBINOMIAL2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "CBINOMIAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_cbinomial;
		ds->data_id = L_CBINOMIAL;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "POM")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_pom;
		ds->data_id = L_POM;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "GAMMA")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gamma;
		ds->data_id = L_GAMMA;
	} else if (!strcasecmp(ds->data_likelihood, "GAMMAJW")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gammajw;
		ds->data_id = L_GAMMAJW;
	} else if (!strcasecmp(ds->data_likelihood, "GAMMACOUNT")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gammacount;
		ds->data_id = L_GAMMACOUNT;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "QKUMAR")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_qkumar;
		ds->data_id = L_QKUMAR;
	} else if (!strcasecmp(ds->data_likelihood, "qloglogistic")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_qloglogistic;
		ds->data_id = L_QLOGLOGISTIC;
	} else if (!strcasecmp(ds->data_likelihood, "qloglogisticsurv")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_qloglogisticsurv;
		ds->data_id = L_QLOGLOGISTICSURV;
	} else if (!strcasecmp(ds->data_likelihood, "BETA")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_beta;
		ds->data_id = L_BETA;
	} else if (!strcasecmp(ds->data_likelihood, "BETABINOMIAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_betabinomial;
		ds->data_id = L_BETABINOMIAL;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "BETABINOMIALNA")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_betabinomialna;
		ds->data_id = L_BETABINOMIALNA;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDBINOMIAL0")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_binomial0;
		ds->data_id = L_ZEROINFLATEDBINOMIAL0;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDBINOMIAL1")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_binomial1;
		ds->data_id = L_ZEROINFLATEDBINOMIAL1;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDBINOMIAL2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_binomial2;
		ds->data_id = L_ZEROINFLATEDBINOMIAL2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZERONINFLATEDBINOMIAL2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zero_n_inflated_binomial2;
		ds->data_id = L_ZERO_N_INFLATEDBINOMIAL2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZERONINFLATEDBINOMIAL3")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zero_n_inflated_binomial3;
		ds->data_id = L_ZERO_N_INFLATEDBINOMIAL3;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDBETABINOMIAL0")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_betabinomial0;
		ds->data_id = L_ZEROINFLATEDBETABINOMIAL0;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDBETABINOMIAL1")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_betabinomial1;
		ds->data_id = L_ZEROINFLATEDBETABINOMIAL1;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDBETABINOMIAL2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_betabinomial2;
		ds->data_id = L_ZEROINFLATEDBETABINOMIAL2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "NBINOMIAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_negative_binomial;
		ds->data_id = L_NBINOMIAL;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDNBINOMIAL0")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_negative_binomial0;
		ds->data_id = L_ZEROINFLATEDNBINOMIAL0;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDNBINOMIAL1")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_negative_binomial1;
		ds->data_id = L_ZEROINFLATEDNBINOMIAL1;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDNBINOMIAL2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_negative_binomial2;
		ds->data_id = L_ZEROINFLATEDNBINOMIAL2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDNBINOMIAL1STRATA2")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_negative_binomial1_strata2;
		ds->data_id = L_ZEROINFLATEDNBINOMIAL1STRATA2;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "ZEROINFLATEDNBINOMIAL1STRATA3")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_zeroinflated_negative_binomial1_strata3;
		ds->data_id = L_ZEROINFLATEDNBINOMIAL1STRATA3;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "STOCHVOL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_stochvol;
		ds->data_id = L_STOCHVOL;
	} else if (!strcasecmp(ds->data_likelihood, "STOCHVOLSN")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_stochvol_sn;
		ds->data_id = L_STOCHVOL_SN;
	} else if (!strcasecmp(ds->data_likelihood, "STOCHVOLT")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_stochvol_t;
		ds->data_id = L_STOCHVOL_T;
	} else if (!strcasecmp(ds->data_likelihood, "STOCHVOLNIG")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_stochvol_nig;
		ds->data_id = L_STOCHVOL_NIG;
	} else if (!strcasecmp(ds->data_likelihood, "LOGPERIODOGRAM")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_logperiodogram;
		ds->data_id = L_LOGPERIODOGRAM;
	} else if (!strcasecmp(ds->data_likelihood, "EXPONENTIAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_exp;
		ds->data_id = L_EXPONENTIAL;
	} else if (!strcasecmp(ds->data_likelihood, "EXPONENTIALSURV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_expsurv;
		ds->data_id = L_EXPONENTIALSURV;
	} else if (!strcasecmp(ds->data_likelihood, "GAMMASURV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gammasurv;
		ds->data_id = L_GAMMASURV;
	} else if (!strcasecmp(ds->data_likelihood, "GAMMAJWSURV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gammajwsurv;
		ds->data_id = L_GAMMAJWSURV;
	} else if (!strcasecmp(ds->data_likelihood, "WEIBULL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_weibull;
		ds->data_id = L_WEIBULL;
	} else if (!strcasecmp(ds->data_likelihood, "WEIBULLSURV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_weibullsurv;
		ds->data_id = L_WEIBULLSURV;
	} else if (!strcasecmp(ds->data_likelihood, "GOMPERTZ")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gompertz;
		ds->data_id = L_GOMPERTZ;
	} else if (!strcasecmp(ds->data_likelihood, "GOMPERTZSURV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gompertzsurv;
		ds->data_id = L_GOMPERTZSURV;
	} else if (!strcasecmp(ds->data_likelihood, "LOGLOGISTIC")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_loglogistic;
		ds->data_id = L_LOGLOGISTIC;
	} else if (!strcasecmp(ds->data_likelihood, "LOGLOGISTICSURV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_loglogisticsurv;
		ds->data_id = L_LOGLOGISTICSURV;
	} else if (!strcasecmp(ds->data_likelihood, "LOGNORMALSURV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_lognormalsurv;
		ds->data_id = L_LOGNORMALSURV;
	} else if (!strcasecmp(ds->data_likelihood, "LOGNORMAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_lognormal;
		ds->data_id = L_LOGNORMAL;
	} else if (!strcasecmp(ds->data_likelihood, "WEIBULLCURE")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_weibull_cure;
		ds->data_id = L_WEIBULL_CURE;
	} else if (!strcasecmp(ds->data_likelihood, "CIRCULARNORMAL")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_circular_normal;
		ds->data_id = L_CIRCULAR_NORMAL;
	} else if (!strcasecmp(ds->data_likelihood, "WRAPPEDCAUCHY")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_wrapped_cauchy;
		ds->data_id = L_WRAPPED_CAUCHY;
	} else if (!strcasecmp(ds->data_likelihood, "TWEEDIE")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_tweedie;
		ds->data_id = L_TWEEDIE;
	} else if (!strcasecmp(ds->data_likelihood, "FMRI")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_fmri;
		ds->data_id = L_FMRI;
	} else if (!strcasecmp(ds->data_likelihood, "FMRISURV")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_fmrisurv;
		ds->data_id = L_FMRISURV;
	} else if (!strcasecmp(ds->data_likelihood, "GP")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_gp;
		ds->data_id = L_GP;
	} else if (!strcasecmp(ds->data_likelihood, "DGP")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_dgp;
		ds->data_id = L_DGP;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "NMIX")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_nmix;
		ds->data_id = L_NMIX;
		discrete_data = 1;
	} else if (!strcasecmp(ds->data_likelihood, "NMIXNB")) {
		ds->loglikelihood = (GMRFLib_logl_tp *) loglikelihood_nmixnb;
		ds->data_id = L_NMIXNB;
		discrete_data = 1;
	} else {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, "LIKELIHOOD", ds->data_likelihood);
	}
	if (mb->verbose) {
		printf("\t\tlikelihood=[%s]\n", ds->data_likelihood);
	}

	inla_read_fileinfo(mb, ini, sec, &(ds->data_file), NULL);
	inla_read_fileinfo(mb, ini, sec, &(ds->weight_file), "WEIGHTS");
	inla_read_fileinfo(mb, ini, sec, &(ds->attr_file), "ATTRIBUTES");
	inla_read_fileinfo(mb, ini, sec, &(ds->lp_scale_file), "LPSCALE");
	inla_read_data_likelihood(mb, ini, sec);

	/*
	 * validate the data 
	 */
	if (discrete_data) {
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] != (int) ds->data_observations.y[i]) {
					GMRFLib_sprintf(&msg, "%s: %s likelihood is defined on integers, but y[%1d] = %.12g\n",
							secname, ds->data_likelihood, i, ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}

	switch (ds->data_id) {
	case L_GAUSSIAN:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_gaussian[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Gaussian weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_gaussian[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_LOGNORMAL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_gaussian[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: LogNormal weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_gaussian[i]);
					inla_error_general(msg);
				}
				if (ds->data_observations.y[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: LogNormal y[%1d] = %g is < 0\n", secname, i, ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_SIMPLEX:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_simplex[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Simplex weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_simplex[i]);
					inla_error_general(msg);
				}
				if (ds->data_observations.y[i] <= 0.0 || ds->data_observations.y[i] >= 1) {
					GMRFLib_sprintf(&msg, "%s: Simplex data[%1d] (y) = (%g) is void\n", secname, i, ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_CIRCULAR_NORMAL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_circular_normal[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Circular Normal weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_circular_normal[i]);
					inla_error_general(msg);
				}
			}
			if (ds->data_observations.d[i]) {
				if (ABS(ds->data_observations.y[i]) > 2.0 * M_PI) {
					GMRFLib_sprintf(&msg, "%s: Circular Normal observation y[%1d] = %g is void\n", secname, i,
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_WRAPPED_CAUCHY:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_wrapped_cauchy[i] <= 0.0 || ds->data_observations.weight_wrapped_cauchy[i] > 1.0) {
					GMRFLib_sprintf(&msg, "%s: Wrapped Cauchy weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_wrapped_cauchy[i]);
					inla_error_general(msg);
				}
			}
			if (ds->data_observations.d[i]) {
				if (ABS(ds->data_observations.y[i]) > 2.0 * M_PI) {
					GMRFLib_sprintf(&msg, "%s: Wrapped Cauchy observation y[%1d] = %g is void\n", secname, i,
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_TWEEDIE:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.tweedie_w[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Tweedie scale[%1d] = %g is void\n", secname, i,
							ds->data_observations.tweedie_w[i]);
					inla_error_general(msg);
				}
			}
			if (ds->data_observations.d[i]) {
				if (ABS(ds->data_observations.y[i]) < 0.0) {
					GMRFLib_sprintf(&msg, "%s: Tweedie observation y[%1d] = %g is void\n", secname, i,
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_FMRI:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.fmri_scale[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: fmri scale[%1d] = %g is void\n", secname, i,
							ds->data_observations.fmri_scale[i]);
					inla_error_general(msg);
				}
			}
			if (ds->data_observations.d[i]) {
				if (ABS(ds->data_observations.y[i]) <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: fmri observation y[%1d] = %g is void\n", secname, i, ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_GP:
	case L_DGP:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: gp/dgp observation y[%1d] = %g is void\n", secname, i,
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_IID_GAMMA:
	case L_IID_LOGITBETA:
	case L_LOGGAMMA_FRAILTY:
	{
		/*
		 * ok...
		 */
	}
		break;

	case L_LOGISTIC:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_logistic[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Logistic weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_logistic[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_SKEWNORMAL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.sn_scale[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Skewnormal scale[%1d] = %g is void\n", secname, i,
							ds->data_observations.sn_scale[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_GEV:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_gev[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: GEV weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_gev[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_BGEV:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.bgev_scale[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: BGEV scale[%1d] = %g is void\n", secname, i,
							ds->data_observations.bgev_scale[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_AGAUSSIAN:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.agaussian[0][i] < 0.0 ||
				    ds->data_observations.agaussian[2][i] <= 0.0 || ds->data_observations.agaussian[3][i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: AGAUSSIAN data[%1d] = %g %g %g %g %g is void\n", secname, i,
							ds->data_observations.agaussian[0][i],
							ds->data_observations.agaussian[1][i],
							ds->data_observations.agaussian[2][i], ds->data_observations.agaussian[3][i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_T:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_t[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Student-t weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_t[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_TSTRATA:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.weight_tstrata[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: t weight[%1d] = %g is void\n", secname, i,
							ds->data_observations.weight_tstrata[i]);
					inla_error_general(msg);
				}
				if ((int) (ds->data_observations.strata_tstrata[i]) < 0) {
					GMRFLib_sprintf(&msg, "%s: tstrata strata[%1d] = %g is void\n", secname, i,
							ds->data_observations.strata_tstrata[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_POISSON:
	case L_XPOISSON:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] < 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: Poisson data[%1d] (e,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_CONTPOISSON:
	case L_QCONTPOISSON:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] < 0.0 || ds->data_observations.y[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: ContPoisson data[%1d] (e,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_CENPOISSON:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] < 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: CenPoisson data[%1d] (e,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_CENPOISSON2:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] < 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: CenPoisson2 data[%1d] (e,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
				if ((ds->data_observations.cen_high[i] > 0 &&
				     (ds->data_observations.cen_high[i] < ds->data_observations.cen_low[i]))) {
					GMRFLib_sprintf(&msg, "%s: CenPoisson2 (idx,low,high) = (%d,%g,%g) is void\n", secname, i,
							ds->data_observations.cen_low[i], ds->data_observations.cen_high[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_CENNBINOMIAL2:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] < 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: CenNBinomial2 data[%1d] (e,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
				if ((ds->data_observations.cen_high[i] > 0 &&
				     (ds->data_observations.cen_high[i] < ds->data_observations.cen_low[i]))) {
					GMRFLib_sprintf(&msg, "%s: CenNBinomial2 (idx,low,high) = (%d,%g,%g) is void\n", secname, i,
							ds->data_observations.cen_low[i], ds->data_observations.cen_high[i]);
					inla_error_general(msg);
				}
				if (ds->data_observations.S[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: CenNBinomial2 data[%1d] S = %g is void\n", secname, i,
							ds->data_observations.S[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_GAUSSIANJW:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.gjw_n[i] <= 0.0 || ds->data_observations.gjw_df[i] <= 0.0 ||
				    ds->data_observations.gjw_var[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: GaussianJW data[%1d] (n,df,var) = (%g,%g,%g) is void\n", secname, i,
							ds->data_observations.gjw_n[i],
							ds->data_observations.gjw_df[i], ds->data_observations.gjw_var[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_POISSON_SPECIAL1:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] < 0.0 || ds->data_observations.y[i] < 1.0) {
					GMRFLib_sprintf(&msg, "%s: Poisson.special1 data[%1d] (e,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_POM:
	{
		int nclasses = -1, iy;
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				iy = (int) ds->data_observations.y[i];
				nclasses = IMAX(nclasses, iy);
				if (iy <= 0) {
					GMRFLib_sprintf(&msg, "%s: POM data[%1d] (y) = %g is void\n", secname, i, ds->data_observations.y[i]);
					inla_error_general(msg);
				}
				if (iy != (int) ds->data_observations.y[i]) {
					GMRFLib_sprintf(&msg, "%s: POM data[%1d] (y) = (%g) is not an integer\n", secname, i,
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
		GMRFLib_ASSERT(nclasses <= POM_MAXTHETA, GMRFLib_EPARAMETER);
		GMRFLib_ASSERT(nclasses > 1, GMRFLib_EPARAMETER);
		ds->data_observations.pom_nclasses = nclasses;
		assert(nclasses > 0);

		int *check = Calloc(nclasses + 1, int);
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				iy = (int) ds->data_observations.y[i];
				check[iy] = 1;
			}
		}
		for (int k = 1; k <= nclasses; k++) {
			if (check[k] == 0) {
				GMRFLib_sprintf(&msg, "%s: POM: There are no observations for class [%1d]. Not allowed\n", secname, k);
				inla_error_general(msg);
			}
		}
		Free(check);
	}
		break;

	case L_GAMMACOUNT:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] < 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: Gammacount data[%1d] (E,y) = (%g, %g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_EXPONENTIAL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: Exponential data[%1d] (y) = (%g) is void\n", secname, i,
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_WEIBULL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Weibull data[%1d] (y) = (%g) is void\n", secname, i, ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_GOMPERTZ:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: GOMPERTZ data[%1d] (y) = (%g) is void\n", secname, i,
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_GPOISSON:
	case L_ZEROINFLATEDPOISSON0:
	case L_ZEROINFLATEDPOISSON1:
	case L_ZEROINFLATEDPOISSON2:
	case L_ZEROINFLATEDCENPOISSON0:
	case L_ZEROINFLATEDCENPOISSON1:
	case L_ZEROINFLATEDNBINOMIAL0:
	case L_ZEROINFLATEDNBINOMIAL1:
	case L_ZEROINFLATEDNBINOMIAL2:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] <= 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: Poisson-like data[%1d] (e,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_NBINOMIAL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] <= 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: Poisson-like data[%1d] (E,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
				if (ds->data_observations.S[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Poisson-like data[%1d] S = %g is void\n", secname, i,
							ds->data_observations.S[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_ZEROINFLATEDNBINOMIAL1STRATA2:
	case L_ZEROINFLATEDNBINOMIAL1STRATA3:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.E[i] < 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: Poisson data[%1d] (e,y) = (%g,%g) is void\n", secname, i,
							ds->data_observations.E[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_GAMMA:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] <= 0.0 || ds->data_observations.gamma_scale[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Gamma data[%1d] (y) = %g or weight %g is void\n", secname, i,
							ds->data_observations.y[i], ds->data_observations.gamma_scale[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_GAMMAJW:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Gammajw data[%1d] (y) = %g or weight %g is void\n", secname, i,
							ds->data_observations.y[i], ds->data_observations.gamma_scale[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_QKUMAR:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] <= 0.0 || ds->data_observations.y[i] >= 1.0) {
					GMRFLib_sprintf(&msg, "%s: qKumar data[%1d] (y) = (%g) is void\n", secname, i, ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_LOGLOGISTIC:
	case L_QLOGLOGISTIC:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: log-logistic/normal data[%1d] (y) = (%g) is void\n", secname, i,
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_BETA:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.y[i] == 0.0 || ds->data_observations.y[i] == 1.0) {
					beta_delayed_error++;
				} else if (ds->data_observations.y[i] < 0.0 || ds->data_observations.y[i] > 1.0
					   || ds->data_observations.beta_weight[i] <= 0.0) {
					GMRFLib_sprintf(&msg, "%s: Beta data[%1d] (y) = (%g) or weight (%g)is void\n", secname, i,
							ds->data_observations.y[i], ds->data_observations.beta_weight[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_ZERO_N_INFLATEDBINOMIAL2:
	case L_ZERO_N_INFLATEDBINOMIAL3:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.nb[i] <= 0.0 ||
				    ds->data_observations.y[i] > ds->data_observations.nb[i] || ds->data_observations.y[i] < 0.0) {
					// we allow for binomial(0,p) if y = 0
					if (!(ISZERO(ds->data_observations.nb[i]) && ISZERO(ds->data_observations.y[i]))) {
						GMRFLib_sprintf(&msg, "%s: Binomial data[%1d] (nb,y) = (%g,%g) is void\n", secname,
								i, ds->data_observations.nb[i], ds->data_observations.y[i]);
						inla_error_general(msg);
					}
				}
			}
		}
	}
		break;

	case L_XBINOMIAL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.nb[i] <= 0.0 ||
				    ds->data_observations.y[i] > ds->data_observations.nb[i] || ds->data_observations.y[i] < 0.0 ||
				    ds->data_observations.p_scale[i] <= 0.0 || ds->data_observations.p_scale[i] > 1.0) {
					GMRFLib_sprintf(&msg, "%s: xBinomial data[%1d] (nb,p.scale,y) = (%g,%g,%g) is void\n", secname,
							i, ds->data_observations.nb[i], ds->data_observations.p_scale[i],
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_BINOMIAL:
	{
		if (ds->variant == 0) {
			for (i = 0; i < mb->predictor_ndata; i++) {
				if (ds->data_observations.d[i]) {
					if (ds->data_observations.nb[i] <= 0.0 ||
					    ds->data_observations.y[i] > ds->data_observations.nb[i] || ds->data_observations.y[i] < 0.0) {
						// we allow for binomial(0,p) if y = 0
						if (!(ISZERO(ds->data_observations.nb[i]) && ISZERO(ds->data_observations.y[i]))) {
							GMRFLib_sprintf(&msg, "%s: Binomial data[%1d] (nb,y) = (%g,%g) is void\n", secname,
									i, ds->data_observations.nb[i], ds->data_observations.y[i]);
							inla_error_general(msg);
						}
					}
				}
			}
		} else {
			// neg binomial
			for (i = 0; i < mb->predictor_ndata; i++) {
				if (ds->data_observations.d[i]) {
					if (!((ds->data_observations.nb[i] - ds->data_observations.y[i]) >= 0.0 &&
					      ds->data_observations.y[i] >= 1.0)) {
						GMRFLib_sprintf(&msg, "%s: Binomial data[%1d] variant=%1d, (nb,y) = (%g,%g) is void\n", secname,
								i, ds->variant, ds->data_observations.nb[i], ds->data_observations.y[i]);
						inla_error_general(msg);
					}
				}
			}
		}
	}
		break;

	case L_NBINOMIAL2:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.nb[i] <= 0.0 || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: NBinomial2 data[%1d] (nb,y) = (%g,%g) is void\n", secname,
							i, ds->data_observations.nb[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_NMIX:
	case L_NMIXNB:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				for (j = 0; j > -1; j++) {
					// printf("%d %d %g\n", i, j, ds->data_observations.nmix_y[j][i]);
					if (gsl_isnan(ds->data_observations.nmix_y[j][i]))
						break;
					if (ds->data_observations.nmix_y[j][i] < 0) {
						GMRFLib_sprintf(&msg, "%s: NMix data[%1d][%1d] (y) = (%g) is void\n", secname,
								i, j, ds->data_observations.nmix_y[j][i]);
						inla_error_general(msg);
					}
				}
				assert(ds->data_observations.y[i] < 0);	/* have to be void */
			}
		}
	}
		break;

	case L_ZEROINFLATEDBINOMIAL0:
	case L_ZEROINFLATEDBINOMIAL1:
	case L_ZEROINFLATEDBINOMIAL2:
	case L_ZEROINFLATEDBETABINOMIAL0:
	case L_ZEROINFLATEDBETABINOMIAL1:
	case L_ZEROINFLATEDBETABINOMIAL2:
	case L_BETABINOMIAL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.nb[i] <= 0.0 ||
				    ds->data_observations.y[i] > ds->data_observations.nb[i] || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: Binomial data[%1d] (nb,y) = (%g,%g) is void\n", secname,
							i, ds->data_observations.nb[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_BETABINOMIALNA:
	{
		// Since we're using a normal approximation, the data can be negative and also larger then nb
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.nb[i] <= 0.0 || ds->data_observations.betabinomialnb_scale[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: BetaBinomialNA data[%1d] (nb,scale,y) = (%g,%g,%g) is void\n", secname,
							i, ds->data_observations.nb[i],
							ds->data_observations.betabinomialnb_scale[i], ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_CBINOMIAL:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				if (ds->data_observations.cbinomial_n[i] <= 0.0 ||
				    ds->data_observations.cbinomial_k[i] <= 0.0 || ds->data_observations.y[i] > ds->data_observations.cbinomial_k[i]
				    || ds->data_observations.y[i] < 0.0) {
					GMRFLib_sprintf(&msg, "%s: CBinomial data[%1d] (k,n,y) = (%g,%g,%g) is void\n", secname, i,
							ds->data_observations.cbinomial_k[i], ds->data_observations.cbinomial_n[i],
							ds->data_observations.y[i]);
					inla_error_general(msg);
				}
			}
		}
	}
		break;

	case L_EXPONENTIALSURV:
	case L_GAMMASURV:
	case L_GAMMAJWSURV:
	case L_WEIBULLSURV:
	case L_WEIBULL_CURE:
	case L_LOGLOGISTICSURV:
	case L_QLOGLOGISTICSURV:
	case L_LOGNORMALSURV:
	case L_FMRISURV:
	case L_GOMPERTZSURV:
	{
		for (i = 0; i < mb->predictor_ndata; i++) {
			if (ds->data_observations.d[i]) {
				int event;
				double truncation, lower, upper, ttime;

				truncation = ds->data_observations.truncation[i];
				lower = ds->data_observations.lower[i];
				upper = ds->data_observations.upper[i];
				ttime = ds->data_observations.y[i];
				event = (int) (ds->data_observations.event[i]);

#define _SERR { GMRFLib_sprintf(&msg, "%s: survival data[%1d] (event,trunc,lower,upper,y) = (%g,%g,%g,%g,%g) is void\n", \
				secname, i, (double)event, truncation, lower,  upper,  ttime); inla_error_general(msg); }

				if (truncation < 0.0 || lower < 0.0 || upper < 0.0 || ttime < 0.0)
					_SERR;

				switch (event) {
				case SURV_EVENT_FAILURE:
				{
					if (ttime < truncation)
						_SERR;
				}
					break;
				case SURV_EVENT_RIGHT:
					if (lower < truncation)
						_SERR;
					break;
				case SURV_EVENT_LEFT:
				{
					if (upper < truncation)
						_SERR;
				}
					break;
				case SURV_EVENT_INTERVAL:
				{
					if (DMIN(lower, upper) < truncation || upper < lower)
						_SERR;
				}
					break;
				case SURV_EVENT_ININTERVAL:
				{
					if (DMIN(lower, upper) < truncation || upper < lower || ttime < lower || ttime > upper)
						_SERR;
				}
					break;
				default:
					_SERR;
					break;
				}
#undef _SERR
			}
		}
	}
		break;

	default:
		break;
	}

	/*
	 * common for all 
	 */
	ds->variant = iniparser_getint(ini, inla_string_join(secname, "VARIANT"), 0);
	if (mb->verbose) {
		printf("\t\tlikelihood.variant=[%1d]\n", ds->variant);
	}
	ds->data_observations.quantile = iniparser_getdouble(ini, inla_string_join(secname, "QUANTILE"), -1.0);
	if (mb->verbose) {
		if (ds->data_observations.quantile > 0.0 && ds->data_observations.quantile < 1.0) {
			printf("\t\tlikelihood.quantile=[%g]\n", ds->data_observations.quantile);
		}
	}

	/*
	 * read spesific options and define hyperparameters, if any.
	 */
	switch (ds->data_id) {
	case L_GAUSSIAN:
	{
		/*
		 * get options related to the gaussian 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_gaussian, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.log_prec_gaussian[0][0]);
			printf("\t\tfixed0=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision for the Gaussian observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision for the Gaussian observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_gaussian;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		// this one must be fixed.
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 999999.9);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 1);
		HYPER_NEW(ds->data_observations.log_prec_gaussian_offset, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision offset[%g]\n", ds->data_observations.log_prec_gaussian_offset[0][0]);
			printf("\t\tfixed1=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "NONE", NULL);
		if (!ds->data_fixed1) {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "FIXED1", "1");
		}
	}
		break;

	case L_AGAUSSIAN:
	{
		/*
		 * get options related to the agaussian 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_gaussian, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.log_prec_gaussian[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision for the AggGaussian observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision for the AggGaussian observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_gaussian;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_LOGNORMAL:
	case L_LOGNORMALSURV:
	{
		/*
		 * get options related to the lognormal
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_gaussian, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.log_prec_gaussian[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

			if (ds->data_id == L_LOGNORMAL) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision for the lognormal observations", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision for the lognormal observations", mb->ds);
			} else {
				mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision for the lognormalsurv observations", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision for the lognormalsurv observations", mb->ds);
			}
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_gaussian;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_GAUSSIANJW:
	{
		for (i = 0; i < 3; i++) {
			char *ctmp;

			GMRFLib_sprintf(&ctmp, "FIXED%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "INITIAL%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "PRIOR%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "HYPERID%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "PARAMETERS%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "to.theta%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "from.theta%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
		}

		ds->data_observations.gjw_beta = Calloc(3, double **);
		ds->data_nfixed = Calloc(3, int);
		ds->data_nprior = Calloc(3, Prior_tp);
		for (int i = 0; i < 3; i++) {
			char *ctmp;

			GMRFLib_sprintf(&ctmp, "INITIAL%1d", i);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), 0.0);	/* YES! */

			GMRFLib_sprintf(&ctmp, "FIXED%1d", i);
			ds->data_nfixed[i] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			if (!ds->data_nfixed[i] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}

			HYPER_NEW(ds->data_observations.gjw_beta[i], tmp);
			if (mb->verbose) {
				printf("\t\tbeta[%1d] = %g\n", i + 1, ds->data_observations.gjw_beta[i][0][0]);
				printf("\t\tfixed[%1d] = %1d\n", i, ds->data_nfixed[i]);
			}
			inla_read_priorN(mb, ini, sec, &(ds->data_nprior[i]), "GAUSSIAN-std", i, NULL);

			if (!ds->data_nfixed[i]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->data_nprior[i].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
				GMRFLib_sprintf(&ctmp, "beta%1d for GaussianJW observations", i);

				mb->theta_tag[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&msg, "%s-parameter%1d", secname, i);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[i].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[i].to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.gjw_beta[i];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);

				mb->theta_map[mb->ntheta] = map_identity;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;

				mb->ntheta++;
				ds->data_ntheta++;
			}
		}
	}
		break;

	case L_SIMPLEX:
	{
		/*
		 * get options related to the gaussian 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_simplex, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_prec[%g]\n", ds->data_observations.log_prec_simplex[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision for the Simplex observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision for the Simplex observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_simplex;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_POISSON:
	case L_XPOISSON:
	case L_CONTPOISSON:
		break;

	case L_QCONTPOISSON:
	{
		GMRFLib_ASSERT(ds->data_observations.quantile > 0.0 && ds->data_observations.quantile < 1.0, GMRFLib_EPARAMETER);
		ds->data_observations.qcontpoisson_func = inla_qcontpois_func(ds->data_observations.quantile, GMRFLib_CACHE_LEN);
	}
		break;

	case L_CENPOISSON:
	{
		/*
		 * get options related to the cenpoisson 
		 */
		ds->data_observations.cenpoisson_interval = Calloc(2, double);
		ctmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CENPOISSON.I"), NULL));
		if (inla_sread_doubles(ds->data_observations.cenpoisson_interval, 2, ctmp) == INLA_FAIL) {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "CENPOISSON.I", ctmp);
		}
		if (mb->verbose) {
			printf("\t\tcenpoisson censor-interval = [%g, %g]\n",
			       ds->data_observations.cenpoisson_interval[0], ds->data_observations.cenpoisson_interval[1]);
		}
		Free(ctmp);
	}
		break;

	case L_CENPOISSON2:
	{
		/*
		 * get options related to the cenpoisson2
		 */
	}
		break;

	case L_GPOISSON:
	{
		/*
		 * get options related to the gpoisson 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), -5.0);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.gpoisson_overdispersion, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_overdispersion[%g]\n", ds->data_observations.gpoisson_overdispersion[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log overdispersion for gpoisson", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Overdispersion for gpoisson", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.gpoisson_overdispersion;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * the 'p' parameter
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 1);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.gpoisson_p, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise p[%g]\n", ds->data_observations.gpoisson_p[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "normal", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Parameter p for gpoisson", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Parameter p for gpoisson", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.gpoisson_p;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_FMRI:
	case L_FMRISURV:
	{
		/*
		 */
		char *lname = (ds->data_id == L_FMRI ? GMRFLib_strdup(" fmri") : GMRFLib_strdup(" fmrisurv"));

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), -4.0);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.fmri_lprec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.fmri_lprec[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag2("Log precision for", mb->ds, lname);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag2("Precision for", mb->ds, lname);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.fmri_lprec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * the 'dof' parameter. must be fixed
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 1);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.fmri_ldof, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise dof[%g]\n", ds->data_observations.fmri_ldof[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		GMRFLib_ASSERT(ds->data_fixed1, GMRFLib_EPARAMETER);
		GMRFLib_ASSERT(ds->data_observations.fmri_ldof[0][0] == round(ds->data_observations.fmri_ldof[0][0]), GMRFLib_EPARAMETER);

		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "normal", NULL);
		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag2("DOF for", mb->ds, lname);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag2("DOF for", mb->ds, lname);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.fmri_ldof;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_POM:
	{
#define _Q(_x) log((_x)/(1.0-(_x)))			       /* we can still use this one for default initial values */
		/*
		 * get options for the POM model. note that all theta`K' for K > nclasses-1 are not used and must be fixed no
		 * matter their input.
		 */
		char *ctmp;
		int nclasses = ds->data_observations.pom_nclasses;
		ds->data_observations.pom_theta = Calloc(POM_MAXTHETA, double **);
		ds->data_nfixed = Calloc(POM_MAXTHETA, int);
		ds->data_nprior = Calloc(POM_MAXTHETA, Prior_tp);

		ds->data_observations.pom_fast_probit = iniparser_getboolean(ini, inla_string_join(secname, "POM.FAST.PROBIT"), 0);
		ctmp = iniparser_getstring(ini, inla_string_join(secname, "pom.cdf"), GMRFLib_strdup("DEFAULT"));
		if (!strcasecmp(ctmp, "DEFAULT")) {
			ds->data_observations.pom_cdf = POM_CDF_DEFAULT;
		} else if (!strcasecmp(ctmp, "LOGIT")) {
			ds->data_observations.pom_cdf = POM_CDF_LOGIT;
		} else if (!strcasecmp(ctmp, "PROBIT")) {
			ds->data_observations.pom_cdf = POM_CDF_PROBIT;
		} else {
			GMRFLib_ASSERT(ds->data_observations.pom_cdf == POM_CDF_DEFAULT ||
				       ds->data_observations.pom_cdf == POM_CDF_LOGIT ||
				       ds->data_observations.pom_cdf == POM_CDF_PROBIT, GMRFLib_EPARAMETER);
		}
		if (mb->verbose) {
			printf("\t\tPOM cdf = [%s]\n", (ds->data_observations.pom_cdf == POM_CDF_DEFAULT ? "default" :
							(ds->data_observations.pom_cdf == POM_CDF_LOGIT ? "logit" :
							 (ds->data_observations.pom_cdf == POM_CDF_PROBIT ? "probit" : "UNKNOWN"))));
			printf("\t\tPOM fast.probit = [%s]\n", (ds->data_observations.pom_fast_probit ? "Yes" : "No"));
		}

		if (mb->verbose) {
			printf("\t\tPOM nclasses = [%1d]\n", nclasses);
		}

		for (int count = 0; count < POM_MAXTHETA; count++) {
			char *ctmp = NULL;
			GMRFLib_sprintf(&ctmp, "INITIAL%1d", count);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), NAN);
			if (ISNAN(tmp)) {
				if (count == 0) {
					tmp = _Q(1.0 / (nclasses + 1.0));
				} else {
					if (count < nclasses) {
						tmp = log(_Q((count + 1.0) / (nclasses + 1.0)) - _Q(count / (nclasses + 1.0)));
					} else {
						tmp = 0.0;     /* not in use */
					}
				}
			}

			GMRFLib_sprintf(&ctmp, "FIXED%1d", count);
			ds->data_nfixed[count] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			if (count + 1 >= ds->data_observations.pom_nclasses) {
				ds->data_nfixed[count] = 1;
			}
			if (!ds->data_nfixed[count] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(ds->data_observations.pom_theta[count], tmp);

			if (mb->verbose) {
				printf("\t\tinitialise theta%1d[%g]\n", count, ds->data_observations.pom_theta[count][0][0]);
				printf("\t\tfixed%1d=[%1d]\n", count, ds->data_nfixed[count]);
			}

			if (count == 0) {
				inla_read_priorN(mb, ini, sec, &(ds->data_nprior[count]), "DIRICHLET", count, NULL);
				assert(ds->data_nprior[count].id == P_DIRICHLET);
				ds->data_nprior[count].parameters[1] = nclasses;
				ds->data_nprior[count].parameters[2] = ds->data_observations.pom_cdf;
			} else {
				inla_read_priorN(mb, ini, sec, &(ds->data_nprior[count]), "NONE", count, NULL);
				assert(ds->data_nprior[count].id == P_NONE);
			}

			/*
			 * add theta 
			 */
			if (!ds->data_nfixed[count]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->data_nprior[count].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				GMRFLib_sprintf(&ctmp, "theta%1d for POM", count + 1);
				mb->theta_tag[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&ctmp, "theta%1d for POM", count + 1);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&msg, "%s-parameter%1d", secname, count + 1);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[count].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[count].to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.pom_theta[count];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_identity;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ds->data_ntheta++;
			}
		}

		int all_fixed = 1, all_nonfixed = 1;
		for (int count = 0; count < nclasses - 1; count++) {
			all_fixed = (all_fixed && (ds->data_nfixed[count] == 1));
			all_nonfixed = (all_nonfixed && (ds->data_nfixed[count] == 0));
		}
		if (all_fixed == 0 && all_nonfixed == 0) {
			char *msg;
			GMRFLib_sprintf(&msg, "Hyperparameters of the POM model must either be all fixed, or all non-fixed.");
			inla_error_general(msg);
			exit(1);
		}
#undef _Q
	}
		break;

	case L_CIRCULAR_NORMAL:
	{
		/*
		 * get options related to the circular normal
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_circular_normal, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision parameter[%g]\n", ds->data_observations.log_prec_circular_normal[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision parameter for the Circular Normal observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision parameter for the Circular Normal observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_circular_normal;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_WRAPPED_CAUCHY:
	{
		/*
		 * get options related to the circular cauchy
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_wrapped_cauchy, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision parameter[%g]\n", ds->data_observations.log_prec_wrapped_cauchy[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision parameter for the Wrapped Cauchy observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision parameter for the Wrapped Cauchy observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_wrapped_cauchy;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_TWEEDIE:
	{
		/*
		 * get options related to the tweedie
		 */
		dtweedie_init_cache();			       // will only initialize once
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 0.0);	/* yes! */
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.tweedie_p_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise p_intern[%g]\n", ds->data_observations.tweedie_p_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("p_intern parameter for Tweedie", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("p parameter for Tweedie", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.tweedie_p_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_interval;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			double *AB = Calloc(2, double);
			AB[0] = 1.0;
			AB[1] = 2.0;
			mb->theta_map_arg[mb->ntheta] = (void *) AB;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * the 'dispersion' parameter
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.tweedie_phi_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise phi_intern[%g]\n", ds->data_observations.tweedie_phi_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "loggamma", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log dispersion parameter for Tweedie", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Dispersion parameter for Tweedie", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.tweedie_phi_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_GP:
	case L_DGP:
	{
		/*
		 * get options related to the gp/dgp
		 */
		GMRFLib_ASSERT(ds->data_observations.quantile > 0.0 && ds->data_observations.quantile < 1.0, GMRFLib_EPARAMETER);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), -3.0);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.gp_intern_tail, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise internal_tail[%g]\n", ds->data_observations.gp_intern_tail[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "PCGEVTAIL", NULL);
		ds->data_observations.gp_tail_interval = Calloc(2, double);
		if (ds->data_prior.id == P_PC_GEVTAIL) {
			ds->data_observations.gp_tail_interval[0] = ds->data_prior.parameters[1];
			ds->data_observations.gp_tail_interval[1] = ds->data_prior.parameters[2];
		} else {
			// used a fixed interval then
			ds->data_observations.gp_tail_interval[0] = 0.0;
			ds->data_observations.gp_tail_interval[1] = 0.5;
		}

		if (DMIN(ds->data_observations.gp_tail_interval[0], ds->data_observations.gp_tail_interval[1]) < 0.0 ||
		    DMAX(ds->data_observations.gp_tail_interval[0], ds->data_observations.gp_tail_interval[1]) >= 1.0 ||
		    ds->data_observations.gp_tail_interval[0] >= ds->data_observations.gp_tail_interval[1]) {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "TAIL.INTERVAL", ctmp);
		}
		if (mb->verbose) {
			printf("\t\tgp.tail.interval [%g %g]\n", ds->data_observations.gp_tail_interval[0],
			       ds->data_observations.gp_tail_interval[1]);
		}

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

			if (ds->data_id == L_GP) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("Intern tail parameter for the gp observations", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Tail parameter for the gp observations", mb->ds);
			} else {
				mb->theta_tag[mb->ntheta] = inla_make_tag("Intern tail parameter for the dgp observations", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Tail parameter for the dgp observations", mb->ds);
			}

			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.gp_intern_tail;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_interval;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) (ds->data_observations.gp_tail_interval);
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_IID_GAMMA:
	{
		/*
		 * get options related to the iid_gamma
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 0.0);	/* yes! */
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.iid_gamma_log_shape, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_shape[%g]\n", ds->data_observations.iid_gamma_log_shape[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log shape parameter for iid-gamma", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Shape parameter for iid-gamma", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.iid_gamma_log_shape;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * the 'rate' parameter
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.iid_gamma_log_rate, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_rate[%g]\n", ds->data_observations.iid_gamma_log_rate[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "loggamma", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log rate parameter for iid-gamma", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Rate parameter for iid-gamma", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.iid_gamma_log_rate;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_IID_LOGITBETA:
	{
		/*
		 * get options related to the iid_logitbeta. first log(a)
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 0.0);	/* yes! */
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.iid_logitbeta_log_a, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_a[%g]\n", ds->data_observations.iid_logitbeta_log_a[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log a parameter for iid-beta", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("a parameter for iid-beta", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.iid_logitbeta_log_a;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * log(b)
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.iid_logitbeta_log_b, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_b[%g]\n", ds->data_observations.iid_logitbeta_log_b[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "loggamma", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log b parameter for iid-beta", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("b parameter for iid-beta", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.iid_logitbeta_log_b;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_LOGGAMMA_FRAILTY:
	{
		/*
		 * get options related to the loggammafrailty
		 */

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_loggamma_frailty, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.log_prec_loggamma_frailty[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log precision for the gamma frailty", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("precision for the gamma frailty", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_loggamma_frailty;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_LOGISTIC:
	{
		/*
		 * get options related to the logistic 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_logistic, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.log_prec_logistic[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log precision for the logistic observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("precision for the logistic observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_logistic;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_SKEWNORMAL:
	{
		/*
		 * get options related to the skew-normal
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 0.0);	/* yes! */
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.sn_lprec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.sn_lprec[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log precision for skew-normal observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("precision for skew-normal observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.sn_lprec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.sn_skew, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise intern_skewness[%g]\n", ds->data_observations.sn_skew[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "PCSN", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Intern skewness for skew-normal observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Skewness for skew-normal observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);
			mb->theta[mb->ntheta] = ds->data_observations.sn_skew;

			double *skewmax = Calloc(1, double);
			*skewmax = GMRFLib_SN_SKEWMAX;	       /* yes, this is correct */

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_phi;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) skewmax;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_GEV:
	{
		/*
		 * get options related to the gev
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "gev.scale.xi"), 0.01);	/* yes! */
		assert(tmp > 0.0);
		ds->data_observations.gev_scale_xi = tmp;
		if (mb->verbose) {
			printf("\t\tgev.scale.xi [%g]\n", ds->data_observations.gev_scale_xi);
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 0.0);	/* YES! */
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_gev, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.log_prec_gev[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log precision for GEV observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("precision for GEV observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_gev;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * the 'xi' parameter/ the gev-parameter. we need a little care, as the user see 'xi' while we work internally with 'xi/xi.scale'
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0) / ds->data_observations.gev_scale_xi;	/* scale
																	 * here */
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			// tmp = mb->theta_file[mb->theta_counter_file++]/ds->data_observations.gev_scale_xi; /* scale here */
			tmp = mb->theta_file[mb->theta_counter_file++];	/* DO NOT scale here */
		}
		HYPER_NEW(ds->data_observations.xi_gev, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise gev-parameter[%g] (scaled with scale.xi=[%g])\n", ds->data_observations.xi_gev[0][0],
			       ds->data_observations.gev_scale_xi);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "GAUSSIAN-a", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("tail parameter for GEV observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("tail parameter for GEV observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.xi_gev;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity_scale;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) &(ds->data_observations.gev_scale_xi);
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_BGEV:
	{
		/*
		 * get options related to the bgev
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "bgev.q.location"), 0.5);
		assert(tmp > 0.0 && tmp < 1.0);
		ds->data_observations.bgev_qlocation = tmp;
		if (mb->verbose) {
			printf("\t\tbgev.q.location [%g]\n", ds->data_observations.bgev_qlocation);
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "bgev.q.spread"), 0.25);
		assert(tmp > 0.0 && tmp < 1.0);
		ds->data_observations.bgev_qspread = tmp;
		if (mb->verbose) {
			printf("\t\tbgev.q.spread [%g]\n", ds->data_observations.bgev_qspread);
		}

		ctmp = iniparser_getstring(ini, inla_string_join(secname, "bgev.q.mix"), GMRFLib_strdup("0.10 0.20"));
		ds->data_observations.bgev_qmix = Calloc(2, double);
		if (inla_sread_doubles(ds->data_observations.bgev_qmix, 2, ctmp) == INLA_FAIL ||
		    DMIN(ds->data_observations.bgev_qmix[0], ds->data_observations.bgev_qmix[1]) <= 0.0 ||
		    DMAX(ds->data_observations.bgev_qmix[0], ds->data_observations.bgev_qmix[1]) >= 1.0 ||
		    ds->data_observations.bgev_qmix[0] >= ds->data_observations.bgev_qmix[1]) {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "BGEV.Q.MIX", ctmp);
		}
		if (mb->verbose) {
			printf("\t\tbgev.q.mix [%g %g]\n", ds->data_observations.bgev_qmix[0], ds->data_observations.bgev_qmix[1]);
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "bgev.beta.ab"), 5);
		ds->data_observations.bgev_beta_ab = tmp;
		if (mb->verbose) {
			printf("\t\tbgev.beta.ab [%g]\n", ds->data_observations.bgev_beta_ab);
		}

		/*
		 * mark all as read 
		 */
		for (i = 0; i < BGEV_MAXTHETA + 2; i++) {
			char *ctmp;

			GMRFLib_sprintf(&ctmp, "FIXED%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "INITIAL%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "PRIOR%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "HYPERID%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "PARAMETERS%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "to.theta%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);

			GMRFLib_sprintf(&ctmp, "from.theta%1d", i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
		}

		/*
		 * this gives the number of betas in the spread and tail
		 */
		assert(BGEV_MAXTHETA == 10);		       /* otherwise change below... */
		ds->data_observations.bgev_nbetas[0] = ds->data_observations.attr[0];
		ds->data_observations.bgev_nbetas[1] = ds->data_observations.attr[1];
		int nbetas = ds->data_observations.bgev_nbetas[0] + ds->data_observations.bgev_nbetas[1];

		ds->data_observations.bgev_betas = Calloc(BGEV_MAXTHETA, double **);
		ds->data_nfixed = Calloc(BGEV_MAXTHETA + 2, int);	/* +2 for spread and tail */
		ds->data_nprior = Calloc(BGEV_MAXTHETA + 2, Prior_tp);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 0.0);
		ds->data_nfixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_nfixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.bgev_log_spread, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log.spread[%g]\n", ds->data_observations.bgev_log_spread[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_nfixed[0]);
		}
		inla_read_priorN(mb, ini, sec, &(ds->data_nprior[0]), "LOGGAMMA", 0, NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_nfixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_nprior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log spread for BGEV observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("spread for BGEV observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[0].to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.bgev_log_spread;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		ds->data_nfixed[1] = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_nfixed[1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.bgev_intern_tail, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise internal tail[%g]\n", ds->data_observations.bgev_intern_tail[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_nfixed[1]);
		}
		inla_read_priorN(mb, ini, sec, &(ds->data_nprior[1]), "PCGEVTAIL", 1, NULL);
		ds->data_observations.bgev_tail_interval = Calloc(2, double);
		if (ds->data_nprior[1].id == P_PC_GEVTAIL) {
			ds->data_observations.bgev_tail_interval[0] = ds->data_nprior[1].parameters[1];
			ds->data_observations.bgev_tail_interval[1] = ds->data_nprior[1].parameters[2];
		} else {
			// used a fixed interval then
			ds->data_observations.bgev_tail_interval[0] = 0.0;
			ds->data_observations.bgev_tail_interval[1] = 0.5;
		}

		if (DMIN(ds->data_observations.bgev_tail_interval[0], ds->data_observations.bgev_tail_interval[1]) < 0.0 ||
		    DMAX(ds->data_observations.bgev_tail_interval[0], ds->data_observations.bgev_tail_interval[1]) >= 1.0 ||
		    ds->data_observations.bgev_tail_interval[0] >= ds->data_observations.bgev_tail_interval[1]) {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "BGEV.TAIL.INTERVAL", ctmp);
		}
		if (mb->verbose) {
			printf("\t\tbgev.tail.interval [%g %g]\n", ds->data_observations.bgev_tail_interval[0],
			       ds->data_observations.bgev_tail_interval[1]);
		}

		/*
		 * add theta 
		 */
		if (!ds->data_nfixed[1]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_nprior[1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern tail for BGEV observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("tail for BGEV observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[1].to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.bgev_intern_tail;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_interval;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) (ds->data_observations.bgev_tail_interval);
			mb->ntheta++;
			ds->data_ntheta++;
		}

		for (i = 0; i < nbetas; i++) {
			char *ctmp;
			int ii, idx = i + 2;

			GMRFLib_sprintf(&ctmp, "INITIAL%1d", idx);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), 0.0);	/* YES! */

			GMRFLib_sprintf(&ctmp, "FIXED%1d", idx);
			ds->data_nfixed[idx] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			if (!ds->data_nfixed[idx] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}

			if (i < ds->data_observations.bgev_nbetas[0]) {
				// log-spread part, as normal
				HYPER_NEW(ds->data_observations.bgev_betas[i], tmp);
				if (mb->verbose) {
					printf("\t\tbetas[%1d] (spread) = %g\n", i, ds->data_observations.bgev_betas[i][0][0]);
					printf("\t\tfixed[%1d] = %1d\n", i, ds->data_nfixed[i]);
				}
			} else {
				// tail part
				HYPER_NEW(ds->data_observations.bgev_betas[i], tmp);
				if (mb->verbose) {
					printf("\t\tbetas[%1d] (tail) = %g\n", i, ds->data_observations.bgev_betas[i][0][0]);
					printf("\t\tfixed[%1d]= %1d\n", i, ds->data_nfixed[i]);
				}
			}

			inla_read_priorN(mb, ini, sec, &(ds->data_nprior[idx]), "GAUSSIAN-std", idx, NULL);

			if (!ds->data_nfixed[idx]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->data_nprior[idx].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
				if (i < ds->data_observations.bgev_nbetas[0]) {
					ii = i + 1;
					GMRFLib_sprintf(&ctmp, "beta%1d (spread) for BGEV observations", ii);
				} else {
					ii = i + 1;
					GMRFLib_sprintf(&ctmp, "beta%1d (tail) for BGEV observations", ii);
				}

				mb->theta_tag[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&msg, "%s-parameter%1d", secname, i);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[idx].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[idx].to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.bgev_betas[i];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);

				if (i < ds->data_observations.bgev_nbetas[0]) {
					// spread
					mb->theta_map[mb->ntheta] = map_identity;
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
					mb->theta_map_arg[mb->ntheta] = NULL;
				} else {
					// tail
					mb->theta_map[mb->ntheta] = map_identity;
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
					mb->theta_map_arg[mb->ntheta] = (void *) NULL;
				}

				mb->ntheta++;
				ds->data_ntheta++;
			}
		}

	}
		break;

	case L_GAMMA:
	case L_GAMMASURV:
	{
		/*
		 * get options related to the gamma
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 0.0);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.gamma_log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise precision_intern[%g]\n", ds->data_observations.gamma_log_prec[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Intern precision-parameter for the Gamma observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision parameter for the Gamma observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.gamma_log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_GAMMAJW:
	case L_GAMMAJWSURV:
	{
		/*
		 * get options related to the gammajw
		 */
	}
		break;

	case L_GAMMACOUNT:
	{
		/*
		 * get options related to the gammacount
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 0.0);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.gammacount_log_alpha, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_alpha[%g]\n", ds->data_observations.gammacount_log_alpha[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log-alpha parameter for Gammacount observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Alpha parameter for Gammacount observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.gammacount_log_alpha;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_QKUMAR:
	{
		/*
		 * get options related to the qkumar-distribution
		 */
		GMRFLib_ASSERT(ds->data_observations.quantile > 0.0 && ds->data_observations.quantile < 1.0, GMRFLib_EPARAMETER);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 0.0);	/* yes! */
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.qkumar_log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.qkumar_log_prec[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log precision for qkumar observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("precision for qkumar observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.qkumar_log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_prec_qkumar;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_QLOGLOGISTIC:
	case L_QLOGLOGISTICSURV:
	case L_LOGLOGISTIC:
	case L_LOGLOGISTICSURV:
	{

		if (ds->data_id == L_QLOGLOGISTIC || ds->data_id == L_QLOGLOGISTICSURV) {
			GMRFLib_ASSERT(ds->data_observations.quantile > 0.0 && ds->data_observations.quantile < 1.0, GMRFLib_EPARAMETER);
		}
		assert(ds->variant == 0 || ds->variant == 1);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 0.0);	/* yes! */
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.alpha_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log(alpha) [%g]\n", ds->data_observations.alpha_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);
		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log alpha for loglogistic observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha for loglogistic observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.alpha_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_BETA:
	{
		/*
		 * get options related to the beta
		 */
		ds->data_observations.beta_censor_value = iniparser_getdouble(ini, inla_string_join(secname, "BETA.CENSOR.VALUE"), 0.0);
		if (mb->verbose) {
			printf("\t\tbcensor.value [%g]\n", ds->data_observations.beta_censor_value);
		}

		if (beta_delayed_error && ds->data_observations.beta_censor_value == 0.0) {
			GMRFLib_sprintf(&msg,
					"%s: Beta data: %1d observations are either 0 or 1,\n\t\tbut then you need to enable censoring, see inla.doc('^beta$')\n",
					secname, beta_delayed_error);
			inla_error_general(msg);
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 0.0);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.beta_precision_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise precision_intern[%g]\n", ds->data_observations.beta_precision_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern precision-parameter for the beta observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("precision parameter for the beta observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.beta_precision_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_BETABINOMIAL:
	{
		/*
		 * get options related to the betabinomial
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 0.0);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.betabinomial_overdispersion_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise overdispersion_intern[%g]\n", ds->data_observations.betabinomial_overdispersion_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern overdispersion for the betabinomial observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("overdispersion for the betabinomial observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.betabinomial_overdispersion_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_BETABINOMIALNA:
	{
		/*
		 * get options related to the betabinomialna
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 0.0);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.betabinomial_overdispersion_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise overdispersion_intern[%g]\n", ds->data_observations.betabinomial_overdispersion_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern overdispersion for the betabinomialna observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("overdispersion for the betabinomialna observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.betabinomial_overdispersion_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_NBINOMIAL:
	{
		/*
		 * get options related to the negative binomial
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), log(10.0));
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_size, tmp);
		assert(ds->variant == 0 || ds->variant == 1 || ds->variant == 2);
		if (mb->verbose) {
			printf("\t\tinitialise log_size[%g]\n", ds->data_observations.log_size[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
			printf("\t\tuse parameterization variant=[%1d]; see doc for details\n", ds->variant);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			if (ds->variant == 0 || ds->variant == 1 || ds->variant == 2) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("log size for the nbinomial observations (1/overdispersion)", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("size for the nbinomial observations (1/overdispersion)", mb->ds);
			} else {
				assert(0 == 1);
			}
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_size;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_CENNBINOMIAL2:
	{
		/*
		 * get options related to the cen negative binomial 2
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), log(10.0));
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_size, tmp);
		assert(ds->variant == 0 || ds->variant == 1 || ds->variant == 2);
		if (mb->verbose) {
			printf("\t\tinitialise log_size[%g]\n", ds->data_observations.log_size[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
			printf("\t\tuse parameterization variant=[%1d]; see doc for details\n", ds->variant);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			if (ds->variant == 0 || ds->variant == 1 || ds->variant == 2) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("log size for the cennbinomial2 observations (1/overdispersion)", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("size for the cennbinomial2 observations (1/overdispersion)", mb->ds);
			} else {
				assert(0 == 1);
			}
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_size;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZEROINFLATEDNBINOMIAL0:
	case L_ZEROINFLATEDNBINOMIAL1:
	{
		/*
		 * get options related to the zeroinflated negative binomial_0/1
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), log(10.0));
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_size, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_size[%g]\n", ds->data_observations.log_size[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log size for nbinomial zero-inflated observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("size for nbinomial zero-inflated observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_size;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * the zeroinflation parameter 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), -1.0);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.prob_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise prob_intern[%g]\n", ds->data_observations.prob_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			if (ds->data_id == L_ZEROINFLATEDNBINOMIAL0) {
				mb->theta_tag[mb->ntheta] =
				    inla_make_tag("intern zero-probability parameter for zero-inflated nbinomial_0", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated nbinomial_0", mb->ds);
			} else {
				mb->theta_tag[mb->ntheta] =
				    inla_make_tag("intern zero-probability parameter for zero-inflated nbinomial_1", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated nbinomial_1", mb->ds);
			}
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.prob_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZEROINFLATEDBETABINOMIAL0:
	case L_ZEROINFLATEDBETABINOMIAL1:
	{
		/*
		 * get options related to the zeroinflated beta binomial_0/1
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), log(10.0));
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zeroinflated_rho_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise rho_intern[%g]\n", ds->data_observations.zeroinflated_rho_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("rho_intern for zero-inflated betabinomial", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("rho for zero-inflated betabinomial", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.zeroinflated_rho_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * the zeroinflation parameter 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), -1.0);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.prob_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise prob_intern[%g]\n", ds->data_observations.prob_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			if (ds->data_id == L_ZEROINFLATEDBETABINOMIAL0) {
				mb->theta_tag[mb->ntheta] =
				    inla_make_tag("intern zero-probability parameter for zero-inflated betabinomial_0", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated betabinomial_0", mb->ds);
			} else {
				mb->theta_tag[mb->ntheta] =
				    inla_make_tag("intern zero-probability parameter for zero-inflated betabinomial_1", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated betabinomial_1", mb->ds);
			}
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.prob_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZEROINFLATEDNBINOMIAL1STRATA2:
	{
		/*
		 * get options related to the zeroinflated negative binomial_0/1, strata2
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), log(10.0));
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_size, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_size[%g]\n", ds->data_observations.log_size[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log size for zero-inflated nbinomial_strata2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("size for zero-inflated nbinomial_strata2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_size;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * THERE are up to STRATA_MAXTHETA of the probs, called prob 1... 10 
		 */
		ds->data_observations.probN_intern = Calloc(STRATA_MAXTHETA, double **);
		ds->data_nfixed = Calloc(STRATA_MAXTHETA, int);
		ds->data_nprior = Calloc(STRATA_MAXTHETA, Prior_tp);

		for (int count = 0; count < STRATA_MAXTHETA; count++) {
			char *ctmp = NULL;

			/*
			 * the zeroinflation prob-parameter
			 */
			GMRFLib_sprintf(&ctmp, "INITIAL%1d", count + 1);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), -1.0);

			GMRFLib_sprintf(&ctmp, "FIXED%1d", count + 1);
			ds->data_nfixed[count] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			if (!ds->data_nfixed[count] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(ds->data_observations.probN_intern[count], tmp);

			if (mb->verbose) {
				printf("\t\tinitialise prob%1d_intern[%g]\n", count + 1, ds->data_observations.probN_intern[count][0][0]);
				printf("\t\tfixed%1d=[%1d]\n", count + 1, ds->data_nfixed[count]);
			}
			inla_read_priorN(mb, ini, sec, &(ds->data_nprior[count]), "GAUSSIAN-std", count + 1, NULL);

			/*
			 * add theta 
			 */
			if (!ds->data_nfixed[count]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->data_nprior[count].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				GMRFLib_sprintf(&ctmp, "intern zero-probability%1d for zero-inflated nbinomial_strata2", count + 1);
				mb->theta_tag[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&ctmp, "zero-probability%1d for zero-inflated nbinomial_strata2", count + 1);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&msg, "%s-parameter%1d", secname, count + 1);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[count].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[count].to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.probN_intern[count];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_probability;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ds->data_ntheta++;
			}
		}
	}
		break;

	case L_ZEROINFLATEDNBINOMIAL1STRATA3:
	{
		/*
		 * get options related to the zeroinflated negative binomial_0/1, strata3
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), log(10.0));
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.prob_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise prob_intern[%g]\n", ds->data_observations.prob_intern[0][0]);
			printf("\t\tfixed0=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern zero-probability for zero-inflated nbinomial_strata3", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("zero-probability for zero-inflated nbinomial_strata3", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.prob_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * THERE are up to STRATA_MAXTHETA of the probs, called prob 1... 10 
		 */
		ds->data_observations.log_sizes = Calloc(STRATA_MAXTHETA, double **);
		ds->data_nfixed = Calloc(STRATA_MAXTHETA, int);
		ds->data_nprior = Calloc(STRATA_MAXTHETA, Prior_tp);

		for (int count = 0; count < STRATA_MAXTHETA; count++) {
			char *ctmp = NULL;

			/*
			 * the zeroinflation prob-parameter
			 */
			GMRFLib_sprintf(&ctmp, "INITIAL%1d", count + 1);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), -1.0);

			GMRFLib_sprintf(&ctmp, "FIXED%1d", count + 1);
			ds->data_nfixed[count] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			if (!ds->data_nfixed[count] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(ds->data_observations.log_sizes[count], tmp);

			if (mb->verbose) {
				printf("\t\tinitialise log_size%1d[%g]\n", count + 1, ds->data_observations.log_sizes[count][0][0]);
				printf("\t\tfixed%1d=[%1d]\n", count + 1, ds->data_nfixed[count]);
			}
			inla_read_priorN(mb, ini, sec, &(ds->data_nprior[count]), "LOGGAMMA", count + 1, NULL);

			/*
			 * add theta 
			 */
			if (!ds->data_nfixed[count]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->data_nprior[count].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				GMRFLib_sprintf(&ctmp, "log_size%1d for zero-inflated nbinomial_strata3", count + 1);
				mb->theta_tag[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&ctmp, "size%1d for zero-inflated nbinomial_strata3", count + 1);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&msg, "%s-parameter%1d", secname, count + 1);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[count].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[count].to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.log_sizes[count];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_exp;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ds->data_ntheta++;
			}
		}
	}
		break;

	case L_ZEROINFLATEDNBINOMIAL2:
	{
		/*
		 * get options related to the zeroinflated negative binomial_2
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), log(10.0));
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_size, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_size[%g]\n", ds->data_observations.log_size[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log size for nbinomial zero-inflated observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("size for nbinomial zero-inflated observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_size;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		/*
		 * the zeroinflation parameter; the parameter alpha (see the documentation) 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), log(2.0));
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zeroinflated_alpha_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha_intern[%g]\n", ds->data_observations.zeroinflated_alpha_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "gaussian-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("parameter alpha.intern for zero-inflated nbinomial2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("parameter alpha for zero-inflated nbinomial2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.zeroinflated_alpha_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_T:
	{
		/*
		 * get options related to the t
		 */

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_prec_t, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", ds->data_observations.log_prec_t[0][0]);
			printf("\t\tfixed0=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA", NULL);

		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("log precision for the student-t observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("precision for the student-t observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_prec_t;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
		/*
		 * dof 
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 3.0);
		if (ISINF(tmp) || ISNAN(tmp)) {
			char *msg;
			GMRFLib_sprintf(&msg, "Initial value for dof_internal is void [%g]\n", tmp);
			inla_error_general(msg);
			exit(1);
		}
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.dof_intern_t, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise dof_intern_t[%g]\n", ds->data_observations.dof_intern_t[0][0]);
			printf("\t\tfixed1=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "normal", NULL);

		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("dof_intern for student-t", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("degrees of freedom for student-t", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.dof_intern_t;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_dof;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_TSTRATA:
	{
		/*
		 * get options related to the tstrata
		 */
		int k;

		ds->data_nprior = Calloc(TSTRATA_MAXTHETA, Prior_tp);
		ds->data_nfixed = Calloc(TSTRATA_MAXTHETA, int);

		/*
		 * check how many strata we have 
		 */
		int nstrata = 0;
		for (k = 0; k < mb->predictor_ndata; k++) {
			if (ds->data_observations.d[k]) {
				nstrata = IMAX(nstrata, (int) ds->data_observations.strata_tstrata[k]);
			}
		}
		nstrata++;
		assert(nstrata <= TSTRATA_MAXTHETA - 1);

		/*
		 * dof = theta0
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 3.0);
		if (ISINF(tmp) || ISNAN(tmp)) {
			char *msg;
			GMRFLib_sprintf(&msg, "Initial value for dof_internal is void [%g]\n", tmp);
			inla_error_general(msg);
			exit(1);
		}
		ds->data_nfixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_nfixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.dof_intern_tstrata, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise dof_intern_tstrata[%g]\n", ds->data_observations.dof_intern_tstrata[0][0]);
			printf("\t\tfixed0=[%1d]\n", ds->data_nfixed[0]);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_nprior[0]), "normal", NULL);

		if (!ds->data_nfixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_nprior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("dof_intern for tstrata", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("degrees of freedom for tstrata", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[0].to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.dof_intern_tstrata;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_dof5;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		ds->data_observations.log_prec_tstrata = Calloc(TSTRATA_MAXTHETA - 1, double **);

		for (k = 1; k < TSTRATA_MAXTHETA; k++) {

			char *ctmp = NULL, *pri = NULL, *par = NULL, *from_theta = NULL, *to_theta = NULL, *hyperid = NULL;

			GMRFLib_sprintf(&pri, "PRIOR%1d", k);
			GMRFLib_sprintf(&par, "PARAMETERS%1d", k);
			GMRFLib_sprintf(&from_theta, "FROM.THETA%1d", k);
			GMRFLib_sprintf(&to_theta, "TO.THETA%1d", k);
			GMRFLib_sprintf(&hyperid, "HYPERID%1d", k);
			inla_read_prior_generic(mb, ini, sec, &(ds->data_nprior[k]), pri, par, from_theta, to_theta, hyperid, "normal", NULL);

			GMRFLib_sprintf(&ctmp, "FIXED%1d", k);
			ds->data_nfixed[k] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			/*
			 * if above number of stata, then its fixed for sure! 
			 */
			if (k > nstrata) {
				ds->data_nfixed[k] = 1;
			}
			GMRFLib_sprintf(&ctmp, "INITIAL%1d", k);
			double initial = iniparser_getdouble(ini, inla_string_join(secname, ctmp), G.log_prec_initial);

			if (!ds->data_nfixed[k] && mb->reuse_mode) {
				initial = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(ds->data_observations.log_prec_tstrata[k - 1], initial);	/* yes, its a -1, prec0, prec1, etc... */
			if (mb->verbose) {
				printf("\t\tinitialise log_prec_tstrata[%1d][%g]\n", ds->data_nfixed[k],
				       ds->data_observations.log_prec_tstrata[k - 1][0][0]);
				printf("\t\tfixed%1d=[%1d]\n", k, ds->data_nfixed[k]);
			}

			if (!ds->data_nfixed[k]) {

				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->data_nprior[k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				mb->theta_tag[mb->ntheta] = inla_make_tag("Log prec for tstrata strata", k - 1);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Prec tstrata strata", k - 1);
				GMRFLib_sprintf(&msg, "%s-parameter%1d", secname, k);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[k].to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.log_prec_tstrata[k - 1];	/* yes its a -1 */
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_precision;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ds->data_ntheta++;
			}

			Free(pri);
			Free(par);
			Free(from_theta);
			Free(to_theta);
			Free(hyperid);
			Free(ctmp);
		}
	}
		break;

	case L_STOCHVOL:
	{
		/*
		 * get options related to the stochvol; the log-offset in the variance
		 */
		double initial_value = 500.0;

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 1);	/* yes, default fixed */
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_offset_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log.offset[%g]\n", ds->data_observations.log_offset_prec[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log offset precision for stochvol", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Offset precision for stochvol", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_offset_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_STOCHVOL_SN:
	{
		/*
		 * get options related to the stochvol_sn
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 0.00123456789);	/* yes! */
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.sn_skew, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise intern skewness[%g]\n", ds->data_observations.sn_skew[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "PCSN", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Intern skewness for stochvol_sn observations", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Skewness for stochvol_sn observations", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);
			mb->theta[mb->ntheta] = ds->data_observations.sn_skew;

			double *skewmax = Calloc(1, double);
			*skewmax = GMRFLib_SN_SKEWMAX;	       /* yes, this is correct */

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_phi;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) skewmax;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		double initial_value = 500.0;
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), initial_value);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 1);	/* yes, default fixed */
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.log_offset_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_offset_prec[%g]\n", ds->data_observations.log_offset_prec[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Log offset precision for stochvol_sn", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Offset precision for stochvol_sn", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.log_offset_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_STOCHVOL_T:
	{
		/*
		 * get options related to the stochvol_t
		 */
		double initial_value = 3.0;

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.dof_intern_svt, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise dof_intern[%g]\n", ds->data_observations.dof_intern_svt[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "GAUSSIAN", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("dof_intern for stochvol student-t", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("degrees of freedom for stochvol student-t", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.dof_intern_svt;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_dof;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_STOCHVOL_NIG:
	{
		/*
		 * get options related to the stochvol_nig
		 *
		 * first parameter is skew, second is shape
		 */
		double initial0 = 0.0, initial1 = 1.0;

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), initial0);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.skew_intern_svnig, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise skew_intern_svnig[%g]\n", ds->data_observations.skew_intern_svnig[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "GAUSSIAN", NULL);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), initial1);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.shape_intern_svnig, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise shape_intern_snvig[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "GAUSSIAN", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("skewness_param_intern for stochvol-nig", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("skewness parameter for stochvol-nig", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.skew_intern_svnig;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("shape_param_intern for stochvol-nig", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("shape parameter for stochvol-nig", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.shape_intern_svnig;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_shape_svnig;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
		ds->data_ntheta = (ds->data_fixed0 ? 0 : 1) + (ds->data_fixed1 ? 0 : 1);
	}
		break;

	case L_WEIBULL:
	case L_WEIBULLSURV:
	{
		/*
		 * get options related to the weibull
		 */
		double initial_value = 0.0;

		GMRFLib_ASSERT(ds->variant == 0 || ds->variant == 1, GMRFLib_EPARAMETER);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.alpha_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha_intern[%g]\n", ds->data_observations.alpha_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA-ALPHA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			if (ds->data_id == L_WEIBULL) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("alpha_intern for weibull", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha parameter for weibull", mb->ds);
			} else {
				mb->theta_tag[mb->ntheta] = inla_make_tag("alpha_intern for weibullsurv", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha parameter for weibullsurv", mb->ds);
			}
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.alpha_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_alpha_weibull;	/* alpha = exp(alpha.intern) */
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_GOMPERTZ:
	case L_GOMPERTZSURV:
	{
		/*
		 * get options related to the gompertz
		 */
		double initial_value = 0.0;

		GMRFLib_ASSERT(ds->variant == 0 || ds->variant == 1, GMRFLib_EPARAMETER);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.alpha_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha_intern[%g]\n", ds->data_observations.alpha_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "LOGGAMMA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			if (ds->data_id == L_GOMPERTZ) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("alpha_intern for Gompertz", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha parameter for Gompertz", mb->ds);
			} else {
				mb->theta_tag[mb->ntheta] = inla_make_tag("alpha_intern for Gompertz-surv", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha parameter for Gompertz-surv", mb->ds);
			}
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.alpha_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_alpha_gompertz;	/* alpha = exp(alpha.intern) */
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_WEIBULL_CURE:
	{
		/*
		 * get options related to the ps
		 */
		double initial_value = 0.0;

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), initial_value);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.alpha_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha_intern[%g]\n", ds->data_observations.alpha_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "LOGGAMMA-ALPHA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("alpha_intern for ps", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha parameter for ps", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.alpha_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_alpha_weibull;	/* alpha = exp(alpha.intern) */
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		initial_value = 1.0;
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), initial_value);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.p_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise p_intern[%g]\n", ds->data_observations.p_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "GAUSSIAN-std", NULL);

		/*
		 * add p
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("p_intern for ps", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("p parameter for ps", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.p_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_p_weibull_cure;	/* p = exp(p.intern)/(1+exp(p.intern)) */
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_POISSON_SPECIAL1:
	{
		double initial_value = -1.0;

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.prob_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise prob_intern[%g]\n", ds->data_observations.prob_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern one-probability parameter for poisson.special1", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("one-probability parameter for poisson.special1", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.prob_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZEROINFLATEDPOISSON0:
	case L_ZEROINFLATEDPOISSON1:
	case L_ZEROINFLATEDCENPOISSON0:
	case L_ZEROINFLATEDCENPOISSON1:
	{
		/*
		 * get options related to the zeroinflatedpoisson0/1
		 */
		double initial_value = -1.0;

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.prob_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise prob_intern[%g]\n", ds->data_observations.prob_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "GAUSSIAN-std", NULL);

		if (ds->data_id == L_ZEROINFLATEDCENPOISSON0 || ds->data_id == L_ZEROINFLATEDCENPOISSON1) {
			ds->data_observations.cenpoisson_interval = Calloc(2, double);
			ctmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CENPOISSON.I"), NULL));
			if (inla_sread_doubles(ds->data_observations.cenpoisson_interval, 2, ctmp) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "CENPOISSON.I", ctmp);
			}

			if ((int) ds->data_observations.cenpoisson_interval[0] == 0) {
				GMRFLib_sprintf(&ctmp,
						"cenpoisson invalid censor-interval [%g, %g]\n",
						ds->data_observations.cenpoisson_interval[0], ds->data_observations.cenpoisson_interval[1]);
				inla_error_general(ctmp);
				exit(1);
			}

			if (mb->verbose) {
				printf("\t\tcenpoisson censor-interval = [%g, %g]\n",
				       ds->data_observations.cenpoisson_interval[0], ds->data_observations.cenpoisson_interval[1]);
			}

			Free(ctmp);
		}

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			if (ds->data_id == L_ZEROINFLATEDPOISSON0) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("intern zero-probability parameter for zero-inflated poisson_0", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated poisson_0", mb->ds);
			} else if (ds->data_id == L_ZEROINFLATEDPOISSON1) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("intern zero-probability parameter for zero-inflated poisson_1", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated poisson_1", mb->ds);
			} else if (ds->data_id == L_ZEROINFLATEDCENPOISSON0) {
				mb->theta_tag[mb->ntheta] =
				    inla_make_tag("intern zero-probability parameter for zero-inflated cenpoisson_0", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated cenpoisson_0", mb->ds);
			} else if (ds->data_id == L_ZEROINFLATEDCENPOISSON1) {
				mb->theta_tag[mb->ntheta] =
				    inla_make_tag("intern zero-probability parameter for zero-inflated cenpoisson_1", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated cenpoisson_1", mb->ds);
			} else {
				GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
			}
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.prob_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZEROINFLATEDPOISSON2:
	{
		/*
		 * get options related to the zeroinflatedpoisson2
		 */
		double initial_value = log(2.0);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zeroinflated_alpha_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha_intern[%g]\n", ds->data_observations.zeroinflated_alpha_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "GAUSSIAN-std", NULL);
		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern zero-probability parameter for zero-inflated poisson_2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("zero-probability parameter for zero-inflated poisson_2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.zeroinflated_alpha_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZEROINFLATEDBINOMIAL2:
	{
		/*
		 * get options related to the zeroinflatedbinomial2
		 */
		double initial_value = log(2.0);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zeroinflated_alpha_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha_intern[%g]\n", ds->data_observations.zeroinflated_alpha_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern zero-probability parameter for zero-inflated binomial_2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("zero-probability parameter for zero-inflated binomial_2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.zeroinflated_alpha_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZERO_N_INFLATEDBINOMIAL2:
	{
		/*
		 * get options related to the zero_n_inflatedbinomial2
		 */
		double initial_value = log(2.0);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), initial_value);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zero_n_inflated_alpha1_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha1_intern[%g]\n", ds->data_observations.zero_n_inflated_alpha1_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern alpha1 parameter for zero-n-inflated binomial_2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha1 parameter for zero-n-inflated binomial_2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.zero_n_inflated_alpha1_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), initial_value);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zero_n_inflated_alpha2_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha2_intern[%g]\n", ds->data_observations.zero_n_inflated_alpha2_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern alpha2 parameter for zero-n-inflated binomial_2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha2 parameter for zero-n-inflated binomial_2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;
			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);
			mb->theta[mb->ntheta] = ds->data_observations.zero_n_inflated_alpha2_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZERO_N_INFLATEDBINOMIAL3:
	{
		/*
		 * get options related to the zero_n_inflatedbinomial3
		 */
		double initial_value = log(2.0);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), initial_value);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zero_n_inflated_alpha0_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha0_intern[%g]\n", ds->data_observations.zero_n_inflated_alpha0_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern alpha0 parameter for zero-n-inflated binomial_3", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alpha0 parameter for zero-n-inflated binomial_3", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.zero_n_inflated_alpha0_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), initial_value);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zero_n_inflated_alphaN_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alphaN_intern[%g]\n", ds->data_observations.zero_n_inflated_alphaN_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern alphaN parameter for zero-n-inflated binomial_3", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("alphaN parameter for zero-n-inflated binomial_3", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;
			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);
			mb->theta[mb->ntheta] = ds->data_observations.zero_n_inflated_alphaN_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZEROINFLATEDBETABINOMIAL2:
	{
		/*
		 * get options related to the zeroinflatedbetabinomial2
		 */
		double initial_value = log(2.0);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), initial_value);
		ds->data_fixed0 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED0"), 0);
		if (!ds->data_fixed0 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zeroinflated_alpha_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha_intern[%g]\n", ds->data_observations.zeroinflated_alpha_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed0);
		}
		inla_read_prior0(mb, ini, sec, &(ds->data_prior0), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed0) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior0.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern zero-probability parameter for zero-inflated betabinomial_2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("zero-probability parameter for zero-inflated betabinomial_2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior0.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.zeroinflated_alpha_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}

		initial_value = log(1.0);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), initial_value);
		ds->data_fixed1 = iniparser_getboolean(ini, inla_string_join(secname, "FIXED1"), 0);
		if (!ds->data_fixed1 && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.zeroinflated_delta_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise delta_intern[%g]\n", ds->data_observations.zeroinflated_delta_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed1);
		}
		inla_read_prior1(mb, ini, sec, &(ds->data_prior1), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed1) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior1.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("intern overdispersion parameter for zero-inflated betabinomial_2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("overdispersion parameter for zero-inflated betabinomial_2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter1", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior1.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.zeroinflated_delta_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_ZEROINFLATEDBINOMIAL0:
	case L_ZEROINFLATEDBINOMIAL1:
	{
		/*
		 * get options related to the zeroinflatedbinomial0/1
		 */
		double initial_value = -1.0;

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), initial_value);
		ds->data_fixed = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
		if (!ds->data_fixed && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->data_observations.prob_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise prob_intern[%g]\n", ds->data_observations.prob_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->data_fixed);
		}
		inla_read_prior(mb, ini, sec, &(ds->data_prior), "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->data_fixed) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->data_prior.hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			if (ds->data_id == L_ZEROINFLATEDBINOMIAL0) {
				mb->theta_tag[mb->ntheta] = inla_make_tag("intern zero-probability parameter for zero-inflated binomial_0", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated binomial_0", mb->ds);
			} else {
				mb->theta_tag[mb->ntheta] = inla_make_tag("intern zero-probability parameter for zero-inflated binomial_1", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] =
				    inla_make_tag("zero-probability parameter for zero-inflated binomial_1", mb->ds);
			}
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_prior.from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_prior.to_theta);

			mb->theta[mb->ntheta] = ds->data_observations.prob_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->data_ntheta++;
		}
	}
		break;

	case L_NMIX:
	case L_NMIXNB:
	{
		/*
		 * get options related to the nmix and nmixnb
		 */
		if (mb->verbose) {
			printf("\t\tmodel for N in the mixture[%s]\n", (ds->data_id == L_NMIX ? "Poisson" : "NegativeBinomial"));
		}
		// first we need to know 'm'. 

		found = 0;
		ds->data_observations.nmix_m = NMIX_MMAX;
		for (i = 0; i < NMIX_MMAX && !found; i++) {
			for (int j = 0; j < mb->predictor_ndata; j++) {
				if (gsl_isnan(ds->data_observations.nmix_x[i][j])) {
					found = 1;
					ds->data_observations.nmix_m = i;
					break;
				}
			}
		}
		if (mb->verbose) {
			printf("\t\tnmix.m=[%1d]\n", ds->data_observations.nmix_m);
		}
		assert(ds->data_observations.nmix_m > 0 && ds->data_observations.nmix_m <= NMIX_MMAX);
		ds->data_observations.nmix_beta = Calloc(NMIX_MMAX + 1, double **);	/* yes, its +1 to cover the NB case */
		ds->data_nprior = Calloc(NMIX_MMAX + 1, Prior_tp);
		ds->data_nfixed = Calloc(NMIX_MMAX + 1, int);

		int k;
		for (k = 0; k < NMIX_MMAX; k++) {
			ds->data_nfixed[k] = 1;		       /* so that the unused ones are fixed, so we can loop over all in the 'extra'
							        * function */
		}

		// mark all as read
		for (i = 0; i < NMIX_MMAX; i++) {
			for (int j = 0; j < keywords_len; j++) {
				GMRFLib_sprintf(&ctmp, "%s%1d", keywords[j], i);
				iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
				Free(ctmp);
			}
		}

		for (int k = 0; k < ds->data_observations.nmix_m; k++) {
			GMRFLib_sprintf(&ctmp, "INITIAL%1d", k);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), 0.0);

			Free(ctmp);
			GMRFLib_sprintf(&ctmp, "FIXED%1d", k);
			ds->data_nfixed[k] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);

			if (!(ds->data_nfixed[k]) && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(ds->data_observations.nmix_beta[k], tmp);
			if (mb->verbose) {
				printf("\t\tinitialise nmix.beta[%1d] = %g\n", k, ds->data_observations.nmix_beta[k][0][0]);
				printf("\t\tfixed = %1d\n", ds->data_nfixed[k]);
			}
			inla_read_priorN(mb, ini, sec, &(ds->data_nprior[k]), "GAUSSIAN", k, NULL);

			if (!ds->data_nfixed[k]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->data_nprior[k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				Free(ctmp);
				GMRFLib_sprintf(&ctmp, "beta[%1d] for NMix observations", k + 1);
				mb->theta_tag[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&msg, "%s-parameter", secname);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[k].to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.nmix_beta[k];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_identity;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ds->data_ntheta++;
			}
		}

		if (ds->data_id == L_NMIXNB) {
			k = NMIX_MMAX;			       /* this the overdisperson */

			GMRFLib_sprintf(&ctmp, "INITIAL%1d", k);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), 0.0);
			HYPER_NEW(ds->data_observations.nmix_log_overdispersion, tmp);

			Free(ctmp);
			GMRFLib_sprintf(&ctmp, "FIXED%1d", k);
			ds->data_nfixed[k] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);

			if (!(ds->data_nfixed[k]) && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}

			if (mb->verbose) {
				printf("\t\tinitialise nmix.log_overdispersion = %g\n", ds->data_observations.nmix_log_overdispersion[0][0]);
				printf("\t\tfixed = %1d\n", ds->data_nfixed[k]);
			}
			inla_read_priorN(mb, ini, sec, &(ds->data_nprior[k]), "LOGGAMMA", k, NULL);

			if (!ds->data_nfixed[k]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->data_nprior[k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				Free(ctmp);
				GMRFLib_sprintf(&ctmp, "log_overdispersion for NMix observations");
				mb->theta_tag[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				Free(ctmp);
				GMRFLib_sprintf(&ctmp, "overdispersion for NMix observations");
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag(ctmp, mb->ds);
				GMRFLib_sprintf(&msg, "%s-parameter", secname);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->data_nprior[k].to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.nmix_log_overdispersion;
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_exp;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ds->data_ntheta++;
			}
		}
	}
		break;

	default:
		/*
		 * nothing to do 
		 */
		ds->data_ntheta = 0;
	}

	/*
	 * setup the link-model
	 */
	ds->link_model = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join(secname, "LINK.MODEL"), GMRFLib_strdup("default"))));
	inla_trim_family(ds->link_model);

	if (!strcasecmp(ds->link_model, "IDENTITY")) {
		ds->link_id = LINK_IDENTITY;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_identity;
	} else if (!strcasecmp(ds->link_model, "inverse")) {
		ds->link_id = LINK_INVERSE;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_inverse;
	} else if (!strcasecmp(ds->link_model, "LOG")) {
		ds->link_id = LINK_LOG;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_log;
	} else if (!strcasecmp(ds->link_model, "LOGa")) {
		ds->link_id = LINK_LOGa;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_loga;
	} else if (!strcasecmp(ds->link_model, "NEGLOG")) {
		ds->link_id = LINK_NEGLOG;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_neglog;
	} else if (!strcasecmp(ds->link_model, "PROBIT")) {
		ds->link_id = LINK_PROBIT;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_probit;
	} else if (!strcasecmp(ds->link_model, "CLOGLOG")) {
		ds->link_id = LINK_CLOGLOG;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_cloglog;
	} else if (!strcasecmp(ds->link_model, "LOGLOG")) {
		ds->link_id = LINK_LOGLOG;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_loglog;
	} else if (!strcasecmp(ds->link_model, "CAUCHIT")) {
		ds->link_id = LINK_CAUCHIT;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_cauchit;
	} else if (!strcasecmp(ds->link_model, "LOGIT")) {
		ds->link_id = LINK_LOGIT;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_logit;
	} else if (!strcasecmp(ds->link_model, "TAN")) {
		ds->link_id = LINK_TAN;
		ds->link_ntheta = 0;
		ds->predictor_invlinkfunc = link_tan;
	} else if (!strcasecmp(ds->link_model, "LOGOFFSET")) {
		ds->link_id = LINK_LOGOFFSET;
		ds->link_ntheta = 1;
		ds->predictor_invlinkfunc = link_logoffset;
	} else if (!strcasecmp(ds->link_model, "LOGITOFFSET")) {
		ds->link_id = LINK_LOGITOFFSET;
		ds->link_ntheta = 1;
		ds->predictor_invlinkfunc = link_logitoffset;
	} else if (!strcasecmp(ds->link_model, "SSLOGIT")) {
		ds->link_id = LINK_SSLOGIT;
		ds->link_ntheta = 2;
		ds->predictor_invlinkfunc = link_sslogit;
	} else if (!strcasecmp(ds->link_model, "ROBIT")) {
		ds->link_id = LINK_ROBIT;
		ds->link_ntheta = 1;
		ds->predictor_invlinkfunc = link_robit;
	} else if (!strcasecmp(ds->link_model, "SN")) {
		ds->link_id = LINK_SN;
		ds->link_ntheta = 2;
		ds->predictor_invlinkfunc = link_sn;
	} else if (!strcasecmp(ds->link_model, "POWERLOGIT")) {
		ds->link_id = LINK_POWER_LOGIT;
		ds->link_ntheta = 2;
		ds->predictor_invlinkfunc = link_power_logit;
	} else if (!strcasecmp(ds->link_model, "TEST1")) {
		ds->link_id = LINK_TEST1;
		ds->link_ntheta = 1;
		ds->predictor_invlinkfunc = link_test1;
	} else if (!strcasecmp(ds->link_model, "SPECIAL1")) {
		ds->link_id = LINK_SPECIAL1;
		ds->link_ntheta = -1;
		ds->predictor_invlinkfunc = link_special1;
	} else if (!strcasecmp(ds->link_model, "SPECIAL2")) {
		ds->link_id = LINK_SPECIAL2;
		ds->link_ntheta = 1;
		ds->predictor_invlinkfunc = link_special2;
	} else if (!strcasecmp(ds->link_model, "QUANTILE")) {
		GMRFLib_ASSERT((ds->data_observations.quantile > 0.0 && ds->data_observations.quantile < 1.0), GMRFLib_EPARAMETER);
		switch (ds->data_id) {
		case L_POISSON:
		case L_XPOISSON:
		{
			ds->link_id = LINK_QPOISSON;
			ds->link_ntheta = 0;
			ds->predictor_invlinkfunc = link_qpoisson;
		}
			break;
		case L_BINOMIAL:
		case L_XBINOMIAL:
		{
			ds->link_id = LINK_QBINOMIAL;
			ds->link_ntheta = 0;
			ds->predictor_invlinkfunc = link_qbinomial;
		}
			break;
		case L_WEIBULL:
		case L_WEIBULLSURV:
		{
			ds->link_id = LINK_QWEIBULL;
			ds->link_ntheta = 0;
			ds->predictor_invlinkfunc = link_qweibull;
		}
			break;
		case L_GAMMA:
		{
			ds->link_id = LINK_QGAMMA;
			ds->link_ntheta = 0;
			ds->predictor_invlinkfunc = link_qgamma;
			inla_qgamma_cache(0.0, ds->data_observations.quantile, -1);
		}
			break;
		case L_GP:
		{
			ds->link_id = LINK_LOG;
			ds->link_ntheta = 0;
			ds->predictor_invlinkfunc = link_log;
		}
			break;
		case L_DGP:
		{
			ds->link_id = LINK_LOG;
			ds->link_ntheta = 0;
			ds->predictor_invlinkfunc = link_log;
		}
			break;
		default:
			assert(0 == 1);
		}
	} else if (!strcasecmp(ds->link_model, "PQUANTILE")) {
		GMRFLib_ASSERT((ds->data_observations.quantile > 0.0 && ds->data_observations.quantile < 1.0), GMRFLib_EPARAMETER);
		switch (ds->data_id) {
		case L_BINOMIAL:
		case L_XBINOMIAL:
		{
			ds->link_id = LINK_QBINOMIAL;
			ds->link_ntheta = 0;
			ds->predictor_invlinkfunc = link_pqbinomial;
		}
			break;
		default:
			assert(0 == 1);
		}
	} else {
		char *msg;
		GMRFLib_sprintf(&msg, "Unknown link-model [%s]\n", ds->link_model);
		inla_error_general(msg);
		exit(1);
	}

	/*
	 * the meaning of 'order' is model dependent
	 */
	ds->link_order = iniparser_getint(ini, inla_string_join(secname, "LINK.ORDER"), -1);
	ds->link_variant = iniparser_getint(ini, inla_string_join(secname, "LINK.VARIANT"), -1);
	ds->link_a = iniparser_getdouble(ini, inla_string_join(secname, "LINK.a"), 1.0);
	if (mb->verbose) {
		printf("\t\tLink model   [%s]\n", ds->link_model);
		printf("\t\tLink order   [%1d]\n", ds->link_order);
		printf("\t\tLink variant [%1d]\n", ds->link_variant);
		printf("\t\tLink a       [%g]\n", ds->link_a);
		printf("\t\tLink ntheta  [%1d]\n", ds->link_ntheta);
	}

	/*
	 * read possible link_covariates 
	 */
	char *link_cov_filename;
	link_cov_filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "LINK.COVARIATES"), NULL));

	if (link_cov_filename) {
		ds->link_covariates = GMRFLib_read_fmesher_file(link_cov_filename, (long int) 0, -1);
		if (mb->verbose) {
			int ii, jj;
			printf("\t\tLink_covariates: file[%s] dim=(%1d x %1d)\n", link_cov_filename, ds->link_covariates->nrow,
			       ds->link_covariates->ncol);
			for (ii = 0; ii < IMIN(PREVIEW, ds->link_covariates->nrow); ii++) {
				printf("\t\t\trow=%1d, covariates=[", ii);
				for (jj = 0; jj < ds->link_covariates->ncol; jj++) {
					printf(" %g", GMRFLib_matrix_get(ii, jj, ds->link_covariates));
				}
				printf(" ]\n");
			}
		}

		int len = (mb->predictor_m > 0 ? mb->predictor_m : mb->predictor_n);
		if (len != ds->link_covariates->nrow) {
			char *emsg;
			GMRFLib_sprintf(&emsg,
					"link.covariates has not the same number of rows as the linear predictor %1d != %1d",
					ds->link_covariates->nrow, len);
			inla_error_general(emsg);
			abort();
		}
	} else {
		ds->link_covariates = NULL;
	}

	/*
	 * read link-parameters, if any
	 */
	ds->predictor_invlinkfunc_arg = Calloc(n_data, void *);

	switch (ds->link_id) {
	case LINK_IDENTITY:
	case LINK_INVERSE:
	case LINK_LOG:
	case LINK_NEGLOG:
	case LINK_PROBIT:
	case LINK_CLOGLOG:
	case LINK_LOGLOG:
	case LINK_CAUCHIT:
	case LINK_LOGIT:
	case LINK_TAN:
		break;

	case LINK_LOGa:
	{
		Link_param_tp *link_param = Calloc(1, Link_param_tp);
		link_param->a = ds->link_a;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) link_param;
		}
	}
		break;

	case LINK_QPOISSON:
	{
		Link_param_tp *link_param = Calloc(1, Link_param_tp);
		link_param->idx = -1;
		link_param->quantile = ds->data_observations.quantile;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) link_param;
		}
	}
		break;

	case LINK_QBINOMIAL:
	{
		for (i = 0; i < n_data; i++) {
			Link_param_tp *link_param = Calloc(1, Link_param_tp);
			link_param->idx = i;
			link_param->quantile = ds->data_observations.quantile;
			link_param->Ntrial = ds->data_observations.nb[i];
			ds->predictor_invlinkfunc_arg[i] = (void *) link_param;
		}
	}
		break;

	case LINK_QWEIBULL:
	{
		Link_param_tp *link_param = Calloc(1, Link_param_tp);
		link_param->idx = -1;
		link_param->quantile = ds->data_observations.quantile;
		link_param->alpha_intern = ds->data_observations.alpha_intern;
		link_param->variant = ds->variant;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) link_param;
		}
	}
		break;

	case LINK_QGAMMA:
	{
		for (i = 0; i < n_data; i++) {
			Link_param_tp *link_param = Calloc(1, Link_param_tp);
			link_param->idx = i;
			link_param->quantile = ds->data_observations.quantile;
			link_param->scale = ds->data_observations.gamma_scale;
			link_param->log_prec = ds->data_observations.gamma_log_prec;
			ds->predictor_invlinkfunc_arg[i] = (void *) link_param;
		}
	}
		break;

	case LINK_SSLOGIT:
	{
		/*
		 * logit link with correction for sensitivity and specificity
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL0"), 0.0);
		ds->link_fixed = Calloc(2, int);
		ds->link_fixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED0"), 0);
		if (!ds->link_fixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = -1;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) (ds->link_parameters);
		}
		HYPER_NEW(ds->link_parameters->sensitivity_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise sslogit link sensitivity_intern[%g]\n", ds->link_parameters->sensitivity_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[0]);
		}
		ds->link_prior = Calloc(2, Prior_tp);
		inla_read_prior_link0(mb, ini, sec, &(ds->link_prior[0]), "LOGITBETA", NULL);	/* read both priors here */
		inla_read_prior_link1(mb, ini, sec, &(ds->link_prior[1]), "LOGITBETA", NULL);	/* ... */

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link sslogit sensitivity_intern", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link sslogit sensitivity", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->sensitivity_intern;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL1"), 0.0);
		ds->link_fixed[1] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED1"), 0);
		if (!ds->link_fixed[1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->link_parameters->specificity_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise sslogit link specificity_intern[%g]\n", ds->link_parameters->specificity_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[1]);
		}
		if (!ds->link_fixed[1]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link sslogit specificity_intern", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link sslogit specificity", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[1].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->specificity_intern;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}
	}
		break;

	case LINK_ROBIT:
	{
		/*
		 * Robit link with default fixed number of df.
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL"), 0.0);
		ds->link_fixed = Calloc(2, int);
		ds->link_fixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED"), 1);
		if (!ds->link_fixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = -1;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) (ds->link_parameters);
		}
		HYPER_NEW(ds->link_parameters->dof_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise robit link dof_intern[%g]\n", ds->link_parameters->dof_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[0]);
		}

		ds->link_prior = Calloc(1, Prior_tp);
		inla_read_prior_link(mb, ini, sec, &(ds->link_prior[0]), "PCDOF", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link robit dof_intern", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link robit dof", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->dof_intern;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_dof;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}
	}
		break;

	case LINK_SN:
	{
		/*
		 * SN link
		 */

		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = -1;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) (ds->link_parameters);
		}

		ds->link_fixed = Calloc(2, int);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL0"), 0.0);
		ds->link_fixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED0"), 1);
		if (!ds->link_fixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}

		HYPER_NEW(ds->link_parameters->sn_skew, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise link_sn skew[%g]\n", ds->link_parameters->sn_skew[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[0]);
		}

		ds->link_prior = Calloc(2, Prior_tp);
		inla_read_prior_link0(mb, ini, sec, &(ds->link_prior[0]), "PCSN", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link sn skew", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link sn skew", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->sn_skew;

			double *skewmax = Calloc(1, double);
			*skewmax = GMRFLib_SN_SKEWMAX;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_phi;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) skewmax;
			mb->ntheta++;
			ds->link_ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL1"), 0);
		ds->link_fixed[1] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED1"), 1);

		// special option. If 'initial=NA' or 'Inf', then remove intercept from the model. This is done setting fixed=1
		// and then recognising NAN in the map_invsn() function.
		if (ISNAN(tmp) || ISINF(tmp)) {
			tmp = NAN;
			ds->link_fixed[1] = 1;
		}

		if (!ds->link_fixed[1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->link_parameters->sn_intercept, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise link_sn intercept[%g]\n", ds->link_parameters->sn_intercept[0][0]);
			if (ISNAN(ds->link_parameters->sn_intercept[0][0])) {
				printf("\t\t *** Intercept is removed from link-model\n");
			}
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[1]);
		}
		inla_read_prior_link1(mb, ini, sec, &(ds->link_prior[1]), "LOGITBETA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[1]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link sn intercept", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link sn intercept", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[1].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->sn_intercept;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}
	}
		break;

	case LINK_POWER_LOGIT:
	{
		/*
		 * power logit link
		 */

		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = -1;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) (ds->link_parameters);
		}

		ds->link_fixed = Calloc(2, int);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL0"), 0.0);
		ds->link_fixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED0"), 1);
		if (!ds->link_fixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}

		HYPER_NEW(ds->link_parameters->power_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise link_power_logit power[%g]\n", ds->link_parameters->power_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[0]);
		}

		ds->link_prior = Calloc(2, Prior_tp);
		inla_read_prior_link0(mb, ini, sec, &(ds->link_prior[0]), "NORMAL", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link power_logit power.intern", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link power_logit power", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->power_intern;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->ntheta++;
			ds->link_ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL1"), 0);
		ds->link_fixed[1] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED1"), 1);

		// special option. If 'initial=NA' or 'Inf', then remove intercept from the model. This is done setting fixed=1
		// and then recognising NAN in the map_invsn() function.
		if (ISNAN(tmp) || ISINF(tmp)) {
			tmp = NAN;
			ds->link_fixed[1] = 1;
		}

		if (!ds->link_fixed[1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		HYPER_NEW(ds->link_parameters->intercept_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise link_power_logit intercept.intern[%g]\n", ds->link_parameters->intercept_intern[0][0]);
			if (ISNAN(ds->link_parameters->intercept_intern[0][0])) {
				printf("\t\t *** Intercept is removed from link-model\n");
			}
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[1]);
		}
		inla_read_prior_link1(mb, ini, sec, &(ds->link_prior[1]), "LOGITBETA", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[1]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link power_logit intercept_intern", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link power_logit intercept", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[1].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->intercept_intern;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}
	}
		break;

	case LINK_LOGOFFSET:
	{
		/*
		 * exp(beta)*cov + exp(linear.predictor)
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL"), 0.0);
		ds->link_fixed = Calloc(1, int);
		ds->link_fixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED"), 0);
		if (!ds->link_fixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = ds->link_order;
		ds->link_parameters->variant = ds->link_variant;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) (ds->link_parameters);
		}
		HYPER_NEW(ds->link_parameters->beta_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise link beta[%g]\n", ds->link_parameters->beta_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[0]);
		}
		ds->link_prior = Calloc(1, Prior_tp);
		inla_read_prior_link(mb, ini, sec, ds->link_prior, "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link beta_intern for logoffset", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link beta for logoffset", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->beta_intern;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}
	}
		break;

	case LINK_LOGITOFFSET:
	{
		/*
		 * p + (1-p) * exp(linear.predictor)/(1 + exp(linear.predictor))
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL"), 0.0);
		ds->link_fixed = Calloc(1, int);
		ds->link_fixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED"), 0);
		if (!ds->link_fixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = ds->link_order;
		ds->link_parameters->variant = ds->link_variant;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) (ds->link_parameters);
		}
		HYPER_NEW(ds->link_parameters->prob_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise link prob[%g]\n", ds->link_parameters->prob_intern[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[0]);
		}
		ds->link_prior = Calloc(1, Prior_tp);
		inla_read_prior_link(mb, ini, sec, ds->link_prior, "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link prob_intern for logitoffset", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link prob for logitoffset", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->prob_intern;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}
	}
		break;

	case LINK_TEST1:
	{
		/*
		 * exp(eta - beta*cov
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL"), 0.0);
		ds->link_fixed = Calloc(1, int);
		ds->link_fixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED"), 0);
		if (!ds->link_fixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = ds->link_order;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) (ds->link_parameters);
		}
		HYPER_NEW(ds->link_parameters->beta, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise link beta[%g]\n", ds->link_parameters->beta[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[0]);
		}
		ds->link_prior = Calloc(1, Prior_tp);
		inla_read_prior_link(mb, ini, sec, ds->link_prior, "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link beta for test1", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link beta for test1", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->beta;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}
	}
		break;

	case LINK_SPECIAL2:
	{
		/*
		 * exp(eta) * ( 1-x + x*exp(beta) )
		 */
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "LINK.INITIAL"), 0.0);
		ds->link_fixed = Calloc(1, int);
		ds->link_fixed[0] = iniparser_getboolean(ini, inla_string_join(secname, "LINK.FIXED"), 0);
		if (!ds->link_fixed[0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = ds->link_order;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg[i] = (void *) (ds->link_parameters);
		}
		HYPER_NEW(ds->link_parameters->beta, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise link beta[%g]\n", ds->link_parameters->beta[0][0]);
			printf("\t\tfixed=[%1d]\n", ds->link_fixed[0]);
		}
		ds->link_prior = Calloc(1, Prior_tp);
		inla_read_prior_link(mb, ini, sec, ds->link_prior, "GAUSSIAN-std", NULL);

		/*
		 * add theta 
		 */
		if (!ds->link_fixed[0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			mb->theta_tag[mb->ntheta] = inla_make_tag("Link beta for special2", mb->ds);
			mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Link beta for special2", mb->ds);
			GMRFLib_sprintf(&msg, "%s-parameter0", secname);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
			mb->theta[mb->ntheta] = ds->link_parameters->beta;

			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
			ds->link_ntheta++;
		}
	}
		break;

	case LINK_SPECIAL1:
	{
		ds->link_prior = Calloc(2, Prior_tp);
		inla_read_prior_link0(mb, ini, sec, &(ds->link_prior[0]), "LOGGAMMA", NULL);	// log precision
		inla_read_prior_link1(mb, ini, sec, &(ds->link_prior[1]), "MVNORM", NULL);	// the beta's

		if (ds->link_order > 0 && (int) ds->link_prior[1].parameters[0] != ds->link_order) {
			char *ptmp;
			GMRFLib_sprintf(&ptmp,
					"Dimension of the MVNORM prior is not equal to the order of the link-model: %1d != %1d\n",
					(int) ds->link_prior[1].parameters[0], ds->link_order);
			inla_error_general(ptmp);
			exit(EXIT_FAILURE);
		}
		if (ds->link_order > ds->link_covariates->ncol) {
			char *ptmp;
			GMRFLib_sprintf(&ptmp, "The link-model %s require more covariates : %1d > %1d\n",
					ds->link_model, ds->link_order, ds->link_covariates->ncol);
			inla_error_general(ptmp);
			exit(EXIT_FAILURE);
		}
		ds->link_ntheta = ds->link_order + 1;
		assert(ds->link_ntheta <= LINK_MAXTHETA + 1);
		if (mb->verbose) {
			printf("\t\tlink ntheta = [%1d]\n", ds->link_ntheta);
		}

		/*
		 * mark all possible as read 
		 */

		// mark all as read
		for (i = 0; i < LINK_MAXTHETA + 1; i++) {
			for (int j = 0; j < keywords_len; j++) {
				GMRFLib_sprintf(&ctmp, "LINK.%s%1d", keywords[j], i);
				iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
				Free(ctmp);
			}
		}

		ds->link_fixed = Calloc(ds->link_ntheta, int);
		ds->link_initial = Calloc(ds->link_ntheta, double);
		ds->link_parameters = Calloc(1, Link_param_tp);
		ds->link_parameters->idx = -1;
		ds->link_parameters->order = ds->link_order;
		for (i = 0; i < n_data; i++) {
			ds->predictor_invlinkfunc_arg = (void **) ((void *)(ds->link_parameters));
		}
		HYPER_NEW(ds->link_parameters->log_prec, 0.0);
		ds->link_parameters->betas = Calloc(LINK_MAXTHETA, double **);
		for (i = 0; i < LINK_MAXTHETA; i++) {
			HYPER_NEW(ds->link_parameters->betas[i], 0.0);
		}

		/*
		 * then read those we need 
		 */
		for (i = 0; i < ds->link_ntheta; i++) {
			double theta_initial = 0;
			char *ctmp;

			GMRFLib_sprintf(&ctmp, "LINK.FIXED%1d", i);
			ds->link_fixed[i] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			GMRFLib_sprintf(&ctmp, "LINK.INITIAL%1d", i);
			theta_initial = iniparser_getdouble(ini, inla_string_join(secname, ctmp), theta_initial);

			if (!ds->link_fixed[i] && mb->reuse_mode) {
				theta_initial = mb->theta_file[mb->theta_counter_file++];
			}

			if (mb->verbose) {
				printf("\t\tlink theta fixed  [%1d] = [%1d]\n", i, ds->link_fixed[i]);
				printf("\t\tlink theta initial[%1d] = [%g]\n", i, ds->link_initial[i]);
			}

			if (i == 0) {
				/*
				 * precision 
				 */
				HYPER_INIT(ds->link_parameters->log_prec, theta_initial);
				if (mb->verbose) {
					printf("\t\tlink initialise log_prec = [%g]\n", theta_initial);
					printf("\t\tlink fixed[%1d]=[%1d]\n", i, ds->link_fixed[i]);
				}

				if (!ds->link_fixed[i]) {
					/*
					 * add this \theta 
					 */
					mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
					mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
					mb->theta_hyperid[mb->ntheta] = ds->link_prior[0].hyperid;
					mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
					mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
					mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
					GMRFLib_sprintf(&msg, "Link log precision for %s", ds->data_likelihood);
					mb->theta_tag[mb->ntheta] = inla_make_tag(msg, mb->ds);
					GMRFLib_sprintf(&msg, "Link precision for %s", ds->data_likelihood);
					mb->theta_tag_userscale[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s-parameter%1d", msg, i);
					mb->theta_dir[mb->ntheta] = inla_make_tag(msg, mb->ds);

					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].from_theta);
					mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[0].to_theta);
					mb->theta[mb->ntheta] = ds->link_parameters->log_prec;
					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map[mb->ntheta] = map_precision;
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
					mb->theta_map_arg[mb->ntheta] = NULL;
					mb->ntheta++;
				}
			} else {
				/*
				 * beta
				 */
				HYPER_INIT(ds->link_parameters->betas[i - 1], theta_initial);
				if (mb->verbose) {
					printf("\t\tlink initialise beta[%1d]=[%g]\n", i, theta_initial);
					printf("\t\tlink fixed[%1d]=[%1d]\n", i, ds->link_fixed[i]);
				}

				if (!ds->link_fixed[i]) {
					/*
					 * add this \theta 
					 */
					mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
					mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
					mb->theta_hyperid[mb->ntheta] = NULL;	/* multivariate normal */
					mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
					mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
					mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
					GMRFLib_sprintf(&msg, "Link beta%1d for %s", i, ds->data_likelihood);
					mb->theta_tag[mb->ntheta] = inla_make_tag(msg, mb->ds);
					GMRFLib_sprintf(&msg, "Link beta%1d for %s", i, ds->data_likelihood);
					mb->theta_tag_userscale[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s-parameter%1d", msg, i);
					mb->theta_dir[mb->ntheta] = inla_make_tag(msg, mb->ds);

					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->link_prior[1].from_theta);
					mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->link_prior[1].to_theta);
					mb->theta[mb->ntheta] = ds->link_parameters->betas[i - 1];	/* yes! */
					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map[mb->ntheta] = map_identity;
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
					mb->theta_map_arg[mb->ntheta] = NULL;
					mb->ntheta++;
				}
			}
		}
	}
		break;

	default:
	{
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}
		break;
	}

	/*
	 * mixing of the likelihood 
	 */
	ds->mix_use = iniparser_getboolean(ini, inla_string_join(secname, "MIX.USE"), 0);
	if (mb->verbose) {
		printf("\t\tmix.use[%1d]\n", ds->mix_use);
	}
	if (ds->mix_use) {
		/*
		 * read mix-parameters
		 */

		char *model = NULL, *integrator = NULL;

		ds->mix_npoints = iniparser_getint(ini, inla_string_join(secname, "MIX.NPOINTS"), 99);
		assert(ds->mix_npoints >= 5);
		model = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join(secname, "MIX.MODEL"), NULL)));
		integrator = GMRFLib_strdup(strupc(iniparser_getstring(ini, inla_string_join(secname, "MIX.INTEGRATOR"), NULL)));
		if (!strcasecmp(integrator, "default")) {
			ds->mix_integrator = MIX_INT_DEFAULT;
		} else if (!strcasecmp(integrator, "quadrature")) {
			ds->mix_integrator = MIX_INT_QUADRATURE;
		} else if (!strcasecmp(integrator, "simpson")) {
			ds->mix_integrator = MIX_INT_SIMPSON;
		} else {
			assert(0 == 1);
		}

		if (mb->verbose) {
			printf("\t\tmix.npoints [%d]\n", ds->mix_npoints);
			printf("\t\tmix.model [%s]\n", model);
			printf("\t\tmix.integrator [%s]\n", integrator);
		}
		if (!strcasecmp(model, "GAUSSIAN")) {
			ds->mix_id = MIX_GAUSSIAN;
		} else if (!strcasecmp(model, "LOGGAMMA")) {
			ds->mix_id = MIX_LOGGAMMA;
		} else if (!strcasecmp(model, "MLOGGAMMA")) {
			ds->mix_id = MIX_MLOGGAMMA;
		} else {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "MIX.MODEL", model);
		}

		switch (ds->mix_id) {
		case MIX_GAUSSIAN:
		{
			/*
			 * get options related to the gaussian 
			 */
			tmp = iniparser_getdouble(ini, inla_string_join(secname, "MIX.INITIAL"), G.log_prec_initial);
			ds->mix_fixed = iniparser_getboolean(ini, inla_string_join(secname, "MIX.FIXED"), 0);
			if (!ds->mix_fixed && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(ds->data_observations.mix_log_prec_gaussian, tmp);
			if (mb->verbose) {
				printf("\t\tinitialise mix.log_precision[%g]\n", ds->data_observations.mix_log_prec_gaussian[0][0]);
				printf("\t\tmix.fixed=[%1d]\n", ds->mix_fixed);
			}
			inla_read_prior_mix(mb, ini, sec, &(ds->mix_prior), "LOGGAMMA", NULL);

			/*
			 * add theta 
			 */
			if (!ds->mix_fixed) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->mix_prior.hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
				mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision for the Gaussian mix", mb->ds);
				mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision for the Gaussian mix", mb->ds);
				GMRFLib_sprintf(&msg, "%s-parameter", secname);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->mix_prior.from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->mix_prior.to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.mix_log_prec_gaussian;
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_precision;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ds->mix_ntheta++;
			}

			ds->mix_loglikelihood = ds->loglikelihood;
			ds->loglikelihood = loglikelihood_mix_gaussian;
		}
			break;

		case MIX_LOGGAMMA:
		case MIX_MLOGGAMMA:
		{
			/*
			 * get options related to the loggamma
			 */
			tmp = iniparser_getdouble(ini, inla_string_join(secname, "MIX.INITIAL"), 1.0);
			ds->mix_fixed = iniparser_getboolean(ini, inla_string_join(secname, "MIX.FIXED"), 0);
			if (!ds->mix_fixed && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(ds->data_observations.mix_log_prec_loggamma, tmp);
			if (mb->verbose) {
				printf("\t\tinitialise mix.log_precision[%g]\n", ds->data_observations.mix_log_prec_loggamma[0][0]);
				printf("\t\tmix.fixed=[%1d]\n", ds->mix_fixed);
			}
			inla_read_prior_mix(mb, ini, sec, &(ds->mix_prior), "PCMGAMMA", NULL);

			/*
			 * add theta 
			 */
			if (!ds->mix_fixed) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->mix_prior.hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				if (ds->mix_id == MIX_LOGGAMMA) {
					mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision for the LogGamma mix", mb->ds);
					mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision for the LogGamma mix", mb->ds);
					GMRFLib_sprintf(&msg, "%s-parameter", secname);
					mb->theta_dir[mb->ntheta] = msg;
				} else {
					mb->theta_tag[mb->ntheta] = inla_make_tag("Log precision for the mLogGamma mix", mb->ds);
					mb->theta_tag_userscale[mb->ntheta] = inla_make_tag("Precision for the mLogGamma mix", mb->ds);
					GMRFLib_sprintf(&msg, "%s-parameter", secname);
					mb->theta_dir[mb->ntheta] = msg;
				}
				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->mix_prior.from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->mix_prior.to_theta);

				mb->theta[mb->ntheta] = ds->data_observations.mix_log_prec_loggamma;
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_precision;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ds->mix_ntheta++;
			}

			ds->mix_loglikelihood = ds->loglikelihood;
			ds->loglikelihood = (ds->mix_id == MIX_LOGGAMMA ? loglikelihood_mix_loggamma : loglikelihood_mix_mloggamma);
		}
			break;

		default:
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
			break;
		}
	}

	if ((ds->data_id != L_GAUSSIAN && ds->data_id != L_AGAUSSIAN) ||
	    ds->predictor_invlinkfunc != link_identity || ds->mix_use || mb->expert_disable_gaussian_check) {
		mb->gaussian_data = GMRFLib_FALSE;
	}

	return INLA_OK;
}

GMRFLib_constr_tp *inla_read_constraint(const char *filename, int n)
{
	/*
	 * read constraints from file 
	 */
	double *x = NULL;
	int i, j, m, nc;

	inla_read_data_all(&x, &m, filename, NULL);
	nc = m / (n + 1);				       /* yes, integer division */
	if (nc * n + nc != m) {
		char *msg = NULL;

		GMRFLib_sprintf(&msg, "Number of elements[%1d] in file[%s] does is not a multiplum of n=[%1d]", m, filename, n + 1);
		inla_error_general(msg);
	}
	GMRFLib_constr_tp *c = NULL;

	GMRFLib_make_empty_constr(&c);
	c->nc = nc;
	c->a_matrix = Calloc(nc * n, double);
	c->e_vector = Calloc(nc, double);

	for (j = 0; j < nc; j++) {
		for (i = 0; i < n; i++) {
			c->a_matrix[i * nc + j] = x[i + j * n];
		}
		c->e_vector[j] = x[nc * n + j];
	}
	/*
	 * this is a stupid construction (i blame myself...): i have to pass the graph in order to pass `n'... 
	 */
	GMRFLib_graph_tp *g = NULL;

	GMRFLib_graph_mk_linear(&g, n, 0, 0);
	GMRFLib_prepare_constr(c, g, 0);
	GMRFLib_graph_free(g);
	Free(x);
	return c;
}

GMRFLib_constr_tp *inla_make_constraint(int n, int sumzero, GMRFLib_constr_tp * constr)
{
	/*
	 * merge the constraints, if any. yes, i have to do this manually. 
	 */

	int i, j, nc;
	GMRFLib_constr_tp *c = NULL;

	if (!sumzero && !constr) {
		return NULL;
	}

	GMRFLib_make_empty_constr(&c);
	if (sumzero && !constr) {
		/*
		 * just the sumzero constraint 
		 */
		nc = 1;
		c->nc = nc;
		c->a_matrix = Calloc(nc * n, double);
		c->e_vector = Calloc(nc, double);
		for (i = 0; i < n; i++) {
			c->a_matrix[i] = 1.0;
		}
	} else if (!sumzero && constr) {
		nc = constr->nc;
		c->nc = nc;
		c->a_matrix = Calloc(nc * n, double);
		c->e_vector = Calloc(nc, double);
		Memcpy(c->a_matrix, constr->a_matrix, n * nc * sizeof(double));
		Memcpy(c->e_vector, constr->e_vector, nc * sizeof(double));
	} else {
		assert(sumzero && constr);

		nc = constr->nc + 1;
		c->nc = nc;
		c->a_matrix = Calloc(nc * n, double);
		c->e_vector = Calloc(nc, double);

		for (j = 0; j < nc - 1; j++) {
			for (i = 0; i < n; i++) {
				c->a_matrix[i * nc + j] = constr->a_matrix[i * constr->nc + j];
			}
			c->e_vector[j] = constr->e_vector[j];
		}
		j = nc - 1;
		for (i = 0; i < n; i++) {
			c->a_matrix[i * nc + j] = 1.0;
		}
		c->e_vector[j] = 0.0;
	}

	/*
	 * this is a stupid construction (i blame myself...): i have to pass the graph in order to pass `n'... 
	 */
	GMRFLib_graph_tp *g = NULL;

	GMRFLib_graph_mk_linear(&g, n, 0, 0);
	GMRFLib_prepare_constr(c, g, 0);
	GMRFLib_graph_free(g);

	return c;
}

GMRFLib_constr_tp *inla_make_constraint2(int n, int replicate, int sumzero, GMRFLib_constr_tp * constr)
{
	/*
	 * merge the constraints, if any. yes, i have to do this manually.
	 * this is the second version for which n is the basic size which has to be replicated.
	 */

	int i, ii, j, k, ccount, Ntotal;
	GMRFLib_constr_tp *c = NULL;

	if (!sumzero && !constr) {
		return NULL;
	}

	Ntotal = n * replicate;
	GMRFLib_make_empty_constr(&c);
	c->nc = ((constr ? constr->nc : 0) + (sumzero ? 1 : 0)) * replicate;
	c->a_matrix = Calloc(c->nc * Ntotal, double);
	c->e_vector = Calloc(c->nc, double);

	ccount = 0;
	if (sumzero) {
		for (j = 0; j < replicate; j++) {
			for (i = 0; i < n; i++) {
				ii = i + j * n;
				c->a_matrix[ii * c->nc + ccount] = 1.0;
			}
			ccount++;
		}
	}
	if (constr) {
		for (k = 0; k < constr->nc; k++) {
			for (j = 0; j < replicate; j++) {
				for (i = 0; i < n; i++) {
					ii = i + j * n;
					c->a_matrix[ii * c->nc + ccount] = constr->a_matrix[i * constr->nc + k];
				}
				c->e_vector[ccount] = constr->e_vector[k];
				ccount++;
			}
		}
	}
	assert(ccount == c->nc);

	/*
	 * this is a stupid construction (i blame myself...): i have to pass the graph in order to pass `n'... 
	 */
	GMRFLib_graph_tp *g = NULL;

	GMRFLib_graph_mk_linear(&g, Ntotal, 0, 0);
	GMRFLib_prepare_constr(c, g, 0);
	GMRFLib_graph_free(g);

	return c;
}

double Qfunc_intslope(int thread_id, int node, int nnode, double *UNUSED(values), void *arg)
{
	if (nnode < 0) {
		return NAN;
	}

	int i, imin, imax, idx, subject, strata, icase;
	double val = 0.0, xval = 0.0, gam, z = NAN;
	inla_intslope_arg_tp *a = (inla_intslope_arg_tp *) arg;

	imin = IMIN(node, nnode);
	imax = IMAX(node, nnode);

	if (imax < a->n) {
		// the diagonal part
		return a->precision;
	} else if (imin >= a->n) {
		// the Wishart part
		imin -= a->n;
		imax -= a->n;
		val = Qfunc_iid_wishart(thread_id, imin, imax, NULL, (void *) a->warg);
		subject = (imin == imax ? (imin < a->nsubject ? imin : imin - a->nsubject) : imin);
		icase = (imax < a->nsubject ? 0 : (imin >= a->nsubject ? 1 : 2));
		for (i = 0; i < a->subject_idx[subject]->n; i++) {
			idx = a->subject_idx[subject]->idx[i];
			strata = (int) GMRFLib_matrix_get(idx, INTSLOPE_STRATA, a->def);
			gam = a->theta_gamma[strata][thread_id][0];
			if (icase > 0) {
				z = GMRFLib_matrix_get(idx, INTSLOPE_Z, a->def);
			}
			switch (icase) {
			case 0:
			{
				xval += SQR(gam);
			}
				break;
			case 1:
			{
				xval += SQR(gam * z);
			}
				break;
			case 2:
			{
				xval += SQR(gam) * z;
			}
				break;
			}
		}

		return val + a->precision * xval;
	} else {
		imax -= a->n;
		strata = (int) GMRFLib_matrix_get(imin, INTSLOPE_STRATA, a->def);
		gam = a->theta_gamma[strata][thread_id][0];
		if (imax < a->nsubject) {
			val = -gam;
		} else {
			z = GMRFLib_matrix_get(imin, INTSLOPE_Z, a->def);
			val = -gam * z;
		}
		return a->precision * val;
	}

	assert(0 == 1);
	return 0.0;
}

int inla_make_intslope_graph(GMRFLib_graph_tp ** graph, inla_intslope_arg_tp * arg)
{
	int idx, subject;
	GMRFLib_ged_tp *ged = NULL;
	GMRFLib_graph_tp *g = NULL;

	// the iid2d part of the model is stored at the end
	GMRFLib_ged_init(&ged, NULL);
	inla_make_iid_wishart_graph(&g, arg->warg);
	GMRFLib_ged_insert_graph(ged, g, arg->n);

	for (idx = 0; idx < arg->n; idx++) {
		subject = (int) GMRFLib_matrix_get(idx, INTSLOPE_SUBJECT, arg->def);
		GMRFLib_ged_add(ged, idx, arg->n + subject);
		GMRFLib_ged_add(ged, idx, arg->n + arg->nsubject + subject);
	}
	GMRFLib_ged_build(graph, ged);
	GMRFLib_ged_free(ged);
	GMRFLib_graph_free(g);

	if (0) {
		GMRFLib_printf_graph(stdout, *graph);
		GMRFLib_graph_write("GRAPH", *graph);
	}

	return GMRFLib_SUCCESS;
}

int inla_cgeneric_debug(FILE * fp, char *secname, inla_cgeneric_cmd_tp cmd, double *out)
{
	int i, n, m;

#pragma omp critical (Name_3bf40dfd2018962c499124a04e65c58fff8542a3)
	{
		fprintf(fp, "cgeneric[ %s ]  cmd = %s\n", secname, INLA_CGENERIC_CMD_NAME(cmd));
		switch (cmd) {
		case INLA_CGENERIC_GRAPH:
		{
			int ii = -1, jj, ii_prev;
			n = (int) out[0];
			m = (int) out[1];
			fprintf(fp, "\tdimension = %1d   number.of.elements = %1d\n", n, m);
			for (i = 0; i < m; i++) {
				ii_prev = ii;
				ii = (int) out[2 + i];
				jj = (int) out[2 + m + i];
				assert(ii >= 0 && jj >= 0);
				assert(ii >= ii_prev);
				assert(jj >= ii);
				fprintf(fp, "\tidx = %1d i = %1d j = %1d\n", i, (int) out[2 + i], (int) out[2 + m + i]);
			}
		}
			break;

		case INLA_CGENERIC_Q:
		{
			n = (int) out[0];
			m = (int) out[1];
			fprintf(fp, "\tn = %d  m = %d\n", n, m);
			if (n == -1) {
				fprintf(fp, "\toptimized format (same as the graph)\n");
				for (i = 0; i < m; i++) {
					fprintf(fp, "\tidx = %1d Q = %.8f\n", i, out[2 + i]);
				}
			} else {
				for (i = 0; i < m; i++) {
					fprintf(fp, "\tidx = %1d i = %1d, j = %1d, Qij = %.8f\n", i, (int) out[2 + i], (int) out[2 + n + i],
						out[2 + 2 * n + i]);
				}
			}
		}
			break;

		case INLA_CGENERIC_MU:
		{
			n = (int) out[0];
			fprintf(fp, "n = %1d\n", n);
			for (i = 0; i < n; i++) {
				fprintf(fp, "\ti = %1d mu_i = %.8f\n", i, out[1 + i]);
			}
		}
			break;

		case INLA_CGENERIC_INITIAL:
		{
			n = (int) out[0];
			fprintf(fp, "n = %1d\n", n);
			for (i = 0; i < n; i++) {
				fprintf(fp, "\tidx = %1d initial = %.8f\n", i, out[1 + i]);
			}
		}
			break;

		case INLA_CGENERIC_LOG_NORM_CONST:
		{
			fprintf(fp, "\tlog.norm.const = %.8f\n", (out ? out[0] : NAN));
		}
			break;

		case INLA_CGENERIC_LOG_PRIOR:
		{
			if (out) {
				fprintf(fp, "\tlog.prior = %.8f\n", out[0]);
			}
		}
			break;

		default:
			break;
		}
	}

	return GMRFLib_SUCCESS;
}

int inla_parse_ffield(inla_tp * mb, dictionary * ini, int sec)
{
#define _SET(a_, b_) mb->f_ ## a_[mb->nf] = b_
#define _OneOf(a_) (!strcasecmp(model, a_))
#define _OneOf2(a_, b_) (_OneOf(a_) || _OneOf(b_))
#define _OneOf3(a_, b_, c_) (_OneOf(a_) || _OneOf(b_) || _OneOf(c_))
#define _SetInitial(id_, val_) mb->f_initial[mb->nf][id_] = val_
	/*
	 * parse section = ffield 
	 */
	int i, j, k, jj, nlocations, nc, n = 0, zn = 0, zm = 0, s = 0, itmp, id = 0, bvalue = 0, fixed, order, slm_n = -1, slm_m = -1,
	    nstrata = 0, nsubject = 0, cgeneric_n = -1, cgeneric_debug = 0;
	char *filename = NULL, *filenamec = NULL, *secname = NULL, *model = NULL, *ptmp = NULL, *ptmp2 = NULL, *msg =
	    NULL, default_tag[100], *file_loc, *ctmp = NULL, *rgeneric_filename = NULL, *rgeneric_model = NULL,
	    *cgeneric_shlib = NULL, *cgeneric_model = NULL;
	double **log_prec = NULL, **log_prec0 = NULL, **log_prec1 = NULL, **log_prec2, **phi_intern = NULL, **rho_intern =
	    NULL, **group_rho_intern = NULL, **group_prec_intern = NULL, **rho_intern01 = NULL, **rho_intern02 =
	    NULL, **rho_intern12 = NULL, **range_intern = NULL, tmp, **beta_intern = NULL, **beta = NULL, **h2_intern =
	    NULL, **a_intern = NULL, ***theta_iidwishart = NULL, **log_diag, rd, **mean_x = NULL, **log_prec_x =
	    NULL, ***pacf_intern = NULL, slm_rho_min = 0.0, slm_rho_max = 0.0, **log_halflife = NULL, **log_shape = NULL, **alpha =
	    NULL, **gama = NULL, **alpha1 = NULL, **alpha2 = NULL, **H_intern = NULL, **nu_intern, ***intslope_gamma = NULL;

	lt_dlhandle handle;
	inla_cgeneric_func_tp *model_func = NULL;
	inla_cgeneric_data_tp *cgeneric_data = NULL;

	GMRFLib_matrix_tp *intslope_def = NULL;
	GMRFLib_crwdef_tp *crwdef = NULL;
	inla_spde_tp *spde_model = NULL;
	inla_spde_tp *spde_model_orig = NULL;
	inla_spde2_tp *spde2_model = NULL;
	inla_spde2_tp *spde2_model_orig = NULL;
	inla_spde3_tp *spde3_model = NULL;
	inla_spde3_tp *spde3_model_orig = NULL;

	int thread_id = 0;
	assert(omp_get_thread_num() == 0);

	if (mb->verbose) {
		printf("\tinla_parse_ffield...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\tsection=[%s]\n", secname);
	}
	mb->f_tag = Realloc(mb->f_tag, mb->nf + 1, char *);
	mb->f_dir = Realloc(mb->f_dir, mb->nf + 1, char *);
	mb->f_modelname = Realloc(mb->f_modelname, mb->nf + 1, char *);
	mb->f_c = Realloc(mb->f_c, mb->nf + 1, int *);
	mb->f_n = Realloc(mb->f_n, mb->nf + 1, int);
	mb->f_N = Realloc(mb->f_N, mb->nf + 1, int);
	mb->f_Ntotal = Realloc(mb->f_Ntotal, mb->nf + 1, int);
	mb->f_order = Realloc(mb->f_order, mb->nf + 1, int);
	mb->f_nrep = Realloc(mb->f_nrep, mb->nf + 1, int);
	mb->f_ngroup = Realloc(mb->f_ngroup, mb->nf + 1, int);
	mb->f_group_model = Realloc(mb->f_group_model, mb->nf + 1, int);
	mb->f_group_cyclic = Realloc(mb->f_group_cyclic, mb->nf + 1, int);
	mb->f_group_order = Realloc(mb->f_group_order, mb->nf + 1, int);
	mb->f_group_graph = Realloc(mb->f_group_graph, mb->nf + 1, GMRFLib_graph_tp *);
	mb->f_nrow = Realloc(mb->f_nrow, mb->nf + 1, int);
	mb->f_ncol = Realloc(mb->f_ncol, mb->nf + 1, int);
	mb->f_locations = Realloc(mb->f_locations, mb->nf + 1, double *);
	mb->f_weights = Realloc(mb->f_weights, mb->nf + 1, double *);
	mb->f_scale = Realloc(mb->f_scale, mb->nf + 1, double *);
	mb->f_Qfunc = Realloc(mb->f_Qfunc, mb->nf + 1, GMRFLib_Qfunc_tp *);
	mb->f_Qfunc_orig = Realloc(mb->f_Qfunc_orig, mb->nf + 1, GMRFLib_Qfunc_tp *);
	mb->f_Qfunc_arg = Realloc(mb->f_Qfunc_arg, mb->nf + 1, void *);
	mb->f_Qfunc_arg_orig = Realloc(mb->f_Qfunc_arg_orig, mb->nf + 1, void *);
	mb->f_bfunc2 = Realloc(mb->f_bfunc2, mb->nf + 1, GMRFLib_bfunc2_tp *);
	mb->f_graph = Realloc(mb->f_graph, mb->nf + 1, GMRFLib_graph_tp *);
	mb->f_graph_orig = Realloc(mb->f_graph_orig, mb->nf + 1, GMRFLib_graph_tp *);
	mb->f_prior = Realloc(mb->f_prior, mb->nf + 1, Prior_tp *);
	mb->f_sumzero = Realloc(mb->f_sumzero, mb->nf + 1, char);
	mb->f_constr = Realloc(mb->f_constr, mb->nf + 1, GMRFLib_constr_tp *);
	mb->f_constr_orig = Realloc(mb->f_constr_orig, mb->nf + 1, GMRFLib_constr_tp *);
	mb->f_diag = Realloc(mb->f_diag, mb->nf + 1, double);
	mb->f_compute = Realloc(mb->f_compute, mb->nf + 1, int);
	mb->f_fixed = Realloc(mb->f_fixed, mb->nf + 1, int *);
	mb->f_initial = Realloc(mb->f_initial, mb->nf + 1, double *);
	mb->f_rankdef = Realloc(mb->f_rankdef, mb->nf + 1, double);
	mb->f_id = Realloc(mb->f_id, mb->nf + 1, inla_component_tp);
	mb->f_ntheta = Realloc(mb->f_ntheta, mb->nf + 1, int);
	mb->f_cyclic = Realloc(mb->f_cyclic, mb->nf + 1, int);
	mb->f_nu = Realloc(mb->f_nu, mb->nf + 1, int);
	mb->f_Torder = Realloc(mb->f_Torder, mb->nf + 1, int);
	mb->f_Tmodel = Realloc(mb->f_Tmodel, mb->nf + 1, char *);
	mb->f_Korder = Realloc(mb->f_Korder, mb->nf + 1, int);
	mb->f_Kmodel = Realloc(mb->f_Kmodel, mb->nf + 1, char *);
	mb->f_model = Realloc(mb->f_model, mb->nf + 1, void *);
	mb->f_theta = Realloc(mb->f_theta, mb->nf + 1, double ***);
	mb->f_theta_map = Realloc(mb->f_theta_map, mb->nf + 1, map_func_tp **);
	mb->f_theta_map_arg = Realloc(mb->f_theta_map_arg, mb->nf + 1, void **);
	mb->f_of = Realloc(mb->f_of, mb->nf + 1, char *);
	mb->f_same_as = Realloc(mb->f_same_as, mb->nf + 1, char *);
	mb->f_precision = Realloc(mb->f_precision, mb->nf + 1, double);
	mb->f_output = Realloc(mb->f_output, mb->nf + 1, Output_tp *);
	mb->f_id_names = Realloc(mb->f_id_names, mb->nf + 1, inla_file_contents_tp *);
	mb->f_correct = Realloc(mb->f_correct, mb->nf + 1, int);
	mb->f_vb_correct = Realloc(mb->f_vb_correct, mb->nf + 1, GMRFLib_idx_tp *);

	/*
	 * set everything to `ZERO' initially 
	 */
	_SET(c, NULL);
	_SET(n, 0);
	_SET(N, 0);
	_SET(Ntotal, 0);
	_SET(order, -1);
	_SET(nrow, 0);
	_SET(ncol, 0);
	_SET(locations, NULL);
	_SET(weights, NULL);				       /* this means default weights = 1 */
	_SET(scale, NULL);
	_SET(Qfunc, (GMRFLib_Qfunc_tp *) NULL);
	_SET(Qfunc_orig, (GMRFLib_Qfunc_tp *) NULL);
	_SET(Qfunc_arg, NULL);
	_SET(Qfunc_arg_orig, NULL);
	_SET(bfunc2, NULL);
	_SET(graph, NULL);
	_SET(graph_orig, NULL);
	_SET(prior, NULL);
	_SET(sumzero, 0);
	_SET(constr, NULL);
	_SET(constr_orig, NULL);
	_SET(diag, 0.0);
	_SET(compute, 1);
	_SET(fixed, NULL);
	_SET(initial, NULL);
	_SET(rankdef, 0);
	_SET(output, NULL);
	_SET(id, INVALID_COMPONENT);
	_SET(ntheta, 0);
	_SET(theta, NULL);
	_SET(cyclic, 0);
	_SET(nu, -1);
	_SET(Tmodel, NULL);
	_SET(Torder, -1);
	_SET(Kmodel, NULL);
	_SET(Korder, -1);
	_SET(of, NULL);
	_SET(precision, exp(14.0));
	_SET(nrep, 1);
	_SET(ngroup, 1);
	_SET(group_model, G_EXCHANGEABLE);
	_SET(group_cyclic, 0);
	_SET(group_order, 0);
	_SET(group_graph, NULL);
	_SET(id_names, NULL);
	_SET(correct, -1);
	_SET(vb_correct, NULL);

	sprintf(default_tag, "default tag for ffield %d", mb->nf);
	mb->f_tag[mb->nf] = GMRFLib_strdup((secname ? secname : default_tag));
	mb->f_dir[mb->nf] = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "DIR"), GMRFLib_strdup(mb->f_tag[mb->nf])));
	if (mb->verbose) {
		printf("\t\tdir=[%s]\n", mb->f_dir[mb->nf]);
	}
	/*
	 * Somewhere, I might need to know this upfront... 
	 */
	HYPER_NEW(log_prec, 0.0);
	HYPER_NEW(log_prec0, 0.0);
	HYPER_NEW(log_prec1, 0.0);
	HYPER_NEW(log_prec2, 0.0);
	HYPER_NEW(H_intern, 0.0);
	HYPER_NEW(phi_intern, 0.0);
	HYPER_NEW(rho_intern, 0.0);
	HYPER_NEW(rho_intern01, 0.0);
	HYPER_NEW(rho_intern02, 0.0);
	HYPER_NEW(rho_intern12, 0.0);
	HYPER_NEW(range_intern, 0.0);
	HYPER_NEW(beta_intern, 0.0);
	HYPER_NEW(beta, 1.0);
	HYPER_NEW(group_rho_intern, 0.0);
	HYPER_NEW(group_prec_intern, 0.0);
	HYPER_NEW(h2_intern, 0.0);
	HYPER_NEW(a_intern, 0.0);
	HYPER_NEW(log_diag, 0.0);
	HYPER_NEW(mean_x, 0.0);
	HYPER_NEW(log_prec_x, 0.0);
	HYPER_NEW(log_halflife, 0.0);
	HYPER_NEW(log_shape, 0.0);
	HYPER_NEW(alpha, 0.0);
	HYPER_NEW(alpha1, 0.0);
	HYPER_NEW(alpha2, 0.0);
	HYPER_NEW(gama, 0.0);
	HYPER_NEW(nu_intern, 0.0);

	/*
	 * start parsing 
	 */
	model = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "MODEL"), NULL));
	if (mb->verbose) {
		printf("\t\tmodel=[%s]\n", model);
	}

	if (_OneOf("RW2D")) {
		mb->f_id[mb->nf] = F_RW2D;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Random walk 2D");
	} else if (_OneOf("RW2DIID")) {
		mb->f_id[mb->nf] = F_RW2DIID;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Random walk 2DIID");
	} else if (_OneOf("BESAG")) {
		mb->f_id[mb->nf] = F_BESAG;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Besags ICAR model");
	} else if (_OneOf("BESAG2")) {
		mb->f_id[mb->nf] = F_BESAG2;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Besags ICAR model for joint models");
	} else if (_OneOf("BYM")) {
		mb->f_id[mb->nf] = F_BYM;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("BYM model");
	} else if (_OneOf("BYM2")) {
		mb->f_id[mb->nf] = F_BYM2;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("BYM2 model");
	} else if (_OneOf("BESAGPROPER")) {
		mb->f_id[mb->nf] = F_BESAGPROPER;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Proper version of Besags ICAR model");
	} else if (_OneOf("BESAGPROPER2")) {
		mb->f_id[mb->nf] = F_BESAGPROPER2;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Proper version of Besags ICAR model version 2");
	} else if (_OneOf2("GENERIC", "GENERIC0")) {
		mb->f_id[mb->nf] = F_GENERIC0;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Generic0 model");
	} else if (_OneOf("GENERIC1")) {
		mb->f_id[mb->nf] = F_GENERIC1;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Generic1 model");
	} else if (_OneOf("GENERIC2")) {
		mb->f_id[mb->nf] = F_GENERIC2;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Generic2 model");
	} else if (_OneOf("GENERIC3")) {
		mb->f_id[mb->nf] = F_GENERIC3;
		mb->f_ntheta[mb->nf] = GENERIC3_MAXTHETA;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Generic3 model");
	} else if (_OneOf("SEASONAL")) {
		mb->f_id[mb->nf] = F_SEASONAL;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Seasonal model");
	} else if (_OneOf("IID")) {
		mb->f_id[mb->nf] = F_IID;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("IID model");
	} else if (_OneOf("IID1D")) {
		mb->f_id[mb->nf] = F_IID1D;
		mb->f_ntheta[mb->nf] = inla_iid_wishart_nparam(WISHART_DIM(mb->nf));
		mb->f_modelname[mb->nf] = GMRFLib_strdup("IID1D model");
	} else if (_OneOf("IID2D")) {
		mb->f_id[mb->nf] = F_IID2D;
		mb->f_ntheta[mb->nf] = inla_iid_wishart_nparam(WISHART_DIM(mb->nf));
		mb->f_modelname[mb->nf] = GMRFLib_strdup("IID2D model");
	} else if (_OneOf("IID3D")) {
		mb->f_id[mb->nf] = F_IID3D;
		mb->f_ntheta[mb->nf] = inla_iid_wishart_nparam(WISHART_DIM(mb->nf));
		mb->f_modelname[mb->nf] = GMRFLib_strdup("IID3D model");
	} else if (_OneOf("IID4D")) {
		mb->f_id[mb->nf] = F_IID4D;
		mb->f_ntheta[mb->nf] = inla_iid_wishart_nparam(WISHART_DIM(mb->nf));
		mb->f_modelname[mb->nf] = GMRFLib_strdup("IID4D model");
	} else if (_OneOf("IID5D")) {
		mb->f_id[mb->nf] = F_IID5D;
		mb->f_ntheta[mb->nf] = inla_iid_wishart_nparam(WISHART_DIM(mb->nf));
		mb->f_modelname[mb->nf] = GMRFLib_strdup("IID5D model");
	} else if (_OneOf("IIDKD")) {
		mb->f_id[mb->nf] = F_IIDKD;
		mb->f_order[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "ORDER"), 0);
		mb->f_ntheta[mb->nf] = INLA_WISHARTK_NTHETA(mb->f_order[mb->nf]);
		mb->f_modelname[mb->nf] = GMRFLib_strdup("IIDKD model");
	} else if (_OneOf("2DIID")) {
		mb->f_id[mb->nf] = F_2DIID;
		mb->f_ntheta[mb->nf] = 3;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("2DIID model");
	} else if (_OneOf("INTSLOPE")) {
		mb->f_id[mb->nf] = F_INTSLOPE;
		mb->f_ntheta[mb->nf] = inla_iid_wishart_nparam(2L) + INTSLOPE_MAXTHETA;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("INTSLOPE model");
	} else if (_OneOf("MEC")) {
		mb->f_id[mb->nf] = F_MEC;
		mb->f_ntheta[mb->nf] = 4;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("MEC");
	} else if (_OneOf("MEB")) {
		mb->f_id[mb->nf] = F_MEB;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("MEB");
	} else if (_OneOf("RGENERIC")) {
		mb->f_id[mb->nf] = F_R_GENERIC;
		mb->f_ntheta[mb->nf] = -1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("RGeneric2");
	} else if (_OneOf("CGENERIC")) {
		mb->f_id[mb->nf] = F_C_GENERIC;
		mb->f_ntheta[mb->nf] = -1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("CGeneric");
	} else if (_OneOf("RW1")) {
		mb->f_id[mb->nf] = F_RW1;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("RW1 model");
	} else if (_OneOf("RW2")) {
		mb->f_id[mb->nf] = F_RW2;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("RW2 model");
	} else if (_OneOf("CRW2")) {
		mb->f_id[mb->nf] = F_CRW2;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("CRW2 model");
	} else if (_OneOf("AR1")) {
		mb->f_id[mb->nf] = F_AR1;
		mb->f_ntheta[mb->nf] = 3;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("AR1 model");
	} else if (_OneOf("AR1C")) {
		mb->f_id[mb->nf] = F_AR1C;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("AR1C model");
	} else if (_OneOf("FGN")) {
		mb->f_id[mb->nf] = F_FGN;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("FGN model");
	} else if (_OneOf("FGN2")) {
		mb->f_id[mb->nf] = F_FGN2;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("FGN2 model");
	} else if (_OneOf("OU")) {
		mb->f_id[mb->nf] = F_OU;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Ornstein-Uhlenbeck model");
	} else if (_OneOf("MATERN2D")) {
		mb->f_id[mb->nf] = F_MATERN2D;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Matern2D model");
	} else if (_OneOf("DMATERN")) {
		mb->f_id[mb->nf] = F_DMATERN;
		mb->f_ntheta[mb->nf] = 3;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("DMatern model");
	} else if (_OneOf("Z")) {
		mb->f_id[mb->nf] = F_Z;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Z model");
	} else if (_OneOf("SLM")) {
		mb->f_id[mb->nf] = F_SLM;
		mb->f_ntheta[mb->nf] = 2;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("SLM model");
	} else if (_OneOf("SPDE")) {
		mb->f_id[mb->nf] = F_SPDE;
		mb->f_ntheta[mb->nf] = 4;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("SPDE model");
	} else if (_OneOf("SPDE2")) {
		mb->f_id[mb->nf] = F_SPDE2;
		mb->f_ntheta[mb->nf] = -1;		       /* Not known yet */
		mb->f_modelname[mb->nf] = GMRFLib_strdup("SPDE2 model");
	} else if (_OneOf("SPDE3")) {
		mb->f_id[mb->nf] = F_SPDE3;
		mb->f_ntheta[mb->nf] = -1;		       /* Not known yet */
		mb->f_modelname[mb->nf] = GMRFLib_strdup("SPDE3 model");
	} else if (_OneOf("AR")) {
		mb->f_id[mb->nf] = F_AR;
		mb->f_ntheta[mb->nf] = AR_MAXTHETA + 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("AR(p) model");
	} else if (_OneOf("COPY")) {
		mb->f_id[mb->nf] = F_COPY;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Copy");
	} else if (_OneOf("CLINEAR")) {
		mb->f_id[mb->nf] = F_CLINEAR;
		mb->f_ntheta[mb->nf] = 1;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Constrained linear");
	} else if (_OneOf("LOG1EXP")) {
		mb->f_id[mb->nf] = F_LOG1EXP;
		mb->f_ntheta[mb->nf] = 3;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Log1Exp");
	} else if (_OneOf("LOGDIST")) {
		mb->f_id[mb->nf] = F_LOGDIST;
		mb->f_ntheta[mb->nf] = 3;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("LogDist");
	} else if (_OneOf("SIGM")) {
		mb->f_id[mb->nf] = F_SIGM;
		mb->f_ntheta[mb->nf] = 3;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Sigmodial");
	} else if (_OneOf("REVSIGM")) {
		mb->f_id[mb->nf] = F_REVSIGM;
		mb->f_ntheta[mb->nf] = 3;
		mb->f_modelname[mb->nf] = GMRFLib_strdup("Reverse sigmodial");
	} else {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, "model", model);
	}
	if (mb->f_ntheta[mb->nf] > 0) {
		mb->f_prior[mb->nf] = Calloc(mb->f_ntheta[mb->nf], Prior_tp);
		mb->f_fixed[mb->nf] = Calloc(mb->f_ntheta[mb->nf], int);
		mb->f_theta[mb->nf] = Calloc(mb->f_ntheta[mb->nf], double **);
	} else {
		mb->f_prior[mb->nf] = NULL;
		mb->f_fixed[mb->nf] = NULL;
		mb->f_theta[mb->nf] = NULL;
	}

	/*
	 * just allocate this here, as its needed all over 
	 */
	if (mb->f_ntheta[mb->nf] > 0) {
		mb->f_initial[mb->nf] = Calloc(mb->f_ntheta[mb->nf], double);
	}

	id = mb->f_id[mb->nf];				       /* shortcut */

	switch (id) {
	case F_RW2D:
	case F_BESAG:
	case F_GENERIC0:
	case F_SEASONAL:
	case F_IID:
	case F_RW1:
	case F_RW2:
	case F_CRW2:
	case F_Z:
	{
		inla_read_prior(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);
	}
		break;

	case F_SLM:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	// kappa
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "NORMAL", NULL);	// rho
	}
		break;

	case F_BESAG2:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	// kappa
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "NORMAL-a", NULL);	// a
	}
		break;

	case F_BESAGPROPER:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	// precision
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "LOGGAMMA", NULL);	// weight
	}
		break;

	case F_BESAGPROPER2:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	// precision
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "GAUSSIAN", NULL);	// lambda
	}
		break;

	case F_SPDE:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "NORMAL", NULL);	// T[0]
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "NORMAL", NULL);	// K[0]
		inla_read_prior2(mb, ini, sec, &(mb->f_prior[mb->nf][2]), "NORMAL", NULL);	// the rest
		inla_read_prior3(mb, ini, sec, &(mb->f_prior[mb->nf][3]), "FLAT", NULL);	// the ocillating cooef
	}
		break;

	case F_SPDE2:
	{
		mb->f_prior[mb->nf] = Calloc(1, Prior_tp);
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "MVNORM", NULL);	// Just one prior...
	}
		break;

	case F_SPDE3:
	{
		mb->f_prior[mb->nf] = Calloc(1, Prior_tp);
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "MVNORM", NULL);	// Just one prior...
	}
		break;

	case F_AR:
	{
		mb->f_prior[mb->nf] = Calloc(11, Prior_tp);
		assert(11 == AR_MAXTHETA + 1);
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "PCPREC", NULL);	// log precision
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "PCRHO0", NULL);	// the pacf
		inla_read_prior2(mb, ini, sec, &(mb->f_prior[mb->nf][2]), "PCRHO0", NULL);	// the pacf
		inla_read_prior3(mb, ini, sec, &(mb->f_prior[mb->nf][3]), "PCRHO0", NULL);	// the pacf
		inla_read_prior4(mb, ini, sec, &(mb->f_prior[mb->nf][4]), "PCRHO0", NULL);	// the pacf
		inla_read_prior5(mb, ini, sec, &(mb->f_prior[mb->nf][5]), "PCRHO0", NULL);	// the pacf
		inla_read_prior6(mb, ini, sec, &(mb->f_prior[mb->nf][6]), "PCRHO0", NULL);	// the pacf
		inla_read_prior7(mb, ini, sec, &(mb->f_prior[mb->nf][7]), "PCRHO0", NULL);	// the pacf
		inla_read_prior8(mb, ini, sec, &(mb->f_prior[mb->nf][8]), "PCRHO0", NULL);	// the pacf
		inla_read_prior9(mb, ini, sec, &(mb->f_prior[mb->nf][9]), "PCRHO0", NULL);	// the pacf
		inla_read_prior10(mb, ini, sec, &(mb->f_prior[mb->nf][10]), "PCRHO0", NULL);	// the pacf
	}
		break;

	case F_COPY:
	{
		inla_read_prior(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "NORMAL-1", NULL);
	}
		break;

	case F_CLINEAR:
	{
		inla_read_prior(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "NORMAL", NULL);
	}
		break;

	case F_LOG1EXP:
	case F_LOGDIST:
	case F_SIGM:
	case F_REVSIGM:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "NORMAL", NULL);	// beta
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "NORMAL", NULL);	// log_halflife
		inla_read_prior2(mb, ini, sec, &(mb->f_prior[mb->nf][2]), "NORMAL", NULL);	// log_shape
	}
		break;

	case F_IID1D:
	case F_IID2D:
	case F_IID3D:
	case F_IID4D:
	case F_IID5D:
	{
		int dim = WISHART_DIM(mb->nf);
		assert(dim > 0);
		char *pri, *par, *to_theta, *from_theta, *prifunc, *hyperid;
		int nt = inla_iid_wishart_nparam(dim);

		GMRFLib_sprintf(&prifunc, "WISHART%1dD", dim);
		int kk;
		if (dim > 1) {
			for (kk = 0; kk < nt; kk++) {
				GMRFLib_sprintf(&pri, "PRIOR%1d", kk);
				GMRFLib_sprintf(&par, "PARAMETERS%1d", kk);
				GMRFLib_sprintf(&from_theta, "FROM.THETA%1d", kk);
				GMRFLib_sprintf(&to_theta, "TO.THETA%1d", kk);
				GMRFLib_sprintf(&hyperid, "HYPERID%1d", kk);
				inla_read_prior_generic(mb, ini, sec, &(mb->f_prior[mb->nf][kk]), pri, par, from_theta, to_theta,
							hyperid, (kk == 0 ? prifunc : "NONE"), NULL);

				Free(pri);
				Free(par);
				Free(from_theta);
				Free(to_theta);
				Free(hyperid);
			}
		} else {
			kk = 0;
			GMRFLib_sprintf(&pri, "PRIOR");
			GMRFLib_sprintf(&par, "PARAMETERS");
			GMRFLib_sprintf(&from_theta, "FROM.THETA");
			GMRFLib_sprintf(&to_theta, "TO.THETA");
			GMRFLib_sprintf(&hyperid, "HYPERID");
			inla_read_prior_generic(mb, ini, sec, &(mb->f_prior[mb->nf][kk]), pri, par, from_theta, to_theta, hyperid,
						(kk == 0 ? prifunc : "NONE"), NULL);
		}

		Free(pri);
		Free(par);
	}
		break;

	case F_IIDKD:
	{
		int dim = mb->f_order[mb->nf];
		assert(dim >= INLA_WISHARTK_KMIN);
		assert(dim <= INLA_WISHARTK_KMAX);
		char *pri, *par, *to_theta, *from_theta, *prifunc, *hyperid;
		int nt_max = INLA_WISHARTK_NTHETA(INLA_WISHARTK_KMAX);
		int nt = INLA_WISHARTK_NTHETA(dim);

		GMRFLib_sprintf(&prifunc, "WISHARTK%1dD", dim);
		int kk;
		for (kk = 0; kk < nt_max; kk++) {
			GMRFLib_sprintf(&pri, "PRIOR%1d", kk);
			GMRFLib_sprintf(&par, "PARAMETERS%1d", kk);
			GMRFLib_sprintf(&from_theta, "FROM.THETA%1d", kk);
			GMRFLib_sprintf(&to_theta, "TO.THETA%1d", kk);
			GMRFLib_sprintf(&hyperid, "HYPERID%1d", kk);
			if (kk < nt) {
				inla_read_prior_generic(mb, ini, sec, &(mb->f_prior[mb->nf][kk]), pri, par, from_theta, to_theta,
							hyperid, (kk == 0 ? prifunc : "NONE"), NULL);
			} else {
				// mark them as read
				iniparser_getstring(ini, inla_string_join(secname, pri), NULL);
				iniparser_getstring(ini, inla_string_join(secname, par), NULL);
				iniparser_getstring(ini, inla_string_join(secname, from_theta), NULL);
				iniparser_getstring(ini, inla_string_join(secname, to_theta), NULL);
				iniparser_getstring(ini, inla_string_join(secname, hyperid), NULL);
			}

			Free(pri);
			Free(par);
			Free(from_theta);
			Free(to_theta);
			Free(hyperid);
		}
	}
		break;

	case F_INTSLOPE:
	{
		char *pri, *par, *to_theta, *from_theta, *prifunc, *hyperid;
		int dim = 2;
		GMRFLib_sprintf(&prifunc, "WISHART%1dD", dim);
		for (int kk = 0; kk < mb->f_ntheta[mb->nf]; kk++) {
			GMRFLib_sprintf(&pri, "PRIOR%1d", kk);
			GMRFLib_sprintf(&par, "PARAMETERS%1d", kk);
			GMRFLib_sprintf(&from_theta, "FROM.THETA%1d", kk);
			GMRFLib_sprintf(&to_theta, "TO.THETA%1d", kk);
			GMRFLib_sprintf(&hyperid, "HYPERID%1d", kk);
			inla_read_prior_generic(mb, ini, sec, &(mb->f_prior[mb->nf][kk]), pri, par, from_theta, to_theta,
						hyperid, (kk == 0 ? prifunc : "NONE"), NULL);

			Free(pri);
			Free(par);
			Free(from_theta);
			Free(to_theta);
			Free(hyperid);
		}
	}
		break;

	case F_BYM:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* precision0 iid */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "LOGGAMMA", NULL);	/* precision1 spatial */
	}
		break;

	case F_BYM2:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "GAUSSIAN", NULL);	/* phi */
	}
		break;

	case F_RW2DIID:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "GAUSSIAN", NULL);	/* phi */
	}
		break;

	case F_AR1:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* marginal precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "GAUSSIAN-rho", NULL);	/* phi (lag-1 correlation) */
		inla_read_prior2(mb, ini, sec, &(mb->f_prior[mb->nf][2]), "GAUSSIAN", NULL);	/* mean */
	}
		break;

	case F_AR1C:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* marginal precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "GAUSSIAN-rho", NULL);	/* phi (lag-1 correlation) */
	}
		break;

	case F_FGN:
	case F_FGN2:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* marginal precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "GAUSSIAN", NULL);	/* H */
	}
		break;

	case F_OU:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* marginal precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "GAUSSIAN", NULL);	/* log(phi) */
	}
		break;

	case F_GENERIC1:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "GAUSSIAN", NULL);	/* beta */
	}
		break;

	case F_GENERIC2:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* precision Cmatrix */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "LOGGAMMA", NULL);	/* the other precision, but theta1 = h^2 */
	}
		break;

	case F_GENERIC3:
	{
		for (i = 0; i < GENERIC3_MAXTHETA; i++) {
			inla_read_priorN(mb, ini, sec, &(mb->f_prior[mb->nf][i]), "LOGGAMMA", i, NULL);
		}
	}
		break;

	case F_2DIID:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* precision0 */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "LOGGAMMA", NULL);	/* precision1 */
		inla_read_prior2(mb, ini, sec, &(mb->f_prior[mb->nf][2]), "GAUSSIAN-rho", NULL);	/* rho */
	}
		break;

	case F_MATERN2D:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "LOGGAMMA", NULL);	/* range */
	}
		break;

	case F_DMATERN:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "LOGGAMMA", NULL);	/* precision */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "LOGGAMMA", NULL);	/* range */
		inla_read_prior2(mb, ini, sec, &(mb->f_prior[mb->nf][2]), "LOGGAMMA", NULL);	/* nu */
	}
		break;

	case F_MEC:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "NORMAL", NULL);	/* beta */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "LOGGAMMA", NULL);	/* prec.u */
		inla_read_prior2(mb, ini, sec, &(mb->f_prior[mb->nf][2]), "NORMAL", NULL);	/* mean */
		inla_read_prior3(mb, ini, sec, &(mb->f_prior[mb->nf][3]), "LOGGAMMA", NULL);	/* prec.x */
	}
		break;

	case F_MEB:
	{
		inla_read_prior0(mb, ini, sec, &(mb->f_prior[mb->nf][0]), "NORMAL", NULL);	/* beta */
		inla_read_prior1(mb, ini, sec, &(mb->f_prior[mb->nf][1]), "LOGGAMMA", NULL);	/* prec.u */
	}
		break;

	case F_R_GENERIC:
	case F_C_GENERIC:
		break;

	default:
		abort();
	}

	char *str = iniparser_getstring(ini, inla_string_join(secname, "VB.CORRECT"), NULL);
	int *idxs = NULL;
	int n_idxs = 0;
	inla_sread_ints_q(&idxs, &n_idxs, str);
	if (n_idxs == 0) {
		GMRFLib_idx_add(&(mb->f_vb_correct[mb->nf]), -1);
	} else {
		for (int i = 0; i < n_idxs; i++) {
			GMRFLib_idx_add(&(mb->f_vb_correct[mb->nf]), idxs[i]);
		}
	}
	if (mb->verbose) {
		printf("\t\tvb.correct n[%1d] ", mb->f_vb_correct[mb->nf]->n);
		for (int i = 0; i < mb->f_vb_correct[mb->nf]->n; i++) {
			printf(" %1d", mb->f_vb_correct[mb->nf]->idx[i]);
		}
		printf("\n");
	}
	mb->f_correct[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "CORRECT"), -1);
	if (mb->verbose) {
		printf("\t\tcorrect=[%1d]\n", mb->f_correct[mb->nf]);
	}
	mb->f_sumzero[mb->nf] = (char) iniparser_getboolean(ini, inla_string_join(secname, "CONSTRAINT"), 0);
	if (mb->verbose) {
		printf("\t\tconstr=[%1d]\n", mb->f_sumzero[mb->nf]);
	}
	mb->f_diag[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "DIAGONAL"), 0.0);
	if (mb->verbose) {
		printf("\t\tdiagonal=[%g]\n", mb->f_diag[mb->nf]);
	}
	mb->f_id_names[mb->nf] = inla_read_file_contents(GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "ID.NAMES"), NULL)));
	if (mb->verbose) {
		printf("\t\tid.names=%s\n", (mb->f_id_names[mb->nf] ? "<read>" : "<not present>"));
	}

	mb->f_compute[mb->nf] = iniparser_getboolean(ini, inla_string_join(secname, "COMPUTE"), 1);
	if (G.mode == INLA_MODE_HYPER) {
		if (mb->f_compute[mb->nf]) {
			fprintf(stderr, "*** Warning: HYPER_MODE require f_compute[%1d] = 0\n", mb->nf);
		}
		mb->f_compute[mb->nf] = 0;
	}
	if (mb->verbose) {
		printf("\t\tcompute=[%1d]\n", mb->f_compute[mb->nf]);
	}
	if (mb->f_ntheta[mb->nf] == 1) {
		mb->f_fixed[mb->nf][0] = iniparser_getboolean(ini, inla_string_join(secname, "FIXED"), 0);
	} else {
		/*
		 * reads FIXED0, FIXED1, FIXED2, etc.... 
		 */
		for (i = 0; i < mb->f_ntheta[mb->nf]; i++) {
			char *fixname;

			GMRFLib_sprintf(&fixname, "FIXED%1d", i);
			mb->f_fixed[mb->nf][i] = iniparser_getboolean(ini, inla_string_join(secname, fixname), 0);
			Free(fixname);
		}
	}

	mb->f_nrep[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "NREP"), mb->f_nrep[mb->nf]);
	mb->f_ngroup[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "NGROUP"), mb->f_ngroup[mb->nf]);
	if (mb->verbose) {
		printf("\t\tnrep=[%1d]\n", mb->f_nrep[mb->nf]);
		printf("\t\tngroup=[%1d]\n", mb->f_ngroup[mb->nf]);
	}

	/*
	 * to avoid errors from the R-interface. This just mark them as 'read'. For some reason file_loc is fine here, but later on it just return "", FIXME! 
	 */
	ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
	file_loc = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "LOCATIONS"), NULL));

	if ((mb->f_id[mb->nf] == F_MATERN2D) || (mb->f_id[mb->nf] == F_RW2D) || (mb->f_id[mb->nf] == F_RW2DIID)) {
		/*
		 * this case is a bit special....
		 *
		 * if predictor->nrow exists this is the default and must be equal if NROW exists. same with NCOL.
		 */
		char *tmp_nrow = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "NROW"), NULL));
		char *tmp_ncol = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "NCOL"), NULL));

		if (!tmp_nrow) {
			inla_error_missing_required_field(__GMRFLib_FuncName, secname, "nrow");
		} else {
			if (inla_sread_ints(&(mb->f_nrow[mb->nf]), 1, tmp_nrow) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "nrow", tmp_nrow);
			}
			if (mb->f_nrow[mb->nf] <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "nrow", tmp_nrow);
			}
		}
		if (!tmp_ncol) {
			inla_error_missing_required_field(__GMRFLib_FuncName, secname, "ncol");
		} else {
			if (inla_sread_ints(&(mb->f_ncol[mb->nf]), 1, tmp_ncol) == INLA_FAIL) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "ncol", tmp_ncol);
			}
			if (mb->f_ncol[mb->nf] <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "ncol", tmp_ncol);
			}
		}
		mb->f_N[mb->nf] = mb->f_n[mb->nf] = mb->f_nrow[mb->nf] * mb->f_ncol[mb->nf];
		if (mb->f_id[mb->nf] == F_RW2DIID) {
			/*
			 * we need this for the RW2DIID model otherwise the locations are not set correctly (the length is wrong...)
			 */
			mb->f_N[mb->nf] = 2 * mb->f_n[mb->nf];
		}

		if (mb->verbose) {
			printf("\t\tnrow[%1d] x ncol[%1d] = n[%1d] \n", mb->f_nrow[mb->nf], mb->f_ncol[mb->nf], mb->f_n[mb->nf]);
		}
		mb->f_cyclic[mb->nf] = iniparser_getboolean(ini, inla_string_join(secname, "CYCLIC"), 0);
		if (mb->verbose) {
			printf("\t\tcyclic=[%1d]\n", mb->f_cyclic[mb->nf]);
		}

		bvalue = iniparser_getint(ini, inla_string_join(secname, "BVALUE"), GMRFLib_BVALUE_DEFAULT);
		if (bvalue != GMRFLib_BVALUE_DEFAULT && bvalue != GMRFLib_BVALUE_ZERO) {
			GMRFLib_sprintf(&msg, "%d", bvalue);
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "BVALUE", (const char *) msg);
		}
		if (mb->verbose) {
			printf("\t\tbvalue=[%s]\n", (bvalue == GMRFLib_BVALUE_DEFAULT ? "Default" : "Zero outside"));
		}
		/*
		 * read the covariates 
		 */
		filenamec = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "COVARIATES"), NULL));
		if (!filenamec) {
			inla_error_missing_required_field(__GMRFLib_FuncName, secname, "covariates");
		}
		if (mb->verbose) {
			printf("\t\tread covariates from file=[%s]\n", filenamec);
		}
		inla_read_data_general(NULL, &(mb->f_c[mb->nf]), &nc, filenamec, mb->predictor_n, 0, 1, mb->verbose, -1.0);

		/*
		 * read weights 
		 */
		filenamec = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "WEIGHTS"), NULL));
		if (!filenamec) {
			mb->f_weights[mb->nf] = NULL;	       /* default */
		} else {
			if (mb->verbose) {
				printf("\t\tread weights from file=[%s]\n", filenamec);
			}
			inla_read_data_general(&(mb->f_weights[mb->nf]), NULL, NULL, filenamec, mb->predictor_n, 0, 1, mb->verbose, 1.0);
		}
	} else {
		/*
		 * read the covariates 
		 */
		filenamec = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "COVARIATES"), NULL));
		if (!filenamec) {
			inla_error_missing_required_field(__GMRFLib_FuncName, secname, "covariates");
		}
		if (mb->verbose) {
			printf("\t\tread covariates from file=[%s]\n", filenamec);
		}
		inla_read_data_general(NULL, &(mb->f_c[mb->nf]), &nc, filenamec, mb->predictor_n, 0, 1, mb->verbose, -1.0);

		/*
		 * read weights 
		 */
		filenamec = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "WEIGHTS"), NULL));
		if (!filenamec) {
			mb->f_weights[mb->nf] = NULL;
		} else {
			if (mb->verbose) {
				printf("\t\tread weights from file=[%s]\n", filenamec);
			}
			inla_read_data_general(&(mb->f_weights[mb->nf]), NULL, NULL, filenamec, mb->predictor_n, 0, 1, mb->verbose, 1.0);
		}

		switch (mb->f_id[mb->nf]) {
		case F_GENERIC0:
		{
			/*
			 * use field: QMATRIX to set both graph and n.
			 */
			GMRFLib_tabulate_Qfunc_tp *tab = NULL;

			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CMATRIX"), NULL));
			if (!filename) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "Cmatrix");
			}
			if (mb->verbose) {
				printf("\t\tread Cmatrix from file=[%s]\n", filename);
			}
			GMRFLib_tabulate_Qfunc_from_file(&tab, &(mb->f_graph[mb->nf]), (const char *) filename, -1, log_prec);
			mb->f_Qfunc[mb->nf] = tab->Qfunc;
			mb->f_Qfunc_arg[mb->nf] = tab->Qfunc_arg;
			mb->f_locations[mb->nf] = NULL;
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = mb->f_graph[mb->nf]->n;
			mb->f_rankdef[mb->nf] = 0.0;	       /* default */
			if (mb->verbose) {
				for (i = 0; i < IMIN(PREVIEW, mb->f_graph[mb->nf]->n); i++) {
					printf("\t\t\tQ(%1d,%1d) = %g\n", i, i, tab->Qfunc(thread_id, i, i, NULL, tab->Qfunc_arg));
				}
			}
		}
			break;

		case F_GENERIC1:
		{
			/*
			 * use field: CMATRIX to set both graph and n.
			 */
			inla_generic1_tp *arg = Calloc(1, inla_generic1_tp);
			int nn = -1;
			GMRFLib_graph_tp *g = NULL;

			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CMATRIX"), NULL));
			if (!filename) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "Cmatrix");
			}
			if (mb->verbose) {
				printf("\t\tread Cmatrix from file=[%s]\n", filename);
			}
			GMRFLib_tabulate_Qfunc_from_file(&(arg->tab), &(mb->f_graph[mb->nf]), (const char *) filename, -1, NULL);
			arg->log_prec = log_prec;
			arg->beta = beta_intern;
			arg->n = nn = mb->f_graph[mb->nf]->n;

			/*
			 * we need to compute the eigenvalues 
			 */
			gsl_matrix *C;
			gsl_vector *evalues;
			gsl_eigen_symm_workspace *w;

			g = mb->f_graph[mb->nf];
			C = gsl_matrix_calloc(nn, nn);
			evalues = gsl_vector_calloc(nn);
			w = gsl_eigen_symm_alloc(nn);
			for (i = 0; i < nn; i++) {
				gsl_matrix_set(C, i, i, arg->tab->Qfunc(thread_id, i, i, NULL, arg->tab->Qfunc_arg));
				for (jj = 0; jj < g->lnnbs[i]; jj++) {
					j = g->lnbs[i][jj];
					double val = arg->tab->Qfunc(thread_id, i, j, NULL, arg->tab->Qfunc_arg);
					gsl_matrix_set(C, i, j, val);
					gsl_matrix_set(C, j, i, val);
				}
			}
			gsl_eigen_symm(C, evalues, w);
			arg->eigenvalues = Calloc(nn, double);
			arg->max_eigenvalue = arg->eigenvalues[0];
			arg->min_eigenvalue = arg->eigenvalues[0];
			for (i = 0; i < nn; i++) {
				arg->eigenvalues[i] = gsl_vector_get(evalues, i);
				arg->max_eigenvalue = DMAX(arg->max_eigenvalue, arg->eigenvalues[i]);
				arg->min_eigenvalue = DMIN(arg->min_eigenvalue, arg->eigenvalues[i]);
			}
			assert(arg->max_eigenvalue > 0.0);
			gsl_eigen_symm_free(w);
			gsl_matrix_free(C);
			gsl_vector_free(evalues);

			if (mb->verbose) {
				printf("\t\tMaxmimum eigenvalue = %.12g\n", arg->max_eigenvalue);
				printf("\t\tMinimum  eigenvalue = %.12g\n", arg->min_eigenvalue);
			}

			mb->f_Qfunc[mb->nf] = Qfunc_generic1;
			mb->f_Qfunc_arg[mb->nf] = (void *) arg;
			mb->f_locations[mb->nf] = NULL;
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = nn;
			mb->f_rankdef[mb->nf] = 0.0;	       /* default */
			if (mb->verbose) {
				for (i = 0; i < IMIN(PREVIEW, mb->f_graph[mb->nf]->n); i++) {
					printf("\t\t\tC(%1d,%1d) = %g\n", i, i, arg->tab->Qfunc(thread_id, i, i, NULL, arg->tab->Qfunc_arg));
				}
			}
		}
			break;

		case F_GENERIC2:
		{
			/*
			 * use field: CMATRIX to set both graph and n.
			 */
			inla_generic2_tp *arg = Calloc(1, inla_generic2_tp);
			int nn = -1, ii;
			GMRFLib_graph_tp *g = NULL;

			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CMATRIX"), NULL));
			if (!filename) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "Cmatrix");
			}
			if (mb->verbose) {
				printf("\t\tread Cmatrix from file=[%s]\n", filename);
			}
			GMRFLib_tabulate_Qfunc_from_file(&(arg->tab), &g, (const char *) filename, -1, NULL);
			arg->log_prec = log_prec;
			arg->h2_intern = h2_intern;
			arg->n = nn = g->n;
			arg->N = 2 * arg->n;

			GMRFLib_ged_tp *ged;
			GMRFLib_ged_init(&ged, NULL);
			for (ii = 0; ii < nn; ii++) {
				GMRFLib_ged_add(ged, ii, ii + nn);
			}
			GMRFLib_ged_insert_graph(ged, g, nn);
			GMRFLib_graph_free(g);
			GMRFLib_ged_build(&g, ged);
			assert(g->n == 2 * nn);
			GMRFLib_ged_free(ged);

			mb->f_graph[mb->nf] = g;
			mb->f_Qfunc[mb->nf] = Qfunc_generic2;
			mb->f_Qfunc_arg[mb->nf] = (void *) arg;
			mb->f_locations[mb->nf] = NULL;
			mb->f_n[mb->nf] = nn;
			mb->f_N[mb->nf] = 2 * nn;
			mb->f_rankdef[mb->nf] = 0.0;	       /* default */
			if (mb->verbose) {
				for (i = 0; i < IMIN(PREVIEW, mb->f_graph[mb->nf]->n); i++) {
					printf("\t\t\tC(%1d,%1d) = %g\n", i, i, arg->tab->Qfunc(thread_id, i, i, NULL, arg->tab->Qfunc_arg));
				}
			}
		}
			break;

		case F_GENERIC3:
		{
			inla_generic3_tp *arg = Calloc(1, inla_generic3_tp);
			inla_generic3_tp *arg_orig = Calloc(1, inla_generic3_tp);

			arg->n = iniparser_getint(ini, inla_string_join(secname, "generic3.n"), -1);
			arg_orig->n = iniparser_getint(ini, inla_string_join(secname, "generic3.n"), -1);
			arg->m = iniparser_getint(ini, inla_string_join(secname, "generic3.m"), -1);
			arg_orig->m = iniparser_getint(ini, inla_string_join(secname, "generic3.m"), -1);
			if (mb->verbose) {
				printf("\t\tread generic3.n[%1d]\n", arg->n);
				printf("\t\tread generic3.m[%1d]\n", arg->m);
			}
			assert(arg->n > 0);
			assert(arg->m > 0 && arg->m < GENERIC3_MAXTHETA);

			arg->g = Calloc(arg->m, GMRFLib_graph_tp *);
			arg_orig->g = Calloc(arg->m, GMRFLib_graph_tp *);
			arg->tab = Calloc(arg->m, GMRFLib_tabulate_Qfunc_tp *);
			arg_orig->tab = Calloc(arg->m, GMRFLib_tabulate_Qfunc_tp *);
			for (k = 0; k < arg->m; k++) {
				ctmp = NULL;
				GMRFLib_sprintf(&ctmp, "generic3.Cmatrix.%1d", k);
				filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL));
				assert(filename != NULL);
				if (mb->verbose) {
					printf("\t\tread Cmatrix[[%1d]] from file=[%s]\n", k, filename);
				}
				GMRFLib_tabulate_Qfunc_from_file(&(arg->tab[k]), &(arg->g[k]), filename, arg->n, NULL);
				GMRFLib_tabulate_Qfunc_from_file(&(arg_orig->tab[k]), &(arg_orig->g[k]), filename, arg_orig->n, NULL);
				Free(ctmp);
				Free(filename);
			}
			GMRFLib_graph_union(&(arg->graph), arg->g, arg->m);
			GMRFLib_graph_union(&(arg_orig->graph), arg_orig->g, arg_orig->m);

			mb->f_graph[mb->nf] = arg->graph;
			mb->f_graph_orig[mb->nf] = arg_orig->graph;
			mb->f_Qfunc[mb->nf] = Qfunc_generic3;
			mb->f_Qfunc_orig[mb->nf] = Qfunc_generic3;
			mb->f_Qfunc_arg[mb->nf] = (void *) arg;
			mb->f_Qfunc_arg_orig[mb->nf] = (void *) arg_orig;
			mb->f_locations[mb->nf] = NULL;
			mb->f_n[mb->nf] = arg->n;
			mb->f_N[mb->nf] = arg->n;
			mb->f_rankdef[mb->nf] = 0.0;	       /* default */
		}
			break;

		case F_BESAG:
		{
			/*
			 * use field: GRAPH. use this to set field N 
			 */
			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GRAPH"), NULL));
			if (!filename) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "graph");
			}
			if (mb->verbose) {
				printf("\t\tread graph from file=[%s]\n", filename);
			}
			GMRFLib_graph_read(&(mb->f_graph[mb->nf]), filename);
			if (mb->f_graph[mb->nf]->n <= 0) {
				GMRFLib_sprintf(&msg, "graph=[%s] has zero size", filename);
				inla_error_general(msg);
			}

			mb->f_locations[mb->nf] = NULL;
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = mb->f_graph[mb->nf]->n;
		}
			break;

		case F_BESAG2:
		{
			/*
			 * use field: GRAPH. use this to set field N 
			 */
			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GRAPH"), NULL));
			if (!filename) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "graph");
			}
			if (mb->verbose) {
				printf("\t\tread graph from file=[%s]\n", filename);
			}
			GMRFLib_graph_read(&(mb->f_graph[mb->nf]), filename);
			if (mb->f_graph[mb->nf]->n <= 0) {
				GMRFLib_sprintf(&msg, "graph=[%s] has zero size", filename);
				inla_error_general(msg);
			}
			mb->f_precision[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), mb->f_precision[mb->nf]);
			if (mb->verbose) {
				printf("\t\tprecision=[%f]\n", mb->f_precision[mb->nf]);
			}
			mb->f_locations[mb->nf] = NULL;
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = 2 * mb->f_graph[mb->nf]->n;	/* YES */
		}
			break;

		case F_BYM:
		case F_BYM2:
		{
			/*
			 * use field: GRAPH. use this to set field N 
			 */
			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GRAPH"), NULL));
			if (!filename) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "graph");
			}
			if (mb->verbose) {
				printf("\t\tread graph from file=[%s]\n", filename);
			}
			GMRFLib_graph_read(&(mb->f_graph[mb->nf]), filename);
			if (mb->f_graph[mb->nf]->n <= 0) {
				GMRFLib_sprintf(&msg, "graph=[%s] has zero size", filename);
				inla_error_general(msg);
			}
			mb->f_locations[mb->nf] = NULL;
			mb->f_n[mb->nf] = mb->f_graph[mb->nf]->n;
			mb->f_N[mb->nf] = 2 * mb->f_n[mb->nf]; /* yes */
		}
			break;

		case F_BESAGPROPER:
		case F_BESAGPROPER2:
		{
			/*
			 * use field: GRAPH. use this to set field N 
			 */
			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GRAPH"), NULL));
			if (!filename) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "graph");
			}
			if (mb->verbose) {
				printf("\t\tread graph from file=[%s]\n", filename);
			}
			GMRFLib_graph_read(&(mb->f_graph[mb->nf]), filename);
			if (mb->f_graph[mb->nf]->n <= 0) {
				GMRFLib_sprintf(&msg, "graph=[%s] has zero size", filename);
				inla_error_general(msg);
			}

			mb->f_locations[mb->nf] = NULL;
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = mb->f_graph[mb->nf]->n;
		}
			break;

		case F_SEASONAL:
		{
			/*
			 * seasonal component; need length N, seasonal length SEASON, and a boolean CYCLIC
			 */
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "N");
			}
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
			}
			if (mb->verbose) {
				printf("\t\tn=[%1d]\n", n);
			}
			Free(ptmp);
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "SEASON"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "SEASON");
			}
			s = iniparser_getint(ini, inla_string_join(secname, "SEASON"), 0);
			if (s <= 0 || s > n) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "SEASON", ptmp);
			}
			if (mb->verbose) {
				printf("\t\tseason=[%1d]\n", s);
			}
			/*
			 * this special option is only valid for model=iid,rw1,rw2 and locations=default. therefore we do not add it
			 * into the mb->f_.... 
			 */
			mb->f_cyclic[mb->nf] = iniparser_getboolean(ini, inla_string_join(secname, "CYCLIC"), 0);
			if (mb->verbose) {
				printf("\t\tcyclic=[%1d]\n", mb->f_cyclic[mb->nf]);
			}
			Free(ptmp);
			mb->f_locations[mb->nf] = NULL;
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = n;
		}
			break;

		case F_FGN:
		case F_FGN2:
		{
			/*
			 * FGN/FGN2-model; need length N 
			 */
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "N");
			}
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
			}
			if (mb->verbose) {
				printf("\t\tn=[%1d]\n", n);
			}
			Free(ptmp);
			// even though we do not need the precision of the FGN2.
			mb->f_precision[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), mb->f_precision[mb->nf]);
			if (mb->verbose) {
				printf("\t\tprecision=[%f]\n", mb->f_precision[mb->nf]);
			}
			mb->f_order[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "ORDER"), 4);
			if (mb->verbose) {
				printf("\t\torder=[%1d]\n", mb->f_order[mb->nf]);
			}

			mb->f_N[mb->nf] = mb->f_n[mb->nf] = n;
		}
			break;

		case F_AR1:
		{
			/*
			 * AR1-model; need length N and a boolean CYCLIC
			 */
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "N");
			}
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
			}
			if (mb->verbose) {
				printf("\t\tn=[%1d]\n", n);
			}
			Free(ptmp);
			mb->f_cyclic[mb->nf] = iniparser_getboolean(ini, inla_string_join(secname, "CYCLIC"), 0);
			if (mb->verbose) {
				printf("\t\tcyclic=[%1d]\n", mb->f_cyclic[mb->nf]);
			}
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = n;
		}
			break;

		case F_AR:
		{
			/*
			 * AR(p)-model; need length N and order P
			 */
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "N");
			}
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
			}
			if (mb->verbose) {
				printf("\t\tn=[%1d]\n", n);
			}
			Free(ptmp);

			order = iniparser_getint(ini, inla_string_join(secname, "ORDER"), 1);
			if (mb->verbose) {
				printf("\t\torder=[%1d]\n", order);
			}
			mb->f_order[mb->nf] = order;
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = n;
		}
			break;

		case F_AR1C:
		{
			/*
			 * AR1-model; need length N and a boolean CYCLIC
			 */
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "N");
			}
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
			}
			if (mb->verbose) {
				printf("\t\tn=[%1d]\n", n);
			}
			Free(ptmp);
			mb->f_cyclic[mb->nf] = iniparser_getboolean(ini, inla_string_join(secname, "CYCLIC"), 0);
			if (mb->verbose) {
				printf("\t\tcyclic=[%1d]\n", mb->f_cyclic[mb->nf]);
			}
			assert(mb->f_cyclic[mb->nf] == 0);     /* not implemented */

			mb->f_N[mb->nf] = mb->f_n[mb->nf] = n;
		}
			break;

		case F_Z:
		{
			/*
			 * Z-model. Here Z is a n x m matrix, and the dimension of the model is (Z*z,z) which is n+m
			 */
			zn = iniparser_getint(ini, inla_string_join(secname, "z.n"), 0);
			zm = iniparser_getint(ini, inla_string_join(secname, "z.m"), 0);
			if (zn == 0) {
				GMRFLib_sprintf(&ctmp, "%1d", zn);
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "z.n", ctmp);
			}
			if (zm == 0) {
				GMRFLib_sprintf(&ctmp, "%1d", zm);
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "z.m", ctmp);
			}
			/*
			 * if given, then argument N must be equal n+m.
			 */
			itmp = iniparser_getint(ini, inla_string_join(secname, "N"), -1);
			if (itmp > -1 && zn + zm != itmp) {
				GMRFLib_sprintf(&ctmp, "Model z: dim(Z)[2] = %1d  !=  argument.N = %1d", zm, itmp);
				inla_error_general(ctmp);
			}
			if (mb->verbose) {
				printf("\t\tz.n=[%1d]\n", zn);
				printf("\t\tz.m=[%1d]\n", zm);
			}
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = zn + zm;	/* Yes, this is correct */
		}
			break;

		case F_SLM:
		{
			/*
			 * SLM-model. 
			 */
			slm_n = iniparser_getint(ini, inla_string_join(secname, "slm.n"), 0);
			slm_m = iniparser_getint(ini, inla_string_join(secname, "slm.m"), 0);
			if (slm_n <= 0) {
				GMRFLib_sprintf(&ctmp, "%1d", slm_n);
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "slm.n", ctmp);
			}
			if (slm_m < 0) {
				GMRFLib_sprintf(&ctmp, "%1d", slm_m);
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "slm.m", ctmp);
			}

			/*
			 * if given, then argument N must be equal n+m.
			 */
			itmp = iniparser_getint(ini, inla_string_join(secname, "N"), -1);
			if (itmp > -1 && slm_n + slm_m != itmp) {
				GMRFLib_sprintf(&ctmp, "Model SLM: N=%1d != slm.n=%1d + slm.m=%1d\n", itmp, slm_n, slm_m);
				inla_error_general(ctmp);
			}
			if (mb->verbose) {
				printf("\t\tslm.n=[%1d]\n", slm_n);
				printf("\t\tslm.m=[%1d]\n", slm_m);
			}

			slm_rho_min = iniparser_getdouble(ini, inla_string_join(secname, "slm.rho.min"), 0);
			slm_rho_max = iniparser_getdouble(ini, inla_string_join(secname, "slm.rho.max"), 0);
			if (mb->verbose) {
				printf("\t\tslm.rho.min=[%g]\n", slm_rho_min);
				printf("\t\tslm.rho.max=[%g]\n", slm_rho_max);
			}

			mb->f_N[mb->nf] = mb->f_n[mb->nf] = slm_n + slm_m;	/* Yes, this is correct */
		}
			break;

		case F_2DIID:
		{
			/*
			 * 2DIID-model; need length N
			 */
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "N");
			}
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
			}
			if (mb->verbose) {
				printf("\t\tn=[%1d]\n", n);
			}
			Free(ptmp);
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = n;
		}
			break;

		case F_IID1D:
		case F_IID2D:
		case F_IID3D:
		case F_IID4D:
		case F_IID5D:
		{
			/*
			 * IID_WISHART-model; need length N
			 */
			int dim = WISHART_DIM(mb->nf);
			assert(dim > 0);

			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "N");
			}
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
			}
			if (!inla_divisible(n, dim)) {
				GMRFLib_sprintf(&msg, "%s: N=%1d is not divisible by %1d", secname, n, dim);
				inla_error_general(msg);
				exit(EXIT_FAILURE);
			}
			if (mb->verbose) {
				printf("\t\tdim=[%1d]\n", dim);
				printf("\t\tn=[%1d]\n", n);
			}
			Free(ptmp);
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = n;
		}
			break;

		case F_IIDKD:
		{
			/*
			 * WISHART-model; need length N
			 */
			int dim = mb->f_order[mb->nf];
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
			if (!ptmp) {
				inla_error_missing_required_field(__GMRFLib_FuncName, secname, "N");
			}
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
			}
			if (!inla_divisible(n, dim)) {
				GMRFLib_sprintf(&msg, "%s: N=%1d is not divisible by %1d", secname, n, dim);
				inla_error_general(msg);
				exit(EXIT_FAILURE);
			}
			if (mb->verbose) {
				printf("\t\tdim=[%1d]\n", dim);
				printf("\t\tn=[%1d]\n", n);
			}
			Free(ptmp);
			mb->f_N[mb->nf] = mb->f_n[mb->nf] = n;
		}
			break;

		case F_INTSLOPE:
		{
			n = iniparser_getint(ini, inla_string_join(secname, "N"), 0);
			if (n <= 0) {
				char *val;
				GMRFLib_sprintf(&val, "%1d", n);
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", val);
			}
			nstrata = iniparser_getint(ini, inla_string_join(secname, "intslope.nstrata"), 1);
			nsubject = iniparser_getint(ini, inla_string_join(secname, "intslope.nsubject"), 1);
			mb->f_n[mb->nf] = n;
			mb->f_N[mb->nf] = n + 2 * nsubject;
			mb->f_precision[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), mb->f_precision[mb->nf]);
			if (mb->verbose) {
				printf("\t\tn=[%1d]\n", mb->f_n[mb->nf]);
				printf("\t\tN=[%1d]\n", mb->f_N[mb->nf]);
				printf("\t\tnstrata=[%1d]\n", nstrata);
				printf("\t\tnsubject=[%1d]\n", nsubject);
				printf("\t\tprecision=[%f]\n", mb->f_precision[mb->nf]);
			}

			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "intslope.def"), NULL));
			assert(filename != NULL);
			intslope_def = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);

			if (mb->verbose) {
				printf("\t\tRead intslope.def[%s] nrow[%1d] ncol[%1d]\n", filename, intslope_def->nrow, intslope_def->ncol);
				printf("\t\t    Idx  Subject Strata  Covariate\n");
				assert(intslope_def->ncol == 3);
				for (int i = 0; i < IMIN(intslope_def->nrow, PREVIEW); i++) {
					printf("\t\t%6d %6.1g %6.1g  %12.6f\n", i,
					       GMRFLib_matrix_get(i, INTSLOPE_SUBJECT, intslope_def),
					       GMRFLib_matrix_get(i, INTSLOPE_STRATA, intslope_def),
					       GMRFLib_matrix_get(i, INTSLOPE_Z, intslope_def));
				}
			}
		}
			break;

		case F_SPDE:
		case F_SPDE2:
		case F_SPDE3:
			break;

		case F_IID:
		case F_RW1:
		case F_RW2:
		case F_CRW2:
		case F_OU:
		case F_COPY:
		case F_MEC:
		case F_MEB:
		case F_CLINEAR:
		case F_SIGM:
		case F_REVSIGM:
		case F_LOG1EXP:
		case F_LOGDIST:
		case F_R_GENERIC:
		case F_C_GENERIC:
		case F_DMATERN:
		{
			/*
			 * RW-models and OU-model and ME: read LOCATIONS, set N from LOCATIONS, else read field N and use LOCATIONS=DEFAULT.
			 */
			filename = GMRFLib_strdup(file_loc);
			if (!filename) {
				if (mb->verbose) {
					printf("\t\tfile for locations=[(NULL)]: read n...\n");
				}
				ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "N"), NULL));
				if (!ptmp) {
					GMRFLib_sprintf(&msg, "%s: section[%s]: LOCATIONS is NULL hence N is required",
							__GMRFLib_FuncName, secname);
					inla_error_general(msg);
				} else {
					mb->f_n[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "N"), -1);
					if (mb->f_n[mb->nf] <= 0) {
						inla_error_field_is_void(__GMRFLib_FuncName, secname, "N", ptmp);
					}
				}
				mb->f_N[mb->nf] = mb->f_n[mb->nf];
				mb->f_locations[mb->nf] = NULL;
				if (mb->verbose) {
					printf("\t\tn=[%1d]: use default locations, if required\n", mb->f_n[mb->nf]);
				}
				/*
				 * this special option is only valid for model=iid,rw1,rw2 and locations=default. therefore we do not add it
				 * into the mb->f_.... 
				 */
				mb->f_cyclic[mb->nf] = iniparser_getboolean(ini, inla_string_join(secname, "CYCLIC"), 0);
				if (mb->verbose) {
					printf("\t\tcyclic=[%1d]\n", mb->f_cyclic[mb->nf]);
				}
			} else {
				if (mb->verbose) {
					printf("\t\tfile for locations=[%s]\n", filename);
				}
				inla_read_data_all(&(mb->f_locations[mb->nf]), &nlocations, filename, NULL);

				/*
				 * if N is set, make sure it match with NLOCATIONS 
				 */
				mb->f_n[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "N"), -99);
				if (mb->f_n[mb->nf] != -99 && nlocations != mb->f_n[mb->nf]) {
					GMRFLib_sprintf(&msg, "Number of locations and N does not match: %d != %d\n", nlocations, mb->f_n[mb->nf]);
					inla_error_general(msg);
					exit(EXIT_FAILURE);
				}
				mb->f_N[mb->nf] = mb->f_n[mb->nf] = nlocations;
				if (mb->verbose) {
					printf("\t\t\tnlocations=[%1d]\n", nlocations);
					for (i = 0; i < IMIN(PREVIEW, nlocations); i++) {
						printf("\t\t\tlocations[%1d]=[%g]\n", i, mb->f_locations[mb->nf][i]);
					}
				}
				/*
				 * the locations must be sorted (for some models only), otherwise, things are messed up!!!!
				 */
				if (mb->f_id[mb->nf] == F_RW1 || mb->f_id[mb->nf] == F_RW2 || mb->f_id[mb->nf] == F_CRW2
				    || mb->f_id[mb->nf] == F_OU) {
					for (i = 0; i < nlocations - 1; i++) {
						if (mb->f_locations[mb->nf][i] >= mb->f_locations[mb->nf][i + 1]) {
							inla_error_file_error_sorted(__GMRFLib_FuncName, filename, nlocations, i,
										     mb->f_locations[mb->nf][i]);
						}
					}
				}
				mb->f_cyclic[mb->nf] = iniparser_getboolean(ini, inla_string_join(secname, "CYCLIC"), 0);
				if (mb->verbose) {
					printf("\t\tcyclic=[%1d]\n", mb->f_cyclic[mb->nf]);
				}
			}
		}
			break;

		default:
			/*
			 * if this happens, its an error, as I have forgot one of the models in the list....
			 */
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
			break;
		}
	}

	// read locations also here if not read before
	if (!mb->f_locations[mb->nf] && mb->f_n[mb->nf] > 0) {
		filename = GMRFLib_strdup(file_loc);
		if (filename)
			if (mb->verbose) {
				printf("\t\tfile for locations=[%s]\n", filename);
			}
		inla_read_data_all(&(mb->f_locations[mb->nf]), &nlocations, filename, NULL);
		if (mb->f_N[mb->nf] > nlocations) {
			double *t = Calloc(mb->f_N[mb->nf], double);
			Memcpy(t, mb->f_locations[mb->nf], nlocations * sizeof(double));
			Free(mb->f_locations[mb->nf]);
			mb->f_locations[mb->nf] = t;
			for (i = nlocations; i < mb->f_N[mb->nf]; i++) {
				mb->f_locations[mb->nf][i] = i + 1;
			}
		}
		if (nlocations != mb->f_n[mb->nf]) {
			GMRFLib_sprintf(&msg, "Number of locations and N does not match: %d != %d\n", nlocations, mb->f_n[mb->nf]);
			inla_error_general(msg);
			exit(EXIT_FAILURE);
		}
		if (mb->verbose) {
			printf("\t\t\tnlocations=[%1d]\n", nlocations);
			for (i = 0; i < IMIN(PREVIEW, nlocations); i++) {
				printf("\t\t\tlocations[%1d]=[%g]\n", i, mb->f_locations[mb->nf][i]);
			}
		}
	}

	switch (mb->f_id[mb->nf]) {
	case F_RW2D:
	case F_BESAG:
	case F_GENERIC0:
	case F_SEASONAL:
	case F_IID:
	case F_RW1:
	case F_RW2:
	case F_CRW2:
	case F_Z:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf] = Calloc(1, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_SPDE:
	{
		char *spde_prefix;
		int nT, nK;

		spde_prefix = GMRFLib_strdup(".");
		spde_prefix = iniparser_getstring(ini, inla_string_join(secname, "SPDE_PREFIX"), spde_prefix);
		spde_prefix = iniparser_getstring(ini, inla_string_join(secname, "SPDE.PREFIX"), spde_prefix);
		spde_prefix = iniparser_getstring(ini, inla_string_join(secname, "SPDEPREFIX"), spde_prefix);
		if (mb->verbose) {
			printf("\t\tspde.prefix = [%s]\n", spde_prefix);
		}

		/*
		 * 
		 */
		inla_spde_build_model(thread_id, &spde_model_orig, (const char *) spde_prefix);
		mb->f_model[mb->nf] = (void *) spde_model_orig;

		/*
		 * The _userfunc0 must be set directly after the _build_model() call. This is a bit dirty; FIXME later. 
		 */
		inla_spde_build_model(thread_id, &spde_model, (const char *) spde_prefix);
		GMRFLib_ai_INLA_userfunc0 = (GMRFLib_ai_INLA_userfunc0_tp *) inla_spde_userfunc0;
		GMRFLib_ai_INLA_userfunc1 = (GMRFLib_ai_INLA_userfunc1_tp *) inla_spde_userfunc1;
		// GMRFLib_ai_INLA_userfunc0_dim = mb->ntheta; NOT NEEDED; set in userfunc0
		GMRFLib_ai_INLA_userfunc1_dim = mb->ntheta;    /* this is a hack and gives the offset of theta... */

		double initial_t = 0.0, initial_k = 0.0, initial_rest = 0.0, initial_oc = 0.0;

		/*
		 * reread this here, as we need non-std defaults 
		 */
		mb->f_fixed[mb->nf][3] = iniparser_getboolean(ini, inla_string_join(secname, "FIXED3"), 1);	/* default fixed, yes */

		// P(mb->nf);
		// P(mb->f_fixed[mb->nf][3]);

		initial_t = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 0.0);
		initial_k = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		initial_rest = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL2"), 0.0);
		initial_oc = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL3"), -20.0);
		_SetInitial(0, initial_t);
		_SetInitial(1, initial_k);
		_SetInitial(2, initial_rest);
		_SetInitial(3, initial_oc);

		nT = spde_model->Tmodel->ntheta;
		nK = spde_model->Kmodel->ntheta;
		mb->f_ntheta[mb->nf] = IMAX(4, nT + nK + 1);
		mb->f_Tmodel[mb->nf] = GMRFLib_strdup("basisT");
		mb->f_Kmodel[mb->nf] = GMRFLib_strdup("basisK");

		if (mb->verbose) {
			printf("\t\tnT=[%d]\n", nT);
			printf("\t\tnK=[%d]\n", nK);
			printf("\t\tinitialise theta_t=[%g]\n", initial_t);
			printf("\t\tinitialise theta_k=[%g]\n", initial_k);
			printf("\t\tinitialise theta_rest=[%g]\n", initial_rest);
			printf("\t\tinitialise theta_oc=[%g]\n", initial_oc);
			printf("\t\tfixed_t=[%1d]\n", mb->f_fixed[mb->nf][0]);
			printf("\t\tfixed_k=[%1d]\n", mb->f_fixed[mb->nf][1]);
			printf("\t\tfixed_rest=[%1d]\n", mb->f_fixed[mb->nf][2]);
			printf("\t\tfixed_oc=[%1d]\n", mb->f_fixed[mb->nf][3]);
		}

		for (k = 0; k < nT; k++) {
			if (k == 0) {
				if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
					tmp = mb->theta_file[mb->theta_counter_file++];
				} else {
					tmp = initial_t;
				}
			} else {
				if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
					tmp = mb->theta_file[mb->theta_counter_file++];
				} else {
					tmp = initial_rest;
				}
			}
			HYPER_INIT(spde_model->Tmodel->theta[k], tmp);
		}
		for (k = 0; k < nK; k++) {
			if (k == 0) {
				if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
					tmp = mb->theta_file[mb->theta_counter_file++];
				} else {
					tmp = initial_k;
				}
			} else {
				if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
					tmp = mb->theta_file[mb->theta_counter_file++];
				} else {
					tmp = initial_rest;
				}
			}
			HYPER_INIT(spde_model->Kmodel->theta[k], tmp);
		}
		if (!mb->f_fixed[mb->nf][3] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		} else {
			tmp = initial_oc;
		}
		HYPER_INIT(spde_model->oc, tmp);

		mb->f_theta[mb->nf] = Calloc(nT + nK + 1, double **);
		for (k = 0; k < nT; k++) {
			mb->f_theta[mb->nf][k] = spde_model->Tmodel->theta[k];
		}
		for (k = 0; k < nK; k++) {
			mb->f_theta[mb->nf][k + nT] = spde_model->Kmodel->theta[k];
		}
		mb->f_theta[mb->nf][nK + nT] = spde_model->oc;

		for (k = 0; k < nT + nK + 1; k++) {
			int fx;

			if (k == 0) {
				fx = mb->f_fixed[mb->nf][0];   /* T[0] */
			} else if (k == nT) {
				fx = mb->f_fixed[mb->nf][1];   /* K[0] */
			} else if (k == nT + nK) {
				fx = mb->f_fixed[mb->nf][3];   /* oc */
			} else {
				fx = mb->f_fixed[mb->nf][2];   /* the rest */
			}

			if (!fx) {
				/*
				 * add this \theta 
				 */
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = NULL;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				if (k == nT + nK) {
					GMRFLib_sprintf(&msg, "%s for %s", "Oc", (secname ? secname : mb->f_tag[mb->nf]));
				} else {
					if (k < nT) {
						GMRFLib_sprintf(&msg, "%s.%1d for %s-%s", "T", k,
								(secname ? secname : mb->f_tag[mb->nf]), mb->f_Tmodel[mb->nf]);
					} else {
						GMRFLib_sprintf(&msg, "%s.%1d for %s-%s", "K", k - nT,
								(secname ? secname : mb->f_tag[mb->nf]), mb->f_Kmodel[mb->nf]);
					}
				}
				mb->theta_tag[mb->ntheta] = msg;
				mb->theta_tag_userscale[mb->ntheta] = msg;

				if (k == nT + nK) {
					GMRFLib_sprintf(&msg, "%s-parameter-Oc", mb->f_dir[mb->nf]);
				} else {
					if (k < nT) {
						GMRFLib_sprintf(&msg, "%s-parameter-T.%1d-%s", mb->f_dir[mb->nf], k, mb->f_Tmodel[mb->nf]);
					} else {
						GMRFLib_sprintf(&msg, "%s-parameter-K.%1d-%s", mb->f_dir[mb->nf], k - nT, mb->f_Kmodel[mb->nf]);
					}
				}
				mb->theta_dir[mb->ntheta] = msg;

				if (k == nT + nK) {
					mb->theta[mb->ntheta] = spde_model->oc;
				} else {
					if (k < nT) {
						mb->theta[mb->ntheta] = spde_model->Tmodel->theta[k];
					} else {
						mb->theta[mb->ntheta] = spde_model->Kmodel->theta[k - nT];
					}
				}

				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				if (k == nT + nK) {
					mb->theta_map[mb->ntheta] = map_probability;
				} else {
					mb->theta_map[mb->ntheta] = map_identity;
				}
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);

				int pri;
				if (k == 0) {
					pri = 0;
				} else if (k == nT) {
					pri = 1;
				} else if (k == nT + nK) {
					pri = 3;
				} else {
					pri = 2;
				}

				mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][pri].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][pri].to_theta);

				mb->ntheta++;
			}
		}
	}
		break;

	case F_SPDE2:
	{
		char *spde2_prefix, *transform;

		spde2_prefix = GMRFLib_strdup(".");
		spde2_prefix = iniparser_getstring(ini, inla_string_join(secname, "SPDE2.PREFIX"), spde2_prefix);
		if (mb->verbose) {
			printf("\t\tspde2.prefix = [%s]\n", spde2_prefix);
		}

		transform = GMRFLib_strdup("logit");
		transform = iniparser_getstring(ini, inla_string_join(secname, "SPDE2.TRANSFORM"), transform);
		if (mb->verbose) {
			printf("\t\tspde2.transform = [%s]\n", transform);
		}

		/*
		 * need to read this twice. can save memory by changing the pointer from spde2_model_orig to spde2_model, like
		 * for B and M matrices and BLC. maybe do later
		 */
		inla_spde2_build_model(thread_id, &spde2_model_orig, (const char *) spde2_prefix, (const char *) transform);
		mb->f_model[mb->nf] = (void *) spde2_model_orig;

		inla_spde2_build_model(thread_id, &spde2_model, (const char *) spde2_prefix, (const char *) transform);

		/*
		 * set up userfunc2 that computes the marginal of BLC*theta.intern 
		 */
		GMRFLib_ai_INLA_userfunc2_n++;

		GMRFLib_ai_INLA_userfunc2_args = Realloc(GMRFLib_ai_INLA_userfunc2_args, GMRFLib_ai_INLA_userfunc2_n, void *);
		GMRFLib_ai_INLA_userfunc2_args[GMRFLib_ai_INLA_userfunc2_n - 1] = (void *) spde2_model;
		GMRFLib_ai_INLA_userfunc2 = Realloc(GMRFLib_ai_INLA_userfunc2, GMRFLib_ai_INLA_userfunc2_n, GMRFLib_ai_INLA_userfunc2_tp *);
		GMRFLib_ai_INLA_userfunc2[GMRFLib_ai_INLA_userfunc2_n - 1] = (GMRFLib_ai_INLA_userfunc2_tp *) inla_spde2_userfunc2;

		char *ltag;
		GMRFLib_sprintf(&ltag, "%s", secname);
		GMRFLib_ai_INLA_userfunc2_tag = Realloc(GMRFLib_ai_INLA_userfunc2_tag, GMRFLib_ai_INLA_userfunc2_n, char *);
		GMRFLib_ai_INLA_userfunc2_tag[GMRFLib_ai_INLA_userfunc2_n - 1] = ltag;

		/*
		 * we know the number of maximum number of hyperparameters
		 */
		int ntheta = spde2_model->ntheta;
		mb->f_initial[mb->nf] = Calloc(ntheta, double);	/* need to do this here as we do not know n_theta upfront */
		if (mb->verbose) {
			printf("\t\tntheta (max) = [%1d]\n", ntheta);
		}

		mb->f_fixed[mb->nf] = Calloc(ntheta, int);
		mb->f_theta[mb->nf] = Calloc(ntheta, double **);
		mb->f_ntheta[mb->nf] = ntheta;

		/*
		 * mark all possible as read 
		 */
		// mark all as read
		for (i = 0; i < SPDE2_MAXTHETA; i++) {
			for (int j = 0; j < keywords_len; j++) {
				GMRFLib_sprintf(&ctmp, "%s%1d", keywords[j], i);
				iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
				Free(ctmp);
			}
		}

		/*
		 * need to store where in the theta-list the spde2 parameters are 
		 */
		spde2_model->theta_first_idx = mb->ntheta;

		/*
		 * then read those we need 
		 */
		int ntheta_used = 0;			       /* then we count */
		for (i = 0; i < ntheta; i++) {
			double theta_initial = 0.0;

			GMRFLib_sprintf(&ctmp, "FIXED%1d", i);
			mb->f_fixed[mb->nf][i] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);

			GMRFLib_sprintf(&ctmp, "INITIAL%1d", i);
			theta_initial = iniparser_getdouble(ini, inla_string_join(secname, ctmp), theta_initial);
			if (!mb->f_fixed[mb->nf][i] && mb->reuse_mode) {
				theta_initial = mb->theta_file[mb->theta_counter_file++];
			}

			HYPER_INIT(spde2_model->theta[i], theta_initial);
			HYPER_INIT(spde2_model_orig->theta[i], theta_initial);
			if (mb->verbose) {
				printf("\t\tinitialise theta[%1d]=[%g]\n", i, theta_initial);
				printf("\t\tfixed[%1d]=[%1d]\n", i, mb->f_fixed[mb->nf][i]);
			}

			GMRFLib_sprintf(&ctmp, "HYPERID%1d", i);
			char *hid = NULL, *cctmp = iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
			GMRFLib_sprintf(&hid, "%s|%s", cctmp, secname);

			/*
			 * add this \theta. make spesific names for the pcmatern-case
			 */
			if (!mb->f_fixed[mb->nf][i]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = hid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				if (mb->f_prior[mb->nf][0].id == P_PC_MATERN && (i == 0 || i == 1)) {
					GMRFLib_sprintf(&msg, "%s for %s", (i == 0 ? "log(Range)" : "log(Stdev)"),
							(secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s for %s", (i == 0 ? "Range" : "Stdev"), (secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag_userscale[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], i + 1);
					mb->theta_dir[mb->ntheta] = msg;
					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup("function (x) <<NEWLINE>>exp(x)");	/* they are not there... */
					mb->theta_to[mb->ntheta] = GMRFLib_strdup("function (x) <<NEWLINE>>log(x)");	/* .... */
					mb->theta[mb->ntheta] = spde2_model->theta[i];
					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map[mb->ntheta] = map_exp;
				} else {
					GMRFLib_sprintf(&msg, "Theta%1d for %s", i + 1, (secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "Theta%1d for %s", i + 1, (secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag_userscale[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], i + 1);
					mb->theta_dir[mb->ntheta] = msg;
					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);	/* YES, use prior0, which
															 * is a joint prior */
					mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);	/* YES, use prior0, which
															 * is a joint prior */
					mb->theta[mb->ntheta] = spde2_model->theta[i];
					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map[mb->ntheta] = map_identity;
				}
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
				ntheta_used++;
			}
		}

		spde2_model->ntheta_used = ntheta_used;
		if (mb->verbose) {
			printf("\t\tntheta (used) = [%1d]\n", spde2_model->ntheta_used);
		}
		spde2_model->fixed = Calloc(ntheta, int);
		spde2_model->fixed_values = Calloc(ntheta, double);
		for (i = 0; i < ntheta; i++) {
			spde2_model->fixed[i] = mb->f_fixed[mb->nf][i];
			if (spde2_model->fixed[i]) {
				spde2_model->fixed_values[i] = spde2_model->theta[i][0][0];
			} else {
				spde2_model->fixed_values[i] = NAN;	/* so that we get an error if used wrongly */
			}
		}
		spde2_model_orig->ntheta_used = spde2_model->ntheta_used;
		spde2_model_orig->fixed = Calloc(ntheta, int);
		spde2_model_orig->fixed_values = Calloc(ntheta, double);
		Memcpy(spde2_model_orig->fixed, spde2_model->fixed, ntheta * sizeof(int));
		Memcpy(spde2_model_orig->fixed_values, spde2_model->fixed_values, ntheta * sizeof(double));

		if (mb->f_prior[mb->nf][0].id == P_MVNORM) {
			if ((int) mb->f_prior[mb->nf][0].parameters[0] != ntheta_used) {
				GMRFLib_sprintf(&ptmp,
						"Dimension of the MVNORM prior is not equal to number of used hyperparameters: %1d != %1d\n",
						(int) mb->f_prior[mb->nf][0].parameters[0], ntheta_used);
				inla_error_general(ptmp);
				exit(EXIT_FAILURE);
			}
		} else if (!strcasecmp(mb->f_prior[mb->nf][0].name, "PCSPDEGA")) {
			assert(ntheta_used == 2);	       /* requirement... */
		} else if (mb->f_prior[mb->nf][0].id == P_PC_MATERN) {
			assert(ntheta_used <= 2);	       /* requirement... */
		} else {
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}

	}
		break;

	case F_SPDE3:
	{
		char *spde3_prefix, *transform;

		spde3_prefix = GMRFLib_strdup(".");
		spde3_prefix = iniparser_getstring(ini, inla_string_join(secname, "SPDE3_PREFIX"), spde3_prefix);
		spde3_prefix = iniparser_getstring(ini, inla_string_join(secname, "SPDE3.PREFIX"), spde3_prefix);
		spde3_prefix = iniparser_getstring(ini, inla_string_join(secname, "SPDE3PREFIX"), spde3_prefix);
		if (mb->verbose) {
			printf("\t\tspde3.prefix = [%s]\n", spde3_prefix);
		}

		transform = GMRFLib_strdup("logit");
		transform = iniparser_getstring(ini, inla_string_join(secname, "SPDE3_TRANSFORM"), transform);
		transform = iniparser_getstring(ini, inla_string_join(secname, "SPDE3.TRANSFORM"), transform);
		transform = iniparser_getstring(ini, inla_string_join(secname, "SPDE3TRANSFORM"), transform);
		if (mb->verbose) {
			printf("\t\tspde3.transform = [%s]\n", transform);
		}

		/*
		 * need to read this twice. can save memory by changing the pointer from spde3_model_orig to spde3_model, like for B and M matrices and
		 * BLC. maybe do later
		 */
		inla_spde3_build_model(thread_id, &spde3_model_orig, (const char *) spde3_prefix, (const char *) transform);
		mb->f_model[mb->nf] = (void *) spde3_model_orig;

		inla_spde3_build_model(thread_id, &spde3_model, (const char *) spde3_prefix, (const char *) transform);

		/*
		 * set up userfunc3 that computes the marginal of BLC*theta.intern 
		 */
		GMRFLib_ai_INLA_userfunc3_n++;

		GMRFLib_ai_INLA_userfunc3_args = Realloc(GMRFLib_ai_INLA_userfunc3_args, GMRFLib_ai_INLA_userfunc3_n, void *);
		GMRFLib_ai_INLA_userfunc3_args[GMRFLib_ai_INLA_userfunc3_n - 1] = (void *) spde3_model;
		GMRFLib_ai_INLA_userfunc3 = Realloc(GMRFLib_ai_INLA_userfunc3, GMRFLib_ai_INLA_userfunc3_n, GMRFLib_ai_INLA_userfunc3_tp *);
		GMRFLib_ai_INLA_userfunc3[GMRFLib_ai_INLA_userfunc3_n - 1] = (GMRFLib_ai_INLA_userfunc3_tp *) inla_spde3_userfunc3;

		char *ltag;
		GMRFLib_sprintf(&ltag, "%s", secname);
		GMRFLib_ai_INLA_userfunc3_tag = Realloc(GMRFLib_ai_INLA_userfunc3_tag, GMRFLib_ai_INLA_userfunc3_n, char *);
		GMRFLib_ai_INLA_userfunc3_tag[GMRFLib_ai_INLA_userfunc3_n - 1] = ltag;

		/*
		 * now we know the number of hyperparameters ;-) 
		 */
		int ntheta;

		mb->f_ntheta[mb->nf] = ntheta = spde3_model->ntheta;
		mb->f_initial[mb->nf] = Calloc(mb->f_ntheta[mb->nf], double);	/* need to do this here as we do not know n_theta upfront */
		if (mb->verbose) {
			printf("\t\tntheta = [%1d]\n", ntheta);
		}

		if ((int) mb->f_prior[mb->nf][0].parameters[0] != ntheta) {
			GMRFLib_sprintf(&ptmp,
					"Dimension of the MVNORM prior is not equal to number of hyperparameters: %1d != %1d\n",
					(int) mb->f_prior[mb->nf][0].parameters[0], ntheta);
			inla_error_general(ptmp);
			exit(EXIT_FAILURE);
		}

		mb->f_fixed[mb->nf] = Calloc(ntheta, int);
		mb->f_theta[mb->nf] = Calloc(ntheta, double **);

		/*
		 * mark all possible as read
		 */

		// mark all as read
		for (i = 0; i < SPDE3_MAXTHETA; i++) {
			for (int j = 0; j < keywords_len; j++) {
				GMRFLib_sprintf(&ctmp, "%s%1d", keywords[j], i);
				iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
				Free(ctmp);
			}
		}

		/*
		 * need to know where in the theta-list the spde3 parameters are 
		 */
		spde3_model->theta_first_idx = mb->ntheta;

		/*
		 * then read those we need 
		 */
		for (i = 0; i < ntheta; i++) {
			double theta_initial = 0.0;

			GMRFLib_sprintf(&ctmp, "FIXED%1d", i);
			mb->f_fixed[mb->nf][i] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			if (mb->f_fixed[mb->nf][i]) {
				inla_error_general("Fixed hyperparmaters is not allowed in the SPDE3 model.");
				exit(EXIT_FAILURE);
			}

			GMRFLib_sprintf(&ctmp, "INITIAL%1d", i);
			theta_initial = iniparser_getdouble(ini, inla_string_join(secname, ctmp), theta_initial);
			if (!mb->f_fixed[mb->nf][i] && mb->reuse_mode) {
				theta_initial = mb->theta_file[mb->theta_counter_file++];
			}

			HYPER_INIT(spde3_model->theta[i], theta_initial);
			HYPER_INIT(spde3_model_orig->theta[i], theta_initial);

			if (mb->verbose) {
				printf("\t\tinitialise theta[%1d]=[%g]\n", i, theta_initial);
				printf("\t\tfixed[%1d]=[%1d]\n", i, mb->f_fixed[mb->nf][i]);
			}

			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = NULL;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Theta%1d for %s", i + 1, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Theta%1d for %s", i + 1, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], i + 1);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);	/* YES, use prior0 */
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);	/* YES, use prior0 */

			mb->theta[mb->ntheta] = spde3_model->theta[i];
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_AR:
	{
		int ntheta, order, ntheta_ref = mb->ntheta;

		order = mb->f_order[mb->nf];
		ntheta = mb->f_ntheta[mb->nf] = AR_MAXTHETA + 1;
		mb->f_initial[mb->nf] = Calloc(ntheta, double);
		if (mb->verbose) {
			printf("\t\tntheta.max = [%1d]\n", ntheta);
		}

		/*
		 * add the order as a parameter in the prior
		 */
		switch (mb->f_prior[mb->nf][1].id) {
		case P_REF_AR:
		{
			/*
			 * add the order as the first parameter in the ref-prior! 
			 */
			mb->f_prior[mb->nf][1].parameters[0] = mb->f_order[mb->nf];
		}
			break;
		default:
			break;
		}

		mb->f_fixed[mb->nf] = Calloc(ntheta, int);
		mb->f_theta[mb->nf] = Calloc(ntheta, double **);

		HYPER_NEW(log_prec, 0.0);
		mb->f_theta[mb->nf][0] = log_prec;
		pacf_intern = Calloc(AR_MAXTHETA, double **);
		for (i = 0; i < AR_MAXTHETA; i++) {
			HYPER_NEW(pacf_intern[i], 0.0);
			mb->f_theta[mb->nf][i + 1] = pacf_intern[i];
		}

		// mark all as read
		for (i = 0; i < AR_MAXTHETA + 1; i++) {
			for (int j = 0; j < keywords_len; j++) {
				GMRFLib_sprintf(&ctmp, "%s%1d", keywords[j], i);
				iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
				Free(ctmp);
			}
		}

		/*
		 * then read those we need 
		 */
		for (i = 0; i < ntheta; i++) {
			double theta_initial = 0.0;

			if (i > order) {
				// by definition, this one must be fixed
				mb->f_fixed[mb->nf][i] = 1;
			} else {
				GMRFLib_sprintf(&ctmp, "FIXED%1d", i);
				mb->f_fixed[mb->nf][i] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);
			}

			GMRFLib_sprintf(&ctmp, "INITIAL%1d", i);
			theta_initial = iniparser_getdouble(ini, inla_string_join(secname, ctmp), theta_initial);
			if (!mb->f_fixed[mb->nf][i] && mb->reuse_mode) {
				theta_initial = mb->theta_file[mb->theta_counter_file++];
			}

			if (i == 0) {
				/*
				 * precision 
				 */
				HYPER_INIT(log_prec, theta_initial);
				if (mb->verbose) {
					printf("\t\tinitialise (log_prec) theta[%1d]=[%g]\n", i, theta_initial);
					printf("\t\tfixed[%1d]=[%1d]\n", i, mb->f_fixed[mb->nf][i]);
				}

				if (!mb->f_fixed[mb->nf][i]) {
					/*
					 * add this \theta 
					 */
					mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
					mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
					mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][i].hyperid;
					mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
					mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
					mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
					GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));

					mb->theta_tag[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag_userscale[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], i + 1);
					mb->theta_dir[mb->ntheta] = msg;

					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][i].from_theta);
					mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][i].to_theta);
					mb->theta[mb->ntheta] = log_prec;
					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map[mb->ntheta] = map_precision;
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
					mb->theta_map_arg[mb->ntheta] = NULL;
					mb->ntheta++;
				}
			} else {
				/*
				 * PACF 
				 */
				HYPER_INIT(pacf_intern[i - 1], theta_initial);
				if (mb->verbose) {
					printf("\t\tinitialise (PACF) theta[%1d]=[%g]\n", i, theta_initial);
					printf("\t\tfixed[%1d]=[%1d]\n", i, mb->f_fixed[mb->nf][i]);
				}
				if (!mb->f_fixed[mb->nf][i]) {
					/*
					 * add this \theta 
					 */
					mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
					mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
					mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][i].hyperid;
					mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
					mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
					mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
					GMRFLib_sprintf(&msg, "Intern PACF%1d for %s", i, (secname ? secname : mb->f_tag[mb->nf]));

					mb->theta_tag[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "PACF%1d for %s", i, (secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag_userscale[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], i + 1);
					mb->theta_dir[mb->ntheta] = msg;

					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][i].from_theta);
					mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][i].to_theta);
					mb->theta[mb->ntheta] = pacf_intern[i - 1];
					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map[mb->ntheta] = ar_map_pacf;
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
					mb->theta_map_arg[mb->ntheta] = NULL;
					mb->ntheta++;
				}
			}
		}
		if (mb->verbose) {
			printf("\t\tntheta = [%1d]\n", mb->ntheta - ntheta_ref);
		}
	}
		break;

	case F_MEC:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 1.0);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(beta, tmp);

		double *range = NULL;
		range = Calloc(2, double);		       /* need this as it will be stored in the map argument */
		range[0] = iniparser_getdouble(ini, inla_string_join(secname, "RANGE.LOW"), 0.0);	/* low = high ==> map = identity */
		range[1] = iniparser_getdouble(ini, inla_string_join(secname, "RANGE.HIGH"), 0.0);

		if (mb->verbose) {
			printf("\t\tinitialise beta[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
			printf("\t\trange[%g, %g]\n", range[0], range[1]);
		}

		mb->f_theta_map[mb->nf] = Calloc(1, map_func_tp *);
		mb->f_theta_map_arg[mb->nf] = Calloc(1, void *);
		mb->f_theta_map[mb->nf][0] = map_beta;	       /* need these */
		mb->f_theta_map_arg[mb->nf][0] = (void *) range;	/* and this one as well */
		mb->f_theta[mb->nf][0] = beta;

		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "MEC beta for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "MEC beta for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = beta;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_beta;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) range;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_prec_u[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = log_prec;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "MEC prec_u_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "MEC prec_u for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL2"), 0.0);
		if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(2, tmp);
		HYPER_INIT(mean_x, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise mean_x[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][2]);
		}

		mb->f_theta[mb->nf][2] = mean_x;
		if (!mb->f_fixed[mb->nf][2]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][2].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "MEC mean_x for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "MEC mean_x for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter2", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].to_theta);

			mb->theta[mb->ntheta] = mean_x;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL3"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][3] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(3, tmp);
		HYPER_INIT(log_prec_x, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_prec_x[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][3]);
		}
		mb->f_theta[mb->nf][3] = log_prec_x;
		if (!mb->f_fixed[mb->nf][3]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][3].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "MEC prec_x_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "MEC prec_x for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter3", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][3].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][3].to_theta);

			mb->theta[mb->ntheta] = log_prec_x;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_MEB:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 1.0);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(beta, tmp);

		double *range = NULL;
		range = Calloc(2, double);		       /* need this as it will be stored in the map argument */
		range[0] = iniparser_getdouble(ini, inla_string_join(secname, "RANGE.LOW"), 0.0);	/* low = high ==> map = identity */
		range[1] = iniparser_getdouble(ini, inla_string_join(secname, "RANGE.HIGH"), 0.0);

		if (mb->verbose) {
			printf("\t\tinitialise beta[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
			printf("\t\trange[%g, %g]\n", range[0], range[1]);
		}

		mb->f_theta_map[mb->nf] = Calloc(1, map_func_tp *);
		mb->f_theta_map_arg[mb->nf] = Calloc(1, void *);
		mb->f_theta_map[mb->nf][0] = map_beta;	       /* need these */
		mb->f_theta_map_arg[mb->nf][0] = (void *) range;	/* and this one as well */
		mb->f_theta[mb->nf][0] = beta;

		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "MEB beta for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "MEB beta for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = beta;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_beta;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) range;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_prec_u[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = log_prec;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "MEB prec_u_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "MEB prec_u for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_R_GENERIC:
	{
		rgeneric_filename = iniparser_getstring(ini, inla_string_join(secname, "RGENERIC.FILE"), NULL);
		rgeneric_model = iniparser_getstring(ini, inla_string_join(secname, "RGENERIC.MODEL"), NULL);

		if (mb->verbose) {
			printf("\t\trgeneric.file   [%s]\n", rgeneric_filename);
			printf("\t\trgeneric.model  [%s]\n", rgeneric_model);
		}

		int n_out, nn_out, nn;
		double *x_out = NULL, *xx_out = NULL;

		/*
		 * we need to know ntheta, therefore we need to initialise and load files etc, here...
		 */
#pragma omp critical (Name_4dc2f57513bfff130bbf6befdb6223652c8569da)
		{
			inla_R_library("INLA");
			inla_R_load(rgeneric_filename);
			int zero = 0;
			inla_R_rgeneric(&n_out, &x_out, R_GENERIC_INITIAL, rgeneric_model, &zero, NULL);
			inla_R_rgeneric(&nn_out, &xx_out, R_GENERIC_GRAPH, rgeneric_model, &zero, NULL);	/* need graph->n */
		}

		nn = (int) xx_out[0];
		if (mb->f_n[mb->nf] != nn) {
			int err = 0;
			for (i = 0; i < mb->f_n[mb->nf]; i++) {
				// provide a warning if something could be wrong in the input
				if (mb->f_locations[mb->nf][i] != i + 1)
					err++;
			}
			if (err) {
				char *msg;
				GMRFLib_sprintf(&msg, "%s\n\t\t%s, %1d != %1d, \n\t\t%s\n\t\t%s%1d%s",
						"There is a potential issue with the 'rgeneric' model and the indices used:",
						"the dimension of the model is different from expected", mb->f_n[mb->nf], nn,
						"and correctness cannot be verified.",
						"Please use argument n=", nn, ", f.ex, to *define* the dimension of the rgeneric model.");
				inla_error_general(msg);
				assert(0 != 1);
				exit(1);
			}

			Free(mb->f_locations[mb->nf]);
			mb->f_locations[mb->nf] = Calloc(nn, double);
			for (i = 0; i < nn; i++) {
				mb->f_locations[mb->nf][i] = i + 1;	/* set default ones */
			}
			mb->f_n[mb->nf] = mb->f_N[mb->nf] = nn;
		}

		int ntheta = 0;
		double *initial = NULL;

		ntheta = (int) x_out[0];
		if (ntheta) {
			initial = Calloc(ntheta, double);
			Memcpy(initial, &(x_out[1]), ntheta * sizeof(double));
		}

		Free(x_out);
		Free(xx_out);

		mb->f_ntheta[mb->nf] = ntheta;
		mb->f_initial[mb->nf] = initial;

		if (mb->verbose) {
			int ii;

			printf("\t\tntheta = [%1d]\n", ntheta);
			for (ii = 0; ii < ntheta; ii++) {
				printf("\t\tinitial[%1d] = %g\n", ii, initial[ii]);
			}
		}

		if (ntheta) {
			mb->f_fixed[mb->nf] = Calloc(ntheta, int);
			mb->f_theta[mb->nf] = Calloc(ntheta, double **);
		} else {
			mb->f_fixed[mb->nf] = NULL;
			mb->f_theta[mb->nf] = NULL;
		}

		for (i = 0; i < ntheta; i++) {
			double theta_initial;

			mb->f_fixed[mb->nf][i] = 0;
			theta_initial = initial[i];

			if (!mb->f_fixed[mb->nf][i] && mb->reuse_mode) {
				theta_initial = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(mb->f_theta[mb->nf][i], theta_initial);
			if (mb->verbose) {
				printf("\t\tinitialise theta[%1d]=[%g]\n", i, theta_initial);
				printf("\t\tfixed[%1d]=[%1d]\n", i, mb->f_fixed[mb->nf][i]);
			}

			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = NULL;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Theta%1d for %s", i + 1, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Theta%1d for %s", i + 1, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], i + 1);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup("function(x) x");
			mb->theta_to[mb->ntheta] = GMRFLib_strdup("function(x) x");

			mb->theta[mb->ntheta] = mb->f_theta[mb->nf][i];
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

	}
		break;

	case F_C_GENERIC:
	{
		const char *emsg = NULL;
		char *cdata_fnm = NULL, *cgeneric_qfnm = NULL;
		int cgeneric_q;
		cgeneric_shlib = iniparser_getstring(ini, inla_string_join(secname, "CGENERIC.SHLIB"), NULL);
		cgeneric_model = iniparser_getstring(ini, inla_string_join(secname, "CGENERIC.MODEL"), NULL);
		cgeneric_n = iniparser_getint(ini, inla_string_join(secname, "CGENERIC.N"), cgeneric_n);
		cgeneric_debug = iniparser_getboolean(ini, inla_string_join(secname, "CGENERIC.DEBUG"), cgeneric_debug);
		cgeneric_q = iniparser_getboolean(ini, inla_string_join(secname, "CGENERIC.Q"), 0);
		cgeneric_qfnm = iniparser_getstring(ini, inla_string_join(secname, "CGENERIC.Q.FILE"), NULL);
		cdata_fnm = iniparser_getstring(ini, inla_string_join(secname, "CGENERIC.DATA"), NULL);

		cgeneric_data = inla_cgeneric_read_data(cdata_fnm, cgeneric_debug);

		if (mb->verbose) {
			printf("\t\tcgeneric.shlib  [%s]\n", cgeneric_shlib);
			printf("\t\tcgeneric.model  [%s]\n", cgeneric_model);
			printf("\t\tcgeneric.data   [%s]\n", cdata_fnm);
			printf("\t\tcgeneric.n      [%1d]\n", cgeneric_n);
			printf("\t\tcgeneric.q      [%1d]\n", cgeneric_q);
			printf("\t\tcgeneric.debug  [%1d]\n", cgeneric_debug);
		}

		int nn;
		double *x_out = NULL, *xx_out = NULL;

		static int ltdl_init = 1;
		if (ltdl_init) {
			lt_dlinit();
			if ((emsg = lt_dlerror())) {
				char *msg;
				GMRFLib_sprintf(&msg, "\n *** dlinit error with model[%s] err_msg[%s]\n", cgeneric_model, emsg);
				inla_error_general(msg);
				assert(0 != 1);
				exit(1);
			}
			ltdl_init = 0;
			lt_dlerror();
		}

		handle = lt_dlopen(cgeneric_shlib);
		if (!handle) {
			char *msg;
			GMRFLib_sprintf(&msg, "\n *** dlopen error with file[%s] err_msg[%s]\n", cgeneric_shlib, lt_dlerror());
			inla_error_general(msg);
			assert(0 != 1);
			exit(1);
		}
		lt_dlerror();

		model_func = (inla_cgeneric_func_tp *) lt_dlsym(handle, cgeneric_model);
		if ((emsg = lt_dlerror())) {
			char *msg;
			GMRFLib_sprintf(&msg, "\n *** dlsym error with model[%s] err_msg[%s]\n", cgeneric_model, emsg);
			inla_error_general(msg);
			assert(0 != 1);
			exit(1);
		}
		lt_dlerror();

		if (cgeneric_q) {
			// this is a hack for `inla.cgeneric.q`. write out info and then exit.

			double *x = NULL, *theta = NULL;
			int nt;

			FILE *fp = fopen(cgeneric_qfnm, "w");

			fprintf(fp, "CGENERIC_BEGIN\n");
			x = model_func(INLA_CGENERIC_INITIAL, NULL, cgeneric_data);
			nt = (int) x[0];
			if (nt > 0) {
				theta = x + 1;
			} else {
				theta = NULL;
			}
			inla_cgeneric_debug(fp, secname, INLA_CGENERIC_INITIAL, x);

			x = model_func(INLA_CGENERIC_GRAPH, NULL, cgeneric_data);
			inla_cgeneric_debug(fp, secname, INLA_CGENERIC_GRAPH, x);

			x = model_func(INLA_CGENERIC_Q, theta, cgeneric_data);
			inla_cgeneric_debug(fp, secname, INLA_CGENERIC_Q, x);

			x = model_func(INLA_CGENERIC_MU, theta, cgeneric_data);
			inla_cgeneric_debug(fp, secname, INLA_CGENERIC_MU, x);

			x = model_func(INLA_CGENERIC_LOG_PRIOR, theta, cgeneric_data);
			inla_cgeneric_debug(fp, secname, INLA_CGENERIC_LOG_PRIOR, x);

			x = model_func(INLA_CGENERIC_LOG_NORM_CONST, theta, cgeneric_data);
			inla_cgeneric_debug(fp, secname, INLA_CGENERIC_LOG_NORM_CONST, x);

			x = model_func(INLA_CGENERIC_QUIT, theta, cgeneric_data);

			fprintf(fp, "CGENERIC_END\n");
			fclose(fp);

			// YES
			exit(0);
		}

		xx_out = model_func(INLA_CGENERIC_GRAPH, NULL, cgeneric_data);
		if (cgeneric_debug) {
			inla_cgeneric_debug(stdout, secname, INLA_CGENERIC_GRAPH, xx_out);
		}
		nn = (int) xx_out[0];

		if (nn != cgeneric_n) {
			char *msg;
			GMRFLib_sprintf(&msg, "f(%s): 'n' does not match with the one in cgeneric-function '%s', %1d != %1d\n",
					secname, cgeneric_model, nn, cgeneric_n);
			inla_error_general(msg);
			assert(0 != 1);
			exit(1);
		}

		if (mb->f_n[mb->nf] != nn) {
			int err = 0;
			for (i = 0; i < mb->f_n[mb->nf]; i++) {
				// provide a warning if something could be wrong in the input
				if (mb->f_locations[mb->nf][i] != i + 1)
					err++;
			}
			if (err) {
				char *msg;
				GMRFLib_sprintf(&msg, "%s\n\t\t%s, %1d != %1d, \n\t\t%s\n\t\t%s%1d%s",
						"There is a potential issue with the 'cgeneric' model and the indices used:",
						"the dimension of the model is different from expected", mb->f_n[mb->nf], nn,
						"and correctness cannot be verified.",
						"Please use argument n=", nn, ", f.ex, to *define* the dimension of the cgeneric model.");
				inla_error_general(msg);
				assert(0 != 1);
				exit(1);
			}

			Free(mb->f_locations[mb->nf]);
			mb->f_locations[mb->nf] = Calloc(nn, double);
			for (i = 0; i < nn; i++) {
				mb->f_locations[mb->nf][i] = i + 1;	/* set default ones */
			}
			mb->f_n[mb->nf] = mb->f_N[mb->nf] = nn;
		}
		Free(xx_out);

		int ntheta = 0;
		double *initial = NULL;

		x_out = model_func(INLA_CGENERIC_INITIAL, NULL, cgeneric_data);
		if (cgeneric_debug) {
			inla_cgeneric_debug(stdout, secname, INLA_CGENERIC_INITIAL, x_out);
		}
		ntheta = (int) x_out[0];
		if (ntheta) {
			initial = Calloc(ntheta, double);
			Memcpy(initial, &(x_out[1]), ntheta * sizeof(double));
		}
		Free(x_out);

		mb->f_ntheta[mb->nf] = ntheta;
		mb->f_initial[mb->nf] = initial;

		if (mb->verbose) {
			printf("\t\tntheta = [%1d]\n", ntheta);
			for (int ii = 0; ii < ntheta; ii++) {
				printf("\t\tinitial[%1d] = %g\n", ii, initial[ii]);
			}
		}

		if (ntheta) {
			mb->f_fixed[mb->nf] = Calloc(ntheta, int);
			mb->f_theta[mb->nf] = Calloc(ntheta, double **);
		} else {
			mb->f_fixed[mb->nf] = NULL;
			mb->f_theta[mb->nf] = NULL;
		}

		for (i = 0; i < ntheta; i++) {
			double theta_initial;

			mb->f_fixed[mb->nf][i] = 0;
			theta_initial = initial[i];

			if (!mb->f_fixed[mb->nf][i] && mb->reuse_mode) {
				theta_initial = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(mb->f_theta[mb->nf][i], theta_initial);
			if (mb->verbose) {
				printf("\t\tinitialise theta[%1d]=[%g]\n", i, theta_initial);
				printf("\t\tfixed[%1d]=[%1d]\n", i, mb->f_fixed[mb->nf][i]);
			}

			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = NULL;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Theta%1d for %s", i + 1, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Theta%1d for %s", i + 1, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], i + 1);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup("function(x) x");
			mb->theta_to[mb->ntheta] = GMRFLib_strdup("function(x) x");

			mb->theta[mb->ntheta] = mb->f_theta[mb->nf][i];
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

	}
		break;

	case F_FGN:
	case F_FGN2:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(H_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise H_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = H_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "H_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "H for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = H_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_H;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_AR1:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf] = Calloc(3, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(phi_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise phi_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = phi_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Rho_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Rho for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = phi_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_rho;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL2"), 0.0);
		if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(2, tmp);
		HYPER_INIT(mean_x, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise mean[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][2]);
		}
		mb->f_theta[mb->nf][2] = mean_x;
		if (!mb->f_fixed[mb->nf][2]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Mean for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Mean for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = mean_x;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

	}
		break;

	case F_AR1C:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(phi_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise phi_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = phi_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Rho_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Rho for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = phi_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_rho;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_SLM:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(rho_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise rho_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = rho_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Rho_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Rho for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = rho_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_OU:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(phi_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise phi_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = phi_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Phi_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Phi for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = phi_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_BESAG2:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(a_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise a_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = a_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Scale parameter a_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Scale paramter a for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = a_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_BESAGPROPER:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(log_diag, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log weight[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = log_diag;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log diagonal for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Diagonal for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = log_diag;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_BESAGPROPER2:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(phi_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise logit lambda[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = phi_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Logit lambda for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Lambda for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = phi_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_GENERIC1:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(beta_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise beta_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = beta_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Beta_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Beta for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = beta_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_GENERIC2:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision-cmatrix for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision-cmatrix for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(h2_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise h2-intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = h2_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "h2-intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "h2 for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = h2_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_GENERIC3:
	{
		inla_generic3_tp *a = (inla_generic3_tp *) mb->f_Qfunc_arg[mb->nf];
		a->log_prec = Calloc(GENERIC3_MAXTHETA, double **);
		mb->f_theta[mb->nf] = Calloc(GENERIC3_MAXTHETA, double **);

		for (k = a->m; k < GENERIC3_MAXTHETA - 1; k++) {	/* yes, do not include the common scaling */
			mb->f_fixed[mb->nf][k] = 1;	       /* those not used are set to fixed */
		}
		for (k = 0; k < GENERIC3_MAXTHETA; k++) {
			GMRFLib_sprintf(&ctmp, "INITIAL%1d", k);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), G.log_prec_initial);
			if (!mb->f_fixed[mb->nf][k] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			_SetInitial(k, tmp);
			HYPER_NEW(a->log_prec[k], tmp);
			if (mb->verbose) {
				printf("\t\tinitialise log_precision[%1d] = %g\n", k, tmp);
				printf("\t\tfixed[%1d] = %1d\n", k, mb->f_fixed[mb->nf][k]);
			}
			mb->f_theta[mb->nf][k] = a->log_prec[k];

			if (!mb->f_fixed[mb->nf][k]) {
				/*
				 * add this \theta 
				 */
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
				if (k < GENERIC3_MAXTHETA - 1) {
					GMRFLib_sprintf(&msg, "Log precision for Cmatrix[[%1d]] for %s", k + 1,
							(secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "Precision for Cmatrix[[%1d]] for %s", k + 1,
							(secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag_userscale[mb->ntheta] = msg;
				} else {
					GMRFLib_sprintf(&msg, "Log common precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "Common precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
					mb->theta_tag_userscale[mb->ntheta] = msg;
				}
				GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], k);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].to_theta);

				mb->theta[mb->ntheta] = a->log_prec[k];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_precision;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
			}
		}
	}
		break;

	case F_COPY:
	{
		mb->f_of[mb->nf] = iniparser_getstring(ini, inla_string_join(secname, "OF"), NULL);
		if (mb->verbose && mb->f_of[mb->nf]) {
			printf("\t\tof=[%s]\n", mb->f_of[mb->nf]);
		}

		/*
		 * same_as, says that the beta-parameters is the same as 'same_as', so this is to be determined later on. so we need to add space for it in
		 * f_theta, but not in mb->theta and mb->ntheta. The error-checking is done later. 
		 */
		mb->f_same_as[mb->nf] = iniparser_getstring(ini, inla_string_join(secname, "SAMEAS"), NULL);
		mb->f_same_as[mb->nf] = iniparser_getstring(ini, inla_string_join(secname, "SAME.AS"), mb->f_same_as[mb->nf]);
		if (mb->verbose) {
			printf("\t\tsame.as=[%s]\n", mb->f_same_as[mb->nf]);
		}

		mb->f_precision[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), mb->f_precision[mb->nf]);
		if (mb->verbose) {
			printf("\t\tprecision=[%f]\n", mb->f_precision[mb->nf]);
		}

		int fixed_default = 1;
		fixed_default = iniparser_getint(ini, inla_string_join(secname, "FIXED"), fixed_default);
		if (fixed_default == -1) {
			mb->f_fixed[mb->nf][0] = 1;
		}

		double *range = NULL;
		range = Calloc(2, double);		       /* need this as it will be stored in the map argument */
		range[0] = iniparser_getdouble(ini, inla_string_join(secname, "RANGE.LOW"), 0.0);	/* low = high ==> map = identity */
		range[1] = iniparser_getdouble(ini, inla_string_join(secname, "RANGE.HIGH"), 0.0);

		int aauto = 0;
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 1.0);	
		if (ISZERO(tmp)) {
			// initial=0.0 means auto-mode: initial=1 if FIXED and 0.1 if not
			tmp = (fixed_default ? 1.0 : 0.1);
			aauto = 1;
		}
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(beta, tmp);
		if (mb->verbose) {
			printf("\t\trange[%g, %g]\n", range[0], range[1]);
			if (aauto) {
				printf("\t\tauto-initialise beta[%g]\n", tmp);
			} else {
				printf("\t\tinitialise beta[%g]\n", tmp);
			}
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		mb->f_theta[mb->nf] = Calloc(1, double **);
		mb->f_theta[mb->nf][0] = beta;

		mb->f_theta_map[mb->nf] = Calloc(1, map_func_tp *);
		mb->f_theta_map_arg[mb->nf] = Calloc(1, void *);
		mb->f_theta_map[mb->nf][0] = map_beta;	       /* need these */
		mb->f_theta_map_arg[mb->nf][0] = (void *) range;	/* and this one as well */

		if (mb->f_same_as[mb->nf] == NULL && !mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Beta_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Beta for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = beta;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_beta;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) range;
			mb->ntheta++;
		}
	}
		break;

	case F_CLINEAR:
	{
		mb->f_precision[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), mb->f_precision[mb->nf]);
		if (mb->verbose) {
			printf("\t\tprecision=[%f]\n", mb->f_precision[mb->nf]);
		}

		int fixed_default = 0;
		fixed_default = iniparser_getint(ini, inla_string_join(secname, "FIXED"), fixed_default);
		if (fixed_default == -1) {
			mb->f_fixed[mb->nf][0] = 1;
		}
		if (mb->verbose && fixed_default == -1) {
			printf("\t\tfixed=[%d]\n", mb->f_fixed[mb->nf][0]);
		}

		double *range = NULL;
		range = Calloc(2, double);		       /* need this as it will be stored in the map argument */
		range[0] = iniparser_getdouble(ini, inla_string_join(secname, "RANGE.LOW"), 0.0);	/* low = high ==> map = identity */
		range[1] = iniparser_getdouble(ini, inla_string_join(secname, "RANGE.HIGH"), 0.0);

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL"), 0.0);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(beta, tmp);
		if (mb->verbose) {
			printf("\t\trange[%g, %g]\n", range[0], range[1]);
			printf("\t\tinitialise beta[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		mb->f_theta[mb->nf] = Calloc(1, double **);
		mb->f_theta[mb->nf][0] = beta;

		mb->f_theta_map[mb->nf] = Calloc(1, map_func_tp *);
		mb->f_theta_map_arg[mb->nf] = Calloc(1, void *);
		mb->f_theta_map[mb->nf][0] = map_beta;	       /* need these */
		mb->f_theta_map_arg[mb->nf][0] = (void *) range;	/* and this one as well */

		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Beta_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Beta for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = beta;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_beta;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = (void *) range;
			mb->ntheta++;
		}
	}
		break;

	case F_SIGM:
	case F_REVSIGM:
	{
		char *local_name = (mb->f_id[mb->nf] == F_SIGM ? GMRFLib_strdup("SIGM") : GMRFLib_strdup("REVSIGM"));

		mb->f_precision[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), mb->f_precision[mb->nf]);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 1.0);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(beta, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise beta[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf][0] = beta;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "%s beta for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s beta for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = beta;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), log(20.0));
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(log_halflife, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_halflife[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = log_halflife;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

			GMRFLib_sprintf(&msg, "%s log_halflife for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s halflife for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = log_halflife;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL2"), log(1.0));
		if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(2, tmp);
		HYPER_INIT(log_shape, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_shape[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][2]);
		}
		mb->f_theta[mb->nf][2] = log_shape;
		if (!mb->f_fixed[mb->nf][2]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][2].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

			GMRFLib_sprintf(&msg, "%s log_shape for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s shape for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].to_theta);

			mb->theta[mb->ntheta] = log_shape;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

	}
		break;

	case F_LOG1EXP:
	{
		char *local_name = GMRFLib_strdup("LOG1EXP");

		mb->f_precision[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), mb->f_precision[mb->nf]);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 1.0);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(beta, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise beta[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf][0] = beta;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "%s beta for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s beta for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = beta;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(alpha, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = alpha;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

			GMRFLib_sprintf(&msg, "%s alpha for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s alpha for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = alpha;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL2"), 0.0);
		if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(2, tmp);
		HYPER_INIT(gama, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise gamma[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][2]);
		}
		mb->f_theta[mb->nf][2] = gama;
		if (!mb->f_fixed[mb->nf][2]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][2].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

			GMRFLib_sprintf(&msg, "%s gamma for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s gamma for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].to_theta);

			mb->theta[mb->ntheta] = gama;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

	}
		break;

	case F_LOGDIST:
	{
		char *local_name = GMRFLib_strdup("LOGDIST");

		mb->f_precision[mb->nf] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), mb->f_precision[mb->nf]);
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), 1.0);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(beta, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise beta[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf][0] = beta;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "%s beta for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s beta for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = beta;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_identity;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(alpha1, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha1[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf][1] = alpha1;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

			GMRFLib_sprintf(&msg, "%s alpha1.intern for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s alpha1 for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = alpha1;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL2"), 0.0);
		if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(2, tmp);
		HYPER_INIT(alpha2, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise alpha2[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][2]);
		}
		mb->f_theta[mb->nf][2] = alpha2;
		if (!mb->f_fixed[mb->nf][2]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][2].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

			GMRFLib_sprintf(&msg, "%s alpha2.intern for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s alpha2 for %s", local_name, (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].to_theta);

			mb->theta[mb->ntheta] = alpha2;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

	}
		break;

	case F_BYM:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec0, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision (iid component)[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(log_prec1, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision (spatial component)[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec0;
		if (!mb->f_fixed[mb->nf][0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s (idd component)", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s (iid component)", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec0;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
		mb->f_theta[mb->nf][1] = log_prec1;
		if (!mb->f_fixed[mb->nf][1]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s (spatial component)", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s (spatial component)", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = log_prec1;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_BYM2:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec0, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision [%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(phi_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise phi_intern [%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec0;
		mb->f_theta[mb->nf][1] = phi_intern;

		if (!mb->f_fixed[mb->nf][0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec0;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		if (!mb->f_fixed[mb->nf][1]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Logit phi for %s", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Phi for %s", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = phi_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_RW2DIID:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision [%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 0.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(phi_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise phi_intern [%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}
		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		mb->f_theta[mb->nf][1] = phi_intern;

		if (!mb->f_fixed[mb->nf][0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		if (!mb->f_fixed[mb->nf][1]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Logit phi for %s", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Phi for %s", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = phi_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_probability;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_2DIID:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec0, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision (first component)[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(log_prec1, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision (second component)[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}

		mb->f_theta[mb->nf] = Calloc(3, double **);
		mb->f_theta[mb->nf][0] = log_prec0;
		if (!mb->f_fixed[mb->nf][0]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s (first component)", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s (first component)", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec0;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
		mb->f_theta[mb->nf][1] = log_prec1;
		if (!mb->f_fixed[mb->nf][1]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s (second component)", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s (second component)", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = log_prec1;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL2"), 0.0);
		if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(2, tmp);
		HYPER_INIT(rho_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise rho_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][2]);
		}

		mb->f_theta[mb->nf][2] = rho_intern;
		if (!mb->f_fixed[mb->nf][2]) {
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][2].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Rho_intern for %s", mb->f_tag[mb->nf]);
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Rho for %s", mb->f_tag[mb->nf]);
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter2", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][2].to_theta);

			mb->theta[mb->ntheta] = rho_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_rho;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_IID1D:
	case F_IID2D:
	case F_IID3D:
	case F_IID4D:
	case F_IID5D:
	{
		int dim = WISHART_DIM(mb->nf);
		assert(dim > 0);

		int n_theta = mb->f_ntheta[mb->nf];
		theta_iidwishart = Calloc(n_theta, double **);
		for (i = 0; i < n_theta; i++) {
			HYPER_NEW(theta_iidwishart[i], 0.0);
		}

		mb->f_theta[mb->nf] = Calloc(n_theta, double **);
		k = 0;
		for (i = 0; i < dim; i++) {
			/*
			 * first get all the precisions 
			 */
			char *init;

			if (dim == 1) {
				GMRFLib_sprintf(&init, "INITIAL");
			} else {
				GMRFLib_sprintf(&init, "INITIAL%1d", k);
			}

			tmp = iniparser_getdouble(ini, inla_string_join(secname, init), G.log_prec_initial);

			if (!mb->f_fixed[mb->nf][k] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			_SetInitial(k, tmp);
			HYPER_INIT(theta_iidwishart[k], tmp);
			if (mb->verbose) {
				printf("\t\tinitialise log_precision (component %d)[%g]\n", k + 1, tmp);
				printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][k]);
			}

			mb->f_theta[mb->nf][k] = theta_iidwishart[k];

			if (!mb->f_fixed[mb->nf][k]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
				GMRFLib_sprintf(&msg, "Log precision for %s (component %1d)", mb->f_tag[mb->nf], k + 1);
				mb->theta_tag[mb->ntheta] = msg;
				GMRFLib_sprintf(&msg, "Precision for %s (component %1d)", mb->f_tag[mb->nf], k + 1);
				mb->theta_tag_userscale[mb->ntheta] = msg;
				GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], k);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].to_theta);

				mb->theta[mb->ntheta] = theta_iidwishart[k];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_precision;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
			}

			k++;
		}
		for (i = 0; i < dim; i++) {
			for (j = i + 1; j < dim; j++) {
				/*
				 * all the correlations 
				 */
				char *init;
				GMRFLib_sprintf(&init, "INITIAL%1d", k);
				tmp = iniparser_getdouble(ini, inla_string_join(secname, init), 0.0);

				if (!mb->f_fixed[mb->nf][k] && mb->reuse_mode) {
					tmp = mb->theta_file[mb->theta_counter_file++];
				}
				_SetInitial(k, tmp);
				HYPER_INIT(theta_iidwishart[k], tmp);
				if (mb->verbose) {
					printf("\t\tinitialise rho_internal%1d:%1d [%g]\n", i + 1, j + 1, tmp);
					printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][k]);
				}

				mb->f_theta[mb->nf][k] = theta_iidwishart[k];

				if (!mb->f_fixed[mb->nf][k]) {
					mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
					mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
					mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][k].hyperid;
					mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
					mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
					mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
					GMRFLib_sprintf(&msg, "Rho_internal%1d:%1d for %s", i + 1, j + 1, mb->f_tag[mb->nf]);
					mb->theta_tag[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "Rho%1d:%1d for %s", i + 1, j + 1, mb->f_tag[mb->nf]);
					mb->theta_tag_userscale[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], k);
					mb->theta_dir[mb->ntheta] = msg;

					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].from_theta);
					mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].to_theta);

					mb->theta[mb->ntheta] = theta_iidwishart[k];
					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map[mb->ntheta] = map_rho;
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
					mb->theta_map_arg[mb->ntheta] = NULL;
					mb->ntheta++;
				}
				k++;
			}
		}
		assert(k == n_theta);
	}
		break;

	case F_IIDKD:
	{
		int dim = mb->f_order[mb->nf];
		int n_theta = mb->f_ntheta[mb->nf];

		theta_iidwishart = Calloc(n_theta, double **);
		for (k = 0; k < n_theta; k++) {
			HYPER_NEW(theta_iidwishart[k], 0.0);
		}

		for (k = 0; k < INLA_WISHARTK_NTHETA(INLA_WISHARTK_KMAX); k++) {
			char *txt = NULL;
			GMRFLib_sprintf(&txt, "INITIAL%1d", k);
			iniparser_getdouble(ini, inla_string_join(secname, txt), 0.0);
			GMRFLib_sprintf(&txt, "FIXED%1d", k);
			iniparser_getint(ini, inla_string_join(secname, txt), 0);
		}

		mb->f_theta[mb->nf] = Calloc(n_theta, double **);
		for (k = 0; k < n_theta; k++) {
			char *init = NULL;
			GMRFLib_sprintf(&init, "INITIAL%1d", k);
			if (k < dim) {
				tmp = iniparser_getdouble(ini, inla_string_join(secname, init), INLA_SPECIAL_NUMBER);
				if (INLA_IS_SPECIAL(tmp)) {
					tmp = G.log_prec_initial / 2.0;
				}
			} else {
				tmp = iniparser_getdouble(ini, inla_string_join(secname, init), INLA_SPECIAL_NUMBER);
				if (INLA_IS_SPECIAL(tmp)) {
					tmp = 0.0;
				}
			}
			if (!mb->f_fixed[mb->nf][k] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			_SetInitial(k, tmp);
			HYPER_INIT(theta_iidwishart[k], tmp);
			if (mb->verbose) {
				printf("\t\tinitialise theta%1d=[%g]\n", k + 1, tmp);
				printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][k]);
			}
			mb->f_theta[mb->nf][k] = theta_iidwishart[k];

			if (!mb->f_fixed[mb->nf][k]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
				GMRFLib_sprintf(&msg, "Theta%1d for %s", k + 1, mb->f_tag[mb->nf]);
				mb->theta_tag[mb->ntheta] = msg;
				mb->theta_tag_userscale[mb->ntheta] = msg;
				GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], k);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].to_theta);

				mb->theta[mb->ntheta] = theta_iidwishart[k];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_identity;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
			}
		}
		assert(k == n_theta);
	}
		break;

	case F_INTSLOPE:
	{
		int dim = 2;
		int n_theta = inla_iid_wishart_nparam(dim);
		theta_iidwishart = Calloc(n_theta, double **);
		for (i = 0; i < n_theta; i++) {
			HYPER_NEW(theta_iidwishart[i], 0.0);
		}

		mb->f_theta[mb->nf] = Calloc(mb->f_ntheta[mb->nf], double **);
		k = 0;
		for (i = 0; i < dim; i++) {
			/*
			 * first get all the precisions 
			 */
			char *init;

			GMRFLib_sprintf(&init, "INITIAL%1d", k);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, init), G.log_prec_initial);
			if (!mb->f_fixed[mb->nf][k] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			_SetInitial(k, tmp);
			HYPER_INIT(theta_iidwishart[k], tmp);
			if (mb->verbose) {
				printf("\t\tinitialise log_precision (component %d)[%g]\n", k + 1, tmp);
				printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][k]);
			}

			mb->f_theta[mb->nf][k] = theta_iidwishart[k];

			if (!mb->f_fixed[mb->nf][k]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
				GMRFLib_sprintf(&msg, "Log precision for %s (component %1d)", mb->f_tag[mb->nf], k + 1);
				mb->theta_tag[mb->ntheta] = msg;
				GMRFLib_sprintf(&msg, "Precision for %s (component %1d)", mb->f_tag[mb->nf], k + 1);
				mb->theta_tag_userscale[mb->ntheta] = msg;
				GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], k);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].to_theta);

				mb->theta[mb->ntheta] = theta_iidwishart[k];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_precision;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
			}

			k++;
		}
		for (i = 0; i < dim; i++) {
			for (j = i + 1; j < dim; j++) {
				/*
				 * all the correlations 
				 */
				char *init;
				GMRFLib_sprintf(&init, "INITIAL%1d", k);
				tmp = iniparser_getdouble(ini, inla_string_join(secname, init), 0.0);

				if (!mb->f_fixed[mb->nf][k] && mb->reuse_mode) {
					tmp = mb->theta_file[mb->theta_counter_file++];
				}
				_SetInitial(k, tmp);
				HYPER_INIT(theta_iidwishart[k], tmp);
				if (mb->verbose) {
					printf("\t\tinitialise rho_internal%1d:%1d [%g]\n", i + 1, j + 1, tmp);
					printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][k]);
				}

				mb->f_theta[mb->nf][k] = theta_iidwishart[k];

				if (!mb->f_fixed[mb->nf][k]) {
					mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
					mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
					mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][k].hyperid;
					mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
					mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
					mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
					GMRFLib_sprintf(&msg, "Rho_internal%1d:%1d for %s", i + 1, j + 1, mb->f_tag[mb->nf]);
					mb->theta_tag[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "Rho%1d:%1d for %s", i + 1, j + 1, mb->f_tag[mb->nf]);
					mb->theta_tag_userscale[mb->ntheta] = msg;
					GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], k);
					mb->theta_dir[mb->ntheta] = msg;

					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].from_theta);
					mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].to_theta);

					mb->theta[mb->ntheta] = theta_iidwishart[k];
					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map[mb->ntheta] = map_rho;
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
					mb->theta_map_arg[mb->ntheta] = NULL;
					mb->ntheta++;
				}
				k++;
			}
		}

		intslope_gamma = Calloc(INTSLOPE_MAXTHETA, double **);
		for (i = 0; i < INTSLOPE_MAXTHETA; i++) {
			HYPER_NEW(intslope_gamma[i], 1.0);
		}

		int kk;
		for (i = 0; i < INTSLOPE_MAXTHETA; i++) {
			char *init;

			kk = k - n_theta;
			if (i >= nstrata) {

				P(nstrata);
				mb->f_fixed[mb->nf][k] = 1;
			}
			GMRFLib_sprintf(&init, "INITIAL%1d", k);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, init), 1.0);

			if (!mb->f_fixed[mb->nf][k] && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			_SetInitial(k, tmp);
			HYPER_INIT(intslope_gamma[kk], tmp);
			if (mb->verbose) {
				printf("\t\tinitialise gamma[%1d] = [%g]\n", kk, tmp);
				printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][k]);
			}
			mb->f_theta[mb->nf][k] = intslope_gamma[kk];
			if (!mb->f_fixed[mb->nf][k]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
				GMRFLib_sprintf(&msg, "Gamma%1d for %s", kk + 1, mb->f_tag[mb->nf]);
				mb->theta_tag[mb->ntheta] = msg;
				GMRFLib_sprintf(&msg, "Gamma%1d for %s", kk + 1, mb->f_tag[mb->nf]);
				mb->theta_tag_userscale[mb->ntheta] = msg;
				GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], k);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][k].to_theta);

				mb->theta[mb->ntheta] = intslope_gamma[kk];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_identity;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
			}
			k++;
		}

		assert(k == n_theta + INTSLOPE_MAXTHETA);
	}
		break;

	case F_MATERN2D:
	{
		itmp = iniparser_getint(ini, inla_string_join(secname, "NU"), 1);
		mb->f_nu[mb->nf] = itmp;
		if (mb->verbose) {
			printf("\t\tnu = [%1d]\n", itmp);
		}
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf] = Calloc(2, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 2.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(range_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise range_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}

		mb->f_theta[mb->nf][1] = range_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Range_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Range for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = range_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_range;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	case F_DMATERN:
	{
		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL0"), G.log_prec_initial);
		if (!mb->f_fixed[mb->nf][0] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(0, tmp);
		HYPER_INIT(log_prec, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise log_precision[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][0]);
		}

		mb->f_theta[mb->nf] = Calloc(3, double **);
		mb->f_theta[mb->nf][0] = log_prec;
		if (!mb->f_fixed[mb->nf][0]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][0].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "Log precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter0", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][0].to_theta);

			mb->theta[mb->ntheta] = log_prec;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_precision;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL1"), 2.0);
		if (!mb->f_fixed[mb->nf][1] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(1, tmp);
		HYPER_INIT(range_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise range_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][1]);
		}

		mb->f_theta[mb->nf][1] = range_intern;
		if (!mb->f_fixed[mb->nf][1]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "log range for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Range for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = range_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_range;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}

		tmp = iniparser_getdouble(ini, inla_string_join(secname, "INITIAL2"), log(0.5));
		if (!mb->f_fixed[mb->nf][2] && mb->reuse_mode) {
			tmp = mb->theta_file[mb->theta_counter_file++];
		}
		_SetInitial(2, tmp);
		HYPER_INIT(nu_intern, tmp);
		if (mb->verbose) {
			printf("\t\tinitialise nu_intern[%g]\n", tmp);
			printf("\t\tfixed=[%1d]\n", mb->f_fixed[mb->nf][2]);
		}

		mb->f_theta[mb->nf][2] = nu_intern;
		if (!mb->f_fixed[mb->nf][2]) {
			/*
			 * add this \theta 
			 */
			mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
			mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
			mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][1].hyperid;
			mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
			mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
			mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
			GMRFLib_sprintf(&msg, "log nu for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "Nu for %s", (secname ? secname : mb->f_tag[mb->nf]));
			mb->theta_tag_userscale[mb->ntheta] = msg;
			GMRFLib_sprintf(&msg, "%s-parameter1", mb->f_dir[mb->nf]);
			mb->theta_dir[mb->ntheta] = msg;

			mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
			mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
			mb->theta_from[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].from_theta);
			mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][1].to_theta);

			mb->theta[mb->ntheta] = nu_intern;
			mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
			mb->theta_map[mb->ntheta] = map_exp;
			mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
			mb->theta_map_arg[mb->ntheta] = NULL;
			mb->ntheta++;
		}
	}
		break;

	default:
		abort();
	}

	/*
	 ***
	 */

	switch (mb->f_id[mb->nf]) {
	case F_GENERIC0:
	{
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
	}
		break;

	case F_GENERIC1:
	{
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
	}
		break;

	case F_GENERIC2:
	{
		assert(mb->f_N[mb->nf] == 2 * mb->f_n[mb->nf]);
	}
		break;

	case F_GENERIC3:
	{
		assert(mb->f_N[mb->nf] == mb->f_n[mb->nf]);
	}
		break;

	case F_COPY:
	{
		/*
		 * to be filled in later 
		 */
		mb->f_Qfunc[mb->nf] = NULL;
		mb->f_Qfunc_arg[mb->nf] = NULL;
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_N[mb->nf] = mb->f_n[mb->nf] = -1;
		mb->f_id[mb->nf] = F_COPY;
	}
		break;

	case F_CLINEAR:
	{
		inla_clinear_tp *def = Calloc(1, inla_clinear_tp);
		def->beta = beta;
		def->beta_arg = mb->f_theta_map_arg[mb->nf][0];
		def->precision = mb->f_precision[mb->nf];
		def->x = mb->f_locations[mb->nf];

		GMRFLib_graph_mk_linear(&(mb->f_graph[mb->nf]), mb->f_n[mb->nf], 0, 0);
		mb->f_Qfunc[mb->nf] = Qfunc_clinear;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = mfunc_clinear;
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_SIGM:
	case F_REVSIGM:
	{
		// mb->f_id[mb->nf]
		inla_sigm_tp *def = Calloc(1, inla_sigm_tp);
		def->beta = beta;
		def->log_halflife = log_halflife;
		def->log_shape = log_shape;
		def->precision = mb->f_precision[mb->nf];
		def->x = mb->f_locations[mb->nf];

		GMRFLib_graph_mk_linear(&(mb->f_graph[mb->nf]), mb->f_n[mb->nf], 0, 0);
		mb->f_Qfunc[mb->nf] = Qfunc_sigm;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = (mb->f_id[mb->nf] == F_SIGM ? mfunc_sigm : mfunc_revsigm);
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_LOG1EXP:
	{
		inla_log1exp_tp *def = Calloc(1, inla_log1exp_tp);
		def->beta = beta;
		def->alpha = alpha;
		def->gamma = gama;
		def->precision = mb->f_precision[mb->nf];
		def->x = mb->f_locations[mb->nf];

		GMRFLib_graph_mk_linear(&(mb->f_graph[mb->nf]), mb->f_n[mb->nf], 0, 0);
		mb->f_Qfunc[mb->nf] = Qfunc_log1exp;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = mfunc_log1exp;
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_LOGDIST:
	{
		inla_logdist_tp *def = Calloc(1, inla_logdist_tp);
		def->beta = beta;
		def->alpha1 = alpha1;
		def->alpha2 = alpha2;
		def->precision = mb->f_precision[mb->nf];
		def->x = mb->f_locations[mb->nf];

		GMRFLib_graph_mk_linear(&(mb->f_graph[mb->nf]), mb->f_n[mb->nf], 0, 0);
		mb->f_Qfunc[mb->nf] = Qfunc_logdist;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = mfunc_logdist;
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_BESAG:
	{
		inla_besag_Qfunc_arg_tp *arg = NULL;

		mb->f_Qfunc[mb->nf] = Qfunc_besag;
		arg = Calloc(1, inla_besag_Qfunc_arg_tp);
		GMRFLib_graph_duplicate(&(arg->graph), mb->f_graph[mb->nf]);
		arg->log_prec = log_prec;

		int adj = iniparser_getint(ini, inla_string_join(secname, "ADJUST.FOR.CON.COMP"), 1);
		int std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 0);
		if (mb->verbose) {
			printf("\t\tadjust.for.con.comp[%1d]\n", adj);
			printf("\t\tscale.model[%1d]\n", std);
		}
		if (std) {
			inla_besag_scale(thread_id, arg, adj, mb->verbose);
			if (mb->verbose) {
				printf("\t\tscale.model: prec_scale[%g]\n", arg->prec_scale[0]);
			}
		}

		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_rankdef[mb->nf] = 1.0;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_id[mb->nf] = F_BESAG;

		// arg->log_prec[0][0] = 0;
		// GMRFLib_printf_Qfunc(stderr, mb->f_graph[mb->nf], mb->f_Qfunc[mb->nf], mb->f_Qfunc_arg[mb->nf]);
	}
		break;

	case F_BESAG2:
	{
		inla_besag2_Qfunc_arg_tp *arg = NULL;

		mb->f_Qfunc[mb->nf] = Qfunc_besag2;
		arg = Calloc(1, inla_besag2_Qfunc_arg_tp);
		arg->besag_arg = Calloc(1, inla_besag_Qfunc_arg_tp);
		arg->besag_arg->graph = mb->f_graph[mb->nf];

		// do this like this, as only the first half of the diag gets this correction
		if (mb->f_diag[mb->nf]) {
			arg->diag = mb->f_diag[mb->nf];
			mb->f_diag[mb->nf] = 0.0;
		} else {
			arg->diag = 0.0;
		}

		int adj = iniparser_getint(ini, inla_string_join(secname, "ADJUST.FOR.CON.COMP"), 1);
		int std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 0);
		if (mb->verbose) {
			printf("\t\tadjust.for.con.comp[%1d]\n", adj);
			printf("\t\tscale.model[%1d]\n", std);
		}
		if (std) {
			inla_besag_scale(thread_id, arg->besag_arg, adj, mb->verbose);
			if (mb->verbose) {
				printf("\t\tscale.model: prec_scale[%g]\n", arg->besag_arg->prec_scale[0]);
			}
		}

		inla_make_besag2_graph(&(mb->f_graph[mb->nf]), arg->besag_arg->graph);
		arg->precision = mb->f_precision[mb->nf];
		arg->besag_arg->log_prec = log_prec;
		arg->log_a = a_intern;

		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_rankdef[mb->nf] = 1.0;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_id[mb->nf] = F_BESAG2;
	}
		break;

	case F_BYM:
	{
		inla_bym_Qfunc_arg_tp *arg = NULL;
		GMRFLib_graph_tp *g = NULL;

		arg = Calloc(1, inla_bym_Qfunc_arg_tp);
		arg->besag_arg = Calloc(1, inla_besag_Qfunc_arg_tp);

		/*
		 * make the new augmented graph 
		 */
		g = mb->f_graph[mb->nf];
		inla_make_bym_graph(&(mb->f_graph[mb->nf]), g);

		/*
		 * args to the 'besag' model (spatial) 
		 */
		GMRFLib_graph_duplicate(&(arg->besag_arg->graph), g);
		arg->besag_arg->log_prec = log_prec1;

		int adj = iniparser_getint(ini, inla_string_join(secname, "ADJUST.FOR.CON.COMP"), 1);
		int std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 0);
		if (mb->verbose) {
			printf("\t\tadjust.for.con.comp[%1d]\n", adj);
			printf("\t\tscale.model[%1d]\n", std);
		}
		if (std) {
			inla_besag_scale(thread_id, arg->besag_arg, adj, mb->verbose);
			if (mb->verbose) {
				printf("\t\tscale.model: prec_scale[%g]\n", arg->besag_arg->prec_scale[0]);
			}
		}

		/*
		 * remaing ones 
		 */
		arg->n = mb->f_n[mb->nf];
		arg->N = mb->f_N[mb->nf] = 2 * mb->f_n[mb->nf];
		arg->log_prec_iid = log_prec0;

		/*
		 * general 
		 */
		mb->f_Qfunc[mb->nf] = Qfunc_bym;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_rankdef[mb->nf] = 0.0;		       /* since constr=T is converted to extraconstr this will be corrected further below
							        * to 1 */
		break;
	}

	case F_RW2DIID:
	{
		int std;
		inla_rw2diid_Qfunc_arg_tp *arg = NULL;

		arg = Calloc(1, inla_rw2diid_Qfunc_arg_tp);
		arg->rw2ddef = Calloc(1, GMRFLib_rw2ddef_tp);
		arg->rw2ddef->nrow = mb->f_nrow[mb->nf];
		arg->rw2ddef->ncol = mb->f_ncol[mb->nf];
		arg->rw2ddef->order = 2;
		arg->rw2ddef->bvalue = bvalue;
		arg->rw2ddef->cyclic = mb->f_cyclic[mb->nf];

		inla_make_rw2diid_graph(&(mb->f_graph[mb->nf]), arg->rw2ddef);
		std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 1);
		assert(std == 1);			       /* this has to be true for this model */
		GMRFLib_rw2d_scale(thread_id, arg->rw2ddef);
		if (mb->verbose) {
			printf("\t\tscale.model[%1d]\n", std);
			printf("\t\tscale.model: prec_scale[%g]\n", arg->rw2ddef->prec_scale[0]);
		}

		/*
		 * remaing ones 
		 */
		arg->n = mb->f_n[mb->nf];
		arg->N = mb->f_N[mb->nf] = 2 * mb->f_n[mb->nf];
		arg->log_prec = log_prec;
		arg->logit_phi = phi_intern;

		/*
		 * general 
		 */
		mb->f_Qfunc[mb->nf] = Qfunc_rw2diid;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_rankdef[mb->nf] = 0.0;		       /* since constr=T is converted to extraconstr this will be corrected further below
							        * to 1 */
	}
		break;

	case F_BYM2:
	{
		inla_bym2_Qfunc_arg_tp *arg = NULL;
		GMRFLib_graph_tp *g = NULL;

		arg = Calloc(1, inla_bym2_Qfunc_arg_tp);
		arg->besag_arg = Calloc(1, inla_besag_Qfunc_arg_tp);

		/*
		 * make the new augmented graph 
		 */
		g = mb->f_graph[mb->nf];
		inla_make_bym_graph(&(mb->f_graph[mb->nf]), g);	/* yes, its the same graph */
		GMRFLib_graph_duplicate(&(arg->besag_arg->graph), g);

		int adj = iniparser_getint(ini, inla_string_join(secname, "ADJUST.FOR.CON.COMP"), 1);
		int std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 1);

		if (mb->verbose) {
			printf("\t\tadjust.for.con.comp[%1d]\n", adj);
			printf("\t\tscale.model[%1d]\n", std);
		}

		if (std) {
			inla_besag_scale(thread_id, arg->besag_arg, adj, mb->verbose);
			if (mb->verbose) {
				printf("\t\tscale.model: prec_scale[%g]\n", arg->besag_arg->prec_scale[0]);
			}
		} else {
			fprintf(stderr,
				"\n\n*** Warning ***\tModel[%s] in Section[%s] use scale.model=FALSE which is NOT recommended!!!\n\n",
				model, secname);
			arg->besag_arg->prec_scale = Calloc(arg->besag_arg->graph->n, double);
			for (k = 0; k < arg->besag_arg->graph->n; k++) {
				arg->besag_arg->prec_scale[k] = 1.0;
			}
		}

		/*
		 * remaing ones 
		 */
		arg->n = mb->f_n[mb->nf];
		arg->N = mb->f_N[mb->nf] = 2 * mb->f_n[mb->nf];
		arg->log_prec = log_prec0;
		arg->logit_phi = phi_intern;

		/*
		 * general 
		 */
		mb->f_Qfunc[mb->nf] = Qfunc_bym2;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_rankdef[mb->nf] = 0.0;		       /* since constr=T is converted to extraconstr this will be corrected further below
							        * to 1 */
	}
		break;

	case F_BESAGPROPER:
	{
		inla_besag_proper_Qfunc_arg_tp *arg = NULL, *arg_orig = NULL;
		arg = Calloc(1, inla_besag_proper_Qfunc_arg_tp);
		arg_orig = Calloc(1, inla_besag_proper_Qfunc_arg_tp);

		mb->f_Qfunc[mb->nf] = Qfunc_besagproper;
		mb->f_Qfunc_orig[mb->nf] = Qfunc_besagproper;
		GMRFLib_graph_duplicate(&arg->graph, mb->f_graph[mb->nf]);
		GMRFLib_graph_duplicate(&arg_orig->graph, mb->f_graph[mb->nf]);
		GMRFLib_graph_duplicate(&mb->f_graph_orig[mb->nf], mb->f_graph[mb->nf]);
		arg->log_prec = log_prec;
		arg->log_diag = log_diag;
		arg_orig->log_prec = arg_orig->log_diag = NULL;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) arg_orig;
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_id[mb->nf] = F_BESAGPROPER;
	}
		break;

	case F_BESAGPROPER2:
	{
		inla_besag_proper2_Qfunc_arg_tp *arg = NULL, *arg_orig = NULL;
		arg = Calloc(1, inla_besag_proper2_Qfunc_arg_tp);
		arg_orig = Calloc(1, inla_besag_proper2_Qfunc_arg_tp);

		mb->f_Qfunc[mb->nf] = Qfunc_besagproper2;
		mb->f_Qfunc_orig[mb->nf] = Qfunc_besagproper2;
		GMRFLib_graph_duplicate(&arg->graph, mb->f_graph[mb->nf]);
		GMRFLib_graph_duplicate(&arg_orig->graph, mb->f_graph[mb->nf]);
		GMRFLib_graph_duplicate(&mb->f_graph_orig[mb->nf], mb->f_graph[mb->nf]);
		arg->log_prec = log_prec;
		arg->logit_lambda = phi_intern;
		arg_orig->log_prec = arg_orig->logit_lambda = NULL;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) arg_orig;
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_id[mb->nf] = F_BESAGPROPER;
	}
		break;

	case F_SPDE:
	{
		mb->f_Qfunc[mb->nf] = spde_model->Qfunc;
		mb->f_Qfunc_arg[mb->nf] = spde_model->Qfunc_arg;
		mb->f_graph[mb->nf] = spde_model->graph;
		mb->f_rankdef[mb->nf] = 0;
		mb->f_n[mb->nf] = mb->f_N[mb->nf] = spde_model->n;
	}
		break;

	case F_SPDE2:
	{
		mb->f_Qfunc[mb->nf] = spde2_model->Qfunc;
		mb->f_Qfunc_arg[mb->nf] = spde2_model->Qfunc_arg;
		mb->f_graph[mb->nf] = spde2_model->graph;
		mb->f_rankdef[mb->nf] = 0;
		mb->f_n[mb->nf] = mb->f_N[mb->nf] = spde2_model->n;
	}
		break;

	case F_SPDE3:
	{
		mb->f_Qfunc[mb->nf] = spde3_model->Qfunc;
		mb->f_Qfunc_arg[mb->nf] = spde3_model->Qfunc_arg;
		mb->f_graph[mb->nf] = spde3_model->graph;
		mb->f_rankdef[mb->nf] = 0;
		mb->f_n[mb->nf] = mb->f_N[mb->nf] = spde3_model->n;
	}
		break;

	case F_AR:
	{
		GMRFLib_graph_tp *g;
		ar_def_tp *def = Calloc(1, ar_def_tp);

		def->n = mb->f_n[mb->nf];
		def->p = mb->f_order[mb->nf];
		assert((def->n > def->p) && (def->p > 0));
		def->log_prec = log_prec;
		def->pacf_intern = pacf_intern;

		def->hold_pacf_intern = Calloc(GMRFLib_CACHE_LEN, double *);
		def->hold_Q = Calloc(GMRFLib_CACHE_LEN, double *);
		def->hold_Qmarg = Calloc(GMRFLib_CACHE_LEN, double *);
		for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
			def->hold_pacf_intern[i] = Calloc(def->p, double);
			for (j = 0; j < def->p; j++) {
				def->hold_pacf_intern[i][j] = GMRFLib_uniform();
			}
		}

		GMRFLib_graph_mk_linear(&g, def->n, def->p, 0);
		mb->f_Qfunc[mb->nf] = Qfunc_ar;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_graph[mb->nf] = g;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
	}
		break;

	case F_RW2D:
	{
		GMRFLib_rw2ddef_tp *arg = NULL;

		mb->f_Qfunc[mb->nf] = GMRFLib_rw2d;
		arg = Calloc(1, GMRFLib_rw2ddef_tp);
		arg->nrow = mb->f_nrow[mb->nf];
		arg->ncol = mb->f_ncol[mb->nf];
		arg->order = 2;
		arg->cyclic = mb->f_cyclic[mb->nf];
		arg->bvalue = bvalue;
		arg->log_prec_omp = log_prec;

		int std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 0);
		if (mb->verbose) {
			printf("\t\tscale.model[%1d]\n", std);
		}
		if (std) {
			GMRFLib_rw2d_scale(thread_id, (void *) arg);
			if (mb->verbose) {
				printf("\t\tscale.model: prec_scale[%g]\n", arg->prec_scale[0]);
			}
		}

		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_rankdef[mb->nf] = (bvalue == GMRFLib_BVALUE_ZERO ? 0.0 : (arg->cyclic ? 1.0 : 3.0));
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_id[mb->nf] = F_RW2D;
		GMRFLib_make_rw2d_graph(&(mb->f_graph[mb->nf]), arg);
	}
		break;

	case F_Z:
	{
		char *Am = NULL, *Bm = NULL;
		GMRFLib_tabulate_Qfunc_tp *Qfunc_A = NULL, *Qfunc_B = NULL;
		GMRFLib_graph_tp *graph_A = NULL, *graph_B = NULL, *graph_AB = NULL, *gs[2];
		inla_z_arg_tp *arg = NULL, *arg_orig = NULL;
		double **log_prec_orig = NULL;

		Am = iniparser_getstring(ini, inla_string_join(secname, "z.Amatrix"), NULL);
		Bm = iniparser_getstring(ini, inla_string_join(secname, "z.Bmatrix"), NULL);
		GMRFLib_tabulate_Qfunc_from_file(&Qfunc_A, &graph_A, Am, zn + zm, NULL);
		GMRFLib_tabulate_Qfunc_from_file(&Qfunc_B, &graph_B, Bm, zn + zm, NULL);

		gs[0] = graph_A;
		gs[1] = graph_B;
		GMRFLib_graph_union(&graph_AB, gs, 2);

		arg = Calloc(1, inla_z_arg_tp);
		arg->n = zn;
		arg->m = zm;
		arg->log_prec = log_prec;
		arg->graph_A = graph_A;
		arg->Qfunc_A = Qfunc_A;
		arg->graph_B = graph_B;
		arg->Qfunc_B = Qfunc_B;
		arg->graph_AB = graph_AB;

		HYPER_NEW(log_prec_orig, log_prec[0][0]);
		arg_orig = Calloc(1, inla_z_arg_tp);
		Memcpy(arg_orig, arg, sizeof(inla_z_arg_tp));
		arg_orig->log_prec = log_prec_orig;

		mb->f_Qfunc[mb->nf] = Qfunc_z;
		mb->f_Qfunc_orig[mb->nf] = Qfunc_z;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) arg_orig;
		mb->f_rankdef[mb->nf] = 0;		       /* default value */
		GMRFLib_graph_duplicate(&(mb->f_graph[mb->nf]), graph_AB);
		GMRFLib_graph_duplicate(&(mb->f_graph_orig[mb->nf]), graph_AB);
	}
		break;

	case F_SLM:
	{
		char *A1m = NULL, *A2m = NULL, *Bm = NULL, *Cm = NULL;
		GMRFLib_tabulate_Qfunc_tp *Qfunc_A1 = NULL, *Qfunc_A2 = NULL, *Qfunc_B = NULL, *Qfunc_C = NULL;
		GMRFLib_graph_tp *graph_A1 = NULL, *graph_A2 = NULL, *graph_B = NULL, *graph_C = NULL, *graph_slm = NULL, *gs[4];
		inla_slm_arg_tp *arg = NULL, *arg_orig = NULL;
		double **log_prec_orig = NULL, **logit_rho_orig = NULL;

		A1m = iniparser_getstring(ini, inla_string_join(secname, "slm.A1matrix"), NULL);
		A2m = iniparser_getstring(ini, inla_string_join(secname, "slm.A2matrix"), NULL);
		Bm = iniparser_getstring(ini, inla_string_join(secname, "slm.Bmatrix"), NULL);
		Cm = iniparser_getstring(ini, inla_string_join(secname, "slm.Cmatrix"), NULL);

		GMRFLib_tabulate_Qfunc_from_file(&Qfunc_A1, &graph_A1, A1m, slm_n + slm_m, NULL);
		GMRFLib_tabulate_Qfunc_from_file(&Qfunc_A2, &graph_A2, A2m, slm_n + slm_m, NULL);
		GMRFLib_tabulate_Qfunc_from_file(&Qfunc_B, &graph_B, Bm, slm_n + slm_m, NULL);
		GMRFLib_tabulate_Qfunc_from_file(&Qfunc_C, &graph_C, Cm, slm_n + slm_m, NULL);

		gs[0] = graph_A1;
		gs[1] = graph_A2;
		gs[2] = graph_B;
		gs[3] = graph_C;
		GMRFLib_graph_union(&graph_slm, gs, 4);

		arg = Calloc(1, inla_slm_arg_tp);
		arg->rho_min = slm_rho_min;
		arg->rho_max = slm_rho_max;
		arg->n = slm_n;
		arg->m = slm_m;
		arg->log_prec = log_prec;
		arg->logit_rho = rho_intern;

		arg->graph_A1 = graph_A1;
		arg->graph_A2 = graph_A2;
		arg->graph_B = graph_B;
		arg->graph_C = graph_C;
		arg->graph_slm = graph_slm;

		arg->Qfunc_A1 = Qfunc_A1;
		arg->Qfunc_A2 = Qfunc_A2;
		arg->Qfunc_B = Qfunc_B;
		arg->Qfunc_C = Qfunc_C;

		HYPER_NEW(log_prec_orig, log_prec[0][0]);
		HYPER_NEW(logit_rho_orig, rho_intern[0][0]);
		arg_orig = Calloc(1, inla_slm_arg_tp);
		Memcpy(arg_orig, arg, sizeof(inla_slm_arg_tp));
		arg_orig->log_prec = log_prec_orig;
		arg_orig->logit_rho = logit_rho_orig;

		mb->f_Qfunc[mb->nf] = Qfunc_slm;
		mb->f_Qfunc_orig[mb->nf] = Qfunc_slm;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) arg_orig;
		mb->f_rankdef[mb->nf] = 0;		       /* default value */
		GMRFLib_graph_duplicate(&(mb->f_graph[mb->nf]), graph_slm);
		GMRFLib_graph_duplicate(&(mb->f_graph_orig[mb->nf]), graph_slm);
	}
		break;

	case F_2DIID:
	{
		inla_2diid_arg_tp *arg = NULL;

		mb->f_N[mb->nf] = 2 * mb->f_n[mb->nf];
		arg = Calloc(1, inla_2diid_arg_tp);
		arg->n = mb->f_n[mb->nf];
		arg->log_prec0 = log_prec0;
		arg->log_prec1 = log_prec1;
		arg->rho_intern = rho_intern;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		if (mb->f_id[mb->nf] == F_2DIID) {
			mb->f_Qfunc[mb->nf] = Qfunc_2diid;
			inla_make_2diid_graph(&(mb->f_graph[mb->nf]), arg);
		} else {
			mb->f_Qfunc[mb->nf] = Qfunc_2diid_wishart;
			inla_make_2diid_wishart_graph(&(mb->f_graph[mb->nf]), arg);
		}
		mb->f_rankdef[mb->nf] = 0;
	}
		break;

	case F_IID1D:
	case F_IID2D:
	case F_IID3D:
	case F_IID4D:
	case F_IID5D:
	{
		inla_iid_wishart_arg_tp *arg = NULL;
		int dim = WISHART_DIM(mb->nf);
		assert(dim > 0);

		assert(mb->f_N[mb->nf] == mb->f_n[mb->nf]);
		arg = Calloc(1, inla_iid_wishart_arg_tp);
		arg->dim = dim;
		arg->n = mb->f_n[mb->nf] / dim;		       /* yes */
		arg->N = mb->f_N[mb->nf];
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_rankdef[mb->nf] = 0;
		arg->log_prec = theta_iidwishart;
		arg->rho_intern = theta_iidwishart + dim;
		arg->hold = Calloc(GMRFLib_CACHE_LEN, inla_wishart_hold_tp *);
		mb->f_Qfunc[mb->nf] = Qfunc_iid_wishart;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		inla_make_iid_wishart_graph(&(mb->f_graph[mb->nf]), arg);
	}
		break;

	case F_IIDKD:
	{
		inla_iid_wishartk_arg_tp *arg = NULL;
		int dim = mb->f_order[mb->nf];

		assert(mb->f_N[mb->nf] == mb->f_n[mb->nf]);
		arg = Calloc(1, inla_iid_wishartk_arg_tp);
		arg->dim = dim;
		arg->n = mb->f_n[mb->nf] / dim;		       /* yes */
		arg->N = mb->f_N[mb->nf];
		arg->ntheta = INLA_WISHARTK_NTHETA(dim);
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_rankdef[mb->nf] = 0;
		arg->theta = theta_iidwishart;
		arg->vec = Calloc(GMRFLib_CACHE_LEN, double *);
		for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
			arg->vec[i] = Calloc(arg->ntheta, double);
		}
		arg->hold = Calloc(GMRFLib_CACHE_LEN, inla_wishartk_hold_tp *);
		mb->f_Qfunc[mb->nf] = Qfunc_iid_wishartk;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		inla_make_iid_wishartk_graph(&(mb->f_graph[mb->nf]), arg);
	}
		break;

	case F_INTSLOPE:
	{
		int subject;
		inla_intslope_arg_tp *arg = Calloc(1, inla_intslope_arg_tp);

		arg->n = mb->f_n[mb->nf];		       /* n */
		arg->N = mb->f_N[mb->nf];		       /* n + 2 * nsubject */
		arg->precision = mb->f_precision[mb->nf];
		arg->theta_gamma = intslope_gamma;
		arg->def = intslope_def;
		arg->nsubject = nsubject;
		arg->nstrata = nstrata;

		arg->warg = Calloc(1, inla_iid_wishart_arg_tp);
		arg->warg->dim = 2;
		arg->warg->n = nsubject;
		arg->warg->N = arg->warg->dim * arg->warg->n;
		arg->warg->log_prec = theta_iidwishart;
		arg->warg->rho_intern = theta_iidwishart + arg->warg->dim;
		arg->warg->hold = Calloc(GMRFLib_CACHE_LEN, inla_wishart_hold_tp *);

		// For each subject, we need to know all those using it. Since we have all stored in the 'intslope_def' matrix,
		// we only need to store the references to the rows in that one.
		arg->subject_idx = Calloc(nsubject, GMRFLib_idx_tp *);
		for (subject = 0; subject < nsubject; subject++) {
			GMRFLib_idx_create(&(arg->subject_idx[subject]));
		}
		for (int idx = 0; idx < n; idx++) {
			subject = GMRFLib_matrix_get(idx, INTSLOPE_SUBJECT, arg->def);
			GMRFLib_idx_add(&(arg->subject_idx[subject]), idx);
		}

		mb->f_rankdef[mb->nf] = 0;
		mb->f_Qfunc[mb->nf] = Qfunc_intslope;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) arg;   /* need access to the internals later */
		inla_make_intslope_graph(&(mb->f_graph[mb->nf]), arg);
	}
		break;

	case F_SEASONAL:
	{
		GMRFLib_seasonaldef_tp *sdef = NULL;
		int std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 0);

		mb->f_Qfunc[mb->nf] = GMRFLib_seasonal;
		sdef = Calloc(1, GMRFLib_seasonaldef_tp);
		sdef->n = n;
		sdef->s = s;
		sdef->cyclic = mb->f_cyclic[mb->nf];
		sdef->log_prec_omp = log_prec;
		GMRFLib_make_seasonal_graph(&(mb->f_graph[mb->nf]), sdef);
		mb->f_Qfunc_arg[mb->nf] = (void *) sdef;

		if (std) {
			int thread_id = 0;
			assert(omp_get_thread_num() == 0);
			GMRFLib_seasonal_scale(thread_id, sdef);
		}
		if (mb->verbose) {
			printf("\t\tscale.model[%1d]\n", std);
			if (std) {
				printf("\t\tscale.model: prec_scale[%g]\n", sdef->prec_scale[0]);
			}
		}

		/*
		 * for the rank-deficieny, we know the result for CYCLIC=FALSE, but we need to compute it for CYCLIC=TRUE 
		 */
		if (!mb->f_cyclic[mb->nf]) {
			mb->f_rankdef[mb->nf] = s - 1.0;
		} else {
			double *chol = NULL, eps = 1.0e-8, *Q = NULL;
			int *map = NULL, rank;
			GMRFLib_graph_tp *g = NULL;

			g = mb->f_graph[mb->nf];
			Q = Calloc(ISQR(n), double);

			for (i = 0; i < n; i++) {
				Q[i + i * n] = GMRFLib_seasonal(thread_id, i, i, NULL, (void *) sdef);
				for (jj = 0; jj < g->nnbs[i]; jj++) {
					j = g->nbs[i][jj];
					Q[j + i * n] = Q[i + j * n] = GMRFLib_seasonal(thread_id, i, j, NULL, (void *) sdef);
				}
			}
			GMRFLib_comp_chol_semidef(&chol, &map, &rank, Q, n, NULL, eps);
			if (mb->verbose) {
				printf("\t\tcomputed default rank deficiency [%1d]\n", n - rank);
			}
			mb->f_rankdef[mb->nf] = n - rank;
			Free(Q);
			Free(chol);
			Free(map);
		}
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_id[mb->nf] = F_SEASONAL;
	}
		break;

	case F_MEC:
	{
		/*
		 * MEC
		 */
		char *filename_s;
		filename_s = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "SCALE"), NULL));
		if (filename_s) {
			if (mb->verbose) {
				printf("\t\tread scale from file=[%s]\n", filename_s);
			}
			inla_read_data_general(&(mb->f_scale[mb->nf]), NULL, NULL, filename_s, mb->predictor_n, 0, 1, mb->verbose, 1.0);
		} else {
			if (mb->verbose) {
				printf("\t\tno scale\n");
			}
			mb->f_scale[mb->nf] = Calloc(mb->predictor_n, double);
			int ii;
			for (ii = 0; ii < mb->predictor_n; ii++) {
				mb->f_scale[mb->nf][ii] = 1.0;
			}
		}

		inla_mec_tp *def = Calloc(1, inla_mec_tp);

		def->beta = beta;
		def->log_prec_obs = log_prec;
		def->mean_x = mean_x;
		def->log_prec_x = log_prec_x;
		def->x_obs = mb->f_locations[mb->nf];
		// must make a copy... (realloc)
		def->scale = Calloc(mb->predictor_n, double);
		def->map_beta_arg = mb->f_theta_map_arg[mb->nf][0];
		Memcpy(def->scale, mb->f_scale[mb->nf], mb->predictor_n * sizeof(double));

		GMRFLib_graph_mk_linear(&(mb->f_graph[mb->nf]), mb->f_n[mb->nf], 0, 0);
		mb->f_Qfunc[mb->nf] = Qfunc_mec;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;

		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = mfunc_mec;
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_MEB:
	{
		/*
		 * MEB
		 */
		char *filename_s;
		filename_s = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "SCALE"), NULL));
		if (filename_s) {
			if (mb->verbose) {
				printf("\t\tread scale from file=[%s]\n", filename_s);
			}
			inla_read_data_general(&(mb->f_scale[mb->nf]), NULL, NULL, filename_s, mb->predictor_n, 0, 1, mb->verbose, 1.0);
		} else {
			if (mb->verbose) {
				printf("\t\tno scale\n");
			}
			mb->f_scale[mb->nf] = Calloc(mb->predictor_n, double);
			int ii;
			for (ii = 0; ii < mb->predictor_n; ii++) {
				mb->f_scale[mb->nf][ii] = 1.0;
			}
		}

		inla_meb_tp *def = Calloc(1, inla_meb_tp);

		def->beta = beta;
		def->log_prec = log_prec;
		def->x = mb->f_locations[mb->nf];
		// must make a copy... (realloc)
		def->scale = Calloc(mb->predictor_n, double);
		Memcpy(def->scale, mb->f_scale[mb->nf], mb->predictor_n * sizeof(double));
		def->map_beta_arg = mb->f_theta_map_arg[mb->nf][0];

		GMRFLib_graph_mk_linear(&(mb->f_graph[mb->nf]), mb->f_n[mb->nf], 0, 0);
		mb->f_Qfunc[mb->nf] = Qfunc_meb;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;

		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = mfunc_meb;
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_R_GENERIC:
	{
		/*
		 * R_GENERIC
		 */
		inla_rgeneric_tp *def = Calloc(1, inla_rgeneric_tp), *def_orig = Calloc(1, inla_rgeneric_tp);
		double ***tptr;

		def->filename = GMRFLib_strdup(rgeneric_filename);
		def->model = GMRFLib_strdup(rgeneric_model);
		def->mu = Calloc(GMRFLib_CACHE_LEN, double *);
		def->mu_param = Calloc(GMRFLib_CACHE_LEN, double *);
		def->ntheta = mb->f_ntheta[mb->nf];
		def->param = Calloc(GMRFLib_CACHE_LEN, double *);
		def->Q = Calloc(GMRFLib_CACHE_LEN, GMRFLib_tabulate_Qfunc_tp *);
		def->reset_cache = 0;			       /* only do if = 0 */
		def->graph = NULL;
		if (def->ntheta) {
			tptr = Calloc(def->ntheta, double **);
			for (j = 0; j < def->ntheta; j++)
				tptr[j] = mb->f_theta[mb->nf][j];
			def->theta = tptr;
		} else {
			def->theta = NULL;
		}

		def_orig->filename = GMRFLib_strdup(rgeneric_filename);
		def_orig->model = GMRFLib_strdup(rgeneric_model);
		def_orig->mu = Calloc(GMRFLib_CACHE_LEN, double *);
		def_orig->mu_param = Calloc(GMRFLib_CACHE_LEN, double *);
		def_orig->ntheta = mb->f_ntheta[mb->nf];
		def_orig->param = Calloc(GMRFLib_CACHE_LEN, double *);
		def_orig->Q = Calloc(GMRFLib_CACHE_LEN, GMRFLib_tabulate_Qfunc_tp *);
		if (def_orig->ntheta) {
			tptr = Calloc(def_orig->ntheta, double **);
			for (j = 0; j < def_orig->ntheta; j++)
				tptr[j] = mb->f_theta[mb->nf][j];
			def_orig->theta = tptr;
		} else {
			def_orig->theta = NULL;
		}

		int n_out;
		double *x_out;
#pragma omp critical (Name_0c216629b47f30b75846e1131aec8233bfdd80bb)
		{
			int zero = 0;
			inla_R_rgeneric(&n_out, &x_out, R_GENERIC_GRAPH, def->model, &zero, NULL);
		}

		int n, len, *ilist, *jlist, k = 0;

		assert(n_out >= 2);
		n = (int) x_out[k++];
		len = (int) x_out[k++];

		ilist = Calloc(len, int);
		for (i = 0; i < len; i++) {
			ilist[i] = (int) x_out[k++];
		}

		jlist = Calloc(len, int);
		for (i = 0; i < len; i++) {
			jlist[i] = (int) x_out[k++];
		}
		assert(k == n_out);

		double *Qijlist = Calloc(len, double);
		for (i = 0; i < len; i++) {
			Qijlist[i] = 1.0;
		}

		GMRFLib_tabulate_Qfunc_tp *tab;
		GMRFLib_graph_tp *graph, *ggraph;

		GMRFLib_tabulate_Qfunc_from_list(&tab, &graph, len, ilist, jlist, Qijlist, n, NULL);
		GMRFLib_free_tabulate_Qfunc(tab);
		Free(ilist);
		Free(jlist);
		Free(Qijlist);
		Free(x_out);

		def->graph = graph;
		mb->f_graph[mb->nf] = graph;
		mb->f_Qfunc[mb->nf] = Qfunc_rgeneric;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;

		// save the indices for the graph, as we need them repeatedly
		def->len_list = graph->nnz / 2 + graph->n;
		def->ilist = Calloc(def->len_list, int);
		def->jlist = Calloc(def->len_list, int);
		for (i = 0, k = 0; i < graph->n; i++) {
			def->ilist[k] = i;
			def->jlist[k] = i;
			k++;
			for (jj = 0; jj < graph->lnnbs[i]; jj++) {
				j = graph->lnbs[i][jj];
				def->ilist[k] = i;
				def->jlist[k] = j;
				k++;
			}
		}

		// we need to revert the order of the list. pretty annoying...
		GMRFLib_qsorts((void *) def->jlist, (size_t) def->len_list, sizeof(int), (void *) def->ilist, sizeof(int), NULL, 0, GMRFLib_icmp);
		// now we need to sort within each value of jlist.
		assert(def->jlist[0] == 0);
		for (j = k = 0; j < graph->n; j++) {
			for (jj = k; jj < def->len_list; jj++) {
				if (def->jlist[jj] > j)
					break;
			}
			qsort((void *) &def->ilist[k], (size_t) (jj - k), sizeof(int), GMRFLib_icmp);
			k = jj;
		}
		assert(k == def->len_list);

		def_orig->len_list = def->len_list;
		def_orig->ilist = Calloc(def_orig->len_list, int);
		def_orig->jlist = Calloc(def_orig->len_list, int);
		Memcpy(def_orig->ilist, def->ilist, def->len_list * sizeof(int));
		Memcpy(def_orig->jlist, def->jlist, def->len_list * sizeof(int));

		GMRFLib_graph_duplicate(&ggraph, graph);
		def_orig->graph = graph;
		mb->f_graph_orig[mb->nf] = ggraph;
		mb->f_Qfunc_orig[mb->nf] = Qfunc_rgeneric;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) def_orig;

		mb->f_N[mb->nf] = mb->f_n[mb->nf] = def->n = graph->n;
		mb->f_rankdef[mb->nf] = 0.0;

		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = mfunc_rgeneric;
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_C_GENERIC:
	{
		/*
		 * C_GENERIC
		 */
		inla_cgeneric_tp *def = Calloc(1, inla_cgeneric_tp), *def_orig = Calloc(1, inla_cgeneric_tp);
		double ***tptr;

		def->shlib = GMRFLib_strdup(cgeneric_shlib);
		def->model = GMRFLib_strdup(cgeneric_model);
		def->model_func = model_func;
		def->data = cgeneric_data;
		def->secname = GMRFLib_strdup(secname);
		def->debug = cgeneric_debug;
		def->mu = Calloc(GMRFLib_CACHE_LEN, double *);
		def->mu_param = Calloc(GMRFLib_CACHE_LEN, double *);
		def->ntheta = mb->f_ntheta[mb->nf];
		def->param = Calloc(GMRFLib_CACHE_LEN, double *);
		def->Q = Calloc(GMRFLib_CACHE_LEN, GMRFLib_tabulate_Qfunc_tp *);
		def->reset_cache = 0;			       /* only do if = 0 */
		def->graph = NULL;
		if (def->ntheta) {
			tptr = Calloc(def->ntheta, double **);
			for (j = 0; j < def->ntheta; j++) {
				tptr[j] = mb->f_theta[mb->nf][j];
			}
			def->theta = tptr;
		} else {
			def->theta = NULL;
		}

		def_orig->shlib = GMRFLib_strdup(cgeneric_shlib);
		def_orig->model = GMRFLib_strdup(cgeneric_model);
		def_orig->model_func = model_func;
		def_orig->data = cgeneric_data;
		def_orig->secname = GMRFLib_strdup(secname);
		def_orig->debug = cgeneric_debug;
		def_orig->mu = Calloc(GMRFLib_CACHE_LEN, double *);
		def_orig->mu_param = Calloc(GMRFLib_CACHE_LEN, double *);
		def_orig->ntheta = mb->f_ntheta[mb->nf];
		def_orig->param = Calloc(GMRFLib_CACHE_LEN, double *);
		def_orig->Q = Calloc(GMRFLib_CACHE_LEN, GMRFLib_tabulate_Qfunc_tp *);
		if (def_orig->ntheta) {
			tptr = Calloc(def_orig->ntheta, double **);
			for (j = 0; j < def_orig->ntheta; j++) {
				tptr[j] = mb->f_theta[mb->nf][j];
			}
			def_orig->theta = tptr;
		} else {
			def_orig->theta = NULL;
		}


		double *x_out = NULL;
		x_out = model_func(INLA_CGENERIC_GRAPH, NULL, cgeneric_data);
		if (cgeneric_debug) {
			inla_cgeneric_debug(stdout, secname, INLA_CGENERIC_GRAPH, x_out);
		}

		int n, len, *ilist, *jlist, k = 0;
		n = (int) x_out[k++];
		len = (int) x_out[k++];
		ilist = Calloc(len, int);
		for (i = 0; i < len; i++) {
			ilist[i] = (int) x_out[k++];
		}
		jlist = Calloc(len, int);
		for (i = 0; i < len; i++) {
			jlist[i] = (int) x_out[k++];
		}

		double *Qijlist = Calloc(len, double);
		for (i = 0; i < len; i++) {
			Qijlist[i] = 1.0;
		}

		GMRFLib_tabulate_Qfunc_tp *tab;
		GMRFLib_graph_tp *graph, *ggraph;

		GMRFLib_tabulate_Qfunc_from_list(&tab, &graph, len, ilist, jlist, Qijlist, n, NULL);
		GMRFLib_free_tabulate_Qfunc(tab);
		Free(ilist);
		Free(jlist);
		Free(Qijlist);
		Free(x_out);

		def->graph = graph;
		mb->f_graph[mb->nf] = graph;
		mb->f_Qfunc[mb->nf] = Qfunc_cgeneric;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;

		// save the indices for the graph, as we need them repeatedly
		def->len_list = graph->nnz / 2 + graph->n;
		def->ilist = Calloc(def->len_list, int);
		def->jlist = Calloc(def->len_list, int);
		for (i = 0, k = 0; i < graph->n; i++) {
			def->ilist[k] = i;
			def->jlist[k] = i;
			k++;
			for (jj = 0; jj < graph->lnnbs[i]; jj++) {
				j = graph->lnbs[i][jj];
				def->ilist[k] = i;
				def->jlist[k] = j;
				assert(def->ilist[k] <= def->jlist[k]);
				k++;
			}
		}

		def_orig->len_list = def->len_list;
		def_orig->ilist = Calloc(def_orig->len_list, int);
		def_orig->jlist = Calloc(def_orig->len_list, int);
		Memcpy(def_orig->ilist, def->ilist, def->len_list * sizeof(int));
		Memcpy(def_orig->jlist, def->jlist, def->len_list * sizeof(int));

		GMRFLib_graph_duplicate(&ggraph, graph);
		def_orig->graph = graph;
		mb->f_graph_orig[mb->nf] = ggraph;
		mb->f_Qfunc_orig[mb->nf] = Qfunc_cgeneric;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) def_orig;

		mb->f_N[mb->nf] = mb->f_n[mb->nf] = def->n = graph->n;
		mb->f_rankdef[mb->nf] = 0.0;

		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = mfunc_cgeneric;
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_FGN:
	{
		inla_fgn_arg_tp *def = NULL, *def_orig = NULL;

		def = Calloc(1, inla_fgn_arg_tp);
		def->n = mb->f_n[mb->nf];
		assert(def->n > 1);
		def->k = mb->f_order[mb->nf];
		def->N = def->n * (def->k + 1);
		def->log_prec = log_prec;
		def->H_intern = H_intern;
		def->prec_eps = mb->f_precision[mb->nf];

		if (mb->f_locations[mb->nf]) {
			double *t = Calloc((def->k + 1) * mb->f_n[mb->nf], double);
			Memcpy(&t[0], mb->f_locations[mb->nf], mb->f_n[mb->nf] * sizeof(double));
			Memcpy(&t[mb->f_n[mb->nf]], mb->f_locations[mb->nf], mb->f_n[mb->nf] * sizeof(double));

			double start = floor(GMRFLib_max_value(t, mb->f_n[mb->nf], NULL) + 1.0);
			for (int ii = 0; ii < def->k * mb->f_n[mb->nf]; ii++) {
				t[ii + mb->f_n[mb->nf]] = start + ii;
			}
			mb->f_locations[mb->nf] = t;
		}

		double **log_prec_orig = NULL, **H_intern_orig = NULL;
		HYPER_NEW(log_prec_orig, log_prec[0][0]);
		HYPER_NEW(H_intern_orig, H_intern[0][0]);

		def_orig = Calloc(1, inla_fgn_arg_tp);
		def_orig->n = def->n;
		def_orig->k = def->k;
		def_orig->N = def->N;
		def_orig->prec_eps = def->prec_eps;
		def_orig->log_prec = log_prec_orig;
		def_orig->H_intern = H_intern_orig;

		inla_make_fgn_graph(&(mb->f_graph[mb->nf]), def);
		mb->f_Qfunc[mb->nf] = Qfunc_fgn;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;

		inla_make_fgn_graph(&(mb->f_graph_orig[mb->nf]), def_orig);
		mb->f_Qfunc_orig[mb->nf] = Qfunc_fgn;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) def_orig;

		mb->f_N[mb->nf] = mb->f_n[mb->nf] = mb->f_graph[mb->nf]->n;
		assert(mb->f_N[mb->nf] == def->N);
		mb->f_rankdef[mb->nf] = 0.0;

		// initialize the cache
		Qfunc_fgn(thread_id, -1, -1, NULL, NULL);
	}
		break;

	case F_FGN2:
	{
		inla_fgn2_arg_tp *def = NULL, *def_orig = NULL;

		def = Calloc(1, inla_fgn2_arg_tp);
		def->n = mb->f_n[mb->nf];
		assert(def->n > 1);
		def->k = mb->f_order[mb->nf];
		def->N = def->n * def->k;
		def->log_prec = log_prec;
		def->H_intern = H_intern;

		if (mb->f_locations[mb->nf]) {
			double *t = Calloc((def->k + 1) * mb->f_n[mb->nf], double);
			Memcpy(&t[0], mb->f_locations[mb->nf], mb->f_n[mb->nf] * sizeof(double));
			Memcpy(&t[mb->f_n[mb->nf]], mb->f_locations[mb->nf], mb->f_n[mb->nf] * sizeof(double));

			double start = floor(GMRFLib_max_value(t, mb->f_n[mb->nf], NULL) + 1.0);
			for (int ii = 0; ii < def->k * mb->f_n[mb->nf]; ii++) {
				t[ii + mb->f_n[mb->nf]] = start + ii;
			}
			mb->f_locations[mb->nf] = t;
		}

		double **log_prec_orig = NULL, **H_intern_orig = NULL;
		HYPER_NEW(log_prec_orig, log_prec[0][0]);
		HYPER_NEW(H_intern_orig, H_intern[0][0]);

		def_orig = Calloc(1, inla_fgn2_arg_tp);
		def_orig->n = def->n;
		def_orig->k = def->k;
		def_orig->N = def->N;
		def_orig->log_prec = log_prec_orig;
		def_orig->H_intern = H_intern_orig;

		inla_make_fgn2_graph(&(mb->f_graph[mb->nf]), def);
		mb->f_Qfunc[mb->nf] = Qfunc_fgn2;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;

		inla_make_fgn2_graph(&(mb->f_graph_orig[mb->nf]), def_orig);
		mb->f_Qfunc_orig[mb->nf] = Qfunc_fgn2;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) def_orig;

		mb->f_N[mb->nf] = mb->f_n[mb->nf] = mb->f_graph[mb->nf]->n;
		assert(mb->f_N[mb->nf] == def->N);
		mb->f_rankdef[mb->nf] = 0.0;

		// initialize the cache
		Qfunc_fgn2(thread_id, -1, -1, NULL, NULL);
	}
		break;

	case F_AR1:
	{
		/*
		 * AR1 
		 */
		inla_ar1_arg_tp *def = NULL;

		def = Calloc(1, inla_ar1_arg_tp);
		def->n = mb->f_n[mb->nf];
		assert(def->n > 1);
		def->cyclic = mb->f_cyclic[mb->nf];
		def->log_prec = log_prec;
		def->phi_intern = phi_intern;
		def->mean = mean_x;
		inla_make_ar1_graph(&(mb->f_graph[mb->nf]), def);
		mb->f_Qfunc[mb->nf] = Qfunc_ar1;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;

		mb->f_bfunc2[mb->nf] = Calloc(1, GMRFLib_bfunc2_tp);
		mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
		mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->diagonal = mb->f_diag[mb->nf];
		mb->f_bfunc2[mb->nf]->mfunc = mfunc_ar1;
		mb->f_bfunc2[mb->nf]->mfunc_arg = mb->f_Qfunc_arg[mb->nf];
		mb->f_bfunc2[mb->nf]->n = mb->f_n[mb->nf];
		mb->f_bfunc2[mb->nf]->nreplicate = 1;
		mb->f_bfunc2[mb->nf]->ngroup = 1;
	}
		break;

	case F_AR1C:
	{
		/*
		 * AR1C
		 */
		inla_ar1c_arg_tp *def = NULL, *def_orig = NULL;
		char *filename;

		def = Calloc(1, inla_ar1c_arg_tp);
		def_orig = Calloc(1, inla_ar1c_arg_tp);

		def->n = iniparser_getint(ini, inla_string_join(secname, "ar1c.n"), -1);
		def->m = iniparser_getint(ini, inla_string_join(secname, "ar1c.m"), -1);
		def->N = def->n + def->m;
		assert(def->N == mb->f_n[mb->nf]);
		if (mb->verbose) {
			printf("\t\tn.ar1=[%1d]\n", def->n);
			printf("\t\tm.beta=[%1d]\n", def->m);
			printf("\t\tN=[%1d]\n", def->N);
		}
		if (def->m > 0) {
			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "ar1c.Z"), NULL));
			def->Z = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);
			Free(filename);

			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "ar1c.ZZ"), NULL));
			def->ZZ = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);
			Free(filename);

			filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "ar1c.Qbeta"), NULL));
			def->Qbeta = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);
			Free(filename);
			{
				// compute the log|Qbeta| for the normalizing constant
				int i, j;
				gsl_matrix *QQ = gsl_matrix_alloc(def->m, def->m);
				for (i = 0; i < def->m; i++) {
					for (j = 0; j < def->m; j++) {
						gsl_matrix_set(QQ, i, j, GMRFLib_matrix_get(i, j, def->Qbeta));
					}
				}
				def->logdet_Qbeta = GMRFLib_gsl_spd_logdet(QQ);
				gsl_matrix_free(QQ);
				if (mb->verbose) {
					printf("\t\tlog(det(Q.beta))=[%.4g]\n", def->logdet_Qbeta);
				}
			}
		} else {
			filename = iniparser_getstring(ini, inla_string_join(secname, "ar1c.Z"), NULL);	/* in case they are there */
			filename = iniparser_getstring(ini, inla_string_join(secname, "ar1c.ZZ"), NULL);
			filename = iniparser_getstring(ini, inla_string_join(secname, "ar1c.Qbeta"), NULL);

			def->Z = NULL;
			def->ZZ = NULL;
			def->Qbeta = NULL;
			def->logdet_Qbeta = 0.0;
		}

		def->log_prec = log_prec;
		def->phi_intern = phi_intern;

		def_orig->n = def->n;			       /* these are the ones I need in extra() */
		def_orig->m = def->m;
		def_orig->logdet_Qbeta = def->logdet_Qbeta;

		inla_make_ar1c_graph(&(mb->f_graph[mb->nf]), def);
		mb->f_Qfunc[mb->nf] = Qfunc_ar1c;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) def_orig;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;
	}
		break;

	case F_OU:
	{
		/*
		 * OU
		 */
		inla_ou_arg_tp *def = NULL;

		def = Calloc(1, inla_ou_arg_tp);
		def->n = mb->f_n[mb->nf];
		def->log_prec = log_prec;
		def->phi_intern = phi_intern;
		assert(mb->f_locations[mb->nf]);
		def->locations = mb->f_locations[mb->nf];
		inla_make_ou_graph(&(mb->f_graph[mb->nf]), def);
		mb->f_Qfunc[mb->nf] = Qfunc_ou;
		mb->f_Qfunc_arg[mb->nf] = (void *) def;

		/*
		 * need this one later to get 'n'. a copy of the original contents is ok. 
		 */
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) Calloc(1, inla_ou_arg_tp);
		Memcpy(mb->f_Qfunc_arg_orig[mb->nf], mb->f_Qfunc_arg[mb->nf], sizeof(inla_ou_arg_tp));

		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_rankdef[mb->nf] = 0.0;
	}
		break;

	case F_MATERN2D:
	{
		/*
		 * MATERN2D
		 */
		GMRFLib_matern2ddef_tp *arg = NULL;

		arg = Calloc(1, GMRFLib_matern2ddef_tp);
		arg->nrow = mb->f_nrow[mb->nf];
		arg->ncol = mb->f_ncol[mb->nf];
		arg->cyclic = mb->f_cyclic[mb->nf];
		arg->nu = mb->f_nu[mb->nf];
		arg->log_prec_omp = log_prec;
		arg->log_range_omp = range_intern;

		GMRFLib_matern2ddef_tp *arg_orig = NULL;
		arg_orig = Calloc(1, GMRFLib_matern2ddef_tp);
		Memcpy(arg_orig, arg, sizeof(GMRFLib_matern2ddef_tp));

		mb->f_Qfunc[mb->nf] = GMRFLib_matern2d;
		mb->f_Qfunc_orig[mb->nf] = GMRFLib_matern2d;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) arg_orig;
		mb->f_rankdef[mb->nf] = 0.0;
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_id[mb->nf] = F_MATERN2D;
		GMRFLib_make_matern2d_graph(&(mb->f_graph[mb->nf]), arg);
		GMRFLib_make_matern2d_graph(&(mb->f_graph_orig[mb->nf]), arg);
	}
		break;

	case F_DMATERN:
	{
		dmatern_arg_tp *arg = Calloc(1, dmatern_arg_tp);
		dmatern_arg_tp *arg_orig = Calloc(1, dmatern_arg_tp);

		filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "dmatern.locations"), NULL));
		arg->locations = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);
		Free(filename);

		if (!strcasecmp(mb->f_prior[mb->nf][1].name, "PCRANGE")) {
			// In this case, the parameters of the prior depends on the dimension. This is fixed here, where we
			// compute lambda = -U^(dim/2)*log(alpha) and then the parametes are redefined to be (lambda, dim)
			double U = mb->f_prior[mb->nf][1].parameters[0];
			double alpha = mb->f_prior[mb->nf][1].parameters[1];
			double dim = arg->locations->ncol;
			mb->f_prior[mb->nf][1].parameters[0] = -pow(U, dim / 2.0) * log(alpha);
			mb->f_prior[mb->nf][1].parameters[1] = dim;
		}

		arg->n = arg->locations->nrow;
		arg->dim = arg->locations->ncol;
		arg->log_range = range_intern;
		arg->log_prec = log_prec;
		arg->log_nu = nu_intern;
		Memcpy(arg_orig, arg, sizeof(dmatern_arg_tp));

		mb->f_Qfunc[mb->nf] = Qfunc_dmatern;
		mb->f_Qfunc_orig[mb->nf] = Qfunc_dmatern;
		mb->f_Qfunc_arg[mb->nf] = (void *) arg;
		mb->f_Qfunc_arg_orig[mb->nf] = (void *) arg_orig;
		// dense graph
		GMRFLib_graph_mk_linear(&(mb->f_graph[mb->nf]), arg->n, arg->n, 0);
		GMRFLib_graph_mk_linear(&(mb->f_graph_orig[mb->nf]), arg->n, arg->n, 0);
		mb->f_rankdef[mb->nf] = 0.0;
		assert(mb->f_n[mb->nf] == arg->n);
		mb->f_N[mb->nf] = mb->f_n[mb->nf];
		mb->f_id[mb->nf] = F_DMATERN;

		// setup cache and prefill parameters with random numbers
		arg->param = Calloc(GMRFLib_CACHE_LEN, double *);
		arg->Q = Calloc(GMRFLib_CACHE_LEN, gsl_matrix *);
		arg_orig->param = Calloc(GMRFLib_CACHE_LEN, double *);
		arg_orig->Q = Calloc(GMRFLib_CACHE_LEN, gsl_matrix *);

		for (int i = 0; i < GMRFLib_CACHE_LEN; i++) {
			int np = 3;
			arg->param[i] = Calloc(np, double);
			arg_orig->param[i] = Calloc(np, double);
			for (int j = 0; j < np; j++) {
				arg->param[i][j] = GMRFLib_uniform();
				arg_orig->param[i][j] = GMRFLib_uniform();
			}
		}

		// compute the distance between locations. 
		arg->dist = gsl_matrix_alloc(arg->n, arg->n);
		arg_orig->dist = arg->dist;		       /* read only */
		for (int i = 0; i < arg->n; i++) {
			for (int j = i; j < arg->n; j++) {
				if (i == j) {
					gsl_matrix_set(arg->dist, i, j, 0.0);
				} else {
					double dist = 0.0;

					for (int k = 0; k < arg->dim; k++) {
						dist += SQR(GMRFLib_matrix_get(i, k, arg->locations)
							    - GMRFLib_matrix_get(j, k, arg->locations));
					}
					dist = sqrt(dist);
					gsl_matrix_set(arg->dist, i, j, dist);
					gsl_matrix_set(arg->dist, j, i, dist);
				}
			}
		}
	}
		break;

	default:
	{
		/*
		 * RW-models. do a special test for cyclic, since this require locations = default
		 */
		if ((mb->f_id[mb->nf] == F_IID || mb->f_id[mb->nf] == F_RW1 || mb->f_id[mb->nf] == F_RW2) && mb->f_cyclic[mb->nf]) {
			GMRFLib_rwdef_tp *rwdef = NULL;

			if (mb->f_locations[mb->nf]) {
				int ok = 1;
				double diff = mb->f_locations[mb->nf][1] - mb->f_locations[mb->nf][0];

				for (int j = 2; j < mb->f_n[mb->nf]; j++) {
					if (mb->f_locations[mb->nf][j] - mb->f_locations[mb->nf][j - 1] != diff) {
						ok = 0;
						break;
					}
				}
				if (!ok) {
					fprintf(stderr, "\n*** Warning ***\tModel[%s] in Section[%s] has cyclic = TRUE but values != NULL.\n",
						model, secname);
					fprintf(stderr, "*** Warning ***\tCylic = TRUE is not implemented for non-equal spaced values.\n");
					fprintf(stderr, "*** Warning ***\tAssume values are equal spaced.\n\n");
				}
			}

			int std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 0);

			rwdef = Calloc(1, GMRFLib_rwdef_tp);
			rwdef->n = mb->f_n[mb->nf];
			if (mb->f_id[mb->nf] == F_IID) {
				rwdef->order = 0;

				/*
				 * this case has an extra option: scale
				 */
				char *filename_s;
				filename_s = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "SCALE"), NULL));
				if (filename_s) {
					if (mb->verbose) {
						printf("\t\tread scale from file=[%s]\n", filename_s);
					}
					inla_read_data_general(&(rwdef->scale0), NULL, NULL, filename_s, rwdef->n, 0, 1, mb->verbose, 1.0);
					mb->f_scale[mb->nf] = rwdef->scale0;	/* need a copy */
				} else {
					rwdef->scale0 = NULL;
				}
			} else if (mb->f_id[mb->nf] == F_RW1) {
				rwdef->order = 1;
			} else {
				assert(mb->f_id[mb->nf] == F_RW2);
				rwdef->order = 2;
			}
			assert(rwdef->n > rwdef->order);
			rwdef->log_prec_omp = log_prec;
			rwdef->cyclic = mb->f_cyclic[mb->nf];
			if (mb->f_cyclic[mb->nf]) {
				if (rwdef->order == 0) {
					mb->f_rankdef[mb->nf] = 0.0;
				} else {
					mb->f_rankdef[mb->nf] = 1.0;
				}
			} else {
				abort();
			}
			GMRFLib_make_rw_graph(&(mb->f_graph[mb->nf]), rwdef);
			if (mb->verbose) {
				printf("\t\tscale.model[%1d]\n", std);
			}
			if (std) {
				GMRFLib_rw_scale(thread_id, (void *) rwdef);
				if (mb->verbose) {
					printf("\t\tscale.model: prec_scale[%g]\n", rwdef->prec_scale[0]);
				}
			}

			mb->f_Qfunc[mb->nf] = GMRFLib_rw;
			mb->f_Qfunc_arg[mb->nf] = (void *) rwdef;
			mb->f_N[mb->nf] = mb->f_graph[mb->nf]->n;
		} else if ((mb->f_id[mb->nf] == F_IID || mb->f_id[mb->nf] == F_RW1 ||
			    mb->f_id[mb->nf] == F_RW2 || mb->f_id[mb->nf] == F_CRW2) && !mb->f_cyclic[mb->nf]) {
			crwdef = Calloc(1, GMRFLib_crwdef_tp);
			crwdef->n = mb->f_n[mb->nf];
			crwdef->log_prec_omp = log_prec;
			if (mb->f_id[mb->nf] == F_IID) {
				crwdef->order = 0;
				/*
				 * this case has an extra option: scale
				 */
				char *filename_s;
				filename_s = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "SCALE"), NULL));
				if (filename_s) {
					if (mb->verbose) {
						printf("\t\tread scale from file=[%s]\n", filename_s);
					}
					inla_read_data_general(&(crwdef->scale0), NULL, NULL, filename_s, crwdef->n, 0, 1, mb->verbose, 1.0);
					mb->f_scale[mb->nf] = crwdef->scale0;	/* need a copy */
				} else {
					crwdef->scale0 = NULL;
				}
				crwdef->layout = GMRFLib_CRW_LAYOUT_SIMPLE;
				mb->f_rankdef[mb->nf] = 0.0;
			} else if (mb->f_id[mb->nf] == F_RW1) {
				crwdef->order = 1;
				crwdef->layout = GMRFLib_CRW_LAYOUT_SIMPLE;
				mb->f_rankdef[mb->nf] = 1.0;
			} else if (mb->f_id[mb->nf] == F_RW2) {
				crwdef->order = 2;
				crwdef->layout = GMRFLib_CRW_LAYOUT_SIMPLE;
				mb->f_rankdef[mb->nf] = 2.0;
			} else if (mb->f_id[mb->nf] == F_CRW2) {
				crwdef->order = 2;
				crwdef->layout = GMRFLib_CRW_LAYOUT_BLOCK;
				mb->f_rankdef[mb->nf] = 2.0;

				/*
				 * duplicate the locations and swap the sign, if they are present
				 */
				if (mb->f_locations[mb->nf]) {
					double *t = Calloc(2 * mb->f_n[mb->nf], double);
					Memcpy(&t[0], mb->f_locations[mb->nf], mb->f_n[mb->nf] * sizeof(double));
					Memcpy(&t[mb->f_n[mb->nf]], mb->f_locations[mb->nf], mb->f_n[mb->nf] * sizeof(double));

					int ii;
					for (ii = mb->f_n[mb->nf]; ii < 2 * mb->f_n[mb->nf]; ii++) {
						t[ii] *= -1.0;
					}

					mb->f_locations[mb->nf] = t;
				}
			} else {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "model", model);
			}
			crwdef->position = mb->f_locations[mb->nf];	/* do this here, as the locations are duplicated for CRW2 */
			assert(crwdef->n > crwdef->order);
			int std = iniparser_getint(ini, inla_string_join(secname, "SCALE.MODEL"), 0);
			if (mb->f_id[mb->nf] == F_RW1 || mb->f_id[mb->nf] == F_RW2 || mb->f_id[mb->nf] == F_CRW2) {
				if (std) {
					GMRFLib_crw_scale(thread_id, (void *) crwdef);
				}
				if (mb->verbose) {
					printf("\t\tscale.model[%1d]\n", std);
					if (std)
						printf("\t\tscale.model: prec_scale[%g]\n", crwdef->prec_scale[0]);
				}
			} else {
				if (std) {
					char *msg;
					GMRFLib_sprintf(&msg,
							"model[%s]. scale.model=TRUE but this model cannot be scaled. Contact developers\n", model);
					inla_error_general(msg);
					exit(1);
				}
			}

			GMRFLib_make_crw_graph(&(mb->f_graph[mb->nf]), crwdef);
			mb->f_Qfunc[mb->nf] = GMRFLib_crw;
			mb->f_Qfunc_arg[mb->nf] = (void *) crwdef;
			mb->f_N[mb->nf] = mb->f_graph[mb->nf]->n;
		} else {
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}
	}
	}

	/*
	 * read optional extra constraint 
	 */
	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "EXTRACONSTRAINT"), NULL));
	if (filename) {
		if (mb->verbose) {
			printf("\t\tread extra constraint from file=[%s]\n", filename);
		}
		mb->f_constr[mb->nf] = inla_read_constraint(filename, mb->f_N[mb->nf]);
		if (mb->verbose) {
			int nnc = mb->f_constr[mb->nf]->nc;

			for (j = 0; j < nnc; j++) {
				printf("\t\tConstraint[%1d]\n", j);
				int k = 0;
				for (i = 0; i < mb->f_N[mb->nf]; i++) {
					double a = mb->f_constr[mb->nf]->a_matrix[i * nnc + j];
					if (!ISZERO(a) || mb->f_N[mb->nf] <= PREVIEW) {
						printf("\t\t\tA[%1d] = %f\n", i, a);
						k++;
					}
					if (k > PREVIEW)
						break;
				}
				printf("\t\t\te[%1d] = %f\n", j, mb->f_constr[mb->nf]->e_vector[j]);
			}
		}
	}

	/*
	 * hold a copy of the original constraints before `group' and `replicate' 
	 */
	mb->f_constr_orig[mb->nf] = inla_make_constraint(mb->f_N[mb->nf], mb->f_sumzero[mb->nf], mb->f_constr[mb->nf]);

	/*
	 * determine the final rankdef. 
	 */
	rd = iniparser_getdouble(ini, inla_string_join(secname, "RANKDEF"), -1.0);
	if (rd >= 0) {
		/*
		 * if RANKDEF is given, then this is used, not matter what! 
		 */
		mb->f_rankdef[mb->nf] = rd;
		if (mb->verbose) {
			printf("\t\trank-deficiency is *defined* [%g]\n", rd);
		}
	} else {
		/*
		 * use the previously set default value for the rankdef.  only in the case of a proper model, correct for sumzero
		 * constraint 
		 */
		if (ISZERO(mb->f_rankdef[mb->nf])) {
			mb->f_rankdef[mb->nf] = (mb->f_sumzero[mb->nf] ? 1.0 : 0.0);
		}
		/*
		 * if extra constraint(s), then correct for this. OOPS: this *can* be wrong, if the extra constraint are in the
		 * NULL-space of Q, but then the RANKDEF *is* required. 
		 */
		mb->f_rankdef[mb->nf] += (mb->f_constr[mb->nf] ? mb->f_constr[mb->nf]->nc : 0.0);
		if (mb->verbose) {
			printf("\t\tcomputed/guessed rank-deficiency = [%g]\n", mb->f_rankdef[mb->nf]);
		}
	}
	inla_parse_output(mb, ini, sec, &(mb->f_output[mb->nf]));

	/*
	 * for all models except the F_COPY one, do the group and replicate expansions 
	 */
	if (mb->f_id[mb->nf] != F_COPY) {

		if (mb->f_ngroup[mb->nf] > 1) {
			/*
			 * add groups! 
			 */
			ptmp = GMRFLib_strdup("EXCHANGEABLE");
			ptmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GROUP.MODEL"), ptmp));
			if (!strcasecmp(ptmp, "EXCHANGEABLE")) {
				mb->f_group_model[mb->nf] = G_EXCHANGEABLE;
			} else if (!strcasecmp(ptmp, "EXCHANGEABLEPOS")) {
				mb->f_group_model[mb->nf] = G_EXCHANGEABLE_POS;
			} else if (!strcasecmp(ptmp, "AR1")) {
				mb->f_group_model[mb->nf] = G_AR1;
			} else if (!strcasecmp(ptmp, "AR")) {
				mb->f_group_model[mb->nf] = G_AR;
			} else if (!strcasecmp(ptmp, "RW1")) {
				mb->f_group_model[mb->nf] = G_RW1;
			} else if (!strcasecmp(ptmp, "RW2")) {
				mb->f_group_model[mb->nf] = G_RW2;
			} else if (!strcasecmp(ptmp, "BESAG")) {
				mb->f_group_model[mb->nf] = G_BESAG;
			} else if (!strcasecmp(ptmp, "IID")) {
				mb->f_group_model[mb->nf] = G_IID;
			} else {
				GMRFLib_sprintf(&msg, "%s: Unknown GROUP.MODEL: %s\n", secname, ptmp);
				inla_error_general(msg);
				abort();
			}

			ptmp2 = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GROUP.GRAPH"), NULL));
			if (ptmp2) {
				GMRFLib_graph_read(&(mb->f_group_graph[mb->nf]), ptmp2);
			}

			mb->f_group_cyclic[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "GROUP.CYCLIC"), 0);
			mb->f_group_order[mb->nf] = iniparser_getint(ini, inla_string_join(secname, "GROUP.ORDER"), -1);
			if (mb->verbose) {
				printf("\t\tgroup.model = %s\n", ptmp);
				printf("\t\tgroup.graph = %s\n", (ptmp2 ? ptmp2 : "<NONE>"));
				printf("\t\tgroup.cyclic = %s\n", (mb->f_group_cyclic[mb->nf] ? "True" : "False"));
				printf("\t\tgroup.order = %1d\n", mb->f_group_order[mb->nf]);
			}

			switch (mb->f_group_model[mb->nf]) {
			case G_EXCHANGEABLE:
			case G_EXCHANGEABLE_POS:
			case G_AR1:
			case G_RW1:
			case G_RW2:
			case G_BESAG:
			case G_IID:
				fixed = iniparser_getboolean(ini, inla_string_join(secname, "GROUP.FIXED"), 0);
				tmp = iniparser_getdouble(ini, inla_string_join(secname, "GROUP.INITIAL"), 0.0);
				if (!fixed && mb->reuse_mode) {
					tmp = mb->theta_file[mb->theta_counter_file++];
				}
				mb->f_initial[mb->nf] = Realloc(mb->f_initial[mb->nf], mb->f_ntheta[mb->nf] + 1, double);
				_SetInitial(mb->f_ntheta[mb->nf], tmp);
				if (mb->f_group_model[mb->nf] == G_AR1 || mb->f_group_model[mb->nf] == G_EXCHANGEABLE ||
				    mb->f_group_model[mb->nf] == G_EXCHANGEABLE_POS) {
					HYPER_INIT(group_rho_intern, tmp);
					if (mb->verbose) {
						printf("\t\tinitialise group_rho_intern[%g]\n", tmp);
						printf("\t\tgroup.fixed=[%1d]\n", fixed);
					}
				} else {
					HYPER_INIT(group_prec_intern, tmp);
					if (mb->verbose) {
						printf("\t\tinitialise group_prec_intern[%g]\n", tmp);
						printf("\t\tgroup.fixed=[%1d]\n", fixed);
					}
				}
				mb->f_theta[mb->nf] = Realloc(mb->f_theta[mb->nf], mb->f_ntheta[mb->nf] + 1, double **);
				mb->f_fixed[mb->nf] = Realloc(mb->f_fixed[mb->nf], mb->f_ntheta[mb->nf] + 1, int);
				mb->f_prior[mb->nf] = Realloc(mb->f_prior[mb->nf], mb->f_ntheta[mb->nf] + 1, Prior_tp);

				if (mb->f_group_model[mb->nf] == G_AR1 || mb->f_group_model[mb->nf] == G_EXCHANGEABLE ||
				    mb->f_group_model[mb->nf] == G_EXCHANGEABLE_POS) {
					mb->f_theta[mb->nf][mb->f_ntheta[mb->nf]] = group_rho_intern;
				} else {
					mb->f_theta[mb->nf][mb->f_ntheta[mb->nf]] = group_prec_intern;
				}
				mb->f_fixed[mb->nf][mb->f_ntheta[mb->nf]] = fixed;

				switch (mb->f_group_model[mb->nf]) {
				case G_EXCHANGEABLE:
				case G_EXCHANGEABLE_POS:
				{
					inla_read_prior_group(mb, ini, sec, &(mb->f_prior[mb->nf][mb->f_ntheta[mb->nf]]), "GAUSSIAN-group", NULL);
					mb->f_ntheta[mb->nf]++;
				}
					break;

				case G_AR1:
				{
					inla_read_prior_group(mb, ini, sec, &(mb->f_prior[mb->nf][mb->f_ntheta[mb->nf]]), "GAUSSIAN-rho", NULL);
					mb->f_ntheta[mb->nf]++;
				}
					break;

				case G_IID:
				case G_RW1:
				case G_RW2:
				case G_BESAG:
				{
					inla_read_prior_group(mb, ini, sec, &(mb->f_prior[mb->nf][mb->f_ntheta[mb->nf]]), "LOGGAMMA", NULL);
					mb->f_ntheta[mb->nf]++;
				}
					break;

				default:
					GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
					abort();
				}

				if (!fixed) {
					/*
					 * add this \theta 
					 */
					mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
					mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
					mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][mb->f_ntheta[mb->nf] - 1].hyperid;
					mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
					mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
					mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

					if (mb->f_group_model[mb->nf] == G_AR1 || mb->f_group_model[mb->nf] == G_EXCHANGEABLE ||
					    mb->f_group_model[mb->nf] == G_EXCHANGEABLE_POS) {
						GMRFLib_sprintf(&msg, "Group rho_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
						mb->theta_tag[mb->ntheta] = msg;
						GMRFLib_sprintf(&msg, "GroupRho for %s", (secname ? secname : mb->f_tag[mb->nf]));
						mb->theta_tag_userscale[mb->ntheta] = msg;
					} else {
						GMRFLib_sprintf(&msg, "Group prec_intern for %s", (secname ? secname : mb->f_tag[mb->nf]));
						mb->theta_tag[mb->ntheta] = msg;
						GMRFLib_sprintf(&msg, "GroupPrec for %s", (secname ? secname : mb->f_tag[mb->nf]));
						mb->theta_tag_userscale[mb->ntheta] = msg;
					}

					GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], mb->f_ntheta[mb->nf] - 1);
					mb->theta_dir[mb->ntheta] = msg;
					if (mb->f_group_model[mb->nf] == G_AR1 || mb->f_group_model[mb->nf] == G_EXCHANGEABLE ||
					    mb->f_group_model[mb->nf] == G_EXCHANGEABLE_POS) {
						mb->theta[mb->ntheta] = group_rho_intern;
					} else {
						mb->theta[mb->ntheta] = group_prec_intern;
					}

					mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
					mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);

					int *ngp = NULL;
					switch (mb->f_group_model[mb->nf]) {
					case G_EXCHANGEABLE:
					{
						mb->theta_map[mb->ntheta] = map_group_rho;
						// need to add a pointer that stays fixed, mb->theta_map_arg[mb->nf] does not!
						ngp = Calloc(1, int);
						*ngp = mb->f_ngroup[mb->nf];
						mb->theta_map_arg[mb->ntheta] = (void *) ngp;
					}
						break;

					case G_EXCHANGEABLE_POS:
					{
						mb->theta_map[mb->ntheta] = map_probability;
						// need to add a pointer that stays fixed, mb->theta_map_arg[mb->nf] does not!
						ngp = Calloc(1, int);
						*ngp = mb->f_ngroup[mb->nf];
						mb->theta_map_arg[mb->ntheta] = (void *) ngp;
					}
						break;

					case G_AR1:
					{
						mb->theta_map[mb->ntheta] = map_rho;
						mb->theta_map_arg[mb->ntheta] = NULL;
					}
						break;

					case G_IID:
					case G_RW1:
					case G_RW2:
					case G_BESAG:
					{
						mb->theta_map[mb->ntheta] = map_precision;
						mb->theta_map_arg[mb->ntheta] = NULL;
					}
						break;

					default:
						inla_error_general("this should not happen");
					}

					Prior_tp *pri = &(mb->f_prior[mb->nf][mb->f_ntheta[mb->nf] - 1]);

					mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
					mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
					mb->theta_from[mb->ntheta] = GMRFLib_strdup(pri->from_theta);
					mb->theta_to[mb->ntheta] = GMRFLib_strdup(pri->to_theta);

					mb->ntheta++;
				}
				break;

			case G_AR:
			{
				int ntheta, ntheta_orig;

				ntheta_orig = mb->f_ntheta[mb->nf];
				ntheta = mb->f_group_order[mb->nf] + 1;
				assert(ntheta <= AR_MAXTHETA + 1 && ntheta >= 1);
				assert(11 == AR_MAXTHETA + 1);

				mb->f_prior[mb->nf] = Realloc(mb->f_prior[mb->nf], ntheta_orig + AR_MAXTHETA + 1, Prior_tp);
				inla_read_prior_group0(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 0]), "LOGGAMMA", NULL);
				inla_read_prior_group1(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 1]), "PCRHO0", NULL);
				inla_read_prior_group2(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 2]), "PCRHO0", NULL);
				inla_read_prior_group3(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 3]), "PCRHO0", NULL);
				inla_read_prior_group4(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 4]), "PCRHO0", NULL);
				inla_read_prior_group5(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 5]), "PCRHO0", NULL);
				inla_read_prior_group6(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 6]), "PCRHO0", NULL);
				inla_read_prior_group7(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 7]), "PCRHO0", NULL);
				inla_read_prior_group8(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 8]), "PCRHO0", NULL);
				inla_read_prior_group9(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 9]), "PCRHO0", NULL);
				inla_read_prior_group10(mb, ini, sec, &(mb->f_prior[mb->nf][ntheta_orig + 10]), "PCRHO0", NULL);

				mb->f_initial[mb->nf] = Realloc(mb->f_initial[mb->nf], ntheta_orig + AR_MAXTHETA + 1, double);
				if (mb->verbose) {
					printf("\t\tgroup.ntheta = [%1d]\n", ntheta);
				}

				/*
				 * mark all possible as read 
				 */

				// mark all as read
				for (i = 0; i < AR_MAXTHETA + 1; i++) {
					for (int j = 0; j < keywords_len; j++) {
						GMRFLib_sprintf(&ctmp, "GROUP.%s%1d", keywords[j], i);
						iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
						Free(ctmp);
					}
				}

				mb->f_fixed[mb->nf] = Realloc(mb->f_fixed[mb->nf], ntheta_orig + AR_MAXTHETA + 1, int);
				mb->f_theta[mb->nf] = Realloc(mb->f_theta[mb->nf], ntheta_orig + AR_MAXTHETA + 1, double **);

				HYPER_NEW(log_prec, 0.0);
				mb->f_theta[mb->nf][ntheta_orig] = log_prec;
				pacf_intern = Calloc(AR_MAXTHETA + 1, double **);
				for (i = 0; i < AR_MAXTHETA; i++) {
					HYPER_NEW(pacf_intern[i], 0.0);
					mb->f_theta[mb->nf][ntheta_orig + i + 1] = pacf_intern[i];
				}

				/*
				 * then read those we need 
				 */
				for (i = 0; i < ntheta; i++) {
					double theta_initial = 0;

					GMRFLib_sprintf(&ctmp, "GROUP.FIXED%1d", i);
					mb->f_fixed[mb->nf][ntheta_orig + i] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);

					GMRFLib_sprintf(&ctmp, "GROUP.INITIAL%1d", i);
					theta_initial = iniparser_getdouble(ini, inla_string_join(secname, ctmp), theta_initial);

					if (!mb->f_fixed[mb->nf][ntheta_orig + i] && mb->reuse_mode) {
						theta_initial = mb->theta_file[mb->theta_counter_file++];
					}

					if (i == 0) {
						/*
						 * precision 
						 */
						HYPER_INIT(log_prec, theta_initial);
						if (mb->verbose) {
							printf("\t\tinitialise (log_prec) group.theta[%1d]=[%g]\n", i, theta_initial);
							printf("\t\tfixed[%1d]=[%1d]\n", i, mb->f_fixed[mb->nf][ntheta_orig + i]);
						}

						if (!mb->f_fixed[mb->nf][ntheta_orig + i]) {
							/*
							 * add this \theta 
							 */
							mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
							mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
							mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][ntheta_orig + 0].hyperid;

							mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
							mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
							mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
							GMRFLib_sprintf(&msg, "Group Log precision for %s",
									(secname ? secname : mb->f_tag[mb->nf]));

							mb->theta_tag[mb->ntheta] = msg;
							GMRFLib_sprintf(&msg, "Group Precision for %s", (secname ? secname : mb->f_tag[mb->nf]));
							mb->theta_tag_userscale[mb->ntheta] = msg;
							GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], ntheta_orig + i + 1);
							mb->theta_dir[mb->ntheta] = msg;

							mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
							mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
							mb->theta_from[mb->ntheta] =
							    GMRFLib_strdup(mb->f_prior[mb->nf][ntheta_orig + 0].from_theta);
							mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][ntheta_orig + 0].to_theta);
							mb->theta[mb->ntheta] = log_prec;
							mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
							mb->theta_map[mb->ntheta] = map_precision;
							mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
							mb->theta_map_arg[mb->ntheta] = NULL;
							mb->ntheta++;
						}
					} else {
						/*
						 * PACF 
						 */
						HYPER_INIT(pacf_intern[i - 1], theta_initial);
						if (mb->verbose) {
							printf("\t\tinitialise (PACF) theta[%1d]=[%g]\n", i, theta_initial);
							printf("\t\tfixed[%1d]=[%1d]\n", i, mb->f_fixed[mb->nf][ntheta_orig + i]);
						}
						if (!mb->f_fixed[mb->nf][ntheta_orig + i]) {
							/*
							 * add this \theta 
							 */
							mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
							mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
							mb->theta_hyperid[mb->ntheta] = mb->f_prior[mb->nf][ntheta_orig + i].hyperid;
							mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
							mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
							mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);
							GMRFLib_sprintf(&msg, "Group Intern PACF%1d for %s", i,
									(secname ? secname : mb->f_tag[mb->nf]));

							mb->theta_tag[mb->ntheta] = msg;
							GMRFLib_sprintf(&msg, "Group PACF%1d for %s", i, (secname ? secname : mb->f_tag[mb->nf]));
							mb->theta_tag_userscale[mb->ntheta] = msg;
							GMRFLib_sprintf(&msg, "%s-parameter%1d", mb->f_dir[mb->nf], ntheta_orig + i + 1);
							mb->theta_dir[mb->ntheta] = msg;

							mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
							mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
							mb->theta_from[mb->ntheta] =
							    GMRFLib_strdup(mb->f_prior[mb->nf][ntheta_orig + i].from_theta);
							mb->theta_to[mb->ntheta] = GMRFLib_strdup(mb->f_prior[mb->nf][ntheta_orig + i].to_theta);
							mb->theta[mb->ntheta] = pacf_intern[i - 1];
							mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
							mb->theta_map[mb->ntheta] = map_phi;
							mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
							mb->theta_map_arg[mb->ntheta] = NULL;
							mb->ntheta++;
						}
					}
				}
			}
				break;

			default:
				GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
			}

			/*
			 * make required changes.  oops, the rankdef is for the size-n model, not the size-N one! 
			 */
			int ng = mb->f_ngroup[mb->nf];
			int Norig = mb->f_N[mb->nf];
			GMRFLib_graph_tp *g;

			inla_make_group_graph(&g, mb->f_graph[mb->nf], ng, mb->f_group_model[mb->nf], mb->f_group_cyclic[mb->nf],
					      mb->f_group_order[mb->nf], mb->f_group_graph[mb->nf]);
			GMRFLib_graph_free(mb->f_graph[mb->nf]);
			mb->f_graph[mb->nf] = g;

			/*
			 * make the constraints 
			 */
			GMRFLib_constr_tp *c;
			c = inla_make_constraint2(mb->f_N[mb->nf], mb->f_ngroup[mb->nf], mb->f_sumzero[mb->nf], mb->f_constr[mb->nf]);
			if (c) {
				mb->f_sumzero[mb->nf] = 0;
				Free(mb->f_constr[mb->nf]);
				mb->f_constr[mb->nf] = c;
			}

			/*
			 * redefine the N's, also change the rankdef as its defined for `n'. 
			 */
			mb->f_n[mb->nf] *= ng;
			mb->f_N[mb->nf] *= ng;
			mb->f_rankdef[mb->nf] *= ng;

			int adj = iniparser_getint(ini, inla_string_join(secname, "GROUP.ADJUST.FOR.CON.COMP"), 1);
			int std = iniparser_getint(ini, inla_string_join(secname, "GROUP.SCALE.MODEL"), 0);

			/*
			 * setup the new Qfunc++ 
			 */
			inla_group_def_tp *def = Calloc(1, inla_group_def_tp);

			def->N = Norig;
			def->ngroup = ng;
			def->cyclic = mb->f_group_cyclic[mb->nf];
			def->graph = mb->f_group_graph[mb->nf];
			def->type = mb->f_group_model[mb->nf];
			def->Qfunc = mb->f_Qfunc[mb->nf];
			mb->f_Qfunc[mb->nf] = Qfunc_group;
			def->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
			mb->f_Qfunc_arg[mb->nf] = (void *) def;
			def->group_rho_intern = group_rho_intern;
			def->group_prec_intern = group_prec_intern;
			if (mb->f_group_model[mb->nf] == G_RW1 || mb->f_group_model[mb->nf] == G_RW2) {
				if (def->cyclic) {
					/*
					 * as cyclic is only implemented for GMRFLib_rw()
					 */
					def->rwdef = Calloc(1, GMRFLib_rwdef_tp);
					def->rwdef->n = ng;
					def->rwdef->order = (mb->f_group_model[mb->nf] == G_RW1 ? 1 : 2);
					def->rwdef->cyclic = mb->f_group_cyclic[mb->nf];
					def->rwdef->log_prec_omp = NULL;
					if (std) {
						char *err;
						GMRFLib_sprintf(&err, "Group: cannot scale.model with option cylic=TRUE. Contact developers.");
						inla_error_general(err);
						exit(1);
					}
				} else {
					/*
					 * otherwise, we use the general function
					 */
					def->crwdef = Calloc(1, GMRFLib_crwdef_tp);
					def->crwdef->n = ng;
					def->crwdef->order = (mb->f_group_model[mb->nf] == G_RW1 ? 1 : 2);
					def->crwdef->log_prec_omp = NULL;
					def->crwdef->layout = GMRFLib_CRW_LAYOUT_SIMPLE;
					def->crwdef->position = Calloc(ng, double);
					int kk;
					for (kk = 0; kk < ng; kk++) {
						def->crwdef->position[kk] = (double) kk;
					}
					if (std) {
						GMRFLib_crw_scale(thread_id, (void *) def->crwdef);
					}
					if (mb->verbose) {
						printf("\t\tgroup.scale.model[%1d]\n", std);
						if (std) {
							printf("\t\tgroup.scale.model: prec_scale[%g]\n", def->crwdef->prec_scale[0]);
						}
					}
				}

			} else if (mb->f_group_model[mb->nf] == G_AR) {
				def->ardef = Calloc(1, ar_def_tp);
				def->ardef->n = mb->f_ngroup[mb->nf];
				def->ardef->p = mb->f_group_order[mb->nf];
				def->ardef->log_prec = log_prec;
				def->ardef->pacf_intern = pacf_intern;
				def->ardef->hold_pacf_intern = Calloc(GMRFLib_CACHE_LEN, double *);
				def->ardef->hold_Q = Calloc(GMRFLib_CACHE_LEN, double *);
				def->ardef->hold_Qmarg = Calloc(GMRFLib_CACHE_LEN, double *);
				for (i = 0; i < GMRFLib_CACHE_LEN; i++) {
					def->ardef->hold_pacf_intern[i] = Calloc(def->ardef->p, double);
					for (j = 0; j < def->ardef->p; j++) {
						def->ardef->hold_pacf_intern[i][j] = GMRFLib_uniform();
					}
				}
			} else if (mb->f_group_model[mb->nf] == G_BESAG) {
				def->besagdef = Calloc(1, inla_besag_Qfunc_arg_tp);
				def->besagdef->graph = mb->f_group_graph[mb->nf];
				if (mb->verbose) {
					printf("\t\tgroup.scale.model[%1d]\n", std);
					printf("\t\tgroup.adjust.for.con.comp[%1d]\n", std);
				}
				if (std) {
					inla_besag_scale(thread_id,  (inla_besag_Qfunc_arg_tp *) (def->besagdef), adj, mb->verbose);
				}
			} else {
				def->rwdef = NULL;
				def->crwdef = NULL;
				def->ardef = NULL;
				def->besagdef = NULL;
			}

			if (mb->f_bfunc2[mb->nf]) {
				/*
				 * then revise the contents
				 */
				mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
				mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
				mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
				mb->f_bfunc2[mb->nf]->ngroup = ng;
			}
		}

		/*
		 * Do the replicate stuff; this is nice hack! 
		 */
		int rep = mb->f_nrep[mb->nf];
		if (rep > 1) {
			inla_replicate_tp *rep_arg = Calloc(1, inla_replicate_tp);
			rep_arg->Qfunc = mb->f_Qfunc[mb->nf];
			rep_arg->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
			rep_arg->n = mb->f_N[mb->nf];
			inla_replicate_graph(&(mb->f_graph[mb->nf]), rep);	/* this also free the old one */
			mb->f_Qfunc[mb->nf] = Qfunc_replicate;
			mb->f_Qfunc_arg[mb->nf] = (void *) rep_arg;

			GMRFLib_constr_tp *c;
			c = inla_make_constraint2(mb->f_N[mb->nf], mb->f_nrep[mb->nf], mb->f_sumzero[mb->nf], mb->f_constr[mb->nf]);
			if (c) {
				mb->f_sumzero[mb->nf] = 0;
				Free(mb->f_constr[mb->nf]);
				mb->f_constr[mb->nf] = c;
			}
			// GMRFLib_constr_printf(stdout, c, mb->f_graph[mb->nf]);

			if (mb->f_bfunc2[mb->nf]) {
				/*
				 * Then revise the contents
				 */
				mb->f_bfunc2[mb->nf]->graph = mb->f_graph[mb->nf];
				mb->f_bfunc2[mb->nf]->Qfunc = mb->f_Qfunc[mb->nf];
				mb->f_bfunc2[mb->nf]->Qfunc_arg = mb->f_Qfunc_arg[mb->nf];
				mb->f_bfunc2[mb->nf]->nreplicate = rep;
			}
		}
		mb->f_Ntotal[mb->nf] = mb->f_N[mb->nf] * rep;
	} else {
		mb->f_Ntotal[mb->nf] = -1;		       /* yes this is set later */
	}

	mb->nf++;
#undef _SET
#undef _OneOf
#undef _OneOf2
#undef _OneOf3
#undef _SetInitial
	return INLA_OK;
}

double iid_mfunc(int idx, void *UNUSED(arg))
{
	return 1.0 + idx;
}

double Qfunc_copy_part00(int thread_id, int i, int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_copy_arg_tp *a = (inla_copy_arg_tp *) arg;

	if (i == j) {
		double beta = a->map_beta(a->beta[thread_id][0], MAP_FORWARD, a->map_beta_arg);
		return a->Qfunc(thread_id, i, j, NULL, a->Qfunc_arg) + a->precision * SQR(beta);
	} else {
		return a->Qfunc(thread_id, i, j, NULL, a->Qfunc_arg);
	}
}

double Qfunc_copy_part01(int thread_id, int UNUSED(i), int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_copy_arg_tp *a = (inla_copy_arg_tp *) arg;
	double beta = a->map_beta(a->beta[thread_id][0], MAP_FORWARD, a->map_beta_arg);

	return -a->precision * beta;
}

double Qfunc_copy_part11(int UNUSED(thread_id), int UNUSED(i), int j, double *UNUSED(values), void *arg)
{
	if (j < 0) {
		return NAN;
	}

	inla_copy_arg_tp *a = (inla_copy_arg_tp *) arg;

	return a->precision;
}

int inla_add_copyof(inla_tp * mb)
{
	int i, k, kk, kkk, nf = mb->nf;
	const int debug = 0;
	char *msg;

	if (debug) {
		for (k = 0; k < nf; k++) {
			printf("k= %1d tag= %s of= %s\n", k, mb->f_tag[k], mb->f_of[k]);
		}
	}

	for (k = 0; k < nf; k++) {
		if (mb->f_id[k] == F_COPY) {
			if (debug) {
				printf("ffield %d is F_COPY\n", k);
			}

			kk = find_tag(mb, mb->f_of[k]);
			if (kk < 0 || k == kk) {
				GMRFLib_sprintf(&msg, "ffield %1d is F_COPY and a copy of %s which is not found", k, mb->f_of[k]);
				inla_error_general(msg);
				exit(EXIT_FAILURE);
			}
			if (mb->f_id[kk] == F_COPY && kk > k) {
				GMRFLib_sprintf(&msg, "ffield [%s] is a copy of a (later defined) F_COPY field [%s]; please swap",
						mb->f_tag[k], mb->f_tag[kk]);
				inla_error_general(msg);
				exit(EXIT_FAILURE);
			}

			if (mb->f_same_as[k]) {
				kkk = find_tag(mb, mb->f_same_as[k]);
				if (kkk < 0) {
					GMRFLib_sprintf(&msg, "ffield %1d is F_COPY but same.as=[%s] is not found", k, mb->f_same_as[k]);
					inla_error_general(msg);
					exit(EXIT_FAILURE);
				}
				if (mb->f_id[kkk] != F_COPY) {
					GMRFLib_sprintf(&msg,
							"ffield [%s] is a copy of [%s], but same.as=[%s] which is not F_COPY\n",
							mb->f_tag[k], mb->f_tag[kk], mb->f_same_as[k]);
					inla_error_general(msg);
					exit(EXIT_FAILURE);
				}
				if (kkk == k) {
					GMRFLib_sprintf(&msg,
							"ffield [%s] is a copy of [%s], but same.as=[%s] which is not allowed.\n",
							mb->f_tag[k], mb->f_tag[kk], mb->f_same_as[k]);
					inla_error_general(msg);
					exit(EXIT_FAILURE);
				}
				if (kkk > k) {
					GMRFLib_sprintf(&msg,
							"ffield [%s] is a copy of [%s], but same.as=[%s] which is after; please swap. %1d > %1d\n",
							mb->f_tag[k], mb->f_tag[kk], mb->f_same_as[k], kkk, k);
					inla_error_general(msg);
					exit(EXIT_FAILURE);
				}
			} else {
				kkk = k;
			}

			if (debug) {
				if (mb->f_same_as[k]) {
					printf("found name %s at ffield %1d [same.as %s = ffield %1d]\n", mb->f_of[k], kk, mb->f_same_as[k], kkk);
				} else {
					printf("found name %s at ffield %1d\n", mb->f_of[k], kk);
				}
			}

			/*
			 * this is required! 
			 */
			if (!mb->ff_Qfunc) {
				mb->ff_Qfunc = Calloc(nf, GMRFLib_Qfunc_tp **);
				mb->ff_Qfunc_arg = Calloc(nf, void **);
				for (i = 0; i < nf; i++) {
					mb->ff_Qfunc[i] = Calloc(nf, GMRFLib_Qfunc_tp *);
					mb->ff_Qfunc_arg[i] = Calloc(nf, void *);
				}
			}

			/*
			 * yes, just use that size 
			 */
			GMRFLib_graph_mk_linear(&(mb->f_graph[k]), mb->f_Ntotal[kk], 0, 0);
			GMRFLib_free_constr(mb->f_constr[k]);  /* if its any */
			mb->f_constr[k] = NULL;
			mb->f_sumzero[k] = 0;
			mb->f_rankdef[k] = 0;

			inla_copy_arg_tp *arg = Calloc(1, inla_copy_arg_tp);

			arg->Qfunc = mb->f_Qfunc[kk];
			arg->Qfunc_arg = mb->f_Qfunc_arg[kk];
			arg->precision = mb->f_precision[k];
			arg->beta = mb->f_theta[kkk][0];

			arg->map_beta = mb->f_theta_map[kkk][0];
			arg->map_beta_arg = mb->f_theta_map_arg[kkk][0];

			if (0) {
				if (arg->map_beta_arg) {
					printf("range %g %g\n", ((double *) (arg->map_beta_arg))[0], ((double *) (arg->map_beta_arg))[1]);
				}
			}

			/*
			 * zero this out if its not needed anymore 
			 */
			if (k != kkk) {
				mb->f_theta[k] = NULL;
			}

			mb->f_Qfunc[kk] = Qfunc_copy_part00;
			mb->f_Qfunc_arg[kk] = (void *) arg;

			mb->f_Qfunc[k] = Qfunc_copy_part11;
			mb->f_Qfunc_arg[k] = (void *) arg;

			mb->ff_Qfunc[k][kk] = mb->ff_Qfunc[kk][k] = Qfunc_copy_part01;
			mb->ff_Qfunc_arg[k][kk] = mb->ff_Qfunc_arg[kk][k] = (void *) arg;

			mb->f_n[k] = mb->f_n[kk];
			mb->f_N[k] = mb->f_N[kk];
			mb->f_Ntotal[k] = mb->f_Ntotal[kk];
		}
	}
	return 0;
}

inla_iarray_tp *find_all_f(inla_tp * mb, inla_component_tp id)
{
	inla_iarray_tp *ia = Calloc(1, inla_iarray_tp);

	ia->n = count_f(mb, id);
	if (ia->n) {
		int i, j;

		ia->array = Calloc(ia->n, int);
		for (i = j = 0; i < mb->nf; i++) {
			if (mb->f_id[i] == id) {
				ia->array[j++] = i;
			}
		}
		assert(j == ia->n);
	}

	return ia;
}

int find_f(inla_tp * mb, inla_component_tp id)
{
	int i;
	for (i = 0; i < mb->nf; i++) {
		if (mb->f_id[i] == id) {
			return i;
		}
	}
	return -1;
}

int find_tag(inla_tp * mb, const char *name)
{
	int i;
	for (i = 0; i < mb->nf; i++) {
		if (!strcasecmp((const char *) mb->f_tag[i], name))
			return i;
	}
	return -1;
}

int count_f(inla_tp * mb, inla_component_tp id)
{
	int i, n = 0;
	for (i = 0; i < mb->nf; i++) {
		if (mb->f_id[i] == id) {
			n++;
		}
	}
	return n;
}

int inla_parse_linear(inla_tp * mb, dictionary * ini, int sec)
{
	/*
	 * parse section = LINEAR 
	 */
	int i;
	char *filename = NULL, *secname = NULL, default_tag[100];

	if (mb->verbose) {
		printf("\tinla_parse_linear...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\tsection[%s]\n", secname);
	}
	mb->linear_tag = Realloc(mb->linear_tag, mb->nlinear + 1, char *);
	mb->linear_dir = Realloc(mb->linear_dir, mb->nlinear + 1, char *);
	mb->linear_covariate = Realloc(mb->linear_covariate, mb->nlinear + 1, double *);
	mb->linear_precision = Realloc(mb->linear_precision, mb->nlinear + 1, double);
	mb->linear_mean = Realloc(mb->linear_mean, mb->nlinear + 1, double);
	mb->linear_compute = Realloc(mb->linear_compute, mb->nlinear + 1, int);
	mb->linear_output = Realloc(mb->linear_output, mb->nlinear + 1, Output_tp *);
	sprintf(default_tag, "default tag for linear %d", (int) (10000 * GMRFLib_uniform()));
	mb->linear_tag[mb->nlinear] = GMRFLib_strdup((secname ? secname : default_tag));
	mb->linear_dir[mb->nlinear] =
	    GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "DIR"), GMRFLib_strdup(mb->linear_tag[mb->nlinear])));
	if (mb->verbose) {
		printf("\t\tdir=[%s]\n", mb->linear_dir[mb->nlinear]);
	}
	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "COVARIATES"), NULL));
	if (!filename) {
		if (mb->verbose) {
			printf("\t\tfile for covariates=[(NULL)]: set all covariates to 1\n");
		}
		mb->linear_covariate[mb->nlinear] = Calloc(mb->predictor_n, double);

		for (i = 0; i < mb->predictor_n; i++) {
			mb->linear_covariate[mb->nlinear][i] = 1.0;
		}
	} else {
		if (mb->verbose) {
			printf("\t\tfile for covariates=[%s]\n", filename);
		}
		inla_read_data_general(&(mb->linear_covariate[mb->nlinear]), NULL, NULL, filename, mb->predictor_n, 0, 1, mb->verbose, -1.0);
	}
	mb->linear_mean[mb->nlinear] = iniparser_getdouble(ini, inla_string_join(secname, "MEAN"), 0.0);
	if (mb->verbose) {
		printf("\t\tprior mean=[%g]\n", mb->linear_mean[mb->nlinear]);
	}
	mb->linear_precision[mb->nlinear] = iniparser_getdouble(ini, inla_string_join(secname, "PRECISION"), DEFAULT_NORMAL_PRIOR_PRECISION);
	if (mb->verbose) {
		printf("\t\tprior precision=[%g]\n", mb->linear_precision[mb->nlinear]);
	}
	mb->linear_compute[mb->nlinear] = iniparser_getboolean(ini, inla_string_join(secname, "COMPUTE"), 1);
	if (G.mode == INLA_MODE_HYPER) {
		if (mb->linear_compute[mb->nlinear]) {
			fprintf(stderr, "*** Warning: HYPER_MODE require linear_compute[%1d] = 0\n", mb->nlinear);
		}
		mb->linear_compute[mb->nlinear] = 0;
	}
	if (mb->verbose) {
		printf("\t\tcompute=[%1d]\n", mb->linear_compute[mb->nlinear]);
	}
	inla_parse_output(mb, ini, sec, &(mb->linear_output[mb->nlinear]));
	mb->nlinear++;
	return INLA_OK;
}

int inla_setup_ai_par_default(inla_tp * mb)
{
	/*
	 * change some these values to provide a inla-spesific defaults:
	 * 
	 * - the verbose controls the output - use CCD as default integrator, except for ntheta=1, where the GRID is used. 
	 */
	int i;

	if (!mb->ai_par) {
		GMRFLib_default_ai_param(&(mb->ai_par));

		mb->ai_par->gaussian_data = mb->gaussian_data;
		// P(mb->gaussian_data);

		if (!(G.mode == INLA_MODE_HYPER)) {
			/*
			 * default mode 
			 */

			if (mb->verbose) {
				mb->ai_par->fp_log = stdout;
			} else {
				mb->ai_par->fp_log = NULL;
			}
			if (mb->ntheta == 1) {
				mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_GRID;
			} else {
				mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_CCD;
			}

			for (i = 0; i < mb->nds; i++) {
				if (mb->data_sections[i].data_id == L_T) {
					/*
					 * use special options for the additive student-t 
					 */
					mb->ai_par->strategy = GMRFLib_AI_STRATEGY_FIT_SCGAUSSIAN;
					mb->ai_par->linear_correction = GMRFLib_AI_LINEAR_CORRECTION_FAST;
				}
			}
		} else {
			/*
			 * hyperparameter mode: special options 
			 */

			if (mb->verbose) {
				mb->ai_par->fp_log = stdout;
			} else {
				mb->ai_par->fp_log = NULL;
			}
			for (i = 0; i < mb->nds; i++) {
				if (mb->data_sections[i].data_id == L_T) {
					/*
					 * use special options for the additive student-t 
					 */
					mb->ai_par->strategy = GMRFLib_AI_STRATEGY_FIT_SCGAUSSIAN;
					mb->ai_par->linear_correction = GMRFLib_AI_LINEAR_CORRECTION_FAST;
				}
			}
			mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_GRID;
			// mb->ai_par->skip_configurations = GMRFLib_FALSE;
			mb->ai_par->hessian_force_diagonal = GMRFLib_TRUE;
			switch (mb->ntheta) {
			case 0:
			case 1:
			{
				mb->ai_par->dz = 0.75;
				mb->ai_par->diff_log_dens = 6;
			}
				break;

			default:
				mb->ai_par->dz = 1.0;
				mb->ai_par->diff_log_dens = 5;
			}
			mb->ai_par->compute_nparam_eff = GMRFLib_FALSE;
		}
	}
	if (mb->reuse_mode && !mb->reuse_mode_but_restart) {
		mb->ai_par->mode_known = GMRFLib_TRUE;
	}

	return INLA_OK;
}

int inla_parse_INLA(inla_tp * mb, dictionary * ini, int sec, int UNUSED(make_dir))
{
	/*
	 * parse section = INLA 
	 */
	char *secname = NULL, *opt = NULL, *msg = NULL, *filename = NULL, *default_int_strategy = NULL, *defname = NULL, *r, *ctmp;
	double tmp, tmp_ref;

	if (mb->verbose) {
		printf("\tinla_parse_INLA...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\tsection[%s]\n", secname);
	}

	inla_setup_ai_par_default(mb);			       /* most likely already done, but... */
	mb->lc_derived_correlation_matrix = iniparser_getboolean(ini, inla_string_join(secname, "LINCOMB.DERIVED.CORRELATION.MATRIX"), 0);
	if (mb->verbose) {
		printf("\t\t\tlincomb.derived.correlation.matrix = [%s]\n", (mb->lc_derived_correlation_matrix ? "Yes" : "No"));
	}

	opt = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "OPTIMISER"), NULL));
	opt = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "OPTIMIZER"), opt));
	if (!opt) {
		mb->ai_par->optimiser = GMRFLib_AI_OPTIMISER_DEFAULT;
	} else if (!strcasecmp(opt, "DEFAULT")) {
		mb->ai_par->optimiser = GMRFLib_AI_OPTIMISER_DEFAULT;
	} else if (!strcasecmp(opt, "GSL")) {
		mb->ai_par->optimiser = GMRFLib_AI_OPTIMISER_GSL;
	} else {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, "optimiser", opt);
	}

	/*
	 * if eps. < 0.0 then factory defaults are used. 
	 */
	mb->ai_par->gsl_tol = iniparser_getdouble(ini, inla_string_join(secname, "GSL.TOL"), mb->ai_par->gsl_tol);
	mb->ai_par->gsl_step_size = iniparser_getdouble(ini, inla_string_join(secname, "GSL.STEP.SIZE"), mb->ai_par->gsl_step_size);
	mb->ai_par->gsl_epsg = iniparser_getdouble(ini, inla_string_join(secname, "GSL.EPSG"), mb->ai_par->gsl_epsg);
	mb->ai_par->gsl_epsg = iniparser_getdouble(ini, inla_string_join(secname, "TOLERANCE.G"), mb->ai_par->gsl_epsg);
	mb->ai_par->gsl_epsf = iniparser_getdouble(ini, inla_string_join(secname, "GSL.EPSF"), mb->ai_par->gsl_epsf);
	mb->ai_par->gsl_epsf = iniparser_getdouble(ini, inla_string_join(secname, "TOLERANCE.F"), mb->ai_par->gsl_epsf);
	mb->ai_par->gsl_epsx = iniparser_getdouble(ini, inla_string_join(secname, "GSL.EPSX"), mb->ai_par->gsl_epsx);
	mb->ai_par->gsl_epsx = iniparser_getdouble(ini, inla_string_join(secname, "TOLERANCE.X"), mb->ai_par->gsl_epsx);
	mb->ai_par->optpar_abserr_func = iniparser_getdouble(ini, inla_string_join(secname, "ABSERR.FUNC"), mb->ai_par->optpar_abserr_func);
	mb->ai_par->optpar_abserr_func = iniparser_getdouble(ini, inla_string_join(secname, "OPTPAR.ABSERR.FUNC"), mb->ai_par->optpar_abserr_func);
	mb->ai_par->optpar_abserr_step = iniparser_getdouble(ini, inla_string_join(secname, "TOLERANCE.STEP"), mb->ai_par->optpar_abserr_step);
	mb->ai_par->optpar_abserr_step = iniparser_getdouble(ini, inla_string_join(secname, "ABSERR.STEP"), mb->ai_par->optpar_abserr_step);
	mb->ai_par->optpar_nr_step_factor =
	    iniparser_getdouble(ini, inla_string_join(secname, "NR.STEP.FACTOR"), mb->ai_par->optpar_nr_step_factor);

	mb->ai_par->mode_known = iniparser_getboolean(ini, inla_string_join(secname, "MODE.KNOWN"), mb->ai_par->mode_known);
	mb->ai_par->restart = iniparser_getint(ini, inla_string_join(secname, "RESTART"), 0);

	if (mb->verbose > 2) {
		ctmp = GMRFLib_strdup("STDOUT");
	} else {
		ctmp = NULL;
	}
	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "OPTPAR.FP"), ctmp));

	if (filename) {
		if (!strcasecmp(filename, "STDOUT")) {
			mb->ai_par->optpar_fp = stdout;
		} else if (!strcasecmp(filename, "STDERR")) {
			mb->ai_par->optpar_fp = stderr;
		} else if (!strcasecmp(filename, "NULL")) {
			mb->ai_par->optpar_fp = NULL;
		} else if (!strcasecmp(filename, "/dev/null")) {
			mb->ai_par->optpar_fp = NULL;
		} else {
			static FILE *fp = NULL;

			fp = fopen(filename, "w");
			if (!fp) {
				GMRFLib_sprintf(&msg, "%s: fail to open file[%s]", __GMRFLib_FuncName, filename);
			}
			mb->ai_par->optpar_fp = fp;
		}
	}

	switch (mb->ai_par->int_strategy) {
	case GMRFLib_AI_INT_STRATEGY_AUTO:
	{
		default_int_strategy = GMRFLib_strdup("GMRFLib_AI_INT_STRATEGY_AUTO");
	}
		break;

	case GMRFLib_AI_INT_STRATEGY_GRID:
	{
		default_int_strategy = GMRFLib_strdup("GMRFLib_AI_INT_STRATEGY_GRID");
	}
		break;

	case GMRFLib_AI_INT_STRATEGY_CCD:
	{
		default_int_strategy = GMRFLib_strdup("GMRFLib_AI_INT_STRATEGY_CCD");
	}
		break;

	default:
		GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
	}

	opt = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "STRATEGY"), GMRFLib_strdup("AUTO")));
	if (!strcasecmp(opt, "AUTO")) {
		mb->ai_par->strategy = (mb->idx_ntot < 5000 ? GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN : GMRFLib_AI_STRATEGY_ADAPTIVE);
	} else if (!strcasecmp(opt, "GMRFLib_AI_STRATEGY_GAUSSIAN") || !strcasecmp(opt, "GAUSSIAN")) {
		mb->ai_par->strategy = GMRFLib_AI_STRATEGY_GAUSSIAN;
	} else if (!strcasecmp(opt, "GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN") ||
		   !strcasecmp(opt, "MEANSKEWCORRECTED_GAUSSIAN") || !strcasecmp(opt, "SLA") || !strcasecmp(opt, "SIMPLIFIED_LAPLACE")
		   || !strcasecmp(opt, "SIMPLIFIED.LAPLACE")) {
		mb->ai_par->strategy = GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN;
	} else if (!strcasecmp(opt, "GMRFLib_AI_STRATEGY_FIT_SCGAUSSIAN") ||
		   !strcasecmp(opt, "FIT_SCGAUSSIAN") ||
		   !strcasecmp(opt, "FIT.SCGAUSSIAN") || !strcasecmp(opt, "SCGAUSSIAN") || !strcasecmp(opt, "LAPLACE")
		   || !strcasecmp(opt, "LA")) {
		mb->ai_par->strategy = GMRFLib_AI_STRATEGY_FIT_SCGAUSSIAN;
	} else if (!strcasecmp(opt, "GMRFLib_AI_STRATEGY_MEANCORRECTED_GAUSSIAN")
		   || !strcasecmp(opt, "MEANCORRECTED_GAUSSIAN")) {
		mb->ai_par->strategy = GMRFLib_AI_STRATEGY_MEANCORRECTED_GAUSSIAN;
	} else if (!strcasecmp(opt, "GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN") ||
		   !strcasecmp(opt, "MEANSKEWCORRECTED_GAUSSIAN") || !strcasecmp(opt, "SLA") || !strcasecmp(opt, "SIMPLIFIED_LAPLACE")
		   || !strcasecmp(opt, "SIMPLIFIED.LAPLACE")) {
		mb->ai_par->strategy = GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN;
	} else if (!strcasecmp(opt, "ADAPTIVE")) {
		mb->ai_par->strategy = GMRFLib_AI_STRATEGY_ADAPTIVE;
	} else {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, "strategy", opt);
	}
	mb->ai_par->adapt_max = iniparser_getint(ini, inla_string_join(secname, "ADAPTIVE.MAX"), 5);

	mb->ai_par->fast = iniparser_getboolean(ini, inla_string_join(secname, "FAST"), mb->ai_par->fast);
	opt = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "LINEAR.CORRECTION"), NULL));
	if (opt) {
		if (!strcasecmp(opt, "GMRFLib_AI_LINEAR_CORRECTION_CENTRAL_DIFFERENCE") || !strcasecmp(opt, "CENTRAL_DIFFERENCE")) {
			mb->ai_par->linear_correction = GMRFLib_AI_LINEAR_CORRECTION_CENTRAL_DIFFERENCE;
		} else if (!strcasecmp(opt, "GMRFLib_AI_LINEAR_CORRECTION_FAST") || !strcasecmp(opt, "FAST")
			   || !strcasecmp(opt, "1") || !strcasecmp(opt, "ON") || !strcasecmp(opt, "YES")
			   || !strcasecmp(opt, "TRUE")) {
			mb->ai_par->linear_correction = GMRFLib_AI_LINEAR_CORRECTION_FAST;
		} else if (!strcasecmp(opt, "GMRFLib_AI_LINEAR_CORRECTION_OFF") || !strcasecmp(opt, "OFF") || !strcasecmp(opt, "NO")
			   || !strcasecmp(opt, "0") || !strcasecmp(opt, "FALSE")) {
			mb->ai_par->linear_correction = GMRFLib_AI_LINEAR_CORRECTION_OFF;
		} else {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "linear_correction", opt);
		}
	}
	mb->ai_par->n_points = iniparser_getint(ini, inla_string_join(secname, "N.POINTS"), mb->ai_par->n_points);
	mb->ai_par->n_points = iniparser_getint(ini, inla_string_join(secname, "NPOINTS"), mb->ai_par->n_points);
	mb->ai_par->step_len = iniparser_getdouble(ini, inla_string_join(secname, "STEP.LEN"), mb->ai_par->step_len);
	mb->ai_par->stencil = iniparser_getint(ini, inla_string_join(secname, "STENCIL"), mb->ai_par->stencil);
	mb->ai_par->cutoff = iniparser_getdouble(ini, inla_string_join(secname, "CUTOFF"), mb->ai_par->cutoff);
	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "FP.LOG"), NULL));
	if (filename) {
		if (!strcasecmp(filename, "STDOUT")) {
			mb->ai_par->fp_log = stdout;
		} else if (!strcasecmp(filename, "STDERR")) {
			mb->ai_par->fp_log = stderr;
		} else if (!strcasecmp(filename, "NULL")) {
			mb->ai_par->fp_log = NULL;
		} else if (!strcasecmp(filename, "/dev/null")) {
			mb->ai_par->fp_log = NULL;
		} else {
			static FILE *fp = NULL;

			fp = fopen(filename, "w");
			if (!fp) {
				GMRFLib_sprintf(&msg, "%s: fail to open file[%s]", __GMRFLib_FuncName, filename);
			}
			mb->ai_par->fp_log = fp;
		}
	}
	GMRFLib_sprintf(&defname, ".inla_hyper");
	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "FP.HYPERPARAM"), defname));
	Free(defname);
	if (!filename) {
		filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "FP.HYPERPARAM"), NULL));
	}
	if (filename) {
		if (!strcasecmp(filename, "STDOUT")) {
			mb->ai_par->fp_hyperparam = stdout;
		} else if (!strcasecmp(filename, "STDERR")) {
			mb->ai_par->fp_hyperparam = stderr;
		} else if (!strcasecmp(filename, "NULL")) {
			mb->ai_par->fp_hyperparam = NULL;
		} else if (!strcasecmp(filename, "/dev/null")) {
			mb->ai_par->fp_hyperparam = NULL;
		} else {
			static FILE *fp = NULL;

			fp = fopen(filename, "w");
			if (!fp) {
				GMRFLib_sprintf(&msg, "%s: fail to open file[%s]", __GMRFLib_FuncName, filename);
			}
			mb->ai_par->fp_hyperparam = fp;
		}
	}
	opt = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "INT.STRATEGY"), default_int_strategy));
	if (opt) {
		if (!strcasecmp(opt, "GMRFLib_AI_INT_STRATEGY_AUTO") || !strcasecmp(opt, "AUTO")) {
			mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_AUTO;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INT_STRATEGY_GRID") || !strcasecmp(opt, "GRID")) {
			mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_GRID;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INT_STRATEGY_CCD") || !strcasecmp(opt, "CCD")) {
			mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_CCD;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INT_STRATEGY_USER") || !strcasecmp(opt, "USER")) {
			mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_USER;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INT_STRATEGY_USER_STD") || !strcasecmp(opt, "USERSTD")
			   || !strcasecmp(opt, "USER.STD")) {
			mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_USER_STD;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INT_STRATEGY_USER_EXPERT") || !strcasecmp(opt, "USEREXPERT")
			   || !strcasecmp(opt, "USER.EXPERT")) {
			mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_USER_EXPERT;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INT_STRATEGY_EMPIRICAL_BAYES")
			   || !strcasecmp(opt, "EMPIRICAL_BAYES") || !strcasecmp(opt, "EB")) {
			mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_EMPIRICAL_BAYES;
		} else {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "int_strategy", opt);
		}
	}
	if (G.mode == INLA_MODE_HYPER) {
		if (mb->ai_par->int_strategy != GMRFLib_AI_INT_STRATEGY_GRID) {
			fprintf(stderr, "*** Warning: HYPER_MODE require int_strategy = GMRFLib_AI_INT_STRATEGY_GRID\n");
		}
		mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_GRID;
	}

	if (mb->ai_par->int_strategy == GMRFLib_AI_INT_STRATEGY_USER || mb->ai_par->int_strategy == GMRFLib_AI_INT_STRATEGY_USER_STD ||
	    mb->ai_par->int_strategy == GMRFLib_AI_INT_STRATEGY_USER_EXPERT) {
		GMRFLib_matrix_tp *D = NULL;
		filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "INT.DESIGN"), NULL));
		if (my_file_exists(filename) != INLA_OK)
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "int.design", filename);
		D = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);
		GMRFLib_design_read(&(mb->ai_par->int_design), D, (mb->ai_par->int_strategy == GMRFLib_AI_INT_STRATEGY_USER_STD ? 1 : 0));
		GMRFLib_matrix_free(D);
	} else {
		// Just mark it as read
		iniparser_getstring(ini, inla_string_join(secname, "INT.DESIGN"), NULL);
	}

	mb->ai_par->f0 = iniparser_getdouble(ini, inla_string_join(secname, "F0"), mb->ai_par->f0);
	tmp = iniparser_getdouble(ini, inla_string_join(secname, "DZ"), mb->ai_par->dz);
	if (G.mode == INLA_MODE_HYPER && tmp > mb->ai_par->dz) {
		/*
		 * cannot set it to a larger value 
		 */
		fprintf(stderr, "*** Warning: HYPER_MODE require dz <= %f\n", mb->ai_par->dz);
	} else {
		mb->ai_par->dz = tmp;
	}
	mb->ai_par->adjust_weights = iniparser_getboolean(ini, inla_string_join(secname, "ADJUST.WEIGHTS"), mb->ai_par->adjust_weights);

	tmp_ref = mb->ai_par->diff_log_dens;
	mb->ai_par->diff_log_dens = iniparser_getdouble(ini, inla_string_join(secname, "DIFF.LOG.DENS"), mb->ai_par->diff_log_dens);
	mb->ai_par->diff_log_dens = iniparser_getdouble(ini, inla_string_join(secname, "DIFF.LOGDENS"), mb->ai_par->diff_log_dens);
	if (G.mode == INLA_MODE_HYPER && mb->ai_par->diff_log_dens < tmp_ref) {
		fprintf(stderr, "*** Warning: HYPER_MODE require diff_log_dens >= %f\n", tmp_ref);
		mb->ai_par->diff_log_dens = tmp_ref;
	}
	mb->ai_par->skip_configurations =
	    iniparser_getboolean(ini, inla_string_join(secname, "SKIP.CONFIGURATIONS"), mb->ai_par->skip_configurations);

	if (G.mode == INLA_MODE_HYPER && mb->ai_par->skip_configurations) {
		fprintf(stderr, "*** Warning: HYPER_MODE require skip_configurations = 0\n");
		mb->ai_par->skip_configurations = 0;
	}

	/*
	 * this is a short version for setting both: grad=H hess=sqrt(H)
	 */
	mb->ai_par->gradient_finite_difference_step_len =
	    iniparser_getdouble(ini, inla_string_join(secname, "H"), mb->ai_par->gradient_finite_difference_step_len);

	/*
	 * if H < 0, use central difference.  FIXME LATER!!! 
	 */
	if (mb->ai_par->gradient_finite_difference_step_len < 0.0) {
		mb->ai_par->gradient_finite_difference_step_len = ABS(mb->ai_par->gradient_finite_difference_step_len);
		mb->ai_par->gradient_forward_finite_difference = GMRFLib_FALSE;
	}

	mb->ai_par->hessian_finite_difference_step_len =
	    sqrt(ABS(iniparser_getdouble(ini, inla_string_join(secname, "H"), SQR(mb->ai_par->hessian_finite_difference_step_len))));

	/*
	 * ...which is overrided by the original names 
	 */
	char *ans;

	ans = iniparser_getstring(ini, inla_string_join(secname, "NUM.GRADIENT"), GMRFLib_strdup("central"));
	if (!strcasecmp(ans, "central")) {
		mb->ai_par->gradient_forward_finite_difference = GMRFLib_FALSE;
	} else {
		mb->ai_par->gradient_forward_finite_difference = GMRFLib_TRUE;
	}

	ans = iniparser_getstring(ini, inla_string_join(secname, "NUM.HESSIAN"), GMRFLib_strdup("central"));
	if (!strcasecmp(ans, "central")) {
		mb->ai_par->hessian_forward_finite_difference = GMRFLib_FALSE;
	} else {
		mb->ai_par->hessian_forward_finite_difference = GMRFLib_TRUE;
	}

	ans = iniparser_getstring(ini, inla_string_join(secname, "OPTIMISE.STRATEGY"), GMRFLib_strdup("smart"));
	if (!strcasecmp(ans, "smart")) {
		mb->ai_par->optimise_smart = GMRFLib_TRUE;
	} else {
		mb->ai_par->optimise_smart = GMRFLib_FALSE;
	}

	mb->ai_par->optimise_use_directions = iniparser_getboolean(ini, inla_string_join(secname, "USE.DIRECTIONS"),
								   mb->ai_par->optimise_use_directions);
	filename = iniparser_getstring(ini, inla_string_join(secname, "USE.DIRECTIONS.MATRIX"), NULL);
	if (filename) {
		GMRFLib_matrix_tp *mat = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);
		assert(mat->nrow == mat->ncol);

		gsl_matrix *M = gsl_matrix_alloc((size_t) mat->nrow, (size_t) mat->ncol);
		for (int i = 0; i < mat->nrow; i++) {
			for (int j = 0; j < mat->ncol; j++) {
				gsl_matrix_set(M, (size_t) i, (size_t) j, GMRFLib_matrix_get(i, j, mat));
			}
		}
		mb->ai_par->optimise_use_directions_m = M;
		GMRFLib_matrix_free(mat);
	} else {
		mb->ai_par->optimise_use_directions_m = NULL;
	}

	mb->ai_par->gradient_finite_difference_step_len =
	    iniparser_getdouble(ini, inla_string_join(secname, "GRADIENT.FINITE.DIFFERENCE.STEP.LEN"),
				mb->ai_par->gradient_finite_difference_step_len);
	mb->ai_par->hessian_finite_difference_step_len =
	    iniparser_getdouble(ini, inla_string_join(secname, "HESSIAN.FINITE.DIFFERENCE.STEP.LEN"),
				mb->ai_par->hessian_finite_difference_step_len);
	mb->ai_par->hessian_force_diagonal =
	    iniparser_getboolean(ini, inla_string_join(secname, "HESSIAN.FORCE.DIAGONAL"), mb->ai_par->hessian_force_diagonal);

	opt = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "INTERPOLATOR"), NULL));
	if (opt) {
		if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_WEIGHTED_DISTANCE") || !strcasecmp(opt, "WEIGHTED_DISTANCE")
		    || !strcasecmp(opt, "WEIGHTED.DISTANCE")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_WEIGHTED_DISTANCE;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_NEAREST") || !strcasecmp(opt, "NEAREST")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_NEAREST;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_LINEAR") || !strcasecmp(opt, "LINEAR")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_LINEAR;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_QUADRATIC") || !strcasecmp(opt, "QUADRATIC")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_QUADRATIC;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_CCD") || !strcasecmp(opt, "CCD")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_CCD;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_CCD_INTEGRATE") || !strcasecmp(opt, "CCDINTEGRATE")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_CCD_INTEGRATE;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_GRIDSUM") || !strcasecmp(opt, "GRIDSUM")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_GRIDSUM;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_AUTO") || !strcasecmp(opt, "AUTO")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_AUTO;
		} else if (!strcasecmp(opt, "GMRFLib_AI_INTERPOLATOR_GAUSSIAN") || !strcasecmp(opt, "GAUSSIAN")) {
			mb->ai_par->interpolator = GMRFLib_AI_INTERPOLATOR_GAUSSIAN;
		} else {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "interpolator", opt);
		}
	}
	if (mb->ai_par->interpolator == GMRFLib_AI_INTERPOLATOR_GRIDSUM) {
		if (!mb->ai_par->hessian_force_diagonal) {
			GMRFLib_sprintf(&msg, "interpolator=GRIDSUM require hessian_force_diagonal=1 (and skip_configurations=0, recommended)");
			inla_error_general(msg);
		}
	}
	mb->ai_par->do_MC_error_check = iniparser_getboolean(ini, inla_string_join(secname, "DO.MC.ERROR.CHECK"), mb->ai_par->do_MC_error_check);
	mb->ai_par->compute_nparam_eff = iniparser_getboolean(ini, inla_string_join(secname, "COMPUTE.NPARAM.EFF"), mb->ai_par->compute_nparam_eff);

	if (G.mode == INLA_MODE_HYPER) {
		if (mb->ai_par->compute_nparam_eff) {
			fprintf(stderr, "*** Warning: HYPER_MODE require compute_nparam_eff = GMRFLib_FALSE\n");
		}
		mb->ai_par->compute_nparam_eff = GMRFLib_FALSE;
	}

	tmp = iniparser_getboolean(ini, inla_string_join(secname, "HUGE"), -1);
	if (tmp != -1) {
		fprintf(stderr, "\n\n*** Warning *** option control.inla(huge=TRUE) is disabled and obsolete.\n");
		fprintf(stderr, "*** Warning *** use control.compute = list(strategy = \"SMALL|MEDIUM|LARGE|HUGE|DEFAULT\") instead.\n\n");
	}

	GMRFLib_global_node.factor = iniparser_getdouble(ini, inla_string_join(secname, "GLOBAL.NODE.FACTOR"), GMRFLib_global_node.factor);
	assert(GMRFLib_global_node.factor >= 0.0);
	if (mb->verbose) {
		printf("\t\tglobal_node.factor = %.3f\n", GMRFLib_global_node.factor);
	}

	GMRFLib_global_node.degree = iniparser_getdouble(ini, inla_string_join(secname, "GLOBAL.NODE.DEGREE"), GMRFLib_global_node.degree);
	assert(GMRFLib_global_node.degree >= 0);
	if (mb->verbose) {
		printf("\t\tglobal_node.degree = %.1d\n", GMRFLib_global_node.degree);
	}

	Memcpy((void *) &(mb->gn), (void *) &GMRFLib_global_node, sizeof(GMRFLib_global_node_tp));

	r = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "REORDERING"), NULL));
	if (mb->verbose) {
		printf("\t\treordering = %s\n", (r ? r : "(default)"));
	}

	if (r) {
		int err;

		/*
		 * both these fail if the reordering is void 
		 */
		int itmp;
		err = inla_sread_ints(&itmp, 1, r);
		G.reorder = (GMRFLib_reorder_tp) itmp;
		if (err) {
			itmp = GMRFLib_reorder_id((const char *) r);
			G.reorder = (GMRFLib_reorder_tp) itmp;
		}
		GMRFLib_reorder = G.reorder;		       /* yes! */
	}

	mb->ai_par->cpo_req_diff_logdens =
	    iniparser_getdouble(ini, inla_string_join(secname, "CPO.REQ.DIFF.LOGDENS"), mb->ai_par->cpo_req_diff_logdens);
	mb->ai_par->cpo_req_diff_logdens = iniparser_getdouble(ini, inla_string_join(secname, "CPO.DIFF"), mb->ai_par->cpo_req_diff_logdens);
	mb->ai_par->cpo_req_diff_logdens = DMAX(0.0, mb->ai_par->cpo_req_diff_logdens);

	mb->ai_par->stupid_search_mode = iniparser_getboolean(ini, inla_string_join(secname, "STUPID.SEARCH"), mb->ai_par->stupid_search_mode);
	mb->ai_par->stupid_search_max_iter =
	    iniparser_getint(ini, inla_string_join(secname, "STUPID.SEARCH.MAX.ITER"), mb->ai_par->stupid_search_max_iter);
	mb->ai_par->stupid_search_factor =
	    iniparser_getdouble(ini, inla_string_join(secname, "STUPID.SEARCH.FACTOR"), mb->ai_par->stupid_search_factor);

	mb->expert_diagonal_emergencey = 0.0;
	mb->expert_diagonal_emergencey = iniparser_getdouble(ini, inla_string_join(secname, "DIAGONAL"), mb->expert_diagonal_emergencey);
	mb->expert_diagonal_emergencey = DMAX(0.0, mb->expert_diagonal_emergencey);
	if (mb->expert_diagonal_emergencey && mb->verbose) {
		printf("\tdiagonal (expert emergency) = %g\n", mb->expert_diagonal_emergencey);
	}

	mb->ai_par->numint_max_fn_eval = iniparser_getint(ini, inla_string_join(secname, "NUMINT.MAXFEVAL"), mb->ai_par->numint_max_fn_eval);
	mb->ai_par->numint_rel_err = iniparser_getdouble(ini, inla_string_join(secname, "NUMINT.RELERR"), mb->ai_par->numint_rel_err);
	mb->ai_par->numint_abs_err = iniparser_getdouble(ini, inla_string_join(secname, "NUMINT.ABSERR"), mb->ai_par->numint_abs_err);

	mb->ai_par->cmin = iniparser_getdouble(ini, inla_string_join(secname, "CMIN"), mb->ai_par->cmin);
	mb->ai_par->b_strategy = iniparser_getint(ini, inla_string_join(secname, "B.STRATEGY"), mb->ai_par->b_strategy);

	mb->ai_par->vb_enable = iniparser_getboolean(ini, inla_string_join(secname, "CONTROL.VB.ENABLE"), 0);
	mb->ai_par->vb_verbose = iniparser_getboolean(ini, inla_string_join(secname, "CONTROL.VB.VERBOSE"), 0);
	mb->ai_par->vb_nodes_mean = (mb->ai_par->vb_enable ? Calloc(1, char) : NULL);
	mb->ai_par->vb_nodes_variance = (mb->ai_par->vb_enable ? Calloc(1, char) : NULL);
	mb->ai_par->vb_iter_max = iniparser_getint(ini, inla_string_join(secname, "CONTROL.VB.ITER.MAX"), 5);
	mb->ai_par->vb_emergency = iniparser_getdouble(ini, inla_string_join(secname, "CONTROL.VB.EMERGENCY"), 10.0);
	mb->ai_par->vb_iter_max = IMAX(1, mb->ai_par->vb_iter_max);
	mb->ai_par->vb_f_enable_limit_mean = iniparser_getint(ini, inla_string_join(secname, "CONTROL.VB.F.ENABLE.LIMIT.MEAN"), 20);
	mb->ai_par->vb_f_enable_limit_variance = iniparser_getint(ini, inla_string_join(secname, "CONTROL.VB.F.ENABLE.LIMIT.VARIANCE"), 5);
	mb->ai_par->vb_hessian_update = iniparser_getint(ini, inla_string_join(secname, "CONTROL.VB.HESSIAN.UPDATE"), 1);

	opt = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CONTROL.VB.STRATEGY"), GMRFLib_strdup("MEAN")));
	if (!strcasecmp(opt, "MEAN")) {
		mb->ai_par->vb_strategy = GMRFLib_AI_VB_MEAN;
	} else if (!strcasecmp(opt, "VARIANCE")) {
		mb->ai_par->vb_strategy = GMRFLib_AI_VB_VARIANCE;
	} else {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, "control.vb.strategy", opt);
	}

	opt = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CONTROL.VB.HESSIAN.STRATEGY"), GMRFLib_strdup("FULL")));
	if (!strcasecmp(opt, "FULL")) {
		mb->ai_par->vb_hessian_strategy = GMRFLib_VB_HESSIAN_STRATEGY_FULL;
	} else if (!strcasecmp(opt, "PARTIAL")) {
		mb->ai_par->vb_hessian_strategy = GMRFLib_VB_HESSIAN_STRATEGY_PARTIAL;
	} else if (!strcasecmp(opt, "DIAGONAL")) {
		mb->ai_par->vb_hessian_strategy = GMRFLib_VB_HESSIAN_STRATEGY_DIAGONAL;
	} else {
		inla_error_field_is_void(__GMRFLib_FuncName, secname, "control.vb.hessian.strategy", opt);
	}

	// default value is set in main()
	GMRFLib_aqat_m_diag_add = iniparser_getdouble(ini, inla_string_join(secname, "CONSTR.MARGINAL.DIAGONAL"), GMRFLib_aqat_m_diag_add);
	assert(GMRFLib_aqat_m_diag_add >= 0.0);
	if (mb->verbose) {
		printf("\t\tconstr.marginal.diagonal = %.3g\n", GMRFLib_aqat_m_diag_add);
	}

	mb->ai_par->improved_simplified_laplace = iniparser_getboolean(ini, inla_string_join(secname, "IMPROVED.SIMPLIFIED.LAPLACE"), 0);
	mb->ai_par->parallel_linesearch = iniparser_getboolean(ini, inla_string_join(secname, "PARALLEL.LINESEARCH"), 0);
	mb->compute_initial_values = iniparser_getboolean(ini, inla_string_join(secname, "COMPUTE.INITIAL.VALUES"), 1);

	if (mb->verbose) {
		GMRFLib_print_ai_param(stdout, mb->ai_par);
	}

	return INLA_OK;
}

int inla_parse_update(inla_tp * mb, dictionary * ini, int sec, int UNUSED(make_dir))
{
	/*
	 * parse section = UPDATE
	 */
	char *secname = NULL, *filename = NULL;
	GMRFLib_matrix_tp *M = NULL;

	if (mb->verbose) {
		printf("\tinla_parse_update...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\tsection[%s]\n", secname);
	}

	filename = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "FILENAME"), NULL));
	if (mb->verbose) {
		printf("\t\tfilename[%s]\n", filename);
	}

	if (filename) {
		M = GMRFLib_read_fmesher_file(filename, (long int) 0, -1);
		mb->update = Calloc(1, inla_update_tp);
		int i = 0, j = 0, nt, k, kk;

		mb->update->ntheta = nt = (int) GMRFLib_matrix_get(i++, j, M);
		if (mb->verbose) {
			printf("\t\tntheta = %1d\n", nt);
		}

		mb->update->theta_mode = Calloc(nt, double);
		for (k = 0; k < nt; k++) {
			mb->update->theta_mode[k] = GMRFLib_matrix_get(i++, j, M);
			if (mb->verbose) {
				printf("\t\ttheta.mode[%1d] = %.10g\n", k, mb->update->theta_mode[k]);
			}
		}
		mb->update->stdev_corr_pos = Calloc(nt, double);
		for (k = 0; k < nt; k++) {
			mb->update->stdev_corr_pos[k] = GMRFLib_matrix_get(i++, j, M);
			if (mb->verbose) {
				printf("\t\tstdev.corr.pos[%1d] = %.10g\n", k, mb->update->stdev_corr_pos[k]);
			}
		}
		mb->update->stdev_corr_neg = Calloc(nt, double);
		for (k = 0; k < nt; k++) {
			mb->update->stdev_corr_neg[k] = GMRFLib_matrix_get(i++, j, M);
			if (mb->verbose) {
				printf("\t\tstdev.corr.neg[%1d] = %.10g\n", k, mb->update->stdev_corr_neg[k]);
			}
		}
		mb->update->sqrt_eigen_values = gsl_vector_calloc((size_t) nt);
		for (k = 0; k < nt; k++) {
			gsl_vector_set(mb->update->sqrt_eigen_values, k, GMRFLib_matrix_get(i++, j, M));
			if (mb->verbose) {
				printf("\t\tsqrt.eigen.values[%1d] = %.10g\n", k, gsl_vector_get(mb->update->sqrt_eigen_values, k));
			}
		}
		mb->update->eigen_vectors = gsl_matrix_calloc((size_t) nt, (size_t) nt);
		for (kk = 0; kk < nt; kk++) {
			for (k = 0; k < nt; k++) {
				/*
				 * column based storage...
				 */
				gsl_matrix_set(mb->update->eigen_vectors, k, kk, GMRFLib_matrix_get(i++, j, M));
				if (mb->verbose) {
					printf("\t\teigenvectors[%1d,%1d] = %.10g\n", k, kk, gsl_matrix_get(mb->update->eigen_vectors, k, kk));
				}
			}
		}
		assert(1 == M->ncol);
		assert(i == M->nrow);
		GMRFLib_matrix_free(M);
	}

	return INLA_OK;
}

int inla_parse_pardiso(inla_tp * mb, dictionary * ini, int sec, int UNUSED(make_dir))
{
	/*
	 * parse section = PARDISO
	 */
	char *secname = NULL;
	int val;

	if (mb->verbose) {
		printf("\tinla_parse_pardiso...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\tsection[%s]\n", secname);
	}

	val = iniparser_getint(ini, inla_string_join(secname, "VERBOSE"), 0);
	if (mb->verbose) {
		printf("\t\tverbose[%1d]\n", val);
	}
	GMRFLib_pardiso_set_verbose(val);

	val = iniparser_getint(ini, inla_string_join(secname, "DEBUG"), 0);
	if (mb->verbose) {
		printf("\t\tdebug[%1d]\n", val);
	}
	GMRFLib_pardiso_set_debug(val);

	val = iniparser_getint(ini, inla_string_join(secname, "PARALLEL.REORDERING"), 0);
	if (mb->verbose) {
		printf("\t\tparallel.reordering[%1d]\n", val);
	}
	GMRFLib_pardiso_set_parallel_reordering(val);

	val = iniparser_getint(ini, inla_string_join(secname, "NRHS"), -1);
	if (mb->verbose) {
		printf("\t\tnrhs[%1d]\n", val);
	}
	GMRFLib_pardiso_set_nrhs(val);

	return INLA_OK;
}

int inla_parse_lp_scale(inla_tp * mb, dictionary * ini, int sec, int UNUSED(make_dir))
{
	/*
	 * parse section = LP.SCALE
	 */
	int i, k;
	char *secname = NULL, *ctmp = NULL, *msg = NULL;
	double tmp = 0.0;
	Data_section_tp *ds = &(mb->data_sections[0]);

	if (mb->verbose) {
		printf("\tinla_parse_lp_scale...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\tsection[%s]\n", secname);
	}

	if (!ds->lp_scale) {
		return INLA_OK;
	}

	ds->lp_scale_in_use = Calloc(INLA_LP_SCALE_MAX, int);

	for (i = 0; i < INLA_LP_SCALE_MAX; i++) {
		ds->lp_scale_in_use[i] = 0;
	}
	for (i = 0; i < mb->predictor_ndata; i++) {
		if ((k = (int) ds->lp_scale[i]) >= 0) {
			ds->lp_scale_in_use[k] = 1;
			GMRFLib_ASSERT(k < INLA_LP_SCALE_MAX, GMRFLib_EPARAMETER);
		}
	}
	if (mb->verbose) {
		printf("\t\tlp_scale variables in use = [");
		for (k = 0; k < INLA_LP_SCALE_MAX; k++) {
			if (ds->lp_scale_in_use[k]) {
				printf(" %1d", k);
			}
		}
		printf(" ]\n");
	}

	// mark all hyperpar defs as read
	for (i = 0; i < INLA_LP_SCALE_MAX; i++) {
		for (int j = 0; j < keywords_len; j++) {
			GMRFLib_sprintf(&ctmp, "%s%1d", keywords[j], i);
			iniparser_getstring(ini, inla_string_join(secname, ctmp), NULL);
			Free(ctmp);
		}
	}

	ds->lp_scale_beta = Calloc(INLA_LP_SCALE_MAX, double **);
	ds->lp_scale_nfixed = Calloc(INLA_LP_SCALE_MAX, int);
	ds->lp_scale_nprior = Calloc(INLA_LP_SCALE_MAX, Prior_tp);

	for (k = 0; k < INLA_LP_SCALE_MAX; k++) {
		if (ds->lp_scale_in_use[k]) {
			GMRFLib_sprintf(&ctmp, "INITIAL%1d", k);
			tmp = iniparser_getdouble(ini, inla_string_join(secname, ctmp), 0.0);

			Free(ctmp);
			GMRFLib_sprintf(&ctmp, "FIXED%1d", k);
			ds->lp_scale_nfixed[k] = iniparser_getboolean(ini, inla_string_join(secname, ctmp), 0);

			if (!(ds->lp_scale_nfixed[k]) && mb->reuse_mode) {
				tmp = mb->theta_file[mb->theta_counter_file++];
			}
			HYPER_NEW(ds->lp_scale_beta[k], tmp);
			if (mb->verbose) {
				printf("\t\tinitialise lp_scale_beta[%1d] = %g\n", k, ds->lp_scale_beta[k][0][0]);
				printf("\t\tfixed = %1d\n", ds->lp_scale_nfixed[k]);
			}
			inla_read_priorN(mb, ini, sec, &(ds->lp_scale_nprior[k]), "GAUSSIAN", k, NULL);

			if (!ds->lp_scale_nfixed[k]) {
				mb->theta = Realloc(mb->theta, mb->ntheta + 1, double **);
				mb->theta_hyperid = Realloc(mb->theta_hyperid, mb->ntheta + 1, char *);
				mb->theta_hyperid[mb->ntheta] = ds->lp_scale_nprior[k].hyperid;
				mb->theta_tag = Realloc(mb->theta_tag, mb->ntheta + 1, char *);
				mb->theta_tag_userscale = Realloc(mb->theta_tag_userscale, mb->ntheta + 1, char *);
				mb->theta_dir = Realloc(mb->theta_dir, mb->ntheta + 1, char *);

				Free(ctmp);
				GMRFLib_sprintf(&ctmp, "beta[%1d] for lp_scale", k + 1);
				mb->theta_tag[mb->ntheta] = ctmp;
				mb->theta_tag_userscale[mb->ntheta] = ctmp;
				GMRFLib_sprintf(&msg, "%s-parameter", secname);
				mb->theta_dir[mb->ntheta] = msg;

				mb->theta_from = Realloc(mb->theta_from, mb->ntheta + 1, char *);
				mb->theta_to = Realloc(mb->theta_to, mb->ntheta + 1, char *);
				mb->theta_from[mb->ntheta] = GMRFLib_strdup(ds->lp_scale_nprior[k].from_theta);
				mb->theta_to[mb->ntheta] = GMRFLib_strdup(ds->lp_scale_nprior[k].to_theta);

				mb->theta[mb->ntheta] = ds->lp_scale_beta[k];
				mb->theta_map = Realloc(mb->theta_map, mb->ntheta + 1, map_func_tp *);
				mb->theta_map[mb->ntheta] = map_identity;
				mb->theta_map_arg = Realloc(mb->theta_map_arg, mb->ntheta + 1, void *);
				mb->theta_map_arg[mb->ntheta] = NULL;
				mb->ntheta++;
			}
		} else {
			ds->lp_scale_nfixed[k] = 1;
		}
	}

	for (i = 1; i < mb->nds; i++) {
		mb->data_sections[i].lp_scale = mb->data_sections[0].lp_scale;
		mb->data_sections[i].lp_scale_in_use = mb->data_sections[0].lp_scale_in_use;
		mb->data_sections[i].lp_scale_beta = mb->data_sections[0].lp_scale_beta;
		mb->data_sections[i].lp_scale_nfixed = mb->data_sections[0].lp_scale_nfixed;
		mb->data_sections[i].lp_scale_nprior = mb->data_sections[0].lp_scale_nprior;
	}

	return INLA_OK;
}

int inla_parse_expert(inla_tp * mb, dictionary * ini, int sec)
{
	/*
	 * parse section = expert
	 */
	char *secname = NULL;

	if (mb->verbose) {
		printf("\tinla_parse_expert...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\tsection[%s]\n", secname);
	}

	mb->expert_disable_gaussian_check = iniparser_getint(ini, inla_string_join(secname, "DISABLE.GAUSSIAN.CHECK"), 0);
	if (mb->verbose) {
		printf("\t\t\tdisable.gaussian.check=[%1d]\n", mb->expert_disable_gaussian_check);
	}

	/*
	 * do error-checking later on 
	 */
	mb->expert_cpo_manual = iniparser_getint(ini, inla_string_join(secname, "CPO.MANUAL"), 0);

	char *str = NULL;
	str = iniparser_getstring(ini, inla_string_join(secname, "CPO.IDX"), str);

	int n = 0;
	int *idx = NULL;
	inla_sread_ints_q(&idx, &n, (const char *) str);

	mb->expert_n_cpo_idx = n;
	mb->expert_cpo_idx = idx;

	if (mb->verbose) {
		int i;

		printf("\t\t\tcpo.manual=[%1d]\n", mb->expert_cpo_manual);
		for (i = 0; i < mb->expert_n_cpo_idx; i++) {
			printf("\t\t\tcpo.idx=[%1d]\n", mb->expert_cpo_idx[i]);
		}
	}

	/*
	 * joint prior?
	 */
	char *file = NULL, *model = NULL;

	file = iniparser_getstring(ini, inla_string_join(secname, "JP.FILE"), file);
	model = iniparser_getstring(ini, inla_string_join(secname, "JP.MODEL"), model);
	if (mb->verbose) {
		printf("\t\t\tjp.file=[%s]\n", file);
		printf("\t\t\tjp.model=[%s]\n", model);
	}
	if (model) {
		mb->jp = Calloc(1, inla_jp_tp);
		mb->jp->file = GMRFLib_strdup(file);
		mb->jp->model = GMRFLib_strdup(model);

	} else {
		mb->jp = NULL;
	}

	return INLA_OK;
}

int inla_parse_libR(inla_tp * mb, dictionary * ini, int sec)
{
	/*
	 * parse section = libR
	 */
	char *secname = NULL, *env = NULL;

	if (mb->verbose) {
		printf("\tinla_parse_libR...\n");
	}
	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (mb->verbose) {
		printf("\t\tsection[%s]\n", secname);
	}

	mb->libR_R_HOME = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "R_HOME"), NULL));
	if (mb->verbose) {
		printf("\t\t\tR_HOME=[%s]\n", mb->libR_R_HOME);
	}

	if (mb->libR_R_HOME) {
		// set the R_HOME variable
		GMRFLib_sprintf(&env, "R_HOME=%s", mb->libR_R_HOME);
		my_setenv(env, 0);
		Free(env);
	}

	return INLA_OK;
}

double inla_ar1_cyclic_logdet(int N_orig, double phi)
{
	double logdet = 0.0;
	double tpon = 2.0 * M_PI / N_orig;
	int jj;

	for (jj = 0; jj < N_orig; jj++) {
		logdet += log1p(SQR(phi) - phi * (cos(tpon * jj) + cos(tpon * (N_orig - 1.0) * jj)));
	}
	return (logdet);
}

// disable '-O3' in this function
#pragma GCC push_options
#pragma GCC optimize ("O2")
double extra(int thread_id, double *theta, int ntheta, void *argument)
{
	int i, j, count = 0, nfixed = 0, fail, fixed0, fixed1, fixed2, fixed3, evaluate_hyper_prior = 1;
	const int debug = 0;

	double val = 0.0, log_precision, log_precision0, log_precision1, rho, rho_intern, beta, beta_intern, logit_rho,
	    group_rho = NAN, group_rho_intern = NAN, ngroup = NAN, normc_g = 0.0, n_orig = NAN, N_orig = NAN, rankdef_orig = NAN,
	    h2_intern, phi, phi_intern, a_intern, dof_intern, logdet, group_prec = NAN, group_prec_intern = NAN, grankdef = 0.0,
	    gcorr = 1.0, log_halflife, log_shape, alpha, gama, alpha1, alpha2;

	inla_tp *mb = NULL;
	gsl_matrix *Q = NULL;
	gsl_matrix *L = NULL;

#define _NOT_FIXED(_fx) (!mb->fixed_mode && !mb->_fx)
#define _SET_GROUP_RHO(_nt_)						\
	if (mb->f_group_model[i] != G_AR) {				\
		if (mb->f_ngroup[i] == 1) {				\
			assert(mb->f_ntheta[i] == (_nt_));		\
		} else {						\
			assert(mb->f_ntheta[i] == (_nt_)+1);		\
		}							\
	}								\
	ngroup = mb->f_ngroup[i];					\
	n_orig = mb->f_n[i]/ngroup;					\
	N_orig = mb->f_N[i]/ngroup;					\
	rankdef_orig = mb->f_rankdef[i]/ngroup;				\
	grankdef = 0.0;							\
	if (mb->f_ngroup[i] > 1) {					\
		if (mb->f_group_model[i] == G_AR) {			\
			double _log_precision, *_pacf, *_pacf_intern;	\
			int _p;						\
									\
			_p = mb->f_group_order[i];			\
			if (_NOT_FIXED(f_fixed[i][(_nt_) + 0])) {	\
				_log_precision = theta[count];		\
				count++;				\
			} else {					\
				_log_precision = mb->f_theta[i][(_nt_) + 0][thread_id][0]; \
			}						\
			_pacf = Calloc(_p, double);			\
			_pacf_intern = Calloc(_p, double);		\
			for (j = 0; j < _p; j++) {			\
				if (_NOT_FIXED(f_fixed[i][(_nt_) + j + 1])) { \
					_pacf_intern[j] = theta[count];	\
					count++;			\
				} else {				\
					_pacf_intern[j] = mb->f_theta[i][(_nt_) + j + 1][thread_id][0]; \
				}					\
				_pacf[j] = ar_map_pacf(_pacf_intern[j], MAP_FORWARD, NULL); \
			}						\
			double _marginal_prec, _conditional_prec, *_marginal_Q, *_param, *_zero; \
			_marginal_Q = Calloc(ISQR(_p), double);		\
			ar_marginal_distribution(_p, _pacf, &_marginal_prec, _marginal_Q); \
			_conditional_prec = exp(_log_precision) / _marginal_prec; \
			_param = Calloc(1 + _p + ISQR(_p), double);	\
			_zero = Calloc(_p, double);			\
			_param[0] = _p;					\
			for (j = 0; j < ISQR(_p); j++) {		\
				_param[1 + _p + j] = _marginal_Q[j] * exp(_log_precision); \
			}						\
			normc_g = priorfunc_mvnorm(_zero, _param) + (ngroup - _p) * (-0.5 * log(2 * M_PI) + 0.5 * log(_conditional_prec)); \
			normc_g -= LOG_NORMC_GAUSSIAN * ngroup; /* This term goes into the main code therefore its removed here	*/ \
			normc_g *= (N_orig - rankdef_orig);		\
			if (_NOT_FIXED(f_fixed[i][(_nt_) + 0])) {	\
				val += PRIOR_EVAL(mb->f_prior[i][(_nt_) + 0], &_log_precision); \
			}						\
			for (j = 0; j < _p; j++) {			\
				if (_NOT_FIXED(f_fixed[i][(_nt_) + j + 1])) { \
					val += PRIOR_EVAL(mb->f_prior[i][(_nt_) + j + 1], &(_pacf_intern[j])); \
				}					\
			}						\
			Free(_param);					\
			Free(_zero);					\
			Free(_pacf);					\
			Free(_pacf_intern);				\
			Free(_marginal_Q);				\
		} else {						\
			if (_NOT_FIXED(f_fixed[i][(_nt_)])){		\
				group_rho_intern = group_prec_intern = theta[count]; \
				count++;				\
			} else {					\
				group_rho_intern = group_prec_intern= mb->f_theta[i][(_nt_)][thread_id][0]; \
			}						\
			if (mb->f_group_model[i] == G_EXCHANGEABLE) {	\
				int ingroup = (int) ngroup;		\
				group_rho = map_group_rho(group_rho_intern, MAP_FORWARD, (void *) &ingroup); \
				normc_g = - 0.5 * (log1p((ngroup - 1.0) * group_rho) + (ngroup-1)*LOG_ONE_MINUS(group_rho)); \
				if (_NOT_FIXED(f_fixed[i][(_nt_)])) {	\
					val += PRIOR_EVAL(mb->f_prior[i][(_nt_)], &group_rho_intern); \
				}					\
			}else if (mb->f_group_model[i] == G_EXCHANGEABLE_POS) {	\
				int ingroup = (int) ngroup;		\
				group_rho = map_probability(group_rho_intern, MAP_FORWARD, (void *) &ingroup); \
				normc_g = - 0.5 * (log1p((ngroup - 1.0) * group_rho) + (ngroup-1)*LOG_ONE_MINUS(group_rho)); \
				if (_NOT_FIXED(f_fixed[i][(_nt_)])) {	\
					val += PRIOR_EVAL(mb->f_prior[i][(_nt_)], &group_rho_intern); \
				}					\
			} else if (mb->f_group_model[i] == G_AR1) {	\
				group_rho = map_rho(group_rho_intern, MAP_FORWARD, NULL); \
				if (mb->f_group_cyclic[i]) {		\
					normc_g = - (ngroup - 0.0) * 0.5 * LOG_ONE_MINUS(SQR(group_rho)) + 0.5 * inla_ar1_cyclic_logdet(ngroup, group_rho); \
				} else {				\
					normc_g = - (ngroup - 1.0) * 0.5 * LOG_ONE_MINUS(SQR(group_rho)); \
				}					\
				if (_NOT_FIXED(f_fixed[i][(_nt_)])) {	\
					val += PRIOR_EVAL(mb->f_prior[i][(_nt_)], &group_rho_intern); \
				}					\
			} else if (mb->f_group_model[i] == G_RW1 || mb->f_group_model[i] == G_RW2 || mb->f_group_model[i] == G_BESAG) { \
				grankdef = (mb->f_group_model[i] == G_RW1 || mb->f_group_model[i] == G_BESAG ? 1.0 : 2.0); \
				group_prec = map_precision(group_prec_intern, MAP_FORWARD, NULL); \
				normc_g = 0.5 * (ngroup - grankdef) * log(group_prec); \
				if (_NOT_FIXED(f_fixed[i][(_nt_)])) {	\
					val += PRIOR_EVAL(mb->f_prior[i][(_nt_)], &group_prec_intern); \
				}					\
			} else if (mb->f_group_model[i] == G_IID) {	\
				grankdef = 0.0;				\
				group_prec = map_precision(group_prec_intern, MAP_FORWARD, NULL); \
				normc_g = 0.5 * (ngroup - grankdef) * log(group_prec); \
				if (_NOT_FIXED(f_fixed[i][(_nt_)])) {	\
					val += PRIOR_EVAL(mb->f_prior[i][(_nt_)], &group_prec_intern); \
				}					\
			} else {					\
				abort();				\
			}						\
			normc_g *= (N_orig - rankdef_orig);		\
		}							\
		gcorr = 1.0 - grankdef / mb->f_ngroup[i];		\
	} else {							\
		group_rho = group_rho_intern = 0.0;			\
		normc_g = 0.0;						\
		ngroup = 1.0;						\
		n_orig = mb->f_n[i];					\
		N_orig = mb->f_N[i];					\
		rankdef_orig = mb->f_rankdef[i];			\
		grankdef = 0.0;						\
		gcorr = 1.0;						\
	}

	mb = (inla_tp *) argument;

	/*
	 * this will evaluate all the hyperparameters and disable EVAL_PRIOR...
	 */
	if (mb->update) {
		val += inla_update_density(theta, mb->update);
		evaluate_hyper_prior = 0;
	}
	// joint prior evaluated in R
	static int jp_first_time = 1;
	static void *jp_vec_sexp = NULL;

	if (mb->jp) {
#pragma omp critical (Name_886e56613636db7114635f9aacba5e4fc01cca40)
		{
			if (jp_first_time) {
				char **vec_str = NULL;

				inla_R_library("INLA");
				inla_R_load(mb->jp->file);
				if (mb->ntheta > 0) {
					vec_str = Calloc(mb->ntheta, char *);
					for (int i = 0; i < mb->ntheta; i++) {
						vec_str[i] = GMRFLib_strdup(mb->theta_tag[i]);
					}
				}
				jp_vec_sexp = inla_R_vector_of_strings(mb->ntheta, vec_str);
				jp_first_time = 0;

				if (vec_str) {
					for (int i = 0; i < mb->ntheta; i++) {
						Free(vec_str[i]);
					}
					Free(vec_str);
				}
			}
			assert(!(mb->update));		       /* only one at the time... */
			evaluate_hyper_prior = 0;

			int verbose = 0;
			if (ntheta > 0) {
				int n_out = 0;
				double *lprior = NULL;

				inla_R_funcall_jp(&n_out, &lprior, (const char *) mb->jp->model, &ntheta, theta, jp_vec_sexp);
				assert(n_out == 1);
				assert(lprior);
				val += *lprior;
				if (verbose) {
					printf("got lprior = %g\n", *lprior);
				}
				Free(lprior);
			} else {
				if (verbose) {
					printf("lprior: ntheta= 0, no prior needed\n");
				}
			}
		}
	}

	/*
	 * this is for the linear predictor
	 */

	if (GMRFLib_inla_mode == GMRFLib_MODE_CLASSIC || GMRFLib_inla_mode == GMRFLib_MODE_TWOSTAGE_PART2) {
		if (!mb->predictor_fixed) {
			log_precision = theta[count];
			count++;
		} else {
			log_precision = mb->predictor_log_prec[thread_id][0];
		}
		val += mb->predictor_n * (LOG_NORMC_GAUSSIAN + 1.0 / 2.0 * log_precision);
		if (!mb->predictor_fixed) {
			val += PRIOR_EVAL(mb->predictor_prior, &log_precision);
		}

		/*
		 * this is for the A-matrix
		 */
		if (mb->predictor_m > 0) {
			log_precision = log(mb->predictor_Aext_precision);
			val += mb->predictor_m * (LOG_NORMC_GAUSSIAN + 1.0 / 2.0 * log_precision);
		}
	}

	if (mb->data_ntheta_all) {
		int check = 0;

		for (j = 0; j < mb->nds; j++) {
			Data_section_tp *ds = &(mb->data_sections[j]);

			check += ds->data_ntheta;
			switch (ds->data_id) {
			case L_GAUSSIAN:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &log_precision);
					count++;
				}
				if (!ds->data_fixed1) {
					// this should not happen, as data_fixed1 must be TRUE. We prepare the code for it, in
					// any case. 
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &log_precision);
					count++;
				}
			}
				break;

			case L_GAUSSIANJW:
			{
				for (int k = 0; k < 3; k++) {
					if (!ds->data_nfixed[k]) {
						double beta = theta[count];
						val += PRIOR_EVAL(ds->data_nprior[k], &beta);
						count++;
					}
				}
			}
				break;

			case L_AGAUSSIAN:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_precision);
					count++;
				}
			}
				break;

			case L_LOGNORMAL:
			case L_LOGNORMALSURV:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_precision);
					count++;
				}
			}
				break;

			case L_SIMPLEX:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_precision);
					count++;
				}
			}
				break;

			case L_GPOISSON:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_overdispersion = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &log_overdispersion);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double p = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &p);
					count++;
				}
			}
				break;

			case L_CIRCULAR_NORMAL:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_precision);
					count++;
				}
			}
				break;

			case L_WRAPPED_CAUCHY:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_precision);
					count++;
				}
			}
				break;

			case L_TWEEDIE:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double p_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &p_intern);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_phi = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &log_phi);
					count++;
				}
			}
				break;

			case L_FMRI:
			case L_FMRISURV:
			{
				if (!ds->data_fixed0) {
					double lprec = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &lprec);
					count++;
				}
				if (!ds->data_fixed1) {
					double ldof = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &ldof);
					count++;
				}
			}
				break;

			case L_GP:
			case L_DGP:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_tail = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_tail);
					count++;
				}
			}
				break;

			case L_IID_GAMMA:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_shape = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &log_shape);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_rate = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &log_rate);
					count++;
				}
			}
				break;

			case L_IID_LOGITBETA:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_a = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &log_a);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_b = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &log_b);
					count++;
				}
			}
				break;

			case L_LOGGAMMA_FRAILTY:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_precision);
					count++;
				}
			}
				break;

			case L_LOGISTIC:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_precision);
					count++;
				}
			}
				break;

			case L_SKEWNORMAL:
			{
				if (!ds->data_fixed0) {
					log_precision = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &log_precision);
					count++;
				}
				if (!ds->data_fixed1) {
					double skewness = theta[count];

					val += PRIOR_EVAL(ds->data_prior1, &skewness);
					count++;
				}
			}
				break;

			case L_GEV:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					log_precision = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &log_precision);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * this is the gev-parameter. Note that we need to scale it back to the real scale, as
					 * 'scale_xi' is there to help the numerics only
					 */
					double xi = theta[count] * ds->data_observations.gev_scale_xi;

					val += PRIOR_EVAL(ds->data_prior1, &xi) + log(ds->data_observations.gev_scale_xi);
					count++;
				}
			}
				break;

			case L_BGEV:
			{
				{
					if (!ds->data_nfixed[0]) {
						double spread = theta[count];
						val += PRIOR_EVAL(ds->data_nprior[0], &spread);
						count++;
					}
					if (!ds->data_nfixed[1]) {
						double intern_tail = theta[count];
						val += PRIOR_EVAL(ds->data_nprior[1], &intern_tail);
						count++;
					}

					int nbetas = ds->data_observations.bgev_nbetas[0] + ds->data_observations.bgev_nbetas[1];
					int off = 2;
					for (int k = off; k < off + nbetas; k++) {
						if (!ds->data_nfixed[k]) {
							double b = theta[count];
							if (k < ds->data_observations.bgev_nbetas[0]) {
								val += PRIOR_EVAL(ds->data_nprior[k], &b);
							} else {
								val += PRIOR_EVAL(ds->data_nprior[k], &b);
							}
							count++;
						}
					}
				}
			}
				break;

			case L_GAMMA:
			case L_GAMMASURV:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double precision_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &precision_intern);
					count++;
				}
			}
				break;

			case L_GAMMAJW:
			case L_GAMMAJWSURV:
				break;

			case L_GAMMACOUNT:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_alpha = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &log_alpha);
					count++;
				}
			}
				break;

			case L_QKUMAR:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double precision_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &precision_intern);
					count++;
				}
			}
				break;

			case L_LOGLOGISTIC:
			case L_LOGLOGISTICSURV:
			case L_QLOGLOGISTIC:
			case L_QLOGLOGISTICSURV:
			{
				if (!ds->data_fixed) {
					double alpha_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &alpha_intern);
					count++;
				}
			}
				break;

			case L_BETA:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double precision_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &precision_intern);
					count++;
				}
			}
				break;

			case L_BETABINOMIAL:
			case L_BETABINOMIALNA:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double intern_overdispersion = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &intern_overdispersion);
					count++;
				}
			}
				break;

			case L_NBINOMIAL:
			case L_CENNBINOMIAL2:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_size = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &log_size);
					count++;
				}
			}
				break;

			case L_ZEROINFLATEDNBINOMIAL0:
			case L_ZEROINFLATEDNBINOMIAL1:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_size = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &log_size);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * this is the probability-parameter in the zero-inflated nbinomial_0/1
					 */
					double prob_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior1, &prob_intern);
					count++;
				}
			}
				break;

			case L_ZEROINFLATEDNBINOMIAL2:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_size = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &log_size);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * this is the alpha-parameter in the zero-inflated nbinomial_0/1
					 */
					double alpha_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior1, &alpha_intern);
					count++;
				}
			}
				break;

			case L_ZEROINFLATEDBETABINOMIAL0:
			case L_ZEROINFLATEDBETABINOMIAL1:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double rho_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &rho_intern);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * this is the probability-parameter in the zero-inflated betabinomial_0/1
					 */
					double prob_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior1, &prob_intern);
					count++;
				}
			}
				break;

			case L_ZEROINFLATEDNBINOMIAL1STRATA2:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_size = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &log_size);
					count++;
				}
				for (int icount = 0; icount < STRATA_MAXTHETA; icount++) {
					if (!ds->data_nfixed[icount]) {
						/*
						 * this is the probability-parameter in the zero-inflated nbinomial_strata2
						 */
						double prob_intern = theta[count];
						val += PRIOR_EVAL(ds->data_nprior[icount], &prob_intern);
						count++;
					}
				}
			}
				break;

			case L_ZEROINFLATEDNBINOMIAL1STRATA3:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double prob_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &prob_intern);
					count++;
				}
				for (int icount = 0; icount < STRATA_MAXTHETA; icount++) {
					if (!ds->data_nfixed[icount]) {
						/*
						 * this is the size-parameter in the zero-inflated nbinomial_strata2
						 */
						double log_size = theta[count];
						val += PRIOR_EVAL(ds->data_nprior[icount], &log_size);
						count++;
					}
				}
			}
				break;

			case L_ZERO_N_INFLATEDBINOMIAL2:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_alpha1 = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &log_alpha1);
					count++;
				}
				if (!ds->data_fixed1) {
					double log_alpha2 = theta[count];

					val += PRIOR_EVAL(ds->data_prior1, &log_alpha2);
					count++;
				}
			}
				break;

			case L_ZERO_N_INFLATEDBINOMIAL3:
			{
				if (!ds->data_fixed0) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is included in the likelihood
					 * function.
					 */
					double log_alpha0 = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &log_alpha0);
					count++;
				}
				if (!ds->data_fixed1) {
					double log_alphaN = theta[count];

					val += PRIOR_EVAL(ds->data_prior1, &log_alphaN);
					count++;
				}
			}
				break;

			case L_T:
			{
				/*
				 * we only need to add the prior, since the normalisation constant due to the likelihood, is
				 * included in the likelihood function. 
				 */
				if (!ds->data_fixed0) {
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &log_precision);
					count++;
				}
				if (!ds->data_fixed1) {
					dof_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &dof_intern);
					count++;
				}
			}
				break;

			case L_TSTRATA:
			{
				/*
				 * we only need to add the prior, since the normalisation constant due to the likelihood, is
				 * included in the likelihood function. 
				 */
				int k;
				for (k = 0; k < TSTRATA_MAXTHETA; k++) {
					if (!ds->data_nfixed[k]) {
						double th = theta[count];
						val += PRIOR_EVAL(ds->data_nprior[k], &th);
						count++;
					}
				}
			}
				break;

			case L_STOCHVOL:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is
					 * included in the likelihood function. this is the offset precision
					 */
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &log_precision);
					count++;
				}
			}
				break;

			case L_STOCHVOL_SN:
			{
				if (!ds->data_fixed0) {
					double skew_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &skew_intern);
					count++;
				}
				if (!ds->data_fixed1) {
					double log_prec_offset = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &log_prec_offset);
					count++;
				}
			}
				break;

			case L_STOCHVOL_T:
			{
				if (!ds->data_fixed) {
					/*
					 * we only need to add the prior, since the normalisation constant due to the likelihood, is
					 * included in the likelihood function. 
					 */
					dof_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &dof_intern);
					count++;
				}
			}
				break;

			case L_STOCHVOL_NIG:
			{
				if (!ds->data_fixed0) {
					/*
					 * this is the skewness 
					 */
					double skew = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &skew);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * this is the shape 
					 */
					double shape_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior1, &shape_intern);
					count++;
				}
			}
				break;

			case L_WEIBULL:
			case L_WEIBULLSURV:
			{
				if (!ds->data_fixed) {
					double alpha_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &alpha_intern);
					count++;
				}
			}
				break;

			case L_GOMPERTZ:
			case L_GOMPERTZSURV:
			{
				if (!ds->data_fixed) {
					double alpha_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior, &alpha_intern);
					count++;
				}
			}
				break;

			case L_WEIBULL_CURE:
			{
				if (!ds->data_fixed0) {
					double alpha_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior0, &alpha_intern);
					count++;
				}
				if (!ds->data_fixed1) {
					double p_intern = theta[count];
					val += PRIOR_EVAL(ds->data_prior1, &p_intern);
					count++;
				}
			}
				break;

			case L_ZEROINFLATEDPOISSON0:
			case L_ZEROINFLATEDPOISSON1:
			case L_ZEROINFLATEDCENPOISSON0:
			case L_ZEROINFLATEDCENPOISSON1:
			case L_POISSON_SPECIAL1:
			{
				if (!ds->data_fixed) {
					/*
					 * this is the probability-parameter in the zero-inflated Poisson_0/1 or special1
					 */
					double prob_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &prob_intern);
					count++;
				}
			}
				break;

			case L_ZEROINFLATEDPOISSON2:
			{
				if (!ds->data_fixed) {
					/*
					 * this is the probability-parameter in the zero-inflated Poisson_2
					 */
					double alpha_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &alpha_intern);
					count++;
				}
			}
				break;

			case L_ZEROINFLATEDBINOMIAL2:
				if (!ds->data_fixed) {
					/*
					 * this is the probability-parameter in the zero-inflated Binomial_2
					 */
					double alpha_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &alpha_intern);
					count++;
				}
				break;

			case L_ZEROINFLATEDBINOMIAL0:
			case L_ZEROINFLATEDBINOMIAL1:
			{
				if (!ds->data_fixed) {
					/*
					 * this is the probability-parameter in the zero-inflated Binomial_0/1
					 */
					double prob_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior, &prob_intern);
					count++;
				}
			}
				break;

			case L_ZEROINFLATEDBETABINOMIAL2:
			{
				if (!ds->data_fixed0) {
					/*
					 * this is the probability-related-parameter 
					 */
					double alpha_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior0, &alpha_intern);
					count++;
				}
				if (!ds->data_fixed1) {
					/*
					 * this is the delta-parameter 
					 */
					double delta_intern = theta[count];

					val += PRIOR_EVAL(ds->data_prior1, &delta_intern);
					count++;
				}
			}
				break;

			case L_NMIX:
			{
				for (int k = 0; k < NMIX_MMAX; k++) {
					if (!ds->data_nfixed[k]) {
						beta = theta[count];
						val += PRIOR_EVAL(ds->data_nprior[k], &beta);
						count++;
					}
				}
			}
				break;

			case L_NMIXNB:
			{
				/*
				 *  the last one here is the log_overdispersion, which I do not rename to, for simplicity
				 */
				for (int k = 0; k < NMIX_MMAX + 1; k++) {
					if (!ds->data_nfixed[k]) {
						beta = theta[count];
						val += PRIOR_EVAL(ds->data_nprior[k], &beta);
						count++;
					}
				}
			}
				break;

			case L_BINOMIAL:
			case L_XBINOMIAL:
			case L_EXPONENTIAL:
			case L_EXPONENTIALSURV:
			case L_POISSON:
			case L_XPOISSON:
			case L_CONTPOISSON:
			case L_QCONTPOISSON:
				/*
				 * nothing to do
				 */
				break;

			case L_POM:
			{
				double *v = Calloc(POM_MAXTHETA, double);
				int v_count = 0;

				for (int k = 0; k < POM_MAXTHETA; k++) {
					if (!ds->data_nfixed[k]) {
						v[v_count] = theta[count];
						v_count++;
						count++;
					}
				}
				if (v_count > 0) {
					val += PRIOR_EVAL(ds->data_nprior[0], v);
				}
				Free(v);
			}
				break;

			default:
				/*
				 * nothing to do
				 */
				break;
			}

			/*
			 * link-models 
			 */
			check += ds->link_ntheta;

			if (debug) {
				P(ds->link_id);
				P(ds->link_ntheta);
			}

			switch (ds->link_id) {
			case LINK_IDENTITY:
			case LINK_INVERSE:
			case LINK_LOG:
			case LINK_LOGa:
			case LINK_NEGLOG:
			case LINK_PROBIT:
			case LINK_CLOGLOG:
			case LINK_LOGLOG:
			case LINK_CAUCHIT:
			case LINK_LOGIT:
			case LINK_TAN:
			case LINK_QPOISSON:
			case LINK_QBINOMIAL:
			case LINK_QWEIBULL:
			case LINK_QGAMMA:
				break;

			case LINK_LOGOFFSET:
			{
				if (!ds->link_fixed[0]) {
					double beta_intern = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &beta_intern);
					count++;
				}
			}
				break;

			case LINK_LOGITOFFSET:
			{
				if (!ds->link_fixed[0]) {
					double prob_intern = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &prob_intern);
					count++;
				}
			}
				break;

			case LINK_SSLOGIT:
			{
				if (!ds->link_fixed[0]) {
					double sensitivity_intern = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &sensitivity_intern);
					count++;
				}
				if (!ds->link_fixed[1]) {
					double specificity_intern = theta[count];
					val += PRIOR_EVAL(ds->link_prior[1], &specificity_intern);
					count++;
				}
			}
				break;

			case LINK_ROBIT:
			{
				if (!ds->link_fixed[0]) {
					double dof_intern = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &dof_intern);
					count++;
				}
			}
				break;

			case LINK_SN:
			{
				if (!ds->link_fixed[0]) {
					double skew = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &skew);
					count++;
				}
				if (!ds->link_fixed[1]) {
					double intercept = theta[count];
					val += PRIOR_EVAL(ds->link_prior[1], &intercept);
					count++;
				}
			}
				break;

			case LINK_POWER_LOGIT:
			{
				if (!ds->link_fixed[0]) {
					double power = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &power);
					count++;
				}
				if (!ds->link_fixed[1]) {
					double intercept = theta[count];
					val += PRIOR_EVAL(ds->link_prior[1], &intercept);
					count++;
				}
			}
				break;

			case LINK_TEST1:
			{
				if (!ds->link_fixed[0]) {
					double beta = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &beta);
					count++;
				}
			}
				break;

			case LINK_SPECIAL2:
			{
				if (!ds->link_fixed[0]) {
					double beta = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &beta);
					count++;
				}
			}
				break;

			case LINK_SPECIAL1:
			{
				if (!ds->link_fixed[0]) {
					double log_precision;
					log_precision = theta[count];
					val += PRIOR_EVAL(ds->link_prior[0], &log_precision);
					count++;
				} else {
					// log_precision = ds->link_parameters->log_prec[thread_id][0]; 
				}

				if (ds->link_order > 0) {
					double *beta = Calloc(ds->link_order, double);
					for (j = 0; j < ds->link_order; j++) {
						if (!ds->link_fixed[j + 1]) {
							beta[j] = theta[count];
							count++;
						} else {
							beta[j] = ds->link_parameters->betas[j][thread_id][0];
						}
					}
					val += PRIOR_EVAL(ds->link_prior[1], beta);
					Free(beta);
				}
			}
				break;

			default:
				GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
			}

			/*
			 * re-models 
			 */
			if (ds->mix_use) {
				check += ds->mix_ntheta;

				switch (ds->mix_id) {
				case MIX_GAUSSIAN:
				case MIX_LOGGAMMA:
				case MIX_MLOGGAMMA:
					if (!ds->mix_fixed) {
						log_precision = theta[count];
						val += PRIOR_EVAL(ds->mix_prior, &log_precision);
						count++;
					}
					break;
				default:
					GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
				}
			}
		}
		assert(mb->data_ntheta_all == check);
	}

	for (i = 0; i < mb->nlinear; i++) {
		if (mb->linear_precision[i] > 0.0) {
			val += LOG_NORMC_GAUSSIAN + 1.0 / 2.0 * log(mb->linear_precision[i])
			    - 1.0 / 2.0 * mb->linear_precision[i] * SQR(mb->linear_mean[i]);
		}
	}

	for (i = 0; i < mb->nf; i++) {
		switch (mb->f_id[i]) {
		case F_RW2D:
		case F_BESAG:
		case F_GENERIC0:
		case F_SEASONAL:
		case F_IID:
		case F_RW1:
		case F_RW2:
		case F_CRW2:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			_SET_GROUP_RHO(1);

			double scale_correction = 0.0;
			if (mb->f_id[i] == F_IID && mb->f_scale[i]) {
				int ii, nii = mb->f_N[i] / mb->f_ngroup[i];

				for (ii = 0; ii < nii; ii++) {
					scale_correction += log(mb->f_scale[i][ii]);
				}
				scale_correction /= nii;
			}

			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (mb->f_N[i] - mb->f_rankdef[i]) +
								   (mb->f_N[i] - mb->f_rankdef[i]) / 2.0 * (log_precision + scale_correction)));
			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
		}
			break;

		case F_SPDE:
		{
			int k, nT, nK, nt, Toffset = 0, Koffset = 0;
			double t;
			inla_spde_tp *spde;
			double *Tpar = NULL, *Kpar = NULL, init0, init1, init2, init3;

			spde = (inla_spde_tp *) mb->f_model[i];
			assert(spde->Qfunc_arg == spde);

			nT = spde->Tmodel->ntheta;
			nK = spde->Kmodel->ntheta;
			nt = mb->f_ntheta[i];

			fixed0 = !_NOT_FIXED(f_fixed[i][0]);
			fixed1 = !_NOT_FIXED(f_fixed[i][1]);
			fixed2 = !_NOT_FIXED(f_fixed[i][2]);
			fixed3 = !_NOT_FIXED(f_fixed[i][3]);
			init0 = mb->f_initial[i][0];
			init1 = mb->f_initial[i][1];
			init2 = mb->f_initial[i][2];
			init3 = mb->f_initial[i][3];

			Tpar = Calloc(nT, double);
			Kpar = Calloc(nK, double);

			if (debug) {
				P(i);
				P(mb->f_fixed[i][0]);
				P(mb->f_fixed[i][1]);
				P(mb->f_fixed[i][2]);
				P(mb->f_fixed[i][3]);
				P(nT);
				P(nK);
				P(nt);
				P(fixed0);
				P(fixed1);
				P(fixed2);
				P(fixed3);
				P(init0);
				P(init1);
				P(init2);
				P(init3);
			}

			if (nT) {
				if (fixed0) {
					Tpar[0] = init0;
				} else {
					Tpar[0] = theta[count];
					Toffset++;
				}
				if (nT > 1) {
					if (fixed2) {
						for (k = 1; k < nT; k++)
							Tpar[k] = init2;
					} else {
						for (k = 1; k < nT; k++) {
							Tpar[k] = theta[count + Toffset];
							Toffset++;
						}
					}
				}
				spde->Tmodel->theta_extra[thread_id] = Tpar;
			}

			if (debug) {
				P(count);
				P(Toffset);
				for (k = 0; k < nT; k++) {
					printf("Tpar[%d] = %g\n", k, Tpar[k]);
				}
			}

			if (nK) {
				if (fixed1) {
					Kpar[0] = init1;
				} else {
					Kpar[0] = theta[count + Toffset];
					Koffset++;
				}
				if (nK > 1) {
					if (fixed2) {
						for (k = 1; k < nK; k++)
							Kpar[k] = init2;
					} else {
						for (k = 1; k < nK; k++) {
							Kpar[k] = theta[count + Koffset + Toffset];
							Koffset++;
						}
					}
				}
				spde->Kmodel->theta_extra[thread_id] = Kpar;
			}

			if (debug) {
				P(count);
				P(Toffset);
				P(Koffset);
				for (k = 0; k < nT; k++) {
					printf("Tpar[%d] = %g\n", k, Tpar[k]);
				}
				for (k = 0; k < nK; k++) {
					printf("Kpar[%d] = %g\n", k, Kpar[k]);
				}
			}

			if (fixed3) {
				spde->oc[thread_id][0] = init3;
			} else {
				spde->oc[thread_id][0] = theta[count + Koffset + Toffset];
			}

			if (debug) {
				printf("call extra() with\n");
				for (k = 0; k < nT; k++) {
					printf("Tmodel %d %g\n", k, spde->Tmodel->theta_extra[thread_id][k]);
				}
				for (k = 0; k < nK; k++) {
					printf("Kmodel %d %g\n", k, spde->Kmodel->theta_extra[thread_id][k]);
				}
				printf("Oc %g\n", spde->oc[thread_id][0]);
			}

			/*
			 * T 
			 */
			if (nT) {
				if (_NOT_FIXED(f_fixed[i][0])) {
					t = theta[count];
					val += PRIOR_EVAL(mb->f_prior[i][0], &t);
					count++;
				}
				for (k = 1; k < nT; k++) {
					if (_NOT_FIXED(f_fixed[i][2])) {
						t = theta[count];
						val += PRIOR_EVAL(mb->f_prior[i][2], &t);
						count++;
					}
				}
			}

			/*
			 * K 
			 */
			if (nK) {
				if (_NOT_FIXED(f_fixed[i][1])) {
					t = theta[count];
					val += PRIOR_EVAL(mb->f_prior[i][1], &t);
					count++;
				}
				for (k = 1; k < nK; k++) {
					if (_NOT_FIXED(f_fixed[i][2])) {
						t = theta[count];
						val += PRIOR_EVAL(mb->f_prior[i][2], &t);
						count++;
					}
				}
			}
			/*
			 * Ocillating coeff 
			 */
			if (!fixed3) {
				t = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][3], &t);
				count++;
			}

			if (debug) {
				P(nT);
				P(nK);
				P(mb->f_ntheta[i]);
			}
			assert(IMAX(4, nT + nK + 1) + (mb->f_ngroup[i] > 1 ? 1 : 0) == mb->f_ntheta[i]);

			_SET_GROUP_RHO(IMAX(4, nT + nK + 1));

			GMRFLib_problem_tp *problem = NULL;
			/*
			 * do a check for numerical not pos def matrix here, as its so close to being singular 
			 */
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
			double *cc_add = Calloc(spde->graph->n, double);

			if (mb->f_diag[i]) {
				int ii;
				for (ii = 0; ii < spde->graph->n; ii++) {
					cc_add[ii] = mb->f_diag[i];
				}
			}

			while (!ok) {
				retval = GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL,
							      spde->graph, spde->Qfunc, spde->Qfunc_arg, mb->f_constr_orig[i]);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					int ii;
					double eps = GMRFLib_eps(0.5);

					for (ii = 0; ii < spde->graph->n; ii++) {
						cc_add[ii] = (cc_add[ii] == 0.0 ? eps : cc_add[ii] * 10.0);
					}
					break;
				}

				case GMRFLib_SUCCESS:
					ok = 1;
					break;

				default:
					/*
					 * some other error 
					 */
					GMRFLib_set_error_handler(old_handler);
					abort();
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			Free(cc_add);
			GMRFLib_set_error_handler(old_handler);

			GMRFLib_evaluate(problem);
			val += mb->f_nrep[i] * (problem->sub_logdens * (ngroup - grankdef) + normc_g);

			if (nT) {
				spde->Tmodel->theta_extra[thread_id] = NULL;
			}
			if (nK) {
				spde->Kmodel->theta_extra[thread_id] = NULL;
			}

			GMRFLib_free_problem(problem);
			Free(Tpar);
			Free(Kpar);
		}
			break;

		case F_SPDE2:
		{
			int k, kk;
			const int debug = 0;
			inla_spde2_tp *spde2;

			spde2 = (inla_spde2_tp *) mb->f_model[i];
			assert(spde2->Qfunc_arg == spde2);

			if (debug) {
				static int first = 1;
				if (first) {
					P(spde2->ntheta_used);
					P(spde2->ntheta);
					P(mb->f_ntheta[i]);
					first = 0;
				}
			}

			spde2->debug = 0;
			if (!mb->fixed_mode) {
				for (k = kk = 0; k < spde2->ntheta_used; k++, kk++) {
					while (mb->f_fixed[i][kk])
						kk++;
					spde2->theta[kk][thread_id][0] = theta[count + k];
				}
			}
			int count_ref = count;

			if (!mb->fixed_mode) {
				count += spde2->ntheta_used;   /* as _SET_GROUP_RHO need 'count' */
			}
			_SET_GROUP_RHO(spde2->ntheta);

			/*
			 * do a check for numerical not pos def matrix here, as its so close to being singular 
			 */
			GMRFLib_problem_tp *problem = NULL;
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
			double *cc_add = Calloc(spde2->graph->n, double);

			if (mb->f_diag[i]) {
				int ii;
				for (ii = 0; ii < spde2->graph->n; ii++) {
					cc_add[ii] = mb->f_diag[i];
				}
			}

			while (!ok) {
				retval = GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL,
							      spde2->graph, spde2->Qfunc, spde2->Qfunc_arg, mb->f_constr_orig[i]);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					int ii;
					double eps = GMRFLib_eps(0.5);

					for (ii = 0; ii < spde2->graph->n; ii++) {
						cc_add[ii] = (cc_add[ii] == 0.0 ? eps : cc_add[ii] * 10.0);
					}
					break;
				}

				case GMRFLib_SUCCESS:
					ok = 1;
					break;

				default:
					/*
					 * some other error 
					 */
					GMRFLib_set_error_handler(old_handler);
					abort();
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			Free(cc_add);
			GMRFLib_set_error_handler(old_handler);

			GMRFLib_evaluate(problem);
			val += mb->f_nrep[i] * (problem->sub_logdens * (ngroup - grankdef) + normc_g);

			/*
			 * this is a multivariate prior...  'count_ref' is the 'first theta'
			 */
			if (!mb->fixed_mode) {
				if (mb->f_prior[i][0].id == P_PC_MATERN) {
					/*
					 *  This is a special case: the pc_matern prior. pass NAN for fixed values and the prior will do the correct thing.
					 */
					double local_theta[2];
					int local_count = 0;

					local_theta[0] = (_NOT_FIXED(f_fixed[i][0]) ? theta[count_ref + local_count++] : NAN);
					local_theta[1] = (_NOT_FIXED(f_fixed[i][1]) ? theta[count_ref + local_count++] : NAN);
					assert(local_count == spde2->ntheta_used);
					val += PRIOR_EVAL(mb->f_prior[i][0], local_theta);
				} else {
					// the mvnorm prior, defined on the _USED_ thetas!
					val += PRIOR_EVAL(mb->f_prior[i][0], &theta[count_ref]);
				}
			}

			GMRFLib_free_problem(problem);
		}
			break;

		case F_SPDE3:
		{
			int k, spde3_ntheta;
			inla_spde3_tp *spde3;

			spde3 = (inla_spde3_tp *) mb->f_model[i];
			assert(spde3->Qfunc_arg == spde3);

			spde3->debug = 0;
			spde3_ntheta = spde3->ntheta;
			if (!mb->fixed_mode) {
				for (k = 0; k < spde3_ntheta; k++) {
					spde3->theta[k][thread_id][0] = theta[count + k];
				}
			}
			int count_ref = count;

			if (!mb->fixed_mode) {
				count += spde3_ntheta;	       /* as _SET_GROUP_RHO need 'count' */
			}
			_SET_GROUP_RHO(spde3_ntheta);

			/*
			 * do a check for numerical not pos def matrix here, as its so close to being singular 
			 */
			GMRFLib_problem_tp *problem = NULL;
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
			double *cc_add = Calloc(spde3->graph->n, double);

			if (mb->f_diag[i]) {
				int ii;
				for (ii = 0; ii < spde3->graph->n; ii++) {
					cc_add[ii] = mb->f_diag[i];
				}
			}

			while (!ok) {
				retval = GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL,
							      spde3->graph, spde3->Qfunc, spde3->Qfunc_arg, mb->f_constr_orig[i]);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					int ii;
					double eps = GMRFLib_eps(0.5);

					for (ii = 0; ii < spde3->graph->n; ii++) {
						cc_add[ii] = (cc_add[ii] == 0.0 ? eps : cc_add[ii] * 10.0);
					}
					break;
				}

				case GMRFLib_SUCCESS:
					ok = 1;
					break;

				default:
					/*
					 * some other error 
					 */
					GMRFLib_set_error_handler(old_handler);
					abort();
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			Free(cc_add);
			GMRFLib_set_error_handler(old_handler);

			GMRFLib_evaluate(problem);
			val += mb->f_nrep[i] * (problem->sub_logdens * (ngroup - grankdef) + normc_g);

			/*
			 * this is the mvnormal prior...  'count_ref' is the 'first theta as this is a mutivariate prior.
			 */
			if (!mb->fixed_mode) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &theta[count_ref]);
			}

			GMRFLib_free_problem(problem);
		}
			break;

		case F_AR:
		{
			double log_precision, *pacf = NULL, *pacf_intern = NULL;
			int p;

			p = mb->f_order[i];
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			pacf = Calloc(p, double);
			pacf_intern = Calloc(p, double);
			for (j = 0; j < p; j++) {
				if (_NOT_FIXED(f_fixed[i][j + 1])) {
					pacf_intern[j] = theta[count];
					count++;
				} else {
					pacf_intern[j] = mb->f_theta[i][j + 1][thread_id][0];
				}
				pacf[j] = ar_map_pacf(pacf_intern[j], MAP_FORWARD, NULL);
			}
			_SET_GROUP_RHO(AR_MAXTHETA + 1);

			int n_ar;
			double marginal_prec, conditional_prec, *marginal_Q, *param, *zero, ldens;

			marginal_Q = Calloc(ISQR(p), double);
			ar_marginal_distribution(p, pacf, &marginal_prec, marginal_Q);
			conditional_prec = exp(log_precision) / marginal_prec;

			param = Calloc(1 + p + ISQR(p), double);
			zero = Calloc(p, double);
			param[0] = p;
			for (j = 0; j < ISQR(p); j++) {
				param[1 + p + j] = marginal_Q[j] * exp(log_precision);
			}

			n_ar = mb->f_n[i] / mb->f_ngroup[i];
			ldens = priorfunc_mvnorm(zero, param) +
			    (n_ar - p - mb->f_rankdef[i]) * (-0.5 * log(2 * M_PI) + 0.5 * log(conditional_prec));
			val += mb->f_nrep[i] * (ldens * (ngroup - grankdef) + normc_g);

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}

			if (mb->f_prior[i][1].id == P_REF_AR) {
				// joint reference prior
				val += PRIOR_EVAL(mb->f_prior[i][1], pacf_intern);
			} else {
				// sequential pc prior. No need to use AR_MAXTHETA there
				for (j = 0; j < p; j++) {
					if (_NOT_FIXED(f_fixed[i][j + 1])) {
						val += PRIOR_EVAL(mb->f_prior[i][j + 1], &(pacf_intern[j]));
					}
				}
			}
			Free(pacf);
			Free(pacf_intern);
			Free(marginal_Q);
			Free(param);
			Free(zero);
		}
			break;

		case F_GENERIC1:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				beta_intern = theta[count];
				count++;
			} else {
				beta_intern = mb->f_theta[i][1][thread_id][0];
			}
			beta = map_probability(beta_intern, MAP_FORWARD, NULL);
			_SET_GROUP_RHO(2);

			double logdet_Q = 0.0;
			inla_generic1_tp *a = (inla_generic1_tp *) mb->f_Qfunc_arg[i];
			for (j = 0; j < n_orig; j++) {
				logdet_Q += LOG_ONE_MINUS(beta * a->eigenvalues[j] / a->max_eigenvalue);
			}

			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (mb->f_n[i] - mb->f_rankdef[i])
								   + (mb->f_n[i] - mb->f_rankdef[i]) / 2.0 * log_precision +
								   ngroup * 0.5 * logdet_Q));
			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &beta_intern);
			}
		}
			break;

		case F_GENERIC2:
		{
			/*
			 * OOPS: even though the parameters are (log_prec, h2_inter), the prior is defined on (log_prec, log_prec_unstruct), with the proper
			 * Jacobian added. 
			 */
			double h2;

			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				h2_intern = theta[count];
				count++;
			} else {
				h2_intern = mb->f_theta[i][1][thread_id][0];
			}
			h2 = map_probability(h2_intern, MAP_FORWARD, NULL);
			_SET_GROUP_RHO(2);

			double log_prec_unstruct = log(h2 / (1.0 - h2)) + log_precision;
			double n = (double) mb->f_n[i];

			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (n / 2.0 + (n - mb->f_rankdef[i]) / 2.0) +
								   +(n - mb->f_rankdef[i]) / 2.0 * log_precision + n / 2.0 * log_prec_unstruct));

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &log_prec_unstruct);
			}
			/*
			 * The Jacobian for the change of variables, is
			 * 
			 * | d log_prec_unstruct / d h2_intern | = 1, so no need to correct for the Jacobian from the change of variables. 
			 */
		}
			break;

		case F_FGN:
		{
			double H_intern;

			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				H_intern = theta[count];
				count++;
			} else {
				H_intern = mb->f_theta[i][1][thread_id][0];
			}
			_SET_GROUP_RHO(2);

			inla_fgn_arg_tp *arg = (inla_fgn_arg_tp *) mb->f_Qfunc_arg_orig[i];

			arg->log_prec[thread_id][0] = log_precision;
			arg->H_intern[thread_id][0] = H_intern;

			int n = mb->f_graph_orig[i]->n;

			GMRFLib_problem_tp *problem = NULL;
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
			double *cc_add = Calloc(n, double);

			if (mb->f_diag[i]) {
				int ii;
				for (ii = 0; ii < n; ii++) {
					cc_add[ii] = mb->f_diag[i];
				}
			}

			while (!ok) {
				retval =
				    GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL, mb->f_graph_orig[i],
							 mb->f_Qfunc_orig[i], mb->f_Qfunc_arg_orig[i], mb->f_constr_orig[i]);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					int ii;
					double eps = GMRFLib_eps(0.5);

					for (ii = 0; ii < arg->n; ii++) {
						cc_add[ii] = (cc_add[ii] == 0.0 ? eps : cc_add[ii] * 10.0);
					}
				}
					break;

				case GMRFLib_SUCCESS:
				{
					ok = 1;
				}
					break;

				default:
					/*
					 * some other error 
					 */
					GMRFLib_set_error_handler(old_handler);
					abort();
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			Free(cc_add);
			GMRFLib_set_error_handler(old_handler);

			GMRFLib_evaluate(problem);
			val += mb->f_nrep[i] * (problem->sub_logdens * (ngroup - grankdef) + normc_g);

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &H_intern);
			}
			GMRFLib_free_problem(problem);
		}
			break;

		case F_FGN2:
		{
			double H_intern;

			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				H_intern = theta[count];
				count++;
			} else {
				H_intern = mb->f_theta[i][1][thread_id][0];
			}
			_SET_GROUP_RHO(2);

			inla_fgn2_arg_tp *arg = (inla_fgn2_arg_tp *) mb->f_Qfunc_arg_orig[i];

			arg->log_prec[thread_id][0] = log_precision;
			arg->H_intern[thread_id][0] = H_intern;

			int n = mb->f_graph_orig[i]->n;

			/*
			 * do a check for numerical not pos def matrix here, as it may be close to being singular 
			 */
			GMRFLib_problem_tp *problem = NULL;
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
			double *cc_add = Calloc(n, double);

			if (mb->f_diag[i]) {
				int ii;
				for (ii = 0; ii < n; ii++) {
					cc_add[ii] = mb->f_diag[i];
				}
			}

			while (!ok) {
				retval =
				    GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL, mb->f_graph_orig[i],
							 mb->f_Qfunc_orig[i], mb->f_Qfunc_arg_orig[i], mb->f_constr_orig[i]);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					int ii;
					double eps = GMRFLib_eps(0.5);

					for (ii = 0; ii < arg->n; ii++) {
						cc_add[ii] = (cc_add[ii] == 0.0 ? eps : cc_add[ii] * 10.0);
					}
					break;
				}

				case GMRFLib_SUCCESS:
					ok = 1;
					break;

				default:
					/*
					 * some other error 
					 */
					GMRFLib_set_error_handler(old_handler);
					abort();
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			Free(cc_add);
			GMRFLib_set_error_handler(old_handler);

			GMRFLib_evaluate(problem);
			val += mb->f_nrep[i] * (problem->sub_logdens * (ngroup - grankdef) + normc_g);

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &H_intern);
			}
			GMRFLib_free_problem(problem);
		}
			break;

		case F_Z:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			_SET_GROUP_RHO(1);

			inla_z_arg_tp *arg = (inla_z_arg_tp *) mb->f_Qfunc_arg_orig[i];
			arg->log_prec[thread_id][0] = log_precision;

			GMRFLib_problem_tp *problem = NULL;
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
			double *cc_add = Calloc(arg->n + arg->m, double);

			assert(mb->f_graph_orig[i]->n == arg->n + arg->m);

			if (mb->f_diag[i]) {
				int ii;
				for (ii = 0; ii < arg->n + arg->m; ii++) {
					cc_add[ii] = mb->f_diag[i];
				}
			}

			while (!ok) {
				retval =
				    GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL, mb->f_graph_orig[i],
							 mb->f_Qfunc_orig[i], mb->f_Qfunc_arg_orig[i], mb->f_constr_orig[i]);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					int ii;
					double eps = GMRFLib_eps(0.5);

					/*
					 * only need to add for the z-part; the last m components.
					 */
					for (ii = arg->n; ii < arg->n + arg->m; ii++) {
						cc_add[ii] = (cc_add[ii] == 0.0 ? eps : cc_add[ii] * 10.0);
					}
					break;
				}

				case GMRFLib_SUCCESS:
					ok = 1;
					break;

				default:
					/*
					 * some other error 
					 */
					GMRFLib_set_error_handler(old_handler);
					abort();
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			Free(cc_add);
			GMRFLib_set_error_handler(old_handler);

			GMRFLib_evaluate(problem);
			val += mb->f_nrep[i] * (problem->sub_logdens * (ngroup - grankdef) + normc_g);

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}

			GMRFLib_free_problem(problem);
		}
			break;

		case F_GENERIC3:
		{
			int k, kk;
			inla_generic3_tp *a;

			a = Calloc(1, inla_generic3_tp);
			Memcpy((void *) a, (void *) mb->f_Qfunc_arg_orig[i], sizeof(inla_generic3_tp));
			a->log_prec = Calloc(GENERIC3_MAXTHETA, double **);
			for (k = 0; k < GENERIC3_MAXTHETA; k++) {
				if (_NOT_FIXED(f_fixed[i][k])) {
					HYPER_NEW(a->log_prec[k], theta[count]);
					count++;
				} else {
					HYPER_NEW(a->log_prec[k], mb->f_theta[i][k][thread_id][0]);
				}
			}
			_SET_GROUP_RHO(GENERIC3_MAXTHETA);

			GMRFLib_problem_tp *problem = NULL;
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
			double *cc_add = Calloc(a->n, double);

			if (mb->f_diag[i]) {
				int ii;
				for (ii = 0; ii < a->n; ii++) {
					cc_add[ii] = mb->f_diag[i];
				}
			}

			while (!ok) {
				retval = GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL,
							      mb->f_graph_orig[i], mb->f_Qfunc_orig[i], (void *) a, mb->f_constr_orig[i]);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					int ii;
					double eps = GMRFLib_eps(0.5);

					/*
					 * only need to add for the z-part; the last m components.
					 */
					for (ii = 0; ii < a->n; ii++) {
						cc_add[ii] = (cc_add[ii] == 0.0 ? eps : cc_add[ii] * 10.0);
					}
					break;
				}

				case GMRFLib_SUCCESS:
					ok = 1;
					break;

				default:
					/*
					 * some other error 
					 */
					GMRFLib_set_error_handler(old_handler);
					abort();
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			Free(cc_add);
			GMRFLib_set_error_handler(old_handler);

			GMRFLib_evaluate(problem);
			val += mb->f_nrep[i] * (problem->sub_logdens * (ngroup - grankdef) + normc_g);

			for (k = 0; k < GENERIC3_MAXTHETA; k++) {
				if (_NOT_FIXED(f_fixed[i][k])) {
					log_precision = a->log_prec[k][0][0];
					val += PRIOR_EVAL(mb->f_prior[i][k], &log_precision);
				}
			}

			/*
			 * Free 'a' 
			 */
			for (k = 0; k < GENERIC3_MAXTHETA; k++) {
				for (kk = 0; kk < GMRFLib_MAX_THREADS(); kk++) {
					Free(a->log_prec[k][kk]);
				}
				Free(a->log_prec[k]);
			}
			Free(a->log_prec);
			Free(a);
			GMRFLib_free_problem(problem);
		}
			break;

		case F_SLM:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				logit_rho = theta[count];
				count++;
			} else {
				logit_rho = mb->f_theta[i][1][thread_id][0];
			}
			_SET_GROUP_RHO(2);

			inla_slm_arg_tp *arg = (inla_slm_arg_tp *) mb->f_Qfunc_arg_orig[i];
			arg->log_prec[thread_id][0] = log_precision;
			arg->logit_rho[thread_id][0] = logit_rho;

			GMRFLib_problem_tp *problem = NULL;
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
			double *cc_add = Calloc(arg->n + arg->m, double);

			assert(mb->f_graph_orig[i]->n == arg->n + arg->m);

			if (mb->f_diag[i]) {
				int ii;
				for (ii = 0; ii < arg->n + arg->m; ii++) {
					cc_add[ii] = mb->f_diag[i];
				}
			}

			while (!ok) {
				retval = GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL,
							      mb->f_graph_orig[i],
							      mb->f_Qfunc_orig[i], mb->f_Qfunc_arg_orig[i], mb->f_constr_orig[i]);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					int ii;
					double eps = GMRFLib_eps(0.5);
					for (ii = 0; ii < mb->f_graph_orig[i]->n; ii++) {
						cc_add[ii] = (cc_add[ii] == 0.0 ? eps : cc_add[ii] * 10.0);
					}
					break;
				}

				case GMRFLib_SUCCESS:
					ok = 1;
					break;

				default:
					/*
					 * some other error 
					 */
					GMRFLib_set_error_handler(old_handler);
					abort();
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			Free(cc_add);
			GMRFLib_set_error_handler(old_handler);

			GMRFLib_evaluate(problem);
			val += mb->f_nrep[i] * (problem->sub_logdens * (ngroup - grankdef) + normc_g);

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &logit_rho);
			}
			GMRFLib_free_problem(problem);
		}
			break;

		case F_MEC:
		{
			double mean_x, log_precision_x, log_precision_obs, beta_intern;

			if (_NOT_FIXED(f_fixed[i][0])) {
				beta_intern = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][0], &beta_intern);
				count++;
			} else {
				beta_intern = mb->f_theta[i][0][thread_id][0];
			}
			beta = mb->f_theta_map[i][0] (beta_intern, MAP_FORWARD, mb->f_theta_map_arg[i][0]);

			if (_NOT_FIXED(f_fixed[i][1])) {
				log_precision_obs = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][1], &log_precision_obs);
				count++;
			} else {
				log_precision_obs = mb->f_theta[i][1][thread_id][0];
			}

			if (_NOT_FIXED(f_fixed[i][2])) {
				mean_x = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][2], &mean_x);
				count++;
			} else {
				mean_x = mb->f_theta[i][2][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][3])) {
				log_precision_x = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][3], &log_precision_x);
				count++;
			} else {
				log_precision_x = mb->f_theta[i][3][thread_id][0];
			}

			_SET_GROUP_RHO(4);

			double AA = 0.0, BB = 0.0, CC = 0.0;
			int ii, nii = mb->f_N[i] / mb->f_ngroup[i];

			/*
			 * we need to do it like this as the scale[i] varies with 'i'.
			 */
			assert(mb->f_scale[i]);
			for (ii = 0; ii < nii; ii++) {
				AA += log((exp(log_precision_obs) * mb->f_scale[i][ii] + exp(log_precision_x)) / SQR(beta));
				BB += log(1.0 / (1.0 / (mb->f_scale[i][ii] * exp(log_precision_obs)) + 1.0 / exp(log_precision_x)));
				CC += SQR(mb->f_locations[i][ii] - mean_x) *
				    (1.0 / (1.0 / (mb->f_scale[i][ii] * exp(log_precision_obs)) + 1.0 / exp(log_precision_x)));
			}
			val += mb->f_nrep[i] * (normc_g + gcorr * (2.0 * LOG_NORMC_GAUSSIAN * (mb->f_N[i] - mb->f_rankdef[i])
								   + mb->f_ngroup[i] * 0.5 * (AA + BB)
								   /*
								    * and the exponent which depends on the precisions. we need to correct with ngroup here as its
								    * not scaled with f_N that already is corrected for ngroup.
								    */
								   - mb->f_ngroup[i] * 0.5 * CC));
		}
			break;

		case F_MEB:
		{
			double beta_intern;

			if (_NOT_FIXED(f_fixed[i][0])) {
				beta_intern = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][0], &beta_intern);
				count++;
			} else {
				beta_intern = mb->f_theta[i][0][thread_id][0];
			}
			beta = mb->f_theta_map[i][0] (beta_intern, MAP_FORWARD, mb->f_theta_map_arg[i][0]);

			if (_NOT_FIXED(f_fixed[i][1])) {
				log_precision = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][1], &log_precision);
				count++;
			} else {
				log_precision = mb->f_theta[i][1][thread_id][0];
			}

			_SET_GROUP_RHO(2);

			double scale_correction = 0.0;
			int ii, nii = mb->f_N[i] / mb->f_ngroup[i];

			/*
			 * we need to do it like this as the scale[i] varies with 'i'.
			 */
			if (mb->f_scale[i]) {
				for (ii = 0; ii < nii; ii++) {
					scale_correction += log(mb->f_scale[i][ii]);
				}
				scale_correction /= nii;
			}
			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (mb->f_N[i] - mb->f_rankdef[i]) +
								   (mb->f_N[i] - mb->f_rankdef[i]) / 2.0 * (log_precision +
													    scale_correction - log(SQR(beta)))));
		}
			break;

		case F_R_GENERIC:
		{
			int n_out, nn_out, ii, ntheta, all_fixed = 0;

			double *x_out = NULL, *xx_out = NULL, *param = NULL, log_norm_const = 0.0, log_prior = 0.0;
			inla_rgeneric_tp *def = NULL;
			def = (inla_rgeneric_tp *) mb->f_Qfunc_arg_orig[i];

			ntheta = def->ntheta;
			if (ntheta) {
				all_fixed = 1;
				param = Calloc(ntheta, double);
				for (ii = 0; ii < ntheta; ii++) {
					if (_NOT_FIXED(f_fixed[i][ii])) {
						param[ii] = theta[count];
						all_fixed = 0;
						count++;
					} else {
						param[ii] = mb->f_theta[i][ii][thread_id][0];
					}
				}
			}

#pragma omp critical (Name_58ab1229a36b0d20f9c714d7896ab4820282193b)
			{
				inla_R_rgeneric(&n_out, &x_out, R_GENERIC_LOG_NORM_CONST, def->model, &ntheta, param);
				inla_R_rgeneric(&nn_out, &xx_out, R_GENERIC_LOG_PRIOR, def->model, &ntheta, param);
			}

			switch (nn_out) {
			case 0:
				log_prior = 0.0;
				break;
			case 1:
				// we need to add a check for 'all_fixed' here, as with control.mode=list(...,fixed=TRUE) will
				// trigger all_fixed=1.
				log_prior = (evaluate_hyper_prior && !all_fixed ? xx_out[0] : 0.0);
				break;
			default:
				assert(0 == 1);
			}
			if (nn_out) {
				Free(xx_out);
			}

			switch (n_out) {
			case 0:
			{
				/*
				 * if it is the standard norm.const, the user can request us to compute it here if numeric(0) is
				 * returned from R_rgeneric.
				 */
				int *ilist = NULL, *jlist = NULL, n, len, k = 0, jj;
				double *Qijlist = NULL;
				GMRFLib_tabulate_Qfunc_tp *Qf = NULL;
#pragma omp critical (Name_94438d8a0faa6fe9957180657829e121c750f1f2)
				{
					inla_R_rgeneric(&nn_out, &xx_out, R_GENERIC_Q, def->model, &ntheta, param);
				}
				assert(nn_out >= 2);

				if ((int) xx_out[0] == -1) {
					// optimized output
					k = 1;
					len = (int) xx_out[k++];
					assert(len == def->len_list);
					assert(def->graph);
					assert(def->ilist);
					assert(def->jlist);
					n = def->graph->n;
					GMRFLib_tabulate_Qfunc_from_list2(&Qf, def->graph, def->len_list, def->ilist, def->jlist, &(xx_out[k]),
									  def->graph->n, NULL);
				} else {
					n = (int) xx_out[k++];
					len = (int) xx_out[k++];
					ilist = (int *) &xx_out[k];
					jlist = (int *) &xx_out[k + len];
					Qijlist = &xx_out[k + 2 * len];
					for (jj = 0; jj < len; jj++) {
						ilist[jj] = (int) xx_out[k + jj];
						jlist[jj] = (int) xx_out[k + len + jj];
					}
					GMRFLib_tabulate_Qfunc_from_list2(&Qf, def->graph, len, ilist, jlist, Qijlist, n, NULL);
				}

				int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
				GMRFLib_problem_tp *problem = NULL;
				GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
				double *cc_add = Calloc(n, double);

				if (mb->f_diag[i]) {
					for (jj = 0; jj < n; jj++) {
						cc_add[jj] = mb->f_diag[i];
					}
				}

				while (!ok) {
					retval = GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL,
								      def->graph, Qf->Qfunc, Qf->Qfunc_arg, mb->f_constr_orig[i]);
					switch (retval) {
					case GMRFLib_EPOSDEF:
					{
						double eps = GMRFLib_eps(0.5);
						for (jj = 0; jj < n; jj++) {
							cc_add[jj] = (cc_add[jj] == 0.0 ? eps : cc_add[jj] * 10.0);
						}
						break;
					}

					case GMRFLib_SUCCESS:
						ok = 1;
						break;

					default:
						/*
						 * some other error 
						 */
						GMRFLib_set_error_handler(old_handler);
						assert(0 == 1);
						abort();
					}

					if (++num_try >= num_try_max) {
						FIXME("This should not happen. Contact developers...");
						abort();
					}
				}
				Free(cc_add);
				GMRFLib_set_error_handler(old_handler);
				GMRFLib_evaluate(problem);
				log_norm_const = problem->sub_logdens;

				GMRFLib_free_problem(problem);
				GMRFLib_free_tabulate_Qfunc(Qf);
				Free(xx_out);
			}
				break;

			case 1:
			{
				log_norm_const = x_out[0];
				break;
			}

			default:
				assert(0 == 1);
			}

			if (debug) {
				for (ii = 0; ii < ntheta; ii++) {
					printf("p %.12g ", param[ii]);
				}
				printf(" %.12g  prior %.12g\n", log_norm_const, log_prior);
			}

			_SET_GROUP_RHO(ntheta);
			val += mb->f_nrep[i] * (normc_g + log_norm_const * (mb->f_ngroup[i] - grankdef)) + log_prior;

			Free(param);
			if (n_out) {
				Free(x_out);
			}
		}
			break;

		case F_C_GENERIC:
		{
			int n_out, nn_out, ii, ntheta, all_fixed = 0;

			double *x_out = NULL, *xx_out = NULL, *param = NULL, log_norm_const = 0.0, log_prior = 0.0;
			inla_cgeneric_tp *def = NULL;
			def = (inla_cgeneric_tp *) mb->f_Qfunc_arg_orig[i];

			ntheta = def->ntheta;
			if (ntheta) {
				all_fixed = 1;
				param = Calloc(ntheta, double);
				for (ii = 0; ii < ntheta; ii++) {
					if (_NOT_FIXED(f_fixed[i][ii])) {
						param[ii] = theta[count];
						all_fixed = 0;
						count++;
					} else {
						param[ii] = mb->f_theta[i][ii][thread_id][0];
					}
				}
			}

			x_out = def->model_func(INLA_CGENERIC_LOG_NORM_CONST, param, def->data);
			if (def->debug) {
				inla_cgeneric_debug(stdout, def->secname, INLA_CGENERIC_LOG_NORM_CONST, x_out);
			}

			xx_out = def->model_func(INLA_CGENERIC_LOG_PRIOR, param, def->data);
			if (def->debug) {
				inla_cgeneric_debug(stdout, def->secname, INLA_CGENERIC_LOG_PRIOR, xx_out);
			}

			nn_out = (xx_out ? 1 : 0);
			switch (nn_out) {
			case 0:
			{
				log_prior = 0.0;
			}
				break;
			case 1:
			{
				// we need to add a check for 'all_fixed' here, as with control.mode=list(...,fixed=TRUE) will
				// trigger all_fixed=1.
				log_prior = (evaluate_hyper_prior && !all_fixed ? xx_out[0] : 0.0);
			}
				break;
			default:
				assert(0 == 1);
			}
			Free(xx_out);

			n_out = (x_out ? 1 : 0);
			switch (n_out) {
			case 0:
			{
				/*
				 * if it is the standard norm.const, the user can request us to compute it here if NULL is returned
				 */
				int *ilist = NULL, *jlist = NULL, n, len, k = 0, jj;
				double *Qijlist = NULL;
				GMRFLib_tabulate_Qfunc_tp *Qf = NULL;
				xx_out = def->model_func(INLA_CGENERIC_Q, param, def->data);
				if (def->debug) {
					inla_cgeneric_debug(stdout, def->secname, INLA_CGENERIC_Q, xx_out);
				}

				if ((int) xx_out[0] == -1) {
					// optimized output
					k = 1;
					len = (int) xx_out[k++];
					assert(len == def->len_list);
					assert(def->graph);
					assert(def->ilist);
					assert(def->jlist);
					n = def->graph->n;
					GMRFLib_tabulate_Qfunc_from_list2(&Qf, def->graph, def->len_list, def->ilist, def->jlist, &(xx_out[k]),
									  def->graph->n, NULL);
				} else {
					n = (int) xx_out[k++];
					len = (int) xx_out[k++];
					ilist = (int *) &xx_out[k];
					jlist = (int *) &xx_out[k + len];
					Qijlist = &xx_out[k + 2 * len];
					for (jj = 0; jj < len; jj++) {
						ilist[jj] = (int) xx_out[k + jj];
						jlist[jj] = (int) xx_out[k + len + jj];
					}
					GMRFLib_tabulate_Qfunc_from_list2(&Qf, def->graph, len, ilist, jlist, Qijlist, n, NULL);
				}

				int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
				GMRFLib_problem_tp *problem = NULL;
				GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();
				double *cc_add = Calloc(n, double);

				if (mb->f_diag[i]) {
					for (jj = 0; jj < n; jj++) {
						cc_add[jj] = mb->f_diag[i];
					}
				}

				while (!ok) {
					retval = GMRFLib_init_problem(thread_id, &problem, NULL, NULL, cc_add, NULL,
								      def->graph, Qf->Qfunc, Qf->Qfunc_arg, mb->f_constr_orig[i]);
					switch (retval) {
					case GMRFLib_EPOSDEF:
					{
						double eps = GMRFLib_eps(0.5);
						for (jj = 0; jj < n; jj++) {
							cc_add[jj] = (cc_add[jj] == 0.0 ? eps : cc_add[jj] * 10.0);
						}
						break;
					}

					case GMRFLib_SUCCESS:
						ok = 1;
						break;

					default:
						/*
						 * some other error 
						 */
						GMRFLib_set_error_handler(old_handler);
						assert(0 == 1);
						abort();
					}

					if (++num_try >= num_try_max) {
						FIXME("This should not happen. Contact developers...");
						abort();
					}
				}
				Free(cc_add);
				GMRFLib_set_error_handler(old_handler);
				GMRFLib_evaluate(problem);
				log_norm_const = problem->sub_logdens;

				GMRFLib_free_problem(problem);
				GMRFLib_free_tabulate_Qfunc(Qf);
				Free(xx_out);
			}
				break;

			case 1:
			{
				log_norm_const = x_out[0];
			}
				break;

			default:
				assert(0 == 1);
			}

			if (debug) {
				for (ii = 0; ii < ntheta; ii++) {
					printf("p %.12g ", param[ii]);
				}
				printf(" %.12g  prior %.12g\n", log_norm_const, log_prior);
			}

			_SET_GROUP_RHO(ntheta);
			val += mb->f_nrep[i] * (normc_g + log_norm_const * (mb->f_ngroup[i] - grankdef)) + log_prior;

			Free(param);
			Free(x_out);
		}
			break;

		case F_AR1:
		{
			double mean_x;

			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}

			if (_NOT_FIXED(f_fixed[i][1])) {
				phi_intern = theta[count];
				count++;
			} else {
				phi_intern = mb->f_theta[i][1][thread_id][0];
			}

			if (_NOT_FIXED(f_fixed[i][2])) {
				mean_x = theta[count];
				count++;
			} else {
				mean_x = mb->f_theta[i][2][thread_id][0];
			}

			phi = map_phi(phi_intern, MAP_FORWARD, NULL);
			_SET_GROUP_RHO(3);

			double log_precision_noise = log_precision - LOG_ONE_MINUS(SQR(phi));

			if (mb->f_cyclic[i]) {
				logdet = inla_ar1_cyclic_logdet(N_orig, phi);
				val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (mb->f_N[i] - mb->f_rankdef[i])
									   + (mb->f_N[i] -
									      mb->f_rankdef[i]) / 2.0 * log_precision_noise +
									   ngroup * 0.5 * logdet));
			} else {
				val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (mb->f_N[i] - mb->f_rankdef[i])
									   + (mb->f_N[i] -
									      mb->f_rankdef[i]) / 2.0 * log_precision_noise +
									   ngroup * 0.5 * LOG_ONE_MINUS(SQR(phi))));
			}
			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &phi_intern);
			}
			if (_NOT_FIXED(f_fixed[i][2])) {
				val += PRIOR_EVAL(mb->f_prior[i][2], &mean_x);
			}
		}
			break;

		case F_AR1C:
		{
			inla_ar1c_arg_tp *a = (inla_ar1c_arg_tp *) mb->f_Qfunc_arg_orig[i];

			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}

			if (_NOT_FIXED(f_fixed[i][1])) {
				phi_intern = theta[count];
				count++;
			} else {
				phi_intern = mb->f_theta[i][1][thread_id][0];
			}

			phi = map_phi(phi_intern, MAP_FORWARD, NULL);
			_SET_GROUP_RHO(2);

			double log_precision_noise = log_precision - LOG_ONE_MINUS(SQR(phi));
			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (mb->f_N[i] - mb->f_rankdef[i])
								   + ((mb->f_N[i] - a->m * ngroup) -
								      mb->f_rankdef[i]) / 2.0 * log_precision_noise +
								   ngroup * 0.5 * LOG_ONE_MINUS(SQR(phi))
								   + ngroup * 0.5 * a->logdet_Qbeta));
			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &phi_intern);
			}
		}
			break;

		case F_OU:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				phi_intern = theta[count];
				count++;
			} else {
				phi_intern = mb->f_theta[i][1][thread_id][0];
			}
			phi = map_exp(phi_intern, MAP_FORWARD, NULL);
			_SET_GROUP_RHO(2);

			int ii;
			double ou_nc = 0.0;
			int nn = ((inla_ou_arg_tp *) mb->f_Qfunc_arg_orig[i])->n;
			for (ii = 1; ii < nn; ii++) {
				ou_nc -= LOG_ONE_MINUS(exp(-2.0 * phi * (mb->f_locations[i][ii] - mb->f_locations[i][ii - 1])));
			}
			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (mb->f_N[i] - mb->f_rankdef[i])
								   + (mb->f_N[i] - mb->f_rankdef[i]) / 2.0 * log_precision + ngroup * ou_nc / 2.0));

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &phi_intern);
			}
		}
			break;

		case F_BESAG2:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				// a_intern= log(a)
				a_intern = theta[count];
				count++;
			} else {
				a_intern = mb->f_theta[i][1][thread_id][0];
			}
			_SET_GROUP_RHO(2);
			// N is 2*graph->n here. 
			// Add the high precision contribution? 
			double high_precision = mb->f_precision[i];
			double n = mb->f_N[i] / 2.0;

			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (2.0 * (n - mb->f_rankdef[i]))
								   + (n - mb->f_rankdef[i]) / 2.0 * log(high_precision)
								   + (n - mb->f_rankdef[i]) / 2.0 * (log_precision - 2.0 * a_intern)));
			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &a_intern);
			}
		}
			break;

		case F_BYM:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {       /* iid */
				log_precision0 = theta[count];
				count++;
			} else {
				log_precision0 = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {       /* spatial */
				log_precision1 = theta[count];
				count++;
			} else {
				log_precision1 = mb->f_theta[i][1][thread_id][0];
			}
			_SET_GROUP_RHO(2);

			double n = (double) mb->f_n[i];
			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (n / 2.0 + (n - mb->f_rankdef[i]) / 2.0)
								   + n / 2.0 * log_precision0	/* iid */
								   + (n - mb->f_rankdef[i]) / 2.0 * log_precision1));	/* spatial */
			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision0);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &log_precision1);
			}
		}
			break;

		case F_RW2DIID:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				phi_intern = theta[count];
				count++;
			} else {
				phi_intern = mb->f_theta[i][1][thread_id][0];
			}
			_SET_GROUP_RHO(2);

			double n = (double) mb->f_n[i];
			double phi = map_probability(phi_intern, MAP_FORWARD, NULL);

			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * n + n / 2.0 * (log_precision - LOG_ONE_MINUS(phi))));

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &phi_intern);
			}
		}
			break;

		case F_BYM2:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				phi_intern = theta[count];
				count++;
			} else {
				phi_intern = mb->f_theta[i][1][thread_id][0];
			}
			_SET_GROUP_RHO(2);

			double n = (double) mb->f_n[i];
			double phi = map_probability(phi_intern, MAP_FORWARD, NULL);

			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * n + n / 2.0 * (log_precision - LOG_ONE_MINUS(phi))));

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &phi_intern);
			}
		}
			break;

		case F_2DIID:
		{
			if (mb->f_ngroup[i] > 1) {
				fprintf(stderr, "\n\n F_2DIID is not yet prepared for ngroup > 1\n");
				exit(EXIT_FAILURE);
			}

			assert(mb->f_ntheta[i] == 3);	       /* yes */
			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision0 = theta[count];
				count++;
			} else {
				log_precision0 = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				log_precision1 = theta[count];
				count++;
			} else {
				log_precision1 = mb->f_theta[i][1][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][2])) {
				rho_intern = theta[count];
				count++;
			} else {
				rho_intern = mb->f_theta[i][2][thread_id][0];
			}
			rho = map_rho(rho_intern, MAP_FORWARD, NULL);
			double n = (double) mb->f_n[i];
			assert(mb->f_ngroup[i] == 1);
			val += mb->f_nrep[i] * (LOG_NORMC_GAUSSIAN * 2.0 * (n - mb->f_rankdef[i])	/* yes, the total length is * N=2n */
						+(n - mb->f_rankdef[i]) / 2.0 * log_precision0	/* and there is n-pairs... */
						+ (n - mb->f_rankdef[i]) / 2.0 * log_precision1 - (n -
												   mb->f_rankdef[i]) / 2.0 *
						LOG_ONE_MINUS(SQR(rho)));
			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision0);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &log_precision1);
			}
			if (_NOT_FIXED(f_fixed[i][2])) {
				val += PRIOR_EVAL(mb->f_prior[i][2], &rho_intern);
			}
		}
			break;

		case F_IID1D:
		case F_IID2D:
		case F_IID3D:
		case F_IID4D:
		case F_IID5D:
		{
			int jj, count_ref = count;
			int dim = WISHART_DIM(i);
			assert(dim > 0);

			int nt = inla_iid_wishart_nparam(dim);
			double log_jacobian = 0.0;
			double *theta_vec = Calloc(nt, double);
			int k = 0;
			nfixed = 0;
			for (j = 0; j < dim; j++) {
				if (_NOT_FIXED(f_fixed[i][k])) {
					theta_vec[k] = theta[count];
					count++;
				} else {
					nfixed++;
					theta_vec[k] = mb->f_theta[i][k][thread_id][0];
				}
				log_jacobian += log(map_precision(theta_vec[k], MAP_DFORWARD, NULL));
				theta_vec[k] = map_precision(theta_vec[k], MAP_FORWARD, NULL);
				k++;
			}

			for (j = 0; j < dim; j++) {
				for (jj = j + 1; jj < dim; jj++) {
					if (_NOT_FIXED(f_fixed[i][k])) {
						theta_vec[k] = theta[count];
						count++;
					} else {
						nfixed++;
						theta_vec[k] = mb->f_theta[i][k][thread_id][0];
					}
					log_jacobian += log(map_rho(theta_vec[k], MAP_DFORWARD, NULL));
					theta_vec[k] = map_rho(theta_vec[k], MAP_FORWARD, NULL);
					k++;
				}
			}
			assert(k == nt);

			fail = inla_iid_wishart_adjust(dim, theta_vec);
			Q = gsl_matrix_calloc(dim, dim);
			k = 0;
			for (j = 0; j < dim; j++) {
				gsl_matrix_set(Q, j, j, 1.0 / theta_vec[k]);
				k++;
			}
			for (j = 0; j < dim; j++) {
				for (jj = j + 1; jj < dim; jj++) {
					double value = theta_vec[k] / sqrt(theta_vec[j] * theta_vec[jj]);
					gsl_matrix_set(Q, j, jj, value);
					gsl_matrix_set(Q, jj, j, value);
					k++;
				}
			}
			assert(k == nt);

			GMRFLib_gsl_spd_inverse(Q);
			logdet = GMRFLib_gsl_spd_logdet(Q);
			gsl_matrix_free(Q);

			_SET_GROUP_RHO(nt);

			/*
			 * n is the small length. yes, the total length is N=dim*n
			 */
			double n = (double) (mb->f_n[i] / dim);	/* YES! */
			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * dim * (n - mb->f_rankdef[i])
								   + (n - mb->f_rankdef[i]) / 2.0 * logdet));
			if (fail) {
				val += PENALTY;
			}

			/*
			 * if all parameters are fixed, there is no prior to add
			 */
			if (count - count_ref > 0) {
				if (nfixed) {
					static char first = 1;
					if (first) {
						fprintf(stderr,
							"\n\n\nWARNING: Wishart prior is not corrected to account for %d fixed hyperparameters.\n\n",
							nfixed);
						first = 0;
					}
				}
				/*
				 * prior density wrt theta. Include here the Jacobian from going from (precision0, precision1, rho), to theta = (log_precision0,
				 * log_precision1, rho_intern). 
				 */
				val += PRIOR_EVAL(mb->f_prior[i][0], theta_vec) + log_jacobian;
			}
		}
			break;

		case F_IIDKD:
		{
			int dim = mb->f_order[i];
			assert(dim > 1);
			int nt = INLA_WISHARTK_NTHETA(dim);
			double *theta_vec = Calloc(nt, double);

			nfixed = 0;
			for (j = 0; j < nt; j++) {
				if (_NOT_FIXED(f_fixed[i][j])) {
					theta_vec[j] = theta[count];
					count++;
				} else {
					nfixed++;
					theta_vec[j] = mb->f_theta[i][j][thread_id][0];
				}
			}
			L = gsl_matrix_calloc(dim, dim);
			Q = gsl_matrix_calloc(dim, dim);
			inla_wishartk_build_Q(dim, theta_vec, Q, L);
			logdet = GMRFLib_gsl_spd_logdet(Q);
			gsl_matrix_free(Q);
			gsl_matrix_free(L);

			_SET_GROUP_RHO(nt);

			/*
			 * n is the small length. yes, the total length is N=dim*n
			 */
			double n = (double) (mb->f_n[i] / dim);	/* YES! */
			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * dim * (n - mb->f_rankdef[i])
								   + (n - mb->f_rankdef[i]) / 2.0 * logdet));
			val += PRIOR_EVAL(mb->f_prior[i][0], theta_vec);
		}
			break;

		case F_INTSLOPE:
		{
			// this first part is just a copy from F_IID2D
			int jj, count_ref = count;
			int dim = 2;
			assert(dim > 0);

			int nt = inla_iid_wishart_nparam(dim);
			double log_jacobian = 0.0;
			double *theta_vec = Calloc(nt, double);
			int k = 0;
			nfixed = 0;
			for (j = 0; j < dim; j++) {
				if (_NOT_FIXED(f_fixed[i][k])) {
					theta_vec[k] = theta[count];
					count++;
				} else {
					nfixed++;
					theta_vec[k] = mb->f_theta[i][k][thread_id][0];
				}
				log_jacobian += log(map_precision(theta_vec[k], MAP_DFORWARD, NULL));
				theta_vec[k] = map_precision(theta_vec[k], MAP_FORWARD, NULL);
				k++;
			}

			for (j = 0; j < dim; j++) {
				for (jj = j + 1; jj < dim; jj++) {
					if (_NOT_FIXED(f_fixed[i][k])) {
						theta_vec[k] = theta[count];
						count++;
					} else {
						nfixed++;
						theta_vec[k] = mb->f_theta[i][k][thread_id][0];
					}
					log_jacobian += log(map_rho(theta_vec[k], MAP_DFORWARD, NULL));
					theta_vec[k] = map_rho(theta_vec[k], MAP_FORWARD, NULL);
					k++;
				}
			}
			assert(k == nt);

			fail = inla_iid_wishart_adjust(dim, theta_vec);	/* should not be needed */
			Q = gsl_matrix_calloc(dim, dim);
			k = 0;
			for (j = 0; j < dim; j++) {
				gsl_matrix_set(Q, j, j, 1.0 / theta_vec[k]);
				k++;
			}
			for (j = 0; j < dim; j++) {
				for (jj = j + 1; jj < dim; jj++) {
					double value = theta_vec[k] / sqrt(theta_vec[j] * theta_vec[jj]);
					gsl_matrix_set(Q, j, jj, value);
					gsl_matrix_set(Q, jj, j, value);
					k++;
				}
			}
			GMRFLib_gsl_spd_inverse(Q);
			assert(k == nt);

			if (count - count_ref > 0) {
				if (nfixed) {
					static char first = 1;
					if (first) {
						fprintf(stderr,
							"\n\n\nWARNING: Wishart prior is not corrected to account for %d fixed hyperparameters.\n\n",
							nfixed);
						first = 0;
					}
				}
				/*
				 * prior density wrt theta. Include here the Jacobian from going from (precision0, precision1,
				 * rho), to theta = (log_precision0, log_precision1, rho_intern).
				 */
				val += PRIOR_EVAL(mb->f_prior[i][0], theta_vec) + log_jacobian;
			}

			Free(theta_vec);

			for (j = 0; j < INTSLOPE_MAXTHETA; j++) {
				if (_NOT_FIXED(f_fixed[i][k + j])) {
					double gam = theta[count];
					count++;
					nt++;
					val += PRIOR_EVAL(mb->f_prior[i][k + j], &gam);
				}
			}
			_SET_GROUP_RHO(mb->f_ntheta[i]);

			inla_intslope_arg_tp *arg = (inla_intslope_arg_tp *) mb->f_Qfunc_arg_orig[i];
			int ngroup = mb->f_ngroup[i];

			assert(mb->f_rankdef[i] == 0);	       /* as this does not make sense if its not 0 */

			logdet = GMRFLib_gsl_spd_logdet(Q) * arg->nsubject + log(arg->precision) * arg->n;
			val += mb->f_nrep[i] * (normc_g + gcorr * ngroup * (LOG_NORMC_GAUSSIAN * arg->N + 0.5 * logdet));
			gsl_matrix_free(Q);
			if (fail) {
				val += PENALTY;
			}
		}
			break;

		case F_MATERN2D:
		{
			/*
			 * this is the safe version, which also works correctly for diagonal > 0. It is possible to reuse the calculations for the same
			 * range and different precision, provided diagonal = 0, but care must be taken about the constraints.
			 */

			typedef struct {
				int n;
				int N;
				int ngroup;
				int nrep;
				double precision;
				double range;
				double *c;
				double rankdef1;
				GMRFLib_matern2ddef_tp *matern2ddef;
				GMRFLib_problem_tp *problem;
			} Hold_tp;

			int jj;
			Hold_tp *h = NULL;
			GMRFLib_matern2ddef_tp *q;

			h = Calloc(1, Hold_tp);

			h->nrep = mb->f_nrep[i];
			h->ngroup = mb->f_ngroup[i];
			h->n = mb->f_n[i] / h->ngroup;
			h->N = mb->f_N[i] / h->ngroup;

			assert(h->N == mb->f_graph_orig[i]->n);

			if (debug) {
				P(h->n);
				P(h->N);
				P(h->nrep);
				P(h->ngroup);
			}

			if (mb->f_diag[i]) {
				h->c = Calloc(h->N, double);
				for (jj = 0; jj < h->N; jj++) {
					h->c[jj] = mb->f_diag[i];
				}
			} else {
				h->c = NULL;
			}

			q = (GMRFLib_matern2ddef_tp *) mb->f_Qfunc_arg_orig[i];
			h->matern2ddef = Calloc(1, GMRFLib_matern2ddef_tp);
			Memcpy(h->matern2ddef, q, sizeof(GMRFLib_matern2ddef_tp));
			if (_NOT_FIXED(f_fixed[i][0])) {
				h->precision = map_precision(theta[count], MAP_FORWARD, NULL);
				val += PRIOR_EVAL(mb->f_prior[i][0], &theta[count]);
				count++;
			} else {
				h->precision = map_precision(mb->f_theta[i][0][thread_id][0], MAP_FORWARD, NULL);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				h->range = map_range(theta[count], MAP_FORWARD, NULL);
				val += PRIOR_EVAL(mb->f_prior[i][1], &theta[count]);
				count++;
			} else {
				h->range = map_range(mb->f_theta[i][1][thread_id][0], MAP_FORWARD, NULL);
			}
			HYPER_NEW(h->matern2ddef->log_prec_omp, map_precision(h->precision, MAP_BACKWARD, NULL));
			HYPER_NEW(h->matern2ddef->log_range_omp, map_precision(h->range, MAP_BACKWARD, NULL));

			_SET_GROUP_RHO(2);

			GMRFLib_init_problem(thread_id, &(h->problem), NULL, NULL, h->c, NULL, mb->f_graph_orig[i], mb->f_Qfunc_orig[i],
					     (void *) h->matern2ddef, mb->f_constr_orig[i]);
			if (debug) {
				P(h->precision);
				P(h->range);
				P(h->problem->sub_logdens);
			}
			val += h->nrep * (h->problem->sub_logdens * (ngroup - grankdef) + normc_g);

			Free(h->c);
			HYPER_FREE(h->matern2ddef->log_prec_omp);
			HYPER_FREE(h->matern2ddef->log_range_omp);
			Free(h->matern2ddef);
			GMRFLib_free_problem(h->problem);
			Free(h);
		}
			break;

		case F_DMATERN:
		{
			double log_range, log_nu, range, var, nu, prec, logdet;

			if (_NOT_FIXED(f_fixed[i][0])) {
				log_precision = theta[count];
				count++;
			} else {
				log_precision = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				log_range = theta[count];
				count++;
			} else {
				log_range = mb->f_theta[i][1][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][2])) {
				log_nu = theta[count];
				count++;
			} else {
				log_nu = mb->f_theta[i][2][thread_id][0];
			}

			dmatern_arg_tp *a = (dmatern_arg_tp *) (mb->f_Qfunc_arg_orig[i]);
			gsl_matrix *S = gsl_matrix_calloc(a->n, a->n);
			prec = map_exp(log_precision, MAP_FORWARD, NULL);
			range = map_range(log_range, MAP_FORWARD, NULL);
			nu = map_exp(log_nu, MAP_FORWARD, NULL);
			var = 1.0 / prec;

			for (int ii = 0; ii < a->n; ii++) {
				for (int jj = ii; jj < a->n; jj++) {
					double dist, val;
					dist = gsl_matrix_get(a->dist, ii, jj);
					val = var * inla_dmatern_cf(dist, range, nu);
					gsl_matrix_set(S, ii, jj, val);
					gsl_matrix_set(S, jj, ii, val);
				}
			}
			// need a '-' as we're computing the |S| instead of |Q|.
			logdet = -GMRFLib_gsl_spd_logdet(S) / a->n;	/* logdet(Q), as if a->n=1. makes its easier below */
			gsl_matrix_free(S);

			_SET_GROUP_RHO(3);
			val += mb->f_nrep[i] * (normc_g + gcorr * (LOG_NORMC_GAUSSIAN * (mb->f_N[i] - mb->f_rankdef[i]) +
								   (mb->f_N[i] - mb->f_rankdef[i]) / 2.0 * logdet));

			if (_NOT_FIXED(f_fixed[i][0])) {
				val += PRIOR_EVAL(mb->f_prior[i][0], &log_precision);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				val += PRIOR_EVAL(mb->f_prior[i][1], &log_range);
			}
			if (_NOT_FIXED(f_fixed[i][2])) {
				val += PRIOR_EVAL(mb->f_prior[i][2], &log_nu);
			}
		}
			break;

		case F_BESAGPROPER:
		{
			typedef struct {
				int n;
				int N;
				int ngroup;
				int nrep;
				double **log_prec;
				double **log_diag;
				double *c;
				double rankdef1;
				inla_besag_proper_Qfunc_arg_tp *def;
				GMRFLib_problem_tp *problem;
			} Hold_tp;
			static Hold_tp ***hhold = NULL;

			if (!hhold) {
#pragma omp critical (Name_35784cb53aa98d636cf2d0897410586e2705f61e)
				{
					if (!hhold) {
						hhold = Calloc(GMRFLib_CACHE_LEN, Hold_tp **);
					}
				}
			}
			int idx = 0;
			GMRFLib_CACHE_SET_ID(idx);

			int jj;
			Hold_tp *h = NULL, **hold = NULL;

			hold = hhold[idx];
			if (!hold) {
				hold = Calloc(mb->nf, Hold_tp *);
			}

			if (!hold[i]) {
				h = hold[i] = Calloc(1, Hold_tp);

				h->nrep = mb->f_nrep[i];
				h->ngroup = mb->f_ngroup[i];
				h->n = mb->f_n[i] / h->ngroup;
				h->N = mb->f_N[i] / h->ngroup;

				assert(h->N == mb->f_graph_orig[i]->n);

				if (debug) {
					P(h->n);
					P(h->N);
					P(h->nrep);
					P(h->ngroup);
				}

				HYPER_NEW(h->log_prec, 0.0);
				HYPER_NEW(h->log_diag, 0.0);

				if (mb->f_diag[i]) {
					h->c = Calloc(h->N, double);
					for (jj = 0; jj < h->N; jj++) {
						h->c[jj] = mb->f_diag[i];
					}
				}

				h->def = Calloc(1, inla_besag_proper_Qfunc_arg_tp);
				Memcpy(h->def, mb->f_Qfunc_arg_orig[i], sizeof(inla_besag_proper_Qfunc_arg_tp));
				h->def->log_prec = h->log_prec;
				h->def->log_diag = h->log_diag;
			} else {
				h = hold[i];
			}

			if (_NOT_FIXED(f_fixed[i][0])) {
				h->log_prec[thread_id][0] = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][0], &theta[count]);
				count++;
			} else {
				h->log_prec[thread_id][0] = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				h->log_diag[thread_id][0] = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][1], &theta[count]);
				count++;
			} else {
				h->log_diag[thread_id][0] = mb->f_theta[i][1][thread_id][0];
			}

			_SET_GROUP_RHO(2);

			GMRFLib_init_problem(thread_id, &(h->problem), NULL, NULL, h->c, NULL, mb->f_graph_orig[i], mb->f_Qfunc_orig[i],
					     (void *) h->def, mb->f_constr_orig[i]);
			if (debug) {
				P(h->log_prec[thread_id][0]);
				P(h->log_diag[thread_id][0]);
				P(h->problem->sub_logdens);
			}
			val += h->nrep * (h->problem->sub_logdens * (ngroup - grankdef) + normc_g);

			GMRFLib_free_problem(h->problem);
			h->problem = NULL;
		}
			break;

		case F_BESAGPROPER2:
		{
			typedef struct {
				int n;
				int N;
				int ngroup;
				int nrep;
				double **log_prec;
				double **logit_lambda;
				double *c;
				double rankdef1;
				inla_besag_proper2_Qfunc_arg_tp *def;
				GMRFLib_problem_tp *problem;
			} Hold_tp;
			static Hold_tp ***hhold = NULL;

			if (!hhold) {
#pragma omp critical (Name_7acab2f371bbea723e9820a667f70647967dbd17)
				if (!hhold) {
					hhold = Calloc(GMRFLib_CACHE_LEN, Hold_tp **);
				}
			}
			int idx = 0;
			GMRFLib_CACHE_SET_ID(idx);

			int jj;
			Hold_tp *h = NULL, **hold = NULL;

			hold = hhold[idx];
			if (!hold) {
				hold = Calloc(mb->nf, Hold_tp *);
			}

			if (!hold[i]) {
				h = hold[i] = Calloc(1, Hold_tp);
				h->nrep = mb->f_nrep[i];
				h->ngroup = mb->f_ngroup[i];
				h->n = mb->f_n[i] / h->ngroup;
				h->N = mb->f_N[i] / h->ngroup;

				assert(h->N == mb->f_graph_orig[i]->n);

				if (debug) {
					P(h->n);
					P(h->N);
					P(h->nrep);
					P(h->ngroup);
				}

				HYPER_NEW(h->log_prec, 0.0);
				HYPER_NEW(h->logit_lambda, 0.0);

				if (mb->f_diag[i]) {
					h->c = Calloc(h->N, double);
					for (jj = 0; jj < h->N; jj++) {
						h->c[jj] = mb->f_diag[i];
					}
				}

				h->def = Calloc(1, inla_besag_proper2_Qfunc_arg_tp);
				Memcpy(h->def, mb->f_Qfunc_arg_orig[i], sizeof(inla_besag_proper2_Qfunc_arg_tp));
				h->def->log_prec = h->log_prec;
				h->def->logit_lambda = h->logit_lambda;
			} else {
				h = hold[i];
			}

			if (_NOT_FIXED(f_fixed[i][0])) {
				h->log_prec[thread_id][0] = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][0], &theta[count]);
				count++;
			} else {
				h->log_prec[thread_id][0] = mb->f_theta[i][0][thread_id][0];
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				h->logit_lambda[thread_id][0] = theta[count];
				val += PRIOR_EVAL(mb->f_prior[i][1], &theta[count]);
				count++;
			} else {
				h->logit_lambda[thread_id][0] = mb->f_theta[i][1][thread_id][0];
			}

			_SET_GROUP_RHO(2);

			GMRFLib_init_problem(thread_id, &(h->problem), NULL, NULL, h->c, NULL, mb->f_graph_orig[i], mb->f_Qfunc_orig[i],
					     (void *) h->def, mb->f_constr_orig[i]);

			val += h->nrep * (h->problem->sub_logdens * (ngroup - grankdef) + normc_g);

			GMRFLib_free_problem(h->problem);
			h->problem = NULL;
		}
			break;

		case F_COPY:
		{
			if (_NOT_FIXED(f_fixed[i][0]) && !mb->f_same_as[i]) {
				beta = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][0], &beta);
			}
			val += mb->f_Ntotal[i] * (LOG_NORMC_GAUSSIAN + 0.5 * log(mb->f_precision[i]));
		}
			break;

		case F_CLINEAR:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				beta = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][0], &beta);
			}
			val += mb->f_Ntotal[i] * (LOG_NORMC_GAUSSIAN + 0.5 * log(mb->f_precision[i]));
		}
			break;

		case F_SIGM:
		case F_REVSIGM:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				beta = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][0], &beta);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				log_halflife = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][1], &log_halflife);
			}
			if (_NOT_FIXED(f_fixed[i][2])) {
				log_shape = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][2], &log_shape);
			}
			val += mb->f_Ntotal[i] * (LOG_NORMC_GAUSSIAN + 0.5 * log(mb->f_precision[i]));
		}
			break;

		case F_LOG1EXP:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				beta = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][0], &beta);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				alpha = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][1], &alpha);
			}
			if (_NOT_FIXED(f_fixed[i][2])) {
				gama = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][2], &gama);
			}
			val += mb->f_Ntotal[i] * (LOG_NORMC_GAUSSIAN + 0.5 * log(mb->f_precision[i]));
		}
			break;

		case F_LOGDIST:
		{
			if (_NOT_FIXED(f_fixed[i][0])) {
				beta = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][0], &beta);
			}
			if (_NOT_FIXED(f_fixed[i][1])) {
				alpha1 = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][1], &alpha1);
			}
			if (_NOT_FIXED(f_fixed[i][2])) {
				alpha2 = theta[count];
				count++;
				val += PRIOR_EVAL(mb->f_prior[i][2], &alpha2);
			}
			val += mb->f_Ntotal[i] * (LOG_NORMC_GAUSSIAN + 0.5 * log(mb->f_precision[i]));
		}
			break;

		default:
		{
			P(mb->f_id[i]);
			abort();
			GMRFLib_ASSERT(0 == 1, GMRFLib_ESNH);
		}
			break;
		}
	}

	if (mb->data_sections[0].lp_scale) {
		for (int k = 0; k < INLA_LP_SCALE_MAX; k++) {
			if (mb->data_sections[0].lp_scale_in_use[k]) {
				if (_NOT_FIXED(data_sections[0].lp_scale_nfixed[k])) {
					double beta = theta[count];
					val = PRIOR_EVAL(mb->data_sections[0].lp_scale_nprior[k], &beta);
					count++;
				}
			}
		}
	}

	if (debug) {
		P(count);
		P(mb->ntheta);
		P(ntheta);
	}

	if (!(mb->fixed_mode)) {
		assert((count == mb->ntheta) && (count == ntheta));	/* check... */
	}
#undef _SET_GROUP_RHO
#undef _NOT_FIXED
	return val;
}
#pragma GCC pop_options

double inla_compute_initial_value(int idx, GMRFLib_logl_tp * loglfunc, double *x_vec, void *arg)
{
	/*
	 * solve arg min logl(x[i]) - prec * 0.5*(x[i]-mean)^2. But we have no option of what PREC is, so I set it to 10.0
	 */
	Data_section_tp *ds = (Data_section_tp *) arg;
	double prec, prec_max = 1.0E6, prec_min = 10.0, w, x, xnew, f, deriv, dderiv, arr[3], eps = 1.0E-4, steplen = 1.0E-4, mean = -OFFSET(idx);
	int niter = 0, niter_min = 25, niter_max = 100, stencil = 5;
	const int debug = 0;

	int thread_id = 0;
	x = xnew = mean;

	while (1) {
		w = (double) DMIN(niter_min, niter) / (double) niter_min;
		prec = exp(w * log(prec_min) + (1.0 - w) * log(prec_max));
		GMRFLib_2order_taylor(thread_id, &arr[0], &arr[1], &arr[2], NULL, 1.0, x, idx, x_vec, loglfunc, arg, &steplen, &stencil);
		f = arr[0] - 0.5 * prec * SQR((x - mean));
		deriv = arr[1] - prec * (x - mean);
		dderiv = DMIN(0.0, arr[2]) - prec;
		xnew = x - DMIN(0.25 + niter * 0.25, 1.0) * deriv / dderiv;
		if (debug) {
			printf("idx %d x %.4g xnew %.4g f %.4g deriv %.4g dderiv %.4g mean %.6g prec %.2g\n",
			       idx, x, xnew, f, deriv, dderiv, mean, prec);
		}
		x = xnew;

		if (niter > niter_min && ABS(deriv / dderiv) < eps) {
			break;
		}
		if (++niter > niter_max) {
			x = mean;
			break;
		}
	}

	return x;
}

double inla_compute_saturated_loglik(int thread_id, int idx, GMRFLib_logl_tp * loglfunc, double *x_vec, void *arg)
{
	inla_tp *a = (inla_tp *) arg;
	assert(loglfunc == loglikelihood_inla);
	return inla_compute_saturated_loglik_core(thread_id, idx, a->loglikelihood[idx], x_vec, a->loglikelihood_arg[idx]);
}

double inla_compute_saturated_loglik_core(int thread_id, int idx, GMRFLib_logl_tp * loglfunc, double *x_vec, void *arg)
{
	double prec_high = 1.0E6, prec_low = 1.0E-6, eps = 1.0E-4;
	double prec, x, xsol, xnew, f, deriv, dderiv, arr[3], steplen = GMRFLib_eps(0.25), w;
	int niter, niter_min = 25, niter_max = 100, stencil = 5;
	const int debug = 0;

	(void) loglfunc(thread_id, NULL, NULL, 0, 0, NULL, NULL, NULL);
	x = xnew = xsol = 0.0;
	for (niter = 0; niter < niter_max; niter++) {
		w = DMIN(1.0, (double) niter / (double) niter_min);
		prec = exp(log(prec_high) * (1.0 - w) + log(prec_low) * w);

		GMRFLib_2order_taylor(thread_id, &arr[0], &arr[1], &arr[2], NULL, 1.0, x, idx, x_vec, loglfunc, arg, &steplen, &stencil);
		f = arr[0] - 0.5 * prec * SQR(x);
		deriv = arr[1] - prec * x;
		dderiv = DMIN(0.0, arr[2]) - prec;

		xnew = x - deriv / dderiv;
		if (debug) {
			printf("ITER%1d: idx %d x %.6g xnew %.6g f %.6g deriv %.6g dderiv %.6g prec %.6g\n", niter, idx, x, xnew, f, deriv, dderiv,
			       prec);
		}
		x = xnew;

		if (niter > niter_min && ABS(deriv / dderiv) < eps) {
			xsol = x;
			break;
		}
	}

	return (xsol);
}

int inla_INLA(inla_tp * mb)
{
	double *c = NULL, *x = NULL, *b = NULL;
	int N, i, j, k, count, local_count;
	char *compute = NULL;
	GMRFLib_bfunc_tp **bfunc;

	if (mb->verbose) {
		printf("%s...\n", __GMRFLib_FuncName);
	}

	/*
	 * We need to determine the strategy if strategy is default 
	 */
	GMRFLib_density_storage_strategy_tp storage_scheme = GMRFLib_DENSITY_STORAGE_STRATEGY_HIGH;
	int ntot = mb->predictor_n + mb->predictor_m + mb->nlinear;

	for (i = 0; i < mb->nf; i++) {
		ntot += mb->f_graph[i]->n;
	}
	if (ntot < 50000) {
		storage_scheme = GMRFLib_DENSITY_STORAGE_STRATEGY_HIGH;
	} else {
		storage_scheme = GMRFLib_DENSITY_STORAGE_STRATEGY_LOW;
	}

	if (mb->strategy == GMRFLib_OPENMP_STRATEGY_DEFAULT) {
		/*
		 * to determine the strategy, count the size of the model 
		 */
		if (mb->verbose) {
			printf("\tStrategy = [DEFAULT]\n");
		}
		if (ntot < 500) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_SMALL;
		} else if (ntot < 2000) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_MEDIUM;
		} else if (ntot < 50000) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_LARGE;
		} else {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_HUGE;
		}
	}

	GMRFLib_density_storage_strategy = storage_scheme;
	GMRFLib_openmp->strategy = mb->strategy;

	if (mb->verbose) {
		printf("\tMode..................... [%s]\n", GMRFLib_MODE_NAME());
		printf("\tSparse-matrix library.... [%s]\n", mb->smtp);
		printf("\tOpenMP strategy.......... [%s]\n", GMRFLib_OPENMP_STRATEGY_NAME(GMRFLib_openmp->strategy));
		printf("\tnum.threads.............. [%1d:%1d]\n", GMRFLib_openmp->max_threads_nested[0], GMRFLib_openmp->max_threads_nested[1]);
		if (GMRFLib_openmp->adaptive) {
			printf("\tnum.threads (adaptive)... [%1d]\n", GMRFLib_PARDISO_MAX_NUM_THREADS());
		}
		printf("\tblas.num.threads......... [%1d]\n", GMRFLib_openmp->blas_num_threads);
		printf("\tDensity-strategy......... [%s]\n",
		       (GMRFLib_density_storage_strategy == GMRFLib_DENSITY_STORAGE_STRATEGY_LOW ? "Low" : "High"));
	}

	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_BUILD_MODEL, NULL, NULL);

	GMRFLib_init_hgmrfm(&(mb->hgmrfm), mb->predictor_n, mb->predictor_m,
			    mb->predictor_cross_sumzero, mb->predictor_log_prec,
			    (const char *) mb->predictor_Aext_fnm, mb->predictor_Aext_precision,
			    mb->nf, mb->f_c, mb->f_weights, mb->f_graph, mb->f_Qfunc, mb->f_Qfunc_arg, mb->f_sumzero, mb->f_constr,
			    mb->ff_Qfunc, mb->ff_Qfunc_arg, mb->nlinear, mb->linear_covariate, mb->linear_precision, mb->ai_par);
	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_OPTIMIZE, NULL, NULL);
	N = ((GMRFLib_hgmrfm_arg_tp *) mb->hgmrfm->Qfunc_arg)->N;
	if (mb->verbose) {
		printf("\tSize of graph............ [%d]\n", N);
		printf("\tNumber of constraints.... [%d]\n", (mb->hgmrfm->constr ? mb->hgmrfm->constr->nc : 0));
	}

	mb->d = Realloc(mb->d, N, double);
	Memset(&(mb->d[mb->predictor_ndata]), 0, (N - mb->predictor_ndata) * sizeof(double));
	mb->loglikelihood = Realloc(mb->loglikelihood, N, GMRFLib_logl_tp *);
	Memset(&(mb->loglikelihood[mb->predictor_ndata]), 0, (N - mb->predictor_ndata) * sizeof(GMRFLib_logl_tp *));
	mb->loglikelihood_arg = Realloc(mb->loglikelihood_arg, N, void *);
	Memset(&(mb->loglikelihood_arg[mb->predictor_ndata]), 0, (N - mb->predictor_ndata) * sizeof(void *));

	if (0) {
		for (i = 0; i < N; i++)
			printf("d[%d]=%g\n", i, mb->d[i]);
	}

	/*
	 * add the diagonal, if any 
	 */

	c = Calloc(N, double);
	count = mb->predictor_n + mb->predictor_m;
	for (i = 0; i < mb->nf; i++) {
		for (k = 0; k < mb->f_nrep[i]; k++) {
			for (j = 0; j < mb->f_n[i]; j++) {
				c[count + j + k * mb->f_N[i]] = mb->f_diag[i];	/* yes; this is correct */
			}
		}
		count += mb->f_Ntotal[i];		       /* yes; this is correct */
	}

	/*
	 * this is an emergency option to prevent singular matrices (and is known to be >= 0) 
	 */
	if (mb->expert_diagonal_emergencey) {
		for (i = mb->predictor_n + mb->predictor_m; i < N; i++)
			c[i] += mb->expert_diagonal_emergencey;
	}

	if (0) {
		for (i = 0; i < N; i++)
			printf("c[%d]=%g\n", i, c[i]);
	}

	/*
	 * mark those we want to compute and compute the b
	 */
	compute = Calloc(N, char);
	b = Calloc(N, double);
	bfunc = Calloc(N, GMRFLib_bfunc_tp *);
	count = 0;
	if (mb->expert_cpo_manual) {
		/*
		 * if set, then only then only `linear.predictor[idx]' is set
		 */
		for (i = 0; i < mb->predictor_n + mb->predictor_m; i++) {
			compute[count] = (char) 0;
			count++;
		}

		for (i = 0; i < mb->expert_n_cpo_idx; i++) {
			compute[mb->expert_cpo_idx[i]] = (char) 1;
			mb->d[mb->expert_cpo_idx[i]] = 0.0;
		}
		mb->ai_par->cpo_manual = 1;
		mb->output->hyperparameters = GMRFLib_FALSE;

		for (i = 0; i < mb->nf; i++) {
			if (mb->f_bfunc2[i]) {
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					bfunc[count + j] = Calloc(1, GMRFLib_bfunc_tp);
					bfunc[count + j]->bdef = mb->f_bfunc2[i];
					bfunc[count + j]->idx = j;
				}
			}
			for (j = 0; j < mb->f_Ntotal[i]; j++) {
				compute[count] = (char) 0;
				count++;
			}
		}

		for (i = 0; i < mb->nlinear; i++) {
			compute[count] = (char) 0;
			b[count] = mb->linear_precision[i] * mb->linear_mean[i];
			count++;
		}
		assert(count == N);
	} else {
		/*
		 * as before 
		 */
		for (i = 0; i < mb->predictor_n + mb->predictor_m; i++) {
			compute[count++] = (char) mb->predictor_compute;
		}
		for (i = 0; i < mb->nf; i++) {
			if (mb->f_bfunc2[i]) {
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					bfunc[count + j] = Calloc(1, GMRFLib_bfunc_tp);
					bfunc[count + j]->bdef = mb->f_bfunc2[i];
					bfunc[count + j]->idx = j;
				}
			}
			for (j = 0; j < mb->f_Ntotal[i]; j++) {
				compute[count] = (char) mb->f_compute[i];
				count++;
			}
		}
		for (i = 0; i < mb->nlinear; i++) {
			compute[count] = (char) mb->linear_compute[i];
			b[count] = mb->linear_precision[i] * mb->linear_mean[i];
			count++;
		}
		if (count != N) {
			P(count);
			P(N);
			assert(count == N);
		}
	}

	// VB correct 
	char *vb_nodes = NULL;

	local_count = 0;

	if (mb->ai_par->vb_enable) {
		vb_nodes = Calloc(N, char);
		count = mb->predictor_n + mb->predictor_m;
		for (i = 0; i < mb->nf; i++) {
			GMRFLib_idx_tp *vb = mb->f_vb_correct[i];
			if ((vb->idx[0] == -1L && mb->f_Ntotal[i] <= mb->ai_par->vb_f_enable_limit_mean)) {
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					vb_nodes[count + j] = (char) 1;
					local_count++;
				}
			} else if (vb->idx[i] == -1L) {
				int len, k, jj;
				len = IMAX(1, mb->f_Ntotal[i] / mb->ai_par->vb_f_enable_limit_mean);	/* integer division */
				k = IMAX(1, len / 2);	       /* integer division */
				for (j = 0; j < mb->ai_par->vb_f_enable_limit_mean; j++) {
					jj = (j * len + k) % mb->f_Ntotal[i];
					vb_nodes[count + jj] = (char) 1;
					local_count++;
				}
			} else if (vb->idx[0] >= 0) {
				for (j = 0; j < vb->n; j++) {
					vb_nodes[count + IMIN(vb->idx[j], mb->f_Ntotal[i] - 1)] = (char) 1;
					local_count++;
				}
			}
			count += mb->f_Ntotal[i];
		}

		for (i = 0; i < mb->nlinear; i++) {
			vb_nodes[count++] = (char) 1;
			local_count++;
		}
		if (local_count == 0) {			       /* then there is nothting to correct for */
			Free(vb_nodes);
			vb_nodes = NULL;
		}
	}
	mb->ai_par->vb_nodes_mean = vb_nodes;

	local_count = 0;
	if (mb->ai_par->vb_enable) {
		vb_nodes = Calloc(N, char);
		count = mb->predictor_n + mb->predictor_m;
		for (i = 0; i < mb->nf; i++) {
			GMRFLib_idx_tp *vb = mb->f_vb_correct[i];
			if ((vb->idx[0] == -1L && mb->f_Ntotal[i] <= mb->ai_par->vb_f_enable_limit_variance)) {
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					vb_nodes[count + j] = (char) 1;
					local_count++;
				}
			} else if (vb->idx[i] == -1L) {
				int len, k, jj;
				len = IMAX(1, mb->f_Ntotal[i] / mb->ai_par->vb_f_enable_limit_variance);	/* integer division */
				k = IMAX(1, len / 2);	       /* integer division */
				for (j = 0; j < mb->ai_par->vb_f_enable_limit_variance; j++) {
					jj = (j * len + k) % mb->f_Ntotal[i];
					vb_nodes[count + jj] = (char) 1;
					local_count++;
				}
			} else if (vb->idx[0] >= 0) {
				for (j = 0; j < vb->n; j++) {
					vb_nodes[count + IMIN(vb->idx[j], mb->f_Ntotal[i] - 1)] = (char) 1;
					local_count++;
				}
			}

			count += mb->f_Ntotal[i];
		}
		for (i = 0; i < mb->nlinear; i++) {
			vb_nodes[count++] = (char) 1;
			local_count++;
		}
		if (local_count == 0) {			       /* then there is nothting to correct for */
			Free(vb_nodes);
			vb_nodes = NULL;
		}
	}
	mb->ai_par->vb_nodes_variance = vb_nodes;

	// define the adaptive strategy
	GMRFLib_ai_strategy_tp *adapt = NULL;
	if (mb->ai_par->strategy == GMRFLib_AI_STRATEGY_ADAPTIVE) {
		adapt = Calloc(N, GMRFLib_ai_strategy_tp);
		for (i = 0; i < N; i++) {
			adapt[i] = GMRFLib_AI_STRATEGY_GAUSSIAN;
		}
		count = mb->predictor_n + mb->predictor_m;
		for (i = 0; i < mb->nf; i++) {
			if (mb->f_Ntotal[i] <= mb->ai_par->adapt_max) {
				/*
				 * add also random effects with small size
				 */
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					adapt[count + j] = GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN;
				}
			}
			count += mb->f_Ntotal[i];
		}
		for (i = 0; i < mb->nlinear; i++) {
			adapt[count++] = GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN;
		}
	}
	mb->ai_par->adapt_strategy = adapt;
	mb->ai_par->adapt_len = (adapt ? N : 0);

	if (G.reorder < 0) {
		size_t nnz = 0;
		int use_g = 0;
		GMRFLib_optimize_reorder(mb->hgmrfm->graph, &nnz, &use_g, &(mb->gn));
		if (GMRFLib_smtp != GMRFLib_SMTP_PARDISO) {
			// ....
		} else {
			GMRFLib_reorder = GMRFLib_REORDER_PARDISO;
		}
		if (GMRFLib_smtp != GMRFLib_SMTP_PARDISO) {
			if (mb->verbose) {
				printf("\tFound optimal reordering=[%s] nnz(L)=[%zu] and use_global_nodes(user)=[%s]\n",
				       GMRFLib_reorder_name(GMRFLib_reorder), nnz, (use_g ? "yes" : "no"));
			}
		}
	}
	if (mb->verbose) {
		if (mb->ntheta) {
			printf("\tList of hyperparameters: \n");
			for (i = 0; i < mb->ntheta; i++) {
				printf("\t\ttheta[%1d] = [%s]\n", i, mb->theta_tag[i]);
			}
		} else {
			printf("\tNone hyperparameters\n");
		}
	}
	GMRFLib_ai_store_tp *ai_store = Calloc(1, GMRFLib_ai_store_tp);

	if (mb->output->dic) {
		mb->dic = Calloc(1, GMRFLib_ai_dic_tp);
	} else {
		mb->dic = NULL;
	}
	/*
	 * compute a 'reasonable' initial value for \eta, unless its there from before.
	 */

	int mm = mb->predictor_n + mb->predictor_m;
	Free(G_norm_const_compute);
	Free(G_norm_const);
	for (int i = 0; i < G_norm_const_len; i++) {
		Free(G_norm_const_v[i]);
	}
	Free(G_norm_const_v);
	G_norm_const_len = mm;
	G_norm_const_compute = Calloc(mm, char);
	G_norm_const = Calloc(mm, double);
	G_norm_const_v = Calloc(mm, void *);
	for (int i = 0; i < mm; i++) {
		G_norm_const[i] = NAN;
		G_norm_const_compute[i] = 1;
	}

	x = Calloc(N, double);
	if (mb->reuse_mode && mb->x_file) {
		if (N != mb->nx_file) {
			char *msg;
			GMRFLib_sprintf(&msg, "N = %1d but nx_file = %1d. Stop.", N, mb->nx_file);
			inla_error_general(msg);
		}
		Memcpy(x, mb->x_file, N * sizeof(double));

		/*
		 * subtract the offset 
		 */
		for (i = 0; i < mb->predictor_ndata; i++) {
			x[i] -= OFFSET3(i);
		}

	} else {
#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
		for (int i = 0; i < mb->predictor_ndata; i++) {
			if (mb->d[i]) {
				x[i] = inla_compute_initial_value(i, mb->loglikelihood[i], x, (void *) mb->loglikelihood_arg[i]);
			} else {
				x[i] = 0.0;
			}
			// printf("initial value x[%1d] = %g\n", i, x[i]);
		}
	}

	/*
	 * set the flag to compute correlation-matrix or not 
	 */
	mb->misc_output = Calloc(1, GMRFLib_ai_misc_output_tp);
	if (mb->lc_derived_correlation_matrix) {
		mb->misc_output->compute_corr_lin = mb->nlc;   /* yes, pass the dimension */
	} else {
		mb->misc_output->compute_corr_lin = 0;
	}
	if (mb->output->config) {
		mb->misc_output->configs = Calloc(GMRFLib_MAX_THREADS(), GMRFLib_store_configs_tp *);
	} else {
		mb->misc_output->configs = NULL;
	}

	if (mb->fixed_mode) {
		/*
		 * then there is a request to treat the theta's as fixed and known. This little hack do the job nicely. 
		 */
		mb->ntheta = 0;
		mb->data_ntheta_all = 0;
		mb->theta = NULL;
	}

	mb->transform_funcs = Calloc(N, GMRFLib_transform_array_func_tp *);
	for (i = 0; i < mb->predictor_m + mb->predictor_n; i++) {
		/*
		 * only where we have data (ie n or m), can be a invlinkfunc different from the identity. also the compute-flag must be ON.
		 */
		if (!compute[i]) {
			mb->transform_funcs[i] = NULL;
		} else if (i < mb->predictor_ndata && mb->predictor_invlinkfunc[i]) {
			mb->transform_funcs[i] = Calloc(1, GMRFLib_transform_array_func_tp);
			mb->transform_funcs[i]->func = (GMRFLib_transform_func_tp *) mb->predictor_invlinkfunc[i];
			mb->transform_funcs[i]->arg = mb->predictor_invlinkfunc_arg[i];

			double *cov = NULL;
			if (mb->predictor_invlinkfunc_covariates && mb->predictor_invlinkfunc_covariates[i]) {
				int ncov = mb->predictor_invlinkfunc_covariates[i]->ncol;
				cov = Calloc(ncov, double);
				GMRFLib_matrix_get_row(cov, i, mb->predictor_invlinkfunc_covariates[i]);
			}
			mb->transform_funcs[i]->cov = cov;     /* yes, we store a copy here */
		} else {
			mb->transform_funcs[i] = Calloc(1, GMRFLib_transform_array_func_tp);
			mb->transform_funcs[i]->func = (GMRFLib_transform_func_tp *) link_identity;
			mb->transform_funcs[i]->arg = NULL;
			mb->transform_funcs[i]->cov = NULL;
		}
	}

	/*
	 * If Gaussian data, then force the strategy to be Gaussian  
	 */
	if (mb->gaussian_data) {
		mb->ai_par->strategy = GMRFLib_AI_STRATEGY_GAUSSIAN;
		mb->ai_par->gaussian_data = mb->gaussian_data;
	}

	/*
	 * Finally, let us do the job...
	 */
	GMRFLib_ai_INLA(&(mb->density),
			// DISABLE THIS FEATURE NOW, IT DOES NOT WORK WELL ENOGUH
			(0 ? &(mb->density_transform) : NULL), (0 ? mb->transform_funcs : NULL),
			// ....
			(mb->output->hyperparameters ? &(mb->density_hyper) : NULL),
			(mb->output->cpo || mb->expert_cpo_manual ? &(mb->cpo) : NULL),
			(mb->output->po ? &(mb->po) : NULL),
			mb->dic,
			(mb->output->mlik ? &(mb->mlik) : NULL),
			compute, mb->theta, mb->ntheta,
			extra, (void *) mb,
			x, b, c, NULL, bfunc, mb->d,
			loglikelihood_inla, (void *) mb,
			mb->hgmrfm->graph, mb->hgmrfm->Qfunc, mb->hgmrfm->Qfunc_arg, mb->hgmrfm->constr, mb->ai_par, ai_store,
			mb->nlc, mb->lc_lc, &(mb->density_lin), mb->misc_output, NULL, NULL);

	/*
	 * add the offsets to the linear predictor. Add the offsets to the 'configs' (if any), at a later stage. 
	 */
#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
	for (int i = 0; i < mb->predictor_n + mb->predictor_m; i++) {
		GMRFLib_density_tp *d;
		if (mb->density[i]) {
			d = mb->density[i];
			GMRFLib_density_new_mean(&(mb->density[i]), d, d->std_mean + OFFSET3(i));
			GMRFLib_free_density(d);
		}
	}

	/*
	 * add the offset to 'x' 
	 */
	for (i = 0; i < mb->predictor_n + mb->predictor_m; i++) {
		x[i] += OFFSET3(i);
	}

	Free(mb->x_file);				       /* yes, and then */
	mb->x_file = x;					       /* just take over */
	mb->nx_file = N;

	GMRFLib_free_ai_store(ai_store);
	Free(b);
	Free(c);
	Free(compute);

	return INLA_OK;
}

int inla_INLA_preopt_stage1(inla_tp * mb, GMRFLib_preopt_res_tp * rpreopt)
{
	double *c = NULL, *x = NULL, *b = NULL;
	int N, i, j, count;
	char *compute = NULL;
	GMRFLib_bfunc_tp **bfunc;
	GMRFLib_preopt_tp *preopt = NULL;

	if (mb->verbose) {
		printf("%s...\n", __GMRFLib_FuncName);
	}

	/*
	 * We need to determine the strategy if strategy is default 
	 */
	GMRFLib_density_storage_strategy_tp storage_scheme = GMRFLib_DENSITY_STORAGE_STRATEGY_HIGH;
	int ntot = 0;

	ntot = mb->nlinear;
	for (i = 0; i < mb->nf; i++) {
		ntot += mb->f_graph[i]->n;
	}
	N = ntot;

	if (mb->strategy == GMRFLib_OPENMP_STRATEGY_DEFAULT) {
		/*
		 * to determine the strategy, count the size of the model 
		 */
		if (mb->verbose) {
			printf("\tStrategy = [DEFAULT]\n");
		}
		if (ntot < 500) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_SMALL;
		} else if (ntot < 2000) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_MEDIUM;
		} else if (ntot < 50000) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_LARGE;
		} else {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_HUGE;
		}
	}

	GMRFLib_density_storage_strategy = storage_scheme;
	GMRFLib_openmp->strategy = mb->strategy;

	b = Calloc(N, double);
	bfunc = Calloc(N, GMRFLib_bfunc_tp *);
	for (count = 0, i = 0; i < mb->nf; i++) {
		if (mb->f_bfunc2[i]) {
			for (j = 0; j < mb->f_Ntotal[i]; j++) {
				bfunc[count + j] = Calloc(1, GMRFLib_bfunc_tp);
				bfunc[count + j]->bdef = mb->f_bfunc2[i];
				bfunc[count + j]->idx = j;
			}
		}
		count += mb->f_Ntotal[i];
	}

	// VB correct 
	char *vb_nodes = NULL;
	int local_count = 0;
	if (mb->ai_par->vb_enable) {
		vb_nodes = Calloc(N, char);
		count = 0;
		for (i = 0; i < mb->nf; i++) {
			GMRFLib_idx_tp *vb = mb->f_vb_correct[i];
			if ((vb->idx[0] == -1L && mb->f_Ntotal[i] <= mb->ai_par->vb_f_enable_limit_mean)) {
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					vb_nodes[count + j] = (char) 1;
					local_count++;
				}
			} else if (vb->idx[i] == -1L) {
				int len, k, jj;
				len = IMAX(1, mb->f_Ntotal[i] / mb->ai_par->vb_f_enable_limit_mean);	/* integer division */
				k = IMAX(1, len / 2);	       /* integer division */
				for (j = 0; j < mb->ai_par->vb_f_enable_limit_mean; j++) {
					jj = (j * len + k) % mb->f_Ntotal[i];
					vb_nodes[count + jj] = (char) 1;
					local_count++;
				}
			} else if (vb->idx[0] >= 0) {
				for (j = 0; j < vb->n; j++) {
					vb_nodes[count + IMIN(vb->idx[j], mb->f_Ntotal[i] - 1)] = (char) 1;
					local_count++;
				}
			}
			count += mb->f_Ntotal[i];
		}
		for (i = 0; i < mb->nlinear; i++) {
			vb_nodes[count++] = (char) 1;
			local_count++;
		}
		if (local_count == 0) {			       /* then there is nothting to correct for */
			Free(vb_nodes);
			vb_nodes = NULL;
		}
	}
	mb->ai_par->vb_nodes_mean = vb_nodes;

	double tref = GMRFLib_cpu();
	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_BUILD_MODEL, NULL, NULL);
	GMRFLib_preopt_init(&preopt,
			    mb->predictor_n, mb->nf, mb->f_c, mb->f_weights,
			    mb->f_graph, mb->f_Qfunc, mb->f_Qfunc_arg, mb->f_sumzero, mb->f_constr,
			    mb->f_diag,
			    mb->ff_Qfunc, mb->ff_Qfunc_arg,
			    mb->nlinear, mb->linear_covariate, mb->linear_precision, bfunc, mb->ai_par, mb->predictor_A_fnm);
	mb->preopt = preopt;
	assert(preopt->latent_graph->n == N);

	if (mb->verbose) {
		printf("\tMode..................... [%s]\n", GMRFLib_MODE_NAME());
		printf("\tSetup.................... [%.2fs]\n", GMRFLib_cpu() - tref);
		printf("\tSparse-matrix library.... [%s]\n", mb->smtp);
		printf("\tOpenMP strategy.......... [%s]\n", GMRFLib_OPENMP_STRATEGY_NAME(GMRFLib_openmp->strategy));
		printf("\tnum.threads.............. [%1d:%1d]\n", GMRFLib_openmp->max_threads_nested[0], GMRFLib_openmp->max_threads_nested[1]);
		if (GMRFLib_openmp->adaptive) {
			printf("\tnum.threads (adaptive)... [%1d]\n", GMRFLib_PARDISO_MAX_NUM_THREADS());
		}
		printf("\tblas.num.threads......... [%1d]\n", GMRFLib_openmp->blas_num_threads);
		printf("\tDensity-strategy......... [%s]\n",
		       (GMRFLib_density_storage_strategy == GMRFLib_DENSITY_STORAGE_STRATEGY_LOW ? "Low" : "High"));
		printf("\tSize of graph............ [%d]\n", N);
		printf("\tNumber of constraints.... [%d]\n", (preopt->latent_constr ? preopt->latent_constr->nc : 0));
	}
	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_OPTIMIZE, NULL, NULL);

	c = Calloc(N, double);
	if (mb->expert_diagonal_emergencey) {
		for (i = 0; i < N; i++)
			c[i] += mb->expert_diagonal_emergencey;
	}

	if (G.reorder < 0) {
		size_t nnz = 0;
		int use_g = 0;
		GMRFLib_optimize_reorder(preopt->latent_graph, &nnz, &use_g, &(mb->gn));
		if (GMRFLib_smtp != GMRFLib_SMTP_PARDISO) {
			// ....
		} else {
			GMRFLib_reorder = GMRFLib_REORDER_PARDISO;
		}
		if (GMRFLib_smtp != GMRFLib_SMTP_PARDISO) {
			if (mb->verbose) {
				printf("\tFound optimal reordering=[%s] nnz(L)=[%zu] and use_global_nodes(user)=[%s]\n",
				       GMRFLib_reorder_name(GMRFLib_reorder), nnz, (use_g ? "yes" : "no"));
			}
		}
	}
	/*
	 * mark those we want to compute and compute the b
	 */
	if (mb->verbose) {
		if (mb->ntheta) {
			printf("\tList of hyperparameters: \n");
			for (i = 0; i < mb->ntheta; i++) {
				printf("\t\ttheta[%1d] = [%s]\n", i, mb->theta_tag[i]);
			}
		} else {
			printf("\tNone hyperparameters\n");
		}
	}
	GMRFLib_ai_store_tp *ai_store = Calloc(1, GMRFLib_ai_store_tp);

	mb->dic = NULL;
	mb->misc_output = Calloc(1, GMRFLib_ai_misc_output_tp);
	x = Calloc(N, double);
	if (mb->reuse_mode && mb->x_file) {
		Memcpy(x, mb->x_file + preopt->mnpred, N * sizeof(double));
	}

	int nparam_eff = mb->ai_par->compute_nparam_eff;
	mb->ai_par->compute_nparam_eff = 0;
	compute = Calloc(N, char);

	Free(G_norm_const_compute);
	Free(G_norm_const);
	for (int i = 0; i < G_norm_const_len; i++) {
		Free(G_norm_const_v[i]);
	}
	Free(G_norm_const_v);
	G_norm_const_len = preopt->Npred;
	G_norm_const_compute = Calloc(preopt->Npred, char);
	G_norm_const = Calloc(preopt->Npred, double);
	G_norm_const_v = Calloc(preopt->Npred, void *);
	for (int i = 0; i < preopt->Npred; i++) {
		G_norm_const[i] = NAN;
		G_norm_const_compute[i] = 1;
	}

	GMRFLib_ai_INLA(&(mb->density),
			NULL, NULL,
			(mb->output->hyperparameters ? &(mb->density_hyper) : NULL),
			NULL,
			NULL,
			NULL,
			(mb->output->mlik ? &(mb->mlik) : NULL),
			compute, mb->theta, mb->ntheta,
			extra, (void *) mb,
			x, b, c, NULL, bfunc, mb->d,
			loglikelihood_inla, (void *) mb,
			preopt->preopt_graph, preopt->preopt_Qfunc, preopt->preopt_Qfunc_arg, preopt->latent_constr,
			mb->ai_par, ai_store, 0, NULL, NULL, mb->misc_output, preopt, rpreopt);

	if (rpreopt->int_design) {
		mb->ai_par->int_strategy = GMRFLib_AI_INT_STRATEGY_USER_EXPERT;
		GMRFLib_design_tp *design = NULL;
		GMRFLib_design_read(&design, rpreopt->int_design, 0);

		for (i = 0; i < design->nexperiments; i++) {
			design->int_weight[i] = rpreopt->adj_weights[i];
		}
		mb->ai_par->adjust_weights = 0;

		if (mb->verbose) {
			GMRFLib_design_print(stdout, design);
		}
		if (mb->verbose) {
			printf("\tPrune design: prob=0.95\n");
		}
		GMRFLib_design_prune(design, 0.95);
		if (mb->verbose) {
			GMRFLib_design_print(stdout, design);
		}
		mb->ai_par->int_design = design;
	}

	// set back
	nparam_eff = mb->ai_par->compute_nparam_eff = nparam_eff;

	GMRFLib_free_ai_store(ai_store);
	Free(x);
	Free(b);
	Free(c);
	Free(compute);
	Free(bfunc);

	return INLA_OK;
}

int inla_INLA_preopt_stage2(inla_tp * mb, GMRFLib_preopt_res_tp * rpreopt)
{
	double *c = NULL, *x = NULL, *b = NULL;
	int N, i, j, k, count, local_count;
	char *compute = NULL;
	GMRFLib_bfunc_tp **bfunc;

	if (mb->verbose) {
		printf("%s...\n", __GMRFLib_FuncName);
	}

	/*
	 * We need to determine the strategy if strategy is default 
	 */
	GMRFLib_density_storage_strategy_tp storage_scheme = GMRFLib_DENSITY_STORAGE_STRATEGY_HIGH;
	int ntot = mb->predictor_n + mb->predictor_m + mb->nlinear;

	for (i = 0; i < mb->nf; i++) {
		ntot += mb->f_graph[i]->n;
	}
	if (ntot < 50000) {
		storage_scheme = GMRFLib_DENSITY_STORAGE_STRATEGY_HIGH;
	} else {
		storage_scheme = GMRFLib_DENSITY_STORAGE_STRATEGY_LOW;
	}

	if (mb->strategy == GMRFLib_OPENMP_STRATEGY_DEFAULT) {
		/*
		 * to determine the strategy, count the size of the model 
		 */
		if (mb->verbose) {
			printf("\tStrategy = [DEFAULT]\n");
		}
		if (ntot < 500) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_SMALL;
		} else if (ntot < 2000) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_MEDIUM;
		} else if (ntot < 50000) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_LARGE;
		} else {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_HUGE;
		}
	}

	GMRFLib_density_storage_strategy = storage_scheme;
	GMRFLib_openmp->strategy = mb->strategy;

	if (mb->verbose) {
		printf("\tMode..................... [%s]\n", GMRFLib_MODE_NAME());
		printf("\tSparse-matrix library.... [%s]\n", mb->smtp);
		printf("\tOpenMP strategy.......... [%s]\n", GMRFLib_OPENMP_STRATEGY_NAME(GMRFLib_openmp->strategy));
		printf("\tnum.threads.............. [%1d:%1d]\n", GMRFLib_openmp->max_threads_nested[0], GMRFLib_openmp->max_threads_nested[1]);
		if (GMRFLib_openmp->adaptive) {
			printf("\tnum.threads (adaptive)... [%1d]\n", GMRFLib_PARDISO_MAX_NUM_THREADS());
		}
		printf("\tblas.num.threads......... [%1d]\n", GMRFLib_openmp->blas_num_threads);
		printf("\tDensity-strategy......... [%s]\n",
		       (GMRFLib_density_storage_strategy == GMRFLib_DENSITY_STORAGE_STRATEGY_LOW ? "Low" : "High"));
	}

	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_BUILD_MODEL, NULL, NULL);

	GMRFLib_init_hgmrfm(&(mb->hgmrfm), mb->predictor_n, mb->predictor_m,
			    mb->predictor_cross_sumzero, mb->predictor_log_prec,
			    (const char *) mb->predictor_Aext_fnm, mb->predictor_Aext_precision,
			    mb->nf, mb->f_c, mb->f_weights, mb->f_graph, mb->f_Qfunc, mb->f_Qfunc_arg, mb->f_sumzero, mb->f_constr,
			    mb->ff_Qfunc, mb->ff_Qfunc_arg, mb->nlinear, mb->linear_covariate, mb->linear_precision, mb->ai_par);
	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_OPTIMIZE, NULL, NULL);
	N = ((GMRFLib_hgmrfm_arg_tp *) mb->hgmrfm->Qfunc_arg)->N;
	if (mb->verbose) {
		printf("\tSize of graph............ [%d]\n", N);
		printf("\tNumber of constraints.... [%d]\n", (mb->hgmrfm->constr ? mb->hgmrfm->constr->nc : 0));
	}

	mb->d = Realloc(mb->d, N, double);
	Memset(&(mb->d[mb->predictor_ndata]), 0, (N - mb->predictor_ndata) * sizeof(double));
	mb->loglikelihood = Realloc(mb->loglikelihood, N, GMRFLib_logl_tp *);
	Memset(&(mb->loglikelihood[mb->predictor_ndata]), 0, (N - mb->predictor_ndata) * sizeof(GMRFLib_logl_tp *));
	mb->loglikelihood_arg = Realloc(mb->loglikelihood_arg, N, void *);
	Memset(&(mb->loglikelihood_arg[mb->predictor_ndata]), 0, (N - mb->predictor_ndata) * sizeof(void *));

	if (0) {
		for (i = 0; i < N; i++)
			printf("d[%d]=%g\n", i, mb->d[i]);
	}

	/*
	 * add the diagonal, if any 
	 */

	c = Calloc(N, double);
	count = mb->predictor_n + mb->predictor_m;
	for (i = 0; i < mb->nf; i++) {
		for (k = 0; k < mb->f_nrep[i]; k++) {
			for (j = 0; j < mb->f_n[i]; j++) {
				c[count + j + k * mb->f_N[i]] = mb->f_diag[i];	/* yes; this is correct */
			}
		}
		count += mb->f_Ntotal[i];		       /* yes; this is correct */
	}

	/*
	 * this is an emergency option to prevent singular matrices (and is known to be >= 0) 
	 */
	if (mb->expert_diagonal_emergencey) {
		for (i = mb->predictor_n + mb->predictor_m; i < N; i++)
			c[i] += mb->expert_diagonal_emergencey;
	}

	if (0) {
		for (i = 0; i < N; i++)
			printf("c[%d]=%g\n", i, c[i]);
	}

	/*
	 * mark those we want to compute and compute the b
	 */
	compute = Calloc(N, char);
	b = Calloc(N, double);
	bfunc = Calloc(N, GMRFLib_bfunc_tp *);
	count = 0;
	if (mb->expert_cpo_manual) {
		/*
		 * if set, then only then only `linear.predictor[idx]' is set
		 */
		for (i = 0; i < mb->predictor_n + mb->predictor_m; i++) {
			compute[count] = (char) 0;
			count++;
		}

		for (i = 0; i < mb->expert_n_cpo_idx; i++) {
			compute[mb->expert_cpo_idx[i]] = (char) 1;
			mb->d[mb->expert_cpo_idx[i]] = 0.0;
		}
		mb->ai_par->cpo_manual = 1;
		mb->output->hyperparameters = GMRFLib_FALSE;

		for (i = 0; i < mb->nf; i++) {
			if (mb->f_bfunc2[i]) {
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					bfunc[count + j] = Calloc(1, GMRFLib_bfunc_tp);
					bfunc[count + j]->bdef = mb->f_bfunc2[i];
					bfunc[count + j]->idx = j;
				}
			}
			for (j = 0; j < mb->f_Ntotal[i]; j++) {
				compute[count] = (char) 0;
				count++;
			}
		}

		for (i = 0; i < mb->nlinear; i++) {
			compute[count] = (char) 0;
			b[count] = mb->linear_precision[i] * mb->linear_mean[i];
			count++;
		}
		assert(count == N);
	} else {
		/*
		 * as before 
		 */
		for (i = 0; i < mb->predictor_n + mb->predictor_m; i++) {
			compute[count++] = (char) mb->predictor_compute;
		}
		for (i = 0; i < mb->nf; i++) {
			if (mb->f_bfunc2[i]) {
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					bfunc[count + j] = Calloc(1, GMRFLib_bfunc_tp);
					bfunc[count + j]->bdef = mb->f_bfunc2[i];
					bfunc[count + j]->idx = j;
				}
			}
			for (j = 0; j < mb->f_Ntotal[i]; j++) {
				compute[count] = (char) mb->f_compute[i];
				count++;
			}
		}
		for (i = 0; i < mb->nlinear; i++) {
			compute[count] = (char) mb->linear_compute[i];
			b[count] = mb->linear_precision[i] * mb->linear_mean[i];
			count++;
		}
		if (count != N) {
			P(count);
			P(N);
			assert(count == N);
		}
	}

	// VB correct 
	char *vb_nodes = NULL;
	local_count = 0;
	if (mb->ai_par->vb_enable) {
		vb_nodes = Calloc(N, char);
		count = mb->predictor_n + mb->predictor_m;
		for (i = 0; i < mb->nf; i++) {
			GMRFLib_idx_tp *vb = mb->f_vb_correct[i];
			if ((vb->idx[i] == -1L && mb->f_Ntotal[i] <= mb->ai_par->vb_f_enable_limit_mean)) {
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					vb_nodes[count + j] = (char) 1;
					local_count++;
				}
			} else if (vb->idx[i] == -1L) {
				int len, k, jj;
				len = IMAX(1, mb->f_Ntotal[i] / mb->ai_par->vb_f_enable_limit_mean);	/* integer division */
				k = IMAX(1, len / 2);	       /* integer division */
				for (j = 0; j < mb->ai_par->vb_f_enable_limit_mean; j++) {
					jj = (j * len + k) % mb->f_Ntotal[i];
					vb_nodes[count + jj] = (char) 1;
					local_count++;
				}
			} else if (vb->idx[0] >= 0) {
				for (j = 0; j < vb->n; j++) {
					vb_nodes[count + IMIN(vb->idx[j], mb->f_Ntotal[i] - 1)] = (char) 1;
					local_count++;
				}
			}
			count += mb->f_Ntotal[i];
		}
		for (i = 0; i < mb->nlinear; i++) {
			vb_nodes[count++] = (char) 1;
			local_count++;
		}
		if (local_count == 0) {			       /* then there is nothting to correct for */
			Free(vb_nodes);
			vb_nodes = NULL;
		}
	}
	mb->ai_par->vb_nodes_mean = vb_nodes;

	// define the adaptive strategy
	GMRFLib_ai_strategy_tp *adapt = NULL;
	if (mb->ai_par->strategy == GMRFLib_AI_STRATEGY_ADAPTIVE) {
		adapt = Calloc(N, GMRFLib_ai_strategy_tp);
		for (i = 0; i < N; i++) {
			adapt[i] = GMRFLib_AI_STRATEGY_GAUSSIAN;
		}
		count = mb->predictor_n + mb->predictor_m;
		for (i = 0; i < mb->nf; i++) {
			if (mb->f_Ntotal[i] <= mb->ai_par->adapt_max) {
				/*
				 * add also random effects with small size
				 */
				for (j = 0; j < mb->f_Ntotal[i]; j++) {
					adapt[count + j] = GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN;
				}
			}
			count += mb->f_Ntotal[i];
		}
		for (i = 0; i < mb->nlinear; i++) {
			adapt[count++] = GMRFLib_AI_STRATEGY_MEANSKEWCORRECTED_GAUSSIAN;
		}
	}
	mb->ai_par->adapt_strategy = adapt;
	mb->ai_par->adapt_len = (adapt ? N : 0);

	if (G.reorder < 0) {
		size_t nnz = 0;
		int use_g = 0;
		GMRFLib_optimize_reorder(mb->hgmrfm->graph, &nnz, &use_g, &(mb->gn));
		if (GMRFLib_smtp != GMRFLib_SMTP_PARDISO) {
			// ....
		} else {
			GMRFLib_reorder = GMRFLib_REORDER_PARDISO;
		}
		if (GMRFLib_smtp != GMRFLib_SMTP_PARDISO) {
			if (mb->verbose) {
				printf("\tFound optimal reordering=[%s] nnz(L)=[%zu] and use_global_nodes(user)=[%s]\n",
				       GMRFLib_reorder_name(GMRFLib_reorder), nnz, (use_g ? "yes" : "no"));
			}
		}
	}
	if (mb->verbose) {
		if (mb->ntheta) {
			printf("\tList of hyperparameters: \n");
			for (i = 0; i < mb->ntheta; i++) {
				printf("\t\ttheta[%1d] = [%s]\n", i, mb->theta_tag[i]);
			}
		} else {
			printf("\tNone hyperparameters\n");
		}
	}
	GMRFLib_ai_store_tp *ai_store = Calloc(1, GMRFLib_ai_store_tp);

	if (mb->output->dic) {
		mb->dic = Calloc(1, GMRFLib_ai_dic_tp);
	} else {
		mb->dic = NULL;
	}
	/*
	 * compute a 'reasonable' initial value for \eta, unless its there from before.
	 */

	int mm = mb->predictor_n + mb->predictor_m;
	Free(G_norm_const_compute);
	Free(G_norm_const);
	for (int i = 0; i < G_norm_const_len; i++) {
		Free(G_norm_const_v[i]);
	}
	Free(G_norm_const_v);
	G_norm_const_len = mm;
	G_norm_const_compute = Calloc(mm, char);
	G_norm_const = Calloc(mm, double);
	G_norm_const_v = Calloc(mm, void *);
	for (int i = 0; i < mm; i++) {
		G_norm_const[i] = NAN;
		G_norm_const_compute[i] = 1;
	}

	x = Calloc(N, double);
	if (mb->reuse_mode && mb->x_file) {
		if (N != mb->nx_file) {
			char *msg;
			GMRFLib_sprintf(&msg, "N = %1d but nx_file = %1d. Stop.", N, mb->nx_file);
			inla_error_general(msg);
		}
		Memcpy(x, mb->x_file, N * sizeof(double));
		/*
		 * subtract the offset 
		 */
		for (i = 0; i < mb->predictor_ndata; i++) {
			x[i] -= OFFSET3(i);
		}

	} else {
#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
		for (int i = 0; i < mb->predictor_ndata; i++) {
			if (mb->d[i]) {
				x[i] = inla_compute_initial_value(i, mb->loglikelihood[i], x, (void *) mb->loglikelihood_arg[i]);
			} else {
				x[i] = 0.0;
			}
			// printf("initial value x[%1d] = %g\n", i, x[i]);
		}
	}

	/*
	 * set the flag to compute correlation-matrix or not 
	 */
	mb->misc_output = Calloc(1, GMRFLib_ai_misc_output_tp);
	if (mb->lc_derived_correlation_matrix) {
		mb->misc_output->compute_corr_lin = mb->nlc;   /* yes, pass the dimension */
	} else {
		mb->misc_output->compute_corr_lin = 0;
	}
	if (mb->output->config) {
		mb->misc_output->configs = Calloc(GMRFLib_MAX_THREADS(), GMRFLib_store_configs_tp *);
	} else {
		mb->misc_output->configs = NULL;
	}

	if (mb->fixed_mode) {
		/*
		 * then there is a request to treat the theta's as fixed and known. This little hack do the job nicely. 
		 */
		mb->ntheta = 0;
		mb->data_ntheta_all = 0;
		mb->theta = NULL;
	}

	mb->transform_funcs = Calloc(N, GMRFLib_transform_array_func_tp *);
	for (i = 0; i < mb->predictor_m + mb->predictor_n; i++) {
		/*
		 * only where we have data (ie n or m), can be a invlinkfunc different from the identity. also the compute-flag must be ON.
		 */
		if (!compute[i]) {
			mb->transform_funcs[i] = NULL;
		} else if (i < mb->predictor_ndata && mb->predictor_invlinkfunc[i]) {
			mb->transform_funcs[i] = Calloc(1, GMRFLib_transform_array_func_tp);
			mb->transform_funcs[i]->func = (GMRFLib_transform_func_tp *) mb->predictor_invlinkfunc[i];
			mb->transform_funcs[i]->arg = mb->predictor_invlinkfunc_arg[i];

			double *cov = NULL;
			if (mb->predictor_invlinkfunc_covariates && mb->predictor_invlinkfunc_covariates[i]) {
				int ncov = mb->predictor_invlinkfunc_covariates[i]->ncol;
				cov = Calloc(ncov, double);
				GMRFLib_matrix_get_row(cov, i, mb->predictor_invlinkfunc_covariates[i]);
			}
			mb->transform_funcs[i]->cov = cov;     /* yes, we store a copy here */
		} else {
			mb->transform_funcs[i] = Calloc(1, GMRFLib_transform_array_func_tp);
			mb->transform_funcs[i]->func = (GMRFLib_transform_func_tp *) link_identity;
			mb->transform_funcs[i]->arg = NULL;
			mb->transform_funcs[i]->cov = NULL;
		}
	}

	if (mb->ai_par->int_design) {
		// make sure the dimensions are right
		if (mb->ntheta != mb->ai_par->int_design->nfactors) {
			char *msg;
			GMRFLib_sprintf(&msg, "ntheta = %1d but int.design says %1d\n", mb->ntheta, mb->ai_par->int_design->nfactors);
			inla_error_general(msg);
		}
	}

	/*
	 * If Gaussian data, then force the strategy to be Gaussian  
	 */
	if (mb->gaussian_data) {
		mb->ai_par->strategy = GMRFLib_AI_STRATEGY_GAUSSIAN;
		mb->ai_par->gaussian_data = mb->gaussian_data;
	}

	/*
	 * Finally, let us do the job...
	 */
	GMRFLib_ai_INLA(&(mb->density),
			// DISABLE THIS FEATURE NOW, IT DOES NOT WORK WELL ENOGUH
			(0 ? &(mb->density_transform) : NULL), (0 ? mb->transform_funcs : NULL),
			// ....
			NULL,
			(mb->output->cpo || mb->expert_cpo_manual ? &(mb->cpo) : NULL),
			(mb->output->po ? &(mb->po) : NULL),
			mb->dic,
			(mb->output->mlik ? &(mb->mlik) : NULL),
			compute, mb->theta, mb->ntheta,
			extra, (void *) mb,
			x, b, c, NULL, bfunc, mb->d,
			loglikelihood_inla, (void *) mb,
			mb->hgmrfm->graph, mb->hgmrfm->Qfunc, mb->hgmrfm->Qfunc_arg, mb->hgmrfm->constr, mb->ai_par, ai_store,
			mb->nlc, mb->lc_lc, &(mb->density_lin), mb->misc_output, NULL, rpreopt);

	/*
	 * add the offsets to the linear predictor. Add the offsets to the 'configs' (if any), at a later stage. 
	 */
#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
	for (int i = 0; i < mb->predictor_n + mb->predictor_m; i++) {
		GMRFLib_density_tp *d;
		if (mb->density[i]) {
			d = mb->density[i];
			GMRFLib_density_new_mean(&(mb->density[i]), d, d->std_mean + OFFSET3(i));
			GMRFLib_free_density(d);
		}
	}

	/*
	 * add the offset to 'x' 
	 */
	for (i = 0; i < mb->predictor_n + mb->predictor_m; i++) {
		x[i] += OFFSET3(i);
	}

	/*
	 * need to correct configs for the integration weight, as it should not be there for _orig. only ccd has integration weights 
	 */

	Free(mb->x_file);				       /* yes, and then */
	mb->x_file = x;					       /* just take over */
	mb->nx_file = N;

	GMRFLib_free_ai_store(ai_store);
	Free(b);
	Free(c);
	Free(compute);

	return INLA_OK;
}

int inla_INLA_preopt_experimental(inla_tp * mb)
{
	double *c = NULL, *x = NULL, *b = NULL;
	int N, count, i, j;
	GMRFLib_bfunc_tp **bfunc;
	GMRFLib_preopt_tp *preopt = NULL;

	if (mb->verbose) {
		printf("%s...\n", __GMRFLib_FuncName);
	}

	/*
	 * We need to determine the strategy if strategy is default 
	 */
	int ntot = 0;

	ntot = mb->nlinear;
	for (int i = 0; i < mb->nf; i++) {
		ntot += mb->f_graph[i]->n;
	}
	N = ntot;
	Calloc_init(3 * N, 3);

	ntot += mb->predictor_m + mb->predictor_n;
	if (mb->strategy == GMRFLib_OPENMP_STRATEGY_DEFAULT) {
		if (mb->verbose) {
			printf("\tStrategy = [DEFAULT]\n");
		}
		if (ntot < 500) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_SMALL;
		} else if (ntot < 2000) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_MEDIUM;
		} else if (ntot < 50000) {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_LARGE;
		} else {
			mb->strategy = GMRFLib_OPENMP_STRATEGY_HUGE;
		}
	}

	GMRFLib_density_storage_strategy = (mb->strategy == GMRFLib_OPENMP_STRATEGY_HUGE || mb->strategy == GMRFLib_OPENMP_STRATEGY_LARGE ?
					    GMRFLib_DENSITY_STORAGE_STRATEGY_LOW : GMRFLib_DENSITY_STORAGE_STRATEGY_HIGH);
	GMRFLib_openmp->strategy = mb->strategy;

	b = Calloc_get(N);
	bfunc = Calloc(N, GMRFLib_bfunc_tp *);
	for (count = 0, i = 0; i < mb->nf; i++) {
		if (mb->f_bfunc2[i]) {
			for (j = 0; j < mb->f_Ntotal[i]; j++) {
				bfunc[count + j] = Calloc(1, GMRFLib_bfunc_tp);
				bfunc[count + j]->bdef = mb->f_bfunc2[i];
				bfunc[count + j]->idx = j;
			}
		}
		count += mb->f_Ntotal[i];
	}

	// VB corrections
	if (mb->ai_par->vb_enable) {
		// tp = 0 is mean, tp = 0 is variance
		for (int tp = 0; tp < 2; tp++) {
			char *vb_nodes = Calloc(N, char);
			int debug = 0;
			int local_count = 0;
			int count = 0;
			for (int i = 0; i < mb->nf; i++) {

				int n = mb->f_N[i] / mb->f_ngroup[i];
				int ngroup = mb->f_ngroup[i];
				int nrep = mb->f_Ntotal[i] / mb->f_N[i];
				int ntot = mb->f_Ntotal[i];
				int lim = (tp == 0 ? mb->ai_par->vb_f_enable_limit_mean : mb->ai_par->vb_f_enable_limit_variance);
				int nngroup = n * ngroup;
				assert(ntot == n * ngroup * nrep);

				if (debug) {
					P(n);
					P(ngroup);
					P(nrep);
					P(ntot);
				}

				GMRFLib_idx_tp *vb = mb->f_vb_correct[i];

				if ((vb->idx[0] == -1L && n <= lim)) {
					for (int j = 0; j < ntot; j++) {
						vb_nodes[count + j] = (char) 1;
						local_count++;
					}
				} else if (vb->idx[i] == -1L) {
					int len = IMAX(1, n / lim);
					int k = IMAX(1, len / 2);
					for (int r = 0; r < nrep; r++) {
						for (int g = 0; g < ngroup; g++) {
							for (int j = 0; j < lim; j++) {
								int jj = (j * len + k) % n + g * n + r * nngroup;
								if (debug)
									printf("%d %d %d %d\n", g, r, j, jj);
								vb_nodes[count + jj] = (char) 1;
								local_count++;
							}
						}
					}
				} else if (vb->idx[0] >= 0) {
					for (int r = 0; r < nrep; r++) {
						for (int g = 0; g < ngroup; g++) {
							for (int j = 0; j < vb->n; j++) {
								if (LEGAL(vb->idx[j], n)) {
									int jj = vb->idx[j] + g * n + r * nngroup;
									if (debug)
										printf("%d %d %d %d\n", g, r, j, jj);
									vb_nodes[count + jj] = (char) 1;
									local_count++;
								}
							}
						}
					}
				}
				count += mb->f_Ntotal[i];
			}
			for (i = 0; i < mb->nlinear; i++) {
				vb_nodes[count++] = (char) 1;
				local_count++;
			}
			if (local_count == 0) {		       /* then there is nothting to correct for */
				Free(vb_nodes);
				vb_nodes = NULL;
			}

			if (tp == 0) {
				mb->ai_par->vb_nodes_mean = vb_nodes;
			} else if (tp == 1) {
				mb->ai_par->vb_nodes_variance = vb_nodes;
			} else {
				assert(0 == 1);
			}
		}
	}

	double tref = GMRFLib_cpu();
	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_BUILD_MODEL, NULL, NULL);
	GMRFLib_preopt_init(&preopt,
			    mb->predictor_n, mb->nf, mb->f_c, mb->f_weights,
			    mb->f_graph, mb->f_Qfunc, mb->f_Qfunc_arg, mb->f_sumzero, mb->f_constr,
			    mb->f_diag,
			    mb->ff_Qfunc, mb->ff_Qfunc_arg,
			    mb->nlinear, mb->linear_covariate, mb->linear_precision, bfunc, mb->ai_par, mb->predictor_A_fnm);
	mb->preopt = preopt;
	assert(preopt->latent_graph->n == N);

	// time the two versions of Qfunc_like
	double time_used_Qx[2] = { 0.0, 0.0 };
	double time_used_pred[2] = { 0.0, 0.0 };

	if (1) {
		// cannot run this in parallel as we're changing global variables
		GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_TIMING, NULL, NULL);
		int thread_id = 0;
		assert(omp_get_thread_num() == 0);
		for (int time = -2; time < 4; time++) {
			for (int mett = 0; mett < 2; mett++) {
				GMRFLib_Qx_strategy = mett;
				double *cpu = GMRFLib_preopt_measure_time(thread_id, preopt);
				if (time > 0) {
					time_used_Qx[mett] += cpu[1];
				}
				// printf("%d %d %f %f\n", met, mett, cpu[0], cpu[1]);
				Free(cpu);
			}
		}
		// we have a slight preference for the simpler/serial ones
		GMRFLib_Qx_strategy = (time_used_Qx[0] / time_used_Qx[1] < 1.1 ? 0 : 1);

		// do this alone as this strategy depends on the previous choices
		for (int time = -2; time < 4; time++) {
			for (int mettt = 0; mettt < 2; mettt++) {
				GMRFLib_preopt_predictor_strategy = mettt;
				double *cpu = GMRFLib_preopt_measure_time2(preopt);
				if (time > 0) {
					time_used_pred[mettt] += cpu[0];
				}
				// printf("%d %f\n", mettt, cpu[0]);
				Free(cpu);
			}
		}
		// we have a slight preference for the simpler/serial ones
		GMRFLib_preopt_predictor_strategy = (time_used_pred[0] / time_used_pred[1] < 1.1 ? 0 : 1);
	} else {
		GMRFLib_Qx_strategy = 0;
		GMRFLib_preopt_predictor_strategy = 0;
	}

	// report timings
	double time_loop[9] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
	if (GMRFLib_dot_product_optim_report) {
		for (int i = 0; i < GMRFLib_CACHE_LEN; i++) {
			for (int j = 0; j < 9; j++) {
				time_loop[j] += GMRFLib_dot_product_optim_report[i][j];
			}
		}
		double time_sum = 0.0;
		for (int j = 0; j < 4; j++) {
			time_sum += time_loop[j];
		}
		for (int j = 0; j < 4; j++) {
			time_loop[j] /= time_sum;
		}
		time_loop[4] /= time_sum;

		time_sum = 0.0;
		for (int j = 5; j < 9; j++) {
			time_sum += time_loop[j];
		}
		for (int j = 5; j < 9; j++) {
			time_loop[j] /= time_sum;
		}
	}


	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_DEFAULT, NULL, NULL);
	if (mb->verbose) {
		printf("\tMode....................... [%s]\n", GMRFLib_MODE_NAME());
		printf("\tSetup...................... [%.2fs]\n", GMRFLib_cpu() - tref);
		printf("\tSparse-matrix library...... [%s]\n", mb->smtp);
		printf("\tOpenMP strategy............ [%s]\n", GMRFLib_OPENMP_STRATEGY_NAME(GMRFLib_openmp->strategy));
		printf("\tnum.threads................ [%1d:%1d]\n", GMRFLib_openmp->max_threads_nested[0], GMRFLib_openmp->max_threads_nested[1]);
		if (GMRFLib_openmp->adaptive) {
			printf("\tnum.threads (adaptive)..... [%1d]\n", GMRFLib_PARDISO_MAX_NUM_THREADS());
		}
		printf("\tblas.num.threads........... [%1d]\n", GMRFLib_openmp->blas_num_threads);
		printf("\tDensity-strategy........... [%s]\n",
		       (GMRFLib_density_storage_strategy == GMRFLib_DENSITY_STORAGE_STRATEGY_LOW ? "Low" : "High"));
		printf("\tSize of graph.............. [%d]\n", N);
		printf("\tNumber of constraints...... [%d]\n", (preopt->latent_constr ? preopt->latent_constr->nc : 0));
		printf("\tOptimizing Qx-strategy..... serial[%.3f] parallel [%.3f] choose[%s]\n",
		       time_used_Qx[0] / (time_used_Qx[0] + time_used_Qx[1]),
		       time_used_Qx[1] / (time_used_Qx[0] + time_used_Qx[1]),
		       (GMRFLib_Qx_strategy == 0 ? "serial" : "parallel"));
		printf("\tOptimizing pred-strategy... plain [%.3f] data-rich[%.3f] choose[%s]\n",
		       time_used_pred[0] / (time_used_pred[0] + time_used_pred[1]),
		       time_used_pred[0] / (time_used_pred[0] + time_used_pred[1]),
		       (GMRFLib_preopt_predictor_strategy == 0 ? "plain" : "data-rich"));
		printf("\tOptimizing dot-products.... plain....[%.3f] group....[%.3f]\n", time_loop[0], time_loop[2]);
		printf("\t                            plain.mkl[%.3f] group.mkl[%.3f]\n", time_loop[1], time_loop[3]);
		printf("\t                            => optimal.mix.strategy   [%.3f]\n", time_loop[4]); 
		printf("\t                                plain[%.3f] plain.mkl[%.3f]\n", time_loop[5], time_loop[6]);
		printf("\t                                group[%.3f] group.mkl[%.3f]\n", time_loop[7], time_loop[8]);
		       
	}
	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_OPTIMIZE, NULL, NULL);

	c = Calloc_get(N);
	if (mb->expert_diagonal_emergencey) {
		for (i = 0; i < N; i++)
			c[i] += mb->expert_diagonal_emergencey;
	}

	if (G.reorder < 0) {
		size_t nnz = 0;
		int use_g = 0;
		GMRFLib_optimize_reorder(preopt->latent_graph, &nnz, &use_g, &(mb->gn));
		if (GMRFLib_smtp != GMRFLib_SMTP_PARDISO) {
			// ....
		} else {
			GMRFLib_reorder = GMRFLib_REORDER_PARDISO;
		}
		if (GMRFLib_smtp != GMRFLib_SMTP_PARDISO) {
			if (mb->verbose) {
				printf("\tFound optimal reordering=[%s] nnz(L)=[%zu] and use_global_nodes(user)=[%s]\n",
				       GMRFLib_reorder_name(GMRFLib_reorder), nnz, (use_g ? "yes" : "no"));
			}
		}
	}
	/*
	 * mark those we want to compute and compute the b
	 */
	if (mb->verbose) {
		if (mb->ntheta) {
			printf("\n\tList of hyperparameters: \n");
			for (i = 0; i < mb->ntheta; i++) {
				printf("\t\ttheta[%1d] = [%s]\n", i, mb->theta_tag[i]);
			}
		} else {
			printf("\tNone hyperparameters\n");
		}
	}
	GMRFLib_ai_store_tp *ai_store = Calloc(1, GMRFLib_ai_store_tp);

	if (mb->output->dic) {
		mb->dic = Calloc(1, GMRFLib_ai_dic_tp);
	} else {
		mb->dic = NULL;
	}

	mb->misc_output = Calloc(1, GMRFLib_ai_misc_output_tp);
	if (mb->output->config) {
		mb->misc_output->configs_preopt = Calloc(GMRFLib_MAX_THREADS(), GMRFLib_store_configs_preopt_tp *);
	} else {
		mb->misc_output->configs_preopt = NULL;
	}
	if (mb->lc_derived_correlation_matrix) {
		mb->misc_output->compute_corr_lin = mb->nlc;   /* yes, pass the dimension */
	} else {
		mb->misc_output->compute_corr_lin = 0;
	}

	x = Calloc_get(N);
	if (mb->reuse_mode && mb->x_file) {
		Memcpy(x, mb->x_file + preopt->mnpred, N * sizeof(double));
	}

	mb->ai_par->compute_nparam_eff = 1;
	mb->predictor_compute = GMRFLib_TRUE;
	mb->ai_par->strategy = GMRFLib_AI_STRATEGY_GAUSSIAN;
	if (mb->gaussian_data) {
		mb->ai_par->vb_enable = GMRFLib_FALSE;
	}

	mb->transform_funcs = Calloc(N + preopt->mnpred, GMRFLib_transform_array_func_tp *);
	for (i = 0; i < preopt->mnpred; i++) {
		/*
		 * only where we have data (ie n or m), can be a invlinkfunc different from the identity. 
		 */
		if (i < mb->predictor_ndata && mb->predictor_invlinkfunc[i]) {
			mb->transform_funcs[i] = Calloc(1, GMRFLib_transform_array_func_tp);
			mb->transform_funcs[i]->func = (GMRFLib_transform_func_tp *) mb->predictor_invlinkfunc[i];
			mb->transform_funcs[i]->arg = mb->predictor_invlinkfunc_arg[i];

			double *cov = NULL;
			if (mb->predictor_invlinkfunc_covariates && mb->predictor_invlinkfunc_covariates[i]) {
				int ncov = mb->predictor_invlinkfunc_covariates[i]->ncol;
				cov = Calloc(ncov, double);
				GMRFLib_matrix_get_row(cov, i, mb->predictor_invlinkfunc_covariates[i]);
			}
			mb->transform_funcs[i]->cov = cov;     /* yes, we store a copy here */
		} else {
			mb->transform_funcs[i] = Calloc(1, GMRFLib_transform_array_func_tp);
			mb->transform_funcs[i]->func = (GMRFLib_transform_func_tp *) link_identity;
			mb->transform_funcs[i]->arg = NULL;
			mb->transform_funcs[i]->cov = NULL;
		}
	}

	if (mb->nlc > 0) {
		// postprocess the lincombs to convert APredictor and Predictor into sums of the latent
		int debug = 0;
		int mpred = preopt->mpred;		       // length(pApredictor)
		int mnpred = preopt->mnpred;		       // length(c(pApredictor, Apredictor))

		for (int k = 0; k < mb->nlc; k++) {
			GMRFLib_idxval_tp *idx = NULL;
			GMRFLib_lc_tp *lc = mb->lc_lc[k];
			for (int ii = 0; ii < lc->n; ii++) {
				int i = lc->idx[ii];
				double w = lc->weight[ii];
				if (debug) {
					printf("lc[%1d] decode [idx= %1d, weight= %.8f]\n", k, i, w);
				}
				if (lc->idx[ii] < mnpred) {
					// replace this statement with a row of either pAA or A
					GMRFLib_idxval_tp *AA = NULL;
					if (lc->idx[ii] < mpred) {
						AA = preopt->pAA_idxval[lc->idx[ii]];
					} else {
						AA = preopt->A_idxval[lc->idx[ii] - mpred];
					}

					for (int j = 0; j < AA->n; j++) {
						GMRFLib_idxval_addto(&idx, AA->idx[j] + mnpred, w * AA->val[j]);
					}
				} else {
					GMRFLib_idxval_addto(&idx, i, w);
				}
			}
			GMRFLib_idxval_uniq(idx);
			if (debug) {
				GMRFLib_idxval_printf(stdout, idx, "");
			}

			Free(lc->idx);
			Free(lc->weight);
			lc->n = idx->n;
			lc->idx = idx->idx;
			lc->weight = idx->val;
		}
	}

	Free(G_norm_const_compute);
	Free(G_norm_const);
	for (int i = 0; i < G_norm_const_len; i++) {
		Free(G_norm_const_v[i]);
	}
	Free(G_norm_const_v);
	G_norm_const_len = preopt->Npred;
	G_norm_const_compute = Calloc(preopt->Npred, char);
	G_norm_const = Calloc(preopt->Npred, double);
	G_norm_const_v = Calloc(preopt->Npred, void *);
	for (int i = 0; i < preopt->Npred; i++) {
		G_norm_const[i] = NAN;
		G_norm_const_compute[i] = 1;
	}

	if (!(mb->reuse_mode && mb->x_file) && mb->compute_initial_values && (mb->gaussian_data == GMRFLib_FALSE)) {
		double tref = -GMRFLib_cpu();
		double *eta_pseudo = Calloc(preopt->Npred, double);
		printf("\nCompute initial values...\n");

#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
		for (int i = 0; i < preopt->Npred; i++) {
			if (mb->d[i]) {
				eta_pseudo[i] = inla_compute_initial_value(i, mb->loglikelihood[i], x, (void *) mb->loglikelihood_arg[i]);
			} else {
				eta_pseudo[i] = 0.0;
			}
		}

		double *eta = Calloc(preopt->Npred, double);
		double *Ad = Calloc(preopt->Npred, double);
		double *e = Calloc(preopt->Npred, double);
		double *bb = Calloc(preopt->n, double);
		double *scale = Calloc(preopt->n, double);
		double s0 = 1.0;

		if (preopt->pAAt_idxval) {
#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
			for (int i = 0; i < preopt->n; i++) {
				double s = 0.0;
				for (int k = 0; k < preopt->pAAt_idxval[i]->n; k++) {
					s += SQR(preopt->pAAt_idxval[i]->val[k]);
				}
				scale[i] = 1.0 / (s0 + DMAX(0.0, s));
			}
		} else {
#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
			for (int i = 0; i < preopt->n; i++) {
				double s = 0.0;
				for (int k = 0; k < preopt->AtA_idxval[i][0]->n; k++) {
					s += preopt->AtA_idxval[i][0]->val[k];
				}
				scale[i] = 1.0 / (s0 + DMAX(0.0, s));
			}
		}

		int iter_max = 10;
		double norm_initial = 0.0;
		double *d = bb;				       /* use the same space for both */
		for (int iter = 0; iter < iter_max; iter++) {
			int one = 1;
			double norm = 0.0;
			double sum1 = 0.0, sum2 = 0.0, gamma;

			GMRFLib_preopt_predictor(eta, x, preopt);
#if defined(INLA_LINK_WITH_MKL)
			{
				double d_one = 1.0, d_mone = -1.0;
				Memcpy(e, eta, preopt->Npred * sizeof(double));
				daxpby_(&(preopt->Npred), &d_one, eta_pseudo, &one, &d_mone, e, &one);
			}
#else
			{
#pragma GCC ivdep
				for (int i = 0; i < preopt->Npred; i++) {
					e[i] = eta_pseudo[i] - eta[i];
				}
			}
#endif
			norm = ddot_(&(preopt->Npred), e, &one, e, &one);
			norm = sqrt(norm / preopt->Npred);
			GMRFLib_preopt_bnew_like(bb, e, preopt);

#pragma GCC ivdep
			for (int i = 0; i < preopt->n; i++) {
				// this computes 'd[i] = scale[i] * bb[i]' as d=bb as set above
				d[i] *= scale[i];
			}

			GMRFLib_preopt_predictor(Ad, d, preopt);
			sum1 = GMRFLib_ddot(preopt->Npred, Ad, e);
			sum2 = ddot_(&(preopt->Npred), Ad, &one, Ad, &one);
			gamma = DMAX(0.0, DMIN(2.0, sum1 / (FLT_EPSILON + sum2)));

			if (iter == 0) {
				norm_initial = norm;
			}
			printf("\tIter[%1d] RMS(err) = %.3f, update with step-size = %.3f\n", iter, norm / norm_initial, gamma);

			daxpy_(&(preopt->n), &gamma, d, &one, x, &one);
			if (norm / norm_initial < 0.25) {
				break;
			}
		}

		tref += GMRFLib_cpu();
		printf("\tInitial values computed in %.4f seconds\n", tref);
		for (int i = 0; i < IMIN(preopt->n, PREVIEW / 2L); i++) {
			printf("\t\tx[%1d] = %.4f\n", i, x[i]);
		}
		for (int i = IMAX(0, preopt->n - PREVIEW / 2L); i < preopt->n; i++) {
			printf("\t\tx[%1d] = %.4f\n", i, x[i]);
		}
		printf("\n");

		Free(eta_pseudo);
		Free(eta);
		Free(Ad);
		Free(e);
		Free(bb);
		Free(scale);
	}

	GMRFLib_ai_INLA_experimental(&(mb->density),
				     NULL, NULL,
				     (mb->output->hyperparameters ? &(mb->density_hyper) : NULL),
				     (mb->output->gcpo ? &(mb->gcpo) : NULL), mb->gcpo_param,
				     (mb->output->cpo || mb->expert_cpo_manual ? &(mb->cpo) : NULL),
				     (mb->output->po ? &(mb->po) : NULL),
				     mb->dic,
				     (mb->output->mlik ? &(mb->mlik) : NULL),
				     mb->theta, mb->ntheta,
				     extra, (void *) mb,
				     x, b, c, NULL, bfunc, mb->d,
				     loglikelihood_inla, (void *) mb,
				     preopt->preopt_graph, preopt->preopt_Qfunc, preopt->preopt_Qfunc_arg, preopt->latent_constr,
				     mb->ai_par, ai_store, mb->nlc, mb->lc_lc, &(mb->density_lin), mb->misc_output, preopt);
	GMRFLib_free_ai_store(ai_store);
	Free(bfunc);
	Calloc_free();

	return INLA_OK;
}

int inla_parse_output(inla_tp * mb, dictionary * ini, int sec, Output_tp ** out)
{
	/*
	 * parse the output-options. defaults are given in the type=output-section, which are initialised with program defaults if
	 * the program defaults are NULL. 
	 */
	int i, j, use_defaults = 1, ret, ngroups_eff = 0;
	char *secname = NULL, *tmp = NULL, *gfile = NULL, *sfile;

	secname = GMRFLib_strdup(iniparser_getsecname(ini, sec));
	if (!mb->output) {
		/*
		 * set default options 
		 */
		assert(mb->output == *out);
		use_defaults = 1;			       /* to flag that we're reading mb->output */
		(*out) = Calloc(1, Output_tp);
		(*out)->gcpo = 0;
		(*out)->cpo = 0;
		(*out)->po = 0;
		(*out)->dic = 0;
		(*out)->summary = 1;
		(*out)->return_marginals = 1;
		(*out)->return_marginals_predictor = 0;
		(*out)->kld = 1;
		(*out)->mlik = 0;
		(*out)->q = 0;
		(*out)->graph = 0;
		(*out)->config = 0;
		(*out)->hyperparameters = (G.mode == INLA_MODE_HYPER ? 1 : 1);
		(*out)->mode = 1;
		(*out)->nquantiles = 0;
		(*out)->ncdf = 0;
		(*out)->quantiles = (*out)->cdf = NULL;
	} else {
		use_defaults = 0;
		*out = Calloc(1, Output_tp);
		(*out)->gcpo = mb->output->gcpo;
		(*out)->cpo = mb->output->cpo;
		(*out)->po = mb->output->po;
		(*out)->dic = mb->output->dic;
		(*out)->summary = mb->output->summary;
		(*out)->kld = mb->output->kld;
		(*out)->mlik = mb->output->mlik;
		(*out)->q = mb->output->q;
		(*out)->graph = mb->output->graph;
		(*out)->config = mb->output->config;
		(*out)->hyperparameters = mb->output->hyperparameters;
		(*out)->mode = mb->output->mode;
		(*out)->return_marginals = mb->output->return_marginals;
		(*out)->return_marginals_predictor = mb->output->return_marginals_predictor;
		(*out)->nquantiles = mb->output->nquantiles;
		if (mb->output->nquantiles) {
			(*out)->quantiles = Calloc(mb->output->nquantiles, double);
			Memcpy((*out)->quantiles, mb->output->quantiles, (size_t) mb->output->nquantiles * sizeof(double));
		}
		(*out)->ncdf = mb->output->ncdf;
		if (mb->output->ncdf) {
			(*out)->cdf = Calloc(mb->output->ncdf, double);
			Memcpy((*out)->cdf, mb->output->cdf, (size_t) mb->output->ncdf * sizeof(double));
		}
	}
	if (!(mb->gcpo_param)) {
		mb->gcpo_param = Calloc(1, GMRFLib_gcpo_param_tp);
		mb->gcpo_param->num_level_sets = iniparser_getint(ini, inla_string_join(secname, "GCPO.NUM.LEVEL.SETS"), -1);
		mb->gcpo_param->size_max = iniparser_getint(ini, inla_string_join(secname, "GCPO.SIZE.MAX"), -1);
		mb->gcpo_param->correct_hyperpar = iniparser_getboolean(ini, inla_string_join(secname, "GCPO.CORRECT.HYPERPAR"), 1);
		mb->gcpo_param->epsilon = iniparser_getdouble(ini, inla_string_join(secname, "GCPO.EPSILON"), GMRFLib_eps(1.0 / 3.0));
		mb->gcpo_param->prior_diagonal = iniparser_getdouble(ini, inla_string_join(secname, "GCPO.PRIOR.DIAGONAL"), 1.0);
		mb->gcpo_param->remove_fixed = iniparser_getboolean(ini, inla_string_join(secname, "GCPO.REMOVE.FIXED"), 1);
		mb->gcpo_param->verbose = iniparser_getboolean(ini, inla_string_join(secname, "GCPO.VERBOSE"), 0);

		char *str = NULL;
		char *str_ptr = NULL;
		char *token = NULL;
		const char *delim = " \t";
		str = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GCPO.KEEP"), NULL));
		while ((token = GMRFLib_strtok_r(str, delim, &str_ptr))) {
			str = NULL;
			GMRFLib_str_add(&(mb->gcpo_param->keep), token);
		}

		str_ptr = NULL;
		str = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GCPO.REMOVE"), NULL));
		while ((token = GMRFLib_strtok_r(str, delim, &str_ptr))) {
			str = NULL;
			GMRFLib_str_add(&(mb->gcpo_param->remove), token);
		}

		char *tstr = NULL;
		tstr = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GCPO.STRATEGY"), GMRFLib_strdup("posterior")));
		if (!strcasecmp(tstr, "posterior")) {
			mb->gcpo_param->build_strategy = GMRFLib_GCPO_BUILD_STRATEGY_POSTERIOR;
		} else if (!strcasecmp(tstr, "prior")) {
			mb->gcpo_param->build_strategy = GMRFLib_GCPO_BUILD_STRATEGY_PRIOR;
		} else {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "gcpo.strategy", tstr);
			assert(0 == 1);
		}

		gfile = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GCPO.GROUPS"), NULL));
		sfile = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "GCPO.SELECTION"), NULL));
		assert(!(gfile && sfile));

		if (gfile) {
			FILE *fp = fopen(gfile, "rb");
			int len, total_len, glen, offset = 0;
			ret = fread((void *) &len, sizeof(int), (size_t) 1, fp);
			assert(ret == 1);
			ret = fread((void *) &total_len, sizeof(int), (size_t) 1, fp);
			assert(ret == 1);

			if (mb->gcpo_param->verbose) {
				printf("%s: read groups len %d total_len %d\n", __GMRFLib_FuncName, len, total_len);
			}
			int *buffer = Calloc(total_len, int);
			ret = fread((void *) buffer, sizeof(int), (size_t) total_len, fp);
			assert(ret == total_len);

			mb->gcpo_param->groups = GMRFLib_idxval_ncreate_x(len, IMAX(3, (total_len - len) / len));
			for (int i = 0; i < len; i++) {
				glen = buffer[offset++];
				for (int j = 0; j < glen; j++) {
					GMRFLib_idxval_add(&(mb->gcpo_param->groups[i]), buffer[offset++], NAN);
				}
				if (mb->gcpo_param->verbose) {
					if (mb->gcpo_param->groups[i]->n > 0) {
						char *msg;
						GMRFLib_sprintf(&msg, "group %d", i);
						GMRFLib_idxval_printf(stdout, mb->gcpo_param->groups[i], msg);
					}
				}
			}
			mb->gcpo_param->ngroups = len;
			for (int i = 0; i < len; i++) {
				ngroups_eff += (mb->gcpo_param->groups[i]->n > 0 ? 1 : 0);
			}
			assert(offset == total_len);
			fclose(fp);
			Free(buffer);
		} else {
			mb->gcpo_param->ngroups = -1;
			if (sfile) {
				FILE *fp = fopen(sfile, "rb");
				int len;
				ret = fread((void *) &len, sizeof(int), (size_t) 1, fp);
				assert(ret == 1);
				if (mb->gcpo_param->verbose) {
					printf("%s: read selection len %d\n", __GMRFLib_FuncName, len);
				}
				int *buffer = Calloc(len, int);
				ret = fread((void *) buffer, sizeof(int), (size_t) len, fp);
				assert(ret == len);
				for (int i = 0; i < len; i++) {
					if (mb->gcpo_param->verbose) {
						printf("%s: add idx %d\n", __GMRFLib_FuncName, buffer[i]);
					}
					GMRFLib_idx_add(&(mb->gcpo_param->selection), buffer[i]);
				}
				fclose(fp);
				Free(buffer);
			}
		}
	}

	(*out)->gcpo = iniparser_getboolean(ini, inla_string_join(secname, "GCPO.ENABLE"), (*out)->gcpo);
	(*out)->cpo = iniparser_getboolean(ini, inla_string_join(secname, "CPO"), (*out)->cpo);
	(*out)->po = iniparser_getboolean(ini, inla_string_join(secname, "PO"), (*out)->po);
	(*out)->dic = iniparser_getboolean(ini, inla_string_join(secname, "DIC"), (*out)->dic);
	(*out)->summary = iniparser_getboolean(ini, inla_string_join(secname, "SUMMARY"), (*out)->summary);
	(*out)->return_marginals = iniparser_getboolean(ini, inla_string_join(secname, "RETURN.MARGINALS"), (*out)->return_marginals);
	(*out)->return_marginals_predictor =
	    iniparser_getboolean(ini, inla_string_join(secname, "RETURN.MARGINALS.PREDICTOR"), (*out)->return_marginals_predictor);
	(*out)->hyperparameters = iniparser_getboolean(ini, inla_string_join(secname, "HYPERPARAMETERS"), (*out)->hyperparameters);
	(*out)->mode = iniparser_getboolean(ini, inla_string_join(secname, "MODE"), (*out)->mode);
	(*out)->kld = iniparser_getboolean(ini, inla_string_join(secname, "KLD"), (*out)->kld);
	(*out)->mlik = iniparser_getboolean(ini, inla_string_join(secname, "MLIK"), (*out)->mlik);
	(*out)->q = iniparser_getboolean(ini, inla_string_join(secname, "Q"), (*out)->q);
	(*out)->graph = iniparser_getboolean(ini, inla_string_join(secname, "GRAPH"), (*out)->graph);
	(*out)->config = iniparser_getboolean(ini, inla_string_join(secname, "CONFIG"), (*out)->config);

	tmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "QUANTILES"), NULL));

	if (G.mode == INLA_MODE_HYPER) {
		/*
		 * these are the requirements for the HYPER_MODE 
		 */
		(*out)->gcpo = 0;
		(*out)->cpo = 0;
		(*out)->po = 0;
		(*out)->dic = 0;
		(*out)->mlik = 1;
	}
	if (G.mode == INLA_MODE_HYPER) {
		if (!((*out)->hyperparameters)) {
			fprintf(stderr, "*** Warning: HYPER_MODE require (*out)->hyperparameters = 1\n");
		}
		(*out)->hyperparameters = 1;
	}

	if (tmp) {
		inla_sread_doubles_q(&((*out)->quantiles), &((*out)->nquantiles), tmp);

		if ((*out)->nquantiles == 0)
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "quantiles", tmp);

		for (j = 0; j < (*out)->nquantiles; j++) {
			if ((*out)->quantiles[j] <= 0.0 || (*out)->quantiles[j] >= 1.0) {
				inla_error_field_is_void(__GMRFLib_FuncName, secname, "quantiles", tmp);
			}
		}
	}
	tmp = GMRFLib_strdup(iniparser_getstring(ini, inla_string_join(secname, "CDF"), NULL));
	if (tmp) {
		inla_sread_doubles_q(&((*out)->cdf), &((*out)->ncdf), tmp);
		if ((*out)->ncdf == 0) {
			inla_error_field_is_void(__GMRFLib_FuncName, secname, "cdf", tmp);
		}
	}
	if (mb->verbose) {
		printf("\t\toutput:\n");
		if (use_defaults) {
			printf("\t\t\tgcpo=[%1d]\n", (*out)->gcpo);
			printf("\t\t\t\tnum.level.sets=[%1d]\n", mb->gcpo_param->num_level_sets);
			printf("\t\t\t\tsize.max=[%1d]\n", mb->gcpo_param->size_max);
			printf("\t\t\t\tstrategy=[%s]\n", GMRFLib_GCPO_BUILD_STRATEGY_NAME(mb->gcpo_param->build_strategy));
			printf("\t\t\t\tcorrect.hyperpar=[%1d]\n", mb->gcpo_param->correct_hyperpar);
			printf("\t\t\t\tepsilon=[%g]\n", mb->gcpo_param->epsilon);
			printf("\t\t\t\tprior.diagonal=[%g]\n", mb->gcpo_param->prior_diagonal);
			if (mb->gcpo_param->groups) {
				printf("\t\t\t\tUse user-defined gcpo-groups, ngroups.eff=[%1d]\n", ngroups_eff);
			}
			if (mb->gcpo_param->selection) {
				printf("\t\t\t\tUse user-defined selection, nselection=[%1d]\n", mb->gcpo_param->selection->n);
			}

			if (mb->gcpo_param->keep) {
				printf("\t\t\t\tkeep=[");
				for (int i = 0; i < mb->gcpo_param->keep->n; i++) {
					if (i) {
						printf(" ");
					}
					printf("%s", mb->gcpo_param->keep->str[i]);
				}
				printf("]\n");
			} else {
				printf("\t\t\t\tkeep=[]\n");
			}

			printf("\t\t\t\tremove.fixed=[%1d]\n", mb->gcpo_param->remove_fixed);
			if (mb->gcpo_param->remove) {
				printf("\t\t\t\tremove=[");
				for (int i = 0; i < mb->gcpo_param->remove->n; i++) {
					if (i) {
						printf(" ");
					}
					printf("%s", mb->gcpo_param->remove->str[i]);
				}
				printf("]\n");
			} else {
				printf("\t\t\t\tremove=[]\n");
			}

			printf("\t\t\tcpo=[%1d]\n", (*out)->cpo);
			printf("\t\t\tpo=[%1d]\n", (*out)->po);
			printf("\t\t\tdic=[%1d]\n", (*out)->dic);
			printf("\t\t\tkld=[%1d]\n", (*out)->kld);
			printf("\t\t\tmlik=[%1d]\n", (*out)->mlik);
			printf("\t\t\tq=[%1d]\n", (*out)->q);
			printf("\t\t\tgraph=[%1d]\n", (*out)->graph);
			printf("\t\t\thyperparameters=[%1d]\n", (*out)->hyperparameters);
		}
		printf("\t\t\tsummary=[%1d]\n", (*out)->summary);
		printf("\t\t\treturn.marginals=[%1d]\n", (*out)->return_marginals);
		printf("\t\t\treturn.marginals.predictor=[%1d]\n", (*out)->return_marginals_predictor);
		printf("\t\t\tnquantiles=[%1d]  [", (*out)->nquantiles);
		for (i = 0; i < (*out)->nquantiles; i++) {
			printf(" %g", (*out)->quantiles[i]);
		}
		printf(" ]\n");
		printf("\t\t\tncdf=[%1d]  [", (*out)->ncdf);
		for (i = 0; i < (*out)->ncdf; i++) {
			printf(" %g", (*out)->cdf[i]);
		}
		printf(" ]\n");
	}
	return INLA_OK;
}

int inla_computed(GMRFLib_density_tp ** d, int n)
{
	/*
	 * return 0 if all d[i]'s are NULL, and 1 otherwise. 
	 */
	int i;

	if (!d) {
		return INLA_OK;
	}
	for (i = 0; i < n; i++) {
		if (d[i]) {
			return INLA_FAIL;
		}
	}
	return INLA_OK;
}

int inla_output_Q(inla_tp * mb, const char *dir, GMRFLib_graph_tp * graph)
{
	GMRFLib_problem_tp *p = NULL;
	char *fnm = NULL, *newdir = NULL;
	FILE *fp = NULL;
	int thread_id = 0;
	assert(omp_get_thread_num() == 0);

	GMRFLib_init_problem(thread_id, &p, NULL, NULL, NULL, NULL, graph, GMRFLib_Qfunc_generic, (void *) graph, NULL);
	GMRFLib_sprintf(&newdir, "%s/Q", dir);
	if (mb->verbose) {
		printf("\t\tstore factorisation results in[%s]\n", newdir);
	}
	if (inla_mkdir(newdir) == INLA_OK) {
		if (mb->output->q) {
			if (mb->verbose) {
				printf("\t\tstore info precision and related matrices in[%s]\n", newdir);
			}
			GMRFLib_sprintf(&fnm, "%s/%s", newdir, "precision-matrix");
			GMRFLib_bitmap_problem((const char *) fnm, p);
			Free(fnm);
		}
		GMRFLib_sprintf(&fnm, "%s/%s", newdir, "factorisation-information.txt");
		fp = fopen(fnm, "w");
		if (fp) {
			GMRFLib_fact_info_report(fp, &(p->sub_sm_fact));
			fclose(fp);
		}
		GMRFLib_free_problem(p);
		Free(fnm);
	}
	Free(newdir);

	return INLA_OK;
}

int inla_output_graph(inla_tp * mb, const char *dir, GMRFLib_graph_tp * graph)
{
	char *fnm = NULL;
	GMRFLib_sprintf(&fnm, "%s/graph.dat", dir);
	if (mb->verbose) {
		printf("\t\tstore graph in[%s]\n", fnm);
	}
	GMRFLib_graph_write_b(fnm, graph);
	Free(fnm);

	return INLA_OK;
}

int inla_output_matrix(const char *dir, const char *sdir, const char *filename, int n, double *matrix, int *order)
{
	char *fnm, *ndir;

	if (sdir) {
		GMRFLib_sprintf(&ndir, "%s/%s", dir, sdir);
	} else {
		GMRFLib_sprintf(&ndir, "%s", dir);
	}

	GMRFLib_sprintf(&fnm, "%s/%s", ndir, filename);

	GMRFLib_matrix_tp *M = Calloc(1, GMRFLib_matrix_tp);

	M->nrow = M->ncol = n;
	M->elems = ISQR(n);
	M->A = Calloc(ISQR(n), double);
	if (order == NULL) {
		Memcpy(M->A, matrix, ISQR(n) * sizeof(double));
	} else {
		int i, j;
		for (i = 0; i < n; i++) {
			for (j = 0; j < n; j++) {
				M->A[order[i] + order[j] * n] = matrix[i + j * n];
			}
		}
	}

	M->offset = 0L;
	M->whence = SEEK_SET;
	M->tell = -1L;

	GMRFLib_write_fmesher_file(M, fnm, M->offset, M->whence);
	GMRFLib_matrix_free(M);

	Free(fnm);
	Free(ndir);

	return INLA_OK;
}

int inla_output_names(const char *dir, const char *sdir, int n, const char **names, const char *suffix)
{
	FILE *fp;
	char *fnm, *ndir;

	GMRFLib_sprintf(&ndir, "%s/%s", dir, sdir);
	GMRFLib_sprintf(&fnm, "%s/NAMES", ndir);

	int i;
	fp = fopen(fnm, "w");
	for (i = 0; i < n; i++) {
		fprintf(fp, "%s%s\n", names[i], (suffix ? suffix : ""));
	}
	fclose(fp);

	Free(fnm);
	Free(ndir);

	return INLA_OK;
}

int inla_output_size(const char *dir, const char *sdir, int n, int N, int Ntotal, int ngroup, int nrep)
{
	char *fnm, *ndir;
	GMRFLib_sprintf(&ndir, "%s/%s", dir, sdir);
	GMRFLib_sprintf(&fnm, "%s/size.dat", ndir);

	Dinit_s(fnm);
	D5W(n, (N > 0 ? N : n), (Ntotal > 0 ? Ntotal : n), (ngroup > 0 ? ngroup : 1), (nrep > 0 ? nrep : 1));
	Dclose();
	Free(fnm);
	Free(ndir);

	return INLA_OK;
}

char *inla_create_hyperid(int id, const char *secname)
{
	char *hyperid = NULL;
	GMRFLib_sprintf(&hyperid, "%1d|%s", id, secname);

	return (hyperid);
}

int inla_output_hyperid(const char *dir, const char *sdir, char *hyperid)
{
	FILE *fp;
	char *fnm, *ndir;

	// fprintf(stderr, "output hyperid %s / %s [%s]\n", dir, sdir, hyperid);

	GMRFLib_sprintf(&ndir, "%s/%s", dir, sdir);
	GMRFLib_sprintf(&fnm, "%s/hyperid.dat", ndir);

	fp = fopen(fnm, "w");
	if (!fp) {
		inla_error_open_file(fnm);
	}
	fprintf(fp, "%s\n", (hyperid ? hyperid : ""));
	fclose(fp);

	Free(fnm);
	Free(ndir);

	return INLA_OK;
}

int inla_output_id_names(const char *dir, const char *sdir, inla_file_contents_tp * fc)
{
	if (!fc) {
		return INLA_OK;
	}

	char *fnm, *ndir;

	GMRFLib_sprintf(&ndir, "%s/%s", dir, sdir);
	GMRFLib_sprintf(&fnm, "%s/id-names.dat", ndir);

	inla_write_file_contents(fnm, fc);

	Free(fnm);
	Free(ndir);

	return INLA_OK;
}

int inla_output(inla_tp * mb)
{
	int n = 0, j, *offsets = NULL, len_offsets, local_verbose = 0;
	assert(mb);

	/*
	 * compute the offset for each pack of the results 
	 */
	len_offsets = 1 + mb->nf + mb->nlinear;
	offsets = Calloc(len_offsets, int);

	j = n = 0;
	offsets[j++] = n;
	n += mb->predictor_n + mb->predictor_m;
	for (int i = 0; i < mb->nf; i++) {
		offsets[j++] = n;
		n += mb->f_graph[i]->n;
	}
	for (int i = 0; i < mb->nlinear; i++) {
		offsets[j++] = n;
		n++;
	}
	if (GMRFLib_inla_mode == GMRFLib_MODE_TWOSTAGE_PART1 || GMRFLib_inla_mode == GMRFLib_MODE_EXPERIMENTAL) {
		assert(mb->preopt->mnpred == mb->predictor_m + mb->predictor_n);
	} else {
		assert(mb->hgmrfm->graph->n == n);
	}

	assert(j == len_offsets);

	if (mb->verbose) {
		printf("Store results in directory[%s]\n", mb->dir);
	}
	/*
	 * turn off all the info about output-files... 
	 */
	local_verbose = 0;

	// do this here so they can be parallized in '_output_detail'
	if (1) {
		int offset = offsets[0];
		inla_output_detail(mb->dir, &(mb->density[offset]),
				   NULL, mb->predictor_n + mb->predictor_m, 1,
				   mb->predictor_output, mb->predictor_dir, mb->output->return_marginals_predictor,
				   NULL, NULL, NULL, mb->predictor_tag, NULL, local_verbose);
		inla_output_size(mb->dir, mb->predictor_dir, mb->predictor_n, mb->predictor_n,
				 mb->predictor_n + mb->predictor_m, -1, (mb->predictor_m == 0 ? 1 : 2));
	}

	if (mb->predictor_invlinkfunc && mb->predictor_user_scale) {
		char *sdir, *newtag;
		int offset = offsets[0];
		GMRFLib_sprintf(&newtag, "%s in user scale", mb->predictor_tag);
		GMRFLib_sprintf(&sdir, "%s-user-scale", mb->predictor_dir);
		inla_output_detail(mb->dir, &(mb->density[offset]),
				   NULL, mb->predictor_n + mb->predictor_m, 1,
				   mb->predictor_output, sdir, mb->output->return_marginals_predictor,
				   NULL, NULL, mb->transform_funcs, newtag, NULL, local_verbose);
		inla_output_size(mb->dir, sdir, mb->predictor_n + mb->predictor_m, -1, -1, -1, (mb->predictor_m == 0 ? 1 : 2));
	}

#pragma omp parallel for num_threads(IMIN(IMAX(1, mb->nf), GMRFLib_openmp->max_threads_outer))
	for (int ii = 0; ii < mb->nf; ii++) {
		int offset = offsets[ii + 1];
		inla_output_detail(mb->dir, &(mb->density[offset]),
				   mb->f_locations[ii],
				   mb->f_graph[ii]->n, mb->f_nrep[ii] * mb->f_ngroup[ii], mb->f_output[ii],
				   mb->f_dir[ii], mb->output->return_marginals,
				   NULL, NULL, NULL, mb->f_tag[ii], mb->f_modelname[ii], local_verbose);
		inla_output_size(mb->dir, mb->f_dir[ii], mb->f_n[ii], mb->f_N[ii], mb->f_Ntotal[ii], mb->f_ngroup[ii], mb->f_nrep[ii]);
		inla_output_id_names(mb->dir, mb->f_dir[ii], mb->f_id_names[ii]);
	}


#pragma omp parallel for num_threads(GMRFLib_MAX_THREADS())
	for (int k = 3; k < 9; k++) {
		int ii;
		if (k == 3) {
			char *fnm;
			GMRFLib_sprintf(&fnm, "%s/totaloffset", mb->dir);
			inla_mkdir(fnm);
			Free(fnm);
			GMRFLib_sprintf(&fnm, "%s/totaloffset/totaloffset.dat", mb->dir);
			Dinit(fnm);
			Free(fnm);
			for (ii = 0; ii < mb->predictor_n + mb->predictor_m; ii++) {
				D1W(OFFSET3(ii));
			}
			Dclose();
		} else if (k == 4) {
			for (ii = 0; ii < mb->nlinear; ii++) {
				int offset = offsets[mb->nf + 1 + ii];
				inla_output_detail(mb->dir, &(mb->density[offset]),
						   NULL, 1, 1, mb->linear_output[ii], mb->linear_dir[ii], mb->output->return_marginals,
						   NULL, NULL, NULL, mb->linear_tag[ii], NULL, local_verbose);
				inla_output_size(mb->dir, mb->linear_dir[ii], 1, -1, -1, -1, -1);
			}
		} else if (k == 5) {
			if (mb->density_lin) {
				char *newtag2, *newdir2;
				ii = 0;
				GMRFLib_sprintf(&newtag2, "lincombs.derived.all");
				GMRFLib_sprintf(&newdir2, "lincombs.derived.all");
				inla_output_detail(mb->dir, &(mb->density_lin[ii]), mb->lc_order, mb->nlc,
						   1, mb->lc_output[ii], newdir2, mb->output->return_marginals,
						   NULL, NULL, NULL, newtag2, NULL, local_verbose);
				inla_output_size(mb->dir, newdir2, mb->nlc, -1, -1, -1, -1);
				inla_output_names(mb->dir, newdir2, mb->nlc, (const char **) ((void *) mb->lc_tag), NULL);

				Free(newtag2);
				Free(newdir2);
			}
			if (mb->density_hyper) {
				for (ii = 0; ii < mb->ntheta; ii++) {
					char *sdir;
					GMRFLib_sprintf(&sdir, "hyperparameter-1-%.6d-%s", ii, mb->theta_dir[ii]);
					inla_output_detail(mb->dir, &(mb->density_hyper[ii]), NULL, 1, 1, mb->output, sdir,
							   mb->output->return_marginals, NULL, NULL, NULL, mb->theta_tag[ii], NULL, local_verbose);
					inla_output_hyperid(mb->dir, sdir, mb->theta_hyperid[ii]);
					inla_output_size(mb->dir, sdir, 1, -1, -1, -1, -1);

					GMRFLib_sprintf(&sdir, "hyperparameter-2-%.6d-%s-user-scale", ii, mb->theta_dir[ii]);
					inla_output_detail(mb->dir, &(mb->density_hyper[ii]), NULL, 1, 1, mb->output, sdir,
							   mb->output->return_marginals,
							   mb->theta_map[ii], mb->theta_map_arg[ii], NULL,
							   mb->theta_tag_userscale[ii], NULL, local_verbose);
					inla_output_hyperid(mb->dir, sdir, mb->theta_hyperid[ii]);
					inla_output_size(mb->dir, sdir, 1, -1, -1, -1, -1);
				}
			}
			if (GMRFLib_ai_INLA_userfunc0_density && GMRFLib_ai_INLA_userfunc0_dim > 0) {
				/*
				 * we need to create the corresponding normal as well 
				 */
				char *sdir;
				sdir = GMRFLib_strdup("random.effect.UserFunction0");
				inla_output_detail(mb->dir, GMRFLib_ai_INLA_userfunc0_density, NULL,
						   GMRFLib_ai_INLA_userfunc0_dim, 1, mb->output, sdir, mb->output->return_marginals,
						   NULL, NULL, NULL, "UserFunction0", NULL, local_verbose);
				inla_output_size(mb->dir, sdir, GMRFLib_ai_INLA_userfunc0_dim, -1, -1, -1, -1);
				Free(sdir);
			}
			if (GMRFLib_ai_INLA_userfunc1_density && GMRFLib_ai_INLA_userfunc1_dim > 0) {
				/*
				 * we need to create the corresponding normal as well 
				 */
				char *sdir;
				sdir = GMRFLib_strdup("random.effect.UserFunction1");
				inla_output_detail(mb->dir, GMRFLib_ai_INLA_userfunc1_density, NULL,
						   GMRFLib_ai_INLA_userfunc1_dim, 1, mb->output, sdir, mb->output->return_marginals,
						   NULL, NULL, NULL, "UserFunction1", NULL, local_verbose);
				inla_output_size(mb->dir, sdir, GMRFLib_ai_INLA_userfunc1_dim, -1, -1, -1, -1);

				Free(sdir);
			}
			if (GMRFLib_ai_INLA_userfunc2_density && GMRFLib_ai_INLA_userfunc2_n > 0) {
				for (ii = 0; ii < GMRFLib_ai_INLA_userfunc2_n; ii++) {
					/*
					 * we need to create the corresponding normal as well 
					 */
					char *sdir, *local_tag;

					int dim = GMRFLib_ai_INLA_userfunc2_len[ii];
					GMRFLib_sprintf(&sdir, "spde2.blc.%6.6d", ii + 1);
					GMRFLib_sprintf(&local_tag, "%s", GMRFLib_ai_INLA_userfunc2_tag[ii]);
					inla_output_detail(mb->dir, GMRFLib_ai_INLA_userfunc2_density[ii], NULL, dim, 1,
							   mb->output, sdir, mb->output->return_marginals,
							   NULL, NULL, NULL, local_tag, NULL, local_verbose);
					inla_output_size(mb->dir, sdir, dim, -1, -1, -1, -1);

					Free(sdir);
					Free(local_tag);
				}
			}
			if (GMRFLib_ai_INLA_userfunc3_density && GMRFLib_ai_INLA_userfunc3_n > 0) {
				for (ii = 0; ii < GMRFLib_ai_INLA_userfunc3_n; ii++) {
					/*
					 * we need to create the corresponding normal as well 
					 */
					char *sdir, *local_tag;

					int dim = GMRFLib_ai_INLA_userfunc3_len[ii];
					GMRFLib_sprintf(&sdir, "spde3.blc.%6.6d", ii + 1);
					GMRFLib_sprintf(&local_tag, "%s", GMRFLib_ai_INLA_userfunc3_tag[ii]);
					inla_output_detail(mb->dir, GMRFLib_ai_INLA_userfunc3_density[ii], NULL, dim, 1,
							   mb->output, sdir, mb->output->return_marginals,
							   NULL, NULL, NULL, local_tag, NULL, local_verbose);
					inla_output_size(mb->dir, sdir, dim, -1, -1, -1, -1);

					Free(sdir);
					Free(local_tag);
				}
			}
		} else if (k == 6) {
			if (mb->misc_output) {
				inla_output_misc(mb->dir, mb->misc_output, mb->ntheta, mb->theta_tag, mb->theta_from, mb->theta_to,
						 mb->lc_order, local_verbose, mb);
			}
		} else if (k == 7) {
			if (mb->gcpo) {
				inla_output_detail_gcpo(mb->dir, mb->gcpo, local_verbose);
			}
			if (mb->cpo) {
				inla_output_detail_cpo(mb->dir, mb->cpo, mb->predictor_ndata, local_verbose);
			}
			if (mb->po) {
				inla_output_detail_po(mb->dir, mb->po, mb->predictor_ndata, local_verbose);
			}
			if (mb->dic) {
				inla_output_detail_dic(mb->dir, mb->dic, mb->family_idx, mb->len_family_idx, local_verbose);
			}
			if (mb->output->mlik) {
				inla_output_detail_mlik(mb->dir, &(mb->mlik), local_verbose);
			}
		} else if (k == 8) {
			inla_output_detail_x(mb->dir, mb->x_file, mb->nx_file);
			inla_output_detail_theta(mb->dir, mb->theta, mb->ntheta);
			inla_output_gitid(mb->dir);
			inla_output_linkfunctions(mb->dir, mb);
			if (mb->output->q) {
				if (local_verbose == 0) {
					int save = mb->verbose;
					mb->verbose = 0;
					inla_output_Q(mb, mb->dir, mb->hgmrfm->graph);
					mb->verbose = save;
				}
			}
			if (mb->output->graph) {
				inla_output_graph(mb, mb->dir, mb->hgmrfm->graph);
			}
		}
	}

	int N = -1;
	if (GMRFLib_inla_mode == GMRFLib_MODE_TWOSTAGE_PART1 || GMRFLib_inla_mode == GMRFLib_MODE_EXPERIMENTAL) {
		N = mb->preopt->n + mb->preopt->mnpred;
	} else {
		N = ((GMRFLib_hgmrfm_arg_tp *) mb->hgmrfm->Qfunc_arg)->N;
	}

#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
	for (int i = 0; i < 2; i++) {
		if (i == 0 && mb->density) {
			for (int ii = 0; ii < N; ii++) {
				GMRFLib_free_density(mb->density[ii]);
			}
			Free(mb->density);
		}
	}

	return INLA_OK;
}

int inla_output_detail_gcpo(const char *dir, GMRFLib_gcpo_tp * gcpo, int verbose)
{
	/*
	 * output whatever is requested.... 
	 */
	char *ndir = NULL, *msg = NULL, *nndir = NULL;
	int i, j, n;

	if (!gcpo) {
		return INLA_OK;
	}
	n = gcpo->n;

	GMRFLib_sprintf(&ndir, "%s/%s", dir, "gcpo");
	if (inla_mkdir(ndir) != 0) {
		GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", ndir, strerror(errno));
		inla_error_general(msg);
	}
	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "gcpo.dat");
	{
		Dinit(nndir);
		if (verbose) {
#pragma omp critical (Name_2f68597610da063cce30cec1d19ac794527bc57e)
			{
				printf("\t\tstore gcpo-results in[%s]\n", nndir);
			}
		}
		D1W(n);
		for (i = 0; i < n; i++) {
			D1W(gcpo->value[i]);
		}
		for (i = 0; i < n; i++) {
			D1W(gcpo->kld[i]);
		}
		for (i = 0; i < n; i++) {
			D1W(gcpo->mean[i]);
		}
		for (i = 0; i < n; i++) {
			D1W(gcpo->sd[i]);
		}
		for (i = 0; i < n; i++) {
			D1W(gcpo->groups[i]->n);
			for (j = 0; j < gcpo->groups[i]->n; j++) {
				D1W(gcpo->groups[i]->idx[j] + 1);	/* back to R-style indexing */
			}
			for (j = 0; j < gcpo->groups[i]->n; j++) {
				D1W(gcpo->groups[i]->val[j]);
			}
		}
		Dclose();
	}

	Free(ndir);
	Free(nndir);

	return INLA_OK;
}

int inla_output_detail_cpo(const char *dir, GMRFLib_ai_cpo_tp * cpo, int predictor_n, int verbose)
{
	/*
	 * output whatever is requested.... 
	 */
	char *ndir = NULL, *msg = NULL, *nndir = NULL;
	int i, n, add_empty = 1;

	if (!cpo) {
		return INLA_OK;
	}
	// n = cpo->n;
	n = predictor_n;				       /* the CPO and PIT are at the first predictor_n */

	GMRFLib_sprintf(&ndir, "%s/%s", dir, "cpo");
	if (inla_mkdir(ndir) != 0) {
		GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", ndir, strerror(errno));
		inla_error_general(msg);
	}
	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "cpo.dat");
	{
		Dinit(nndir);
		if (verbose) {
#pragma omp critical (Name_6931944003ec5b67e4101e7995e2a5baab470602)
			{
				printf("\t\tstore cpo-results in[%s]\n", nndir);
			}
		}
		D1W(predictor_n);
		for (i = 0; i < n; i++) {
			if (cpo->value[i]) {
				D2W(i, cpo->value[i][0]);
			} else {
				if (add_empty) {
					D2W(i, NAN);
				}
			}
		}
		Dclose();
	}

	if (cpo->pit_value) {
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "pit.dat");
		Dinit(nndir);
		if (verbose) {
#pragma omp critical (Name_dbf18c17124ff85ed3fce2d13d88ad663accb843)
			{
				printf("\t\tstore pit-results in[%s]\n", nndir);
			}
		}
		D1W(predictor_n);
		for (i = 0; i < n; i++) {
			if (cpo->pit_value[i]) {
				D2W(i, cpo->pit_value[i][0]);
			} else {
				if (add_empty) {
					D2W(i, NAN);
				}
			}
		}
		Dclose();
	}
	if (cpo->failure) {
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "failure.dat");
		Dinit(nndir);
		if (verbose) {
#pragma omp critical (Name_f742aaba395a3aa285064964ce668d0be3e5e7ef)
			{
				printf("\t\tstore failure-results in[%s]\n", nndir);
			}
		}
		D1W(predictor_n);
		for (i = 0; i < n; i++) {
			if (cpo->failure[i]) {
				D2W(i, cpo->failure[i][0]);
			} else {
				if (add_empty) {
					D2W(i, NAN);
				}
			}
		}
		Dclose();
	}
	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "summary.dat");
	{
		Dinit(nndir);
		if (verbose) {
#pragma omp critical (Name_dfd5be6da1007dda6dbb7abfb479ffb6fdd5c005)
			{
				printf("\t\tstore summary of cpo-results in[%s]\n", nndir);
			}
		}
		D2W(cpo->mean_value, cpo->gmean_value);
		Dclose();
	}

	Free(ndir);
	Free(nndir);

	return INLA_OK;
}

int inla_output_detail_po(const char *dir, GMRFLib_ai_po_tp * po, int predictor_n, int verbose)
{
	/*
	 * output whatever is requested.... 
	 */
	char *ndir = NULL, *msg = NULL, *nndir = NULL;
	int i, n, add_empty = 1;

	if (!po) {
		return INLA_OK;
	}
	n = predictor_n;				       /* the PO are at the first predictor_n */

	GMRFLib_sprintf(&ndir, "%s/%s", dir, "po");
	if (inla_mkdir(ndir) != 0) {
		GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", ndir, strerror(errno));
		inla_error_general(msg);
	}
	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "po.dat");
	Dinit(nndir);
	if (verbose) {
#pragma omp critical (Name_879176a6e21c1dedb4becf90d4f21dd37210e46f)
		{
			printf("\t\tstore po-results in[%s]\n", nndir);
		}
	}
	D1W(predictor_n);
	for (i = 0; i < n; i++) {
		if (po->value[i]) {
			D3W(i, po->value[i][0], po->value[i][1]);
		} else {
			if (add_empty) {
				D3W(i, NAN, NAN);
			}
		}
	}
	Dclose();
	Free(ndir);
	Free(nndir);

	return INLA_OK;
}

int inla_output_detail_dic(const char *dir, GMRFLib_ai_dic_tp * dic, double *family_idx, int len_family_idx, int verbose)
{
	/*
	 * output whatever is requested.... 
	 */
	char *ndir = NULL, *msg = NULL, *nndir = NULL;
	double *tmp = NULL;

#define _PAD_WITH_NA(xx)						\
	if (1) {							\
		tmp = Calloc(IMAX(dic->n_deviance, len_family_idx), double); \
		Memcpy(tmp, xx, dic->n_deviance*sizeof(double));	\
		int i;							\
		for(i = dic->n_deviance; i < len_family_idx; i++){	\
			tmp[i] = NAN;					\
		}							\
	}

	if (!dic) {
		return INLA_OK;
	}
	GMRFLib_sprintf(&ndir, "%s/%s", dir, "dic");
	if (inla_mkdir(ndir) != 0) {
		GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", ndir, strerror(errno));
		inla_error_general(msg);
	}
	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "dic.dat");
	Dinit(nndir);
	if (verbose) {
#pragma omp critical (Name_19769e5d041b18c2ff6bee313efb503ad5ad5aef)
		{
			printf("\t\tstore dic-results in[%s]\n", nndir);
		}
	}
	D4W(dic->mean_of_deviance, dic->deviance_of_mean, dic->p, dic->dic);
	D4W(dic->mean_of_deviance_sat, dic->deviance_of_mean_sat, dic->p, dic->dic_sat);
	Dclose();

	if (dic->n_deviance > 0) {
		GMRFLib_matrix_tp *M = NULL;

		M = Calloc(1, GMRFLib_matrix_tp);
		M->nrow = len_family_idx;
		M->ncol = 1;
		M->elems = M->nrow * M->ncol;

		_PAD_WITH_NA(dic->e_deviance);
		M->A = tmp;
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "e_deviance.dat");
		GMRFLib_write_fmesher_file(M, nndir, (long int) 0, -1);
		Free(tmp);

		_PAD_WITH_NA(dic->e_deviance_sat);
		M->A = tmp;
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "e_deviance_sat.dat");
		GMRFLib_write_fmesher_file(M, nndir, (long int) 0, -1);
		Free(tmp);

		_PAD_WITH_NA(dic->deviance_e);
		M->A = tmp;
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "deviance_e.dat");
		GMRFLib_write_fmesher_file(M, nndir, (long int) 0, -1);
		Free(tmp);

		_PAD_WITH_NA(dic->deviance_e_sat);
		M->A = tmp;
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "deviance_e_sat.dat");
		GMRFLib_write_fmesher_file(M, nndir, (long int) 0, -1);
		Free(tmp);

		M->A = family_idx;
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "family_idx.dat");
		GMRFLib_write_fmesher_file(M, nndir, (long int) 0, -1);

		M->A = NULL;
		GMRFLib_matrix_free(M);
	}

	Free(ndir);
	Free(nndir);
#undef _PAD_WITH_NA

	return INLA_OK;
}

int inla_output_misc(const char *dir, GMRFLib_ai_misc_output_tp * mo, int ntheta, char **theta_tag, char **theta_from,
		     char **theta_to, double *lc_order, int verbose, inla_tp * mb)
{
	/*
	 * output whatever is requested.... 
	 */
	char *ndir = NULL, *msg = NULL, *nndir = NULL, *nnndir = NULL;
	int i, any;

	if (!mo) {
		return INLA_OK;
	}
	GMRFLib_sprintf(&ndir, "%s/%s", dir, "misc");
	if (inla_mkdir(ndir) != 0) {
		GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", ndir, strerror(errno));
		inla_error_general(msg);
	}

	if (verbose) {
#pragma omp critical (Name_f2b4e6c2e966340fa5f0b42b80cc8d45f1910623)
		{
			printf("\t\tstore misc-output in[%s]\n", ndir);
		}
	}

	GMRFLib_sprintf(&nndir, "%s/theta-tags", ndir);
	{
		FILE *fp = fopen(nndir, "w");
		for (i = 0; i < ntheta; i++) {
			fprintf(fp, "%s\n", theta_tag[i]);
		}
		fclose(fp);
	}
	Free(nndir);

	for (i = any = 0; i < ntheta; i++) {
		any = (any || theta_from[i]);
	}
	if (any) {
		GMRFLib_sprintf(&nndir, "%s/theta-from", ndir);
		FILE *fp = fopen(nndir, "w");
		for (i = 0; i < ntheta; i++) {
			fprintf(fp, "%s\n", theta_from[i]);
		}
		fclose(fp);
	}
	Free(nndir);

	for (i = any = 0; i < ntheta; i++) {
		any = (any || theta_to[i]);
	}
	if (any) {
		GMRFLib_sprintf(&nndir, "%s/theta-to", ndir);
		FILE *fp = fopen(nndir, "w");
		for (i = 0; i < ntheta; i++) {
			fprintf(fp, "%s\n", theta_to[i]);
		}
		fclose(fp);
		Free(nndir);
	}

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "covmat-hyper-internal.dat");
	{
		Dinit(nndir);
		D1W(mo->nhyper);
		for (i = 0; i < ISQR(mo->nhyper); i++) {
			D1W(mo->cov_m[i]);
		}
		Dclose();
	}
	Free(nndir);


	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "covmat-eigenvectors.dat");
	{
		Dinit(nndir);
		D1W(mo->nhyper);
		for (i = 0; i < ISQR(mo->nhyper); i++) {
			D1W(mo->eigenvectors[i]);
		}
		Dclose();
	}
	Free(nndir);

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "covmat-eigenvalues.dat");
	{
		Dinit(nndir);
		D1W(mo->nhyper);
		for (i = 0; i < mo->nhyper; i++) {
			D1W(mo->eigenvalues[i]);
		}
		Dclose();
	}

	Free(nndir);

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "reordering.dat");
	{
		Dinit(nndir);
		for (i = 0; i < mo->len_reordering; i++) {
			D1W(mo->reordering[i] + 1);	       /* yes, use 1-based indexing. */
		}
		Dclose();
	}
	Free(nndir);

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "mode-status.dat");
	{
		FILE *fp = fopen(nndir, "w");
		if (!fp) {
			inla_error_open_file(nndir);
		}
		fprintf(fp, "%1d\n", mo->mode_status);
		fclose(fp);
	}
	Free(nndir);

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "nfunc.dat");
	{
		FILE *fp = fopen(nndir, "w");
		if (!fp) {
			inla_error_open_file(nndir);
		}
		fprintf(fp, "%1d\n", mo->nfunc);
		fclose(fp);
	}
	Free(nndir);

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "log-posterior-mode.dat");
	{
		FILE *fp = fopen(nndir, "w");
		if (!fp) {
			inla_error_open_file(nndir);
		}
		fprintf(fp, "%.16f\n", mo->log_posterior_mode);
		fclose(fp);
	}
	Free(nndir);

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "stdev_corr_pos.dat");
	if (mo->stdev_corr_pos) {
		GMRFLib_matrix_tp *M = Calloc(1, GMRFLib_matrix_tp);
		M->nrow = mo->nhyper;
		M->ncol = 1;
		M->elems = M->nrow * M->ncol;
		M->A = Calloc(mo->nhyper, double);
		Memcpy(M->A, mo->stdev_corr_pos, mo->nhyper * sizeof(double));
		GMRFLib_write_fmesher_file(M, nndir, 0L, -1);
		GMRFLib_matrix_free(M);
	}

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "stdev_corr_neg.dat");
	if (mo->stdev_corr_pos) {
		GMRFLib_matrix_tp *M = Calloc(1, GMRFLib_matrix_tp);
		M->nrow = mo->nhyper;
		M->ncol = 1;
		M->elems = M->nrow * M->ncol;
		M->A = Calloc(mo->nhyper, double);
		Memcpy(M->A, mo->stdev_corr_neg, mo->nhyper * sizeof(double));
		GMRFLib_write_fmesher_file(M, nndir, 0L, -1);
		GMRFLib_matrix_free(M);
	}

	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "opt_directions.dat");
	if (mo->opt_directions) {
		GMRFLib_write_fmesher_file(mo->opt_directions, nndir, 0L, -1);
	}

	if (mo->compute_corr_lin && mo->corr_lin) {
		/*
		 * OOPS: this matrix is in its own internal ordering, so we need to fix it here.
		 */
		assert(lc_order);
		int n = mo->compute_corr_lin;
		int *order = Calloc(n, int);
		int i;

		for (i = 0; i < n; i++) {
			order[i] = (int) lc_order[i] - 1;
		}
		assert(GMRFLib_imin_value(order, n, NULL) == 0);
		assert(GMRFLib_imax_value(order, n, NULL) == n - 1);
		inla_output_matrix(ndir, NULL, "lincomb_derived_correlation_matrix.dat", n, mo->corr_lin, order);
		inla_output_matrix(ndir, NULL, "lincomb_derived_covariance_matrix.dat", n, mo->cov_lin, order);
		Free(order);
	}

	if (mo->configs) {
		FILE *fp;

		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "config");
		if (inla_mkdir(nndir) != 0) {
			GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", nndir, strerror(errno));
			inla_error_general(msg);
		}

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "theta-tag.dat");
		fp = fopen(nnndir, "w");
		for (i = 0; i < mb->ntheta; i++) {
			fprintf(fp, "%s\n", mb->theta_tag[i]);
		}
		fclose(fp);

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "tag.dat");
		fp = fopen(nnndir, "w");
		for (i = 0; i < mb->idx_tot; i++) {
			fprintf(fp, "%s\n", mb->idx_tag[i]);
		}
		fclose(fp);

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "start.dat");
		fp = fopen(nnndir, "w");
		for (i = 0; i < mb->idx_tot; i++) {
			fprintf(fp, "%d\n", mb->idx_start[i]);
		}
		fclose(fp);

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "n.dat");
		fp = fopen(nnndir, "w");
		for (i = 0; i < mb->idx_tot; i++) {
			fprintf(fp, "%d\n", mb->idx_n[i]);
		}
		fclose(fp);

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "configs.dat");
		fp = fopen(nnndir, "wb");
		int id = 0, header = 0, nconfig = 0;
		for (id = 0; id < GMRFLib_MAX_THREADS(); id++) {
			if (mo->configs[id]) {
				nconfig += mo->configs[id]->nconfig;	/* need the accumulated one! */
			}
		}

		for (id = 0; id < GMRFLib_MAX_THREADS(); id++) {
			if (mo->configs[id]) {

				if (!header) {
					header = 1;	       /* do this only once */
					fwrite((void *) &(mo->configs[id]->n), sizeof(int), (size_t) 1, fp);
					fwrite((void *) &(mo->configs[id]->nz), sizeof(int), (size_t) 1, fp);
					fwrite((void *) &(mo->configs[id]->ntheta), sizeof(int), (size_t) 1, fp);
					fwrite((void *) mo->configs[id]->i, sizeof(int), (size_t) mo->configs[id]->nz, fp);	/* 0-based! */
					fwrite((void *) mo->configs[id]->j, sizeof(int), (size_t) mo->configs[id]->nz, fp);	/* 0-based! */
					fwrite((void *) &nconfig, sizeof(int), (size_t) 1, fp);	/* yes!!! */

					if (mo->configs[id]->constr) {
						fwrite((void *) &(mo->configs[id]->constr->nc), sizeof(int), (size_t) 1, fp);
						fwrite((void *) mo->configs[id]->constr->a_matrix, sizeof(double),
						       (size_t) (mo->configs[id]->n * mo->configs[id]->constr->nc), fp);
						fwrite((void *) mo->configs[id]->constr->e_vector, sizeof(double),
						       (size_t) mo->configs[id]->constr->nc, fp);
					} else {
						int zero = 0;
						fwrite((void *) &zero, sizeof(int), (size_t) 1, fp);
					}
				}

				double *off = Calloc(mo->configs[id]->n, double);
				Memcpy(off, &(OFFSET3(0)), (mb->predictor_n + mb->predictor_m) * sizeof(double));

				for (i = 0; i < mo->configs[id]->nconfig; i++) {
					fwrite((void *) &(mo->configs[id]->config[i]->log_posterior), sizeof(double), (size_t) 1, fp);
					fwrite((void *) &(mo->configs[id]->config[i]->log_posterior_orig), sizeof(double), (size_t) 1, fp);
					fwrite((void *) mo->configs[id]->config[i]->theta, sizeof(double), (size_t) mo->configs[id]->ntheta, fp);
					fwrite((void *) mo->configs[id]->config[i]->mean, sizeof(double), (size_t) mo->configs[id]->n, fp);
					fwrite((void *) mo->configs[id]->config[i]->improved_mean, sizeof(double), (size_t) mo->configs[id]->n, fp);
					fwrite((void *) mo->configs[id]->config[i]->skewness, sizeof(double), (size_t) mo->configs[id]->n, fp);
					fwrite((void *) off, sizeof(double), (size_t) mo->configs[id]->n, fp);
					fwrite((void *) mo->configs[id]->config[i]->Q, sizeof(double), (size_t) mo->configs[id]->nz, fp);
					fwrite((void *) mo->configs[id]->config[i]->Qinv, sizeof(double), (size_t) mo->configs[id]->nz, fp);
					fwrite((void *) mo->configs[id]->config[i]->Qprior, sizeof(double), (size_t) mo->configs[id]->n, fp);
				}

				Free(off);
			}
		}
		fclose(fp);
	}

	if (mo->configs_preopt) {

		FILE *fp;
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "config_preopt");
		if (inla_mkdir(nndir) != 0) {
			GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", nndir, strerror(errno));
			inla_error_general(msg);
		}

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "theta-tag.dat");
		fp = fopen(nnndir, "w");
		for (i = 0; i < mb->ntheta; i++) {
			fprintf(fp, "%s\n", mb->theta_tag[i]);
		}
		fclose(fp);

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "tag.dat");
		fp = fopen(nnndir, "w");
		for (i = 0; i < mb->idx_tot; i++) {
			fprintf(fp, "%s\n", mb->idx_tag[i]);
		}
		fclose(fp);

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "start.dat");
		fp = fopen(nnndir, "w");
		for (i = 0; i < mb->idx_tot; i++) {
			fprintf(fp, "%d\n", mb->idx_start[i]);
		}
		fclose(fp);

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "n.dat");
		fp = fopen(nnndir, "w");
		for (i = 0; i < mb->idx_tot; i++) {
			fprintf(fp, "%d\n", mb->idx_n[i]);
		}
		fclose(fp);

		GMRFLib_sprintf(&nnndir, "%s/%s", nndir, "configs.dat");
		fp = fopen(nnndir, "wb");
		int id = 0, header = 0, nconfig = 0;
		for (id = 0; id < GMRFLib_MAX_THREADS(); id++) {
			if (mo->configs_preopt[id]) {
				nconfig += mo->configs_preopt[id]->nconfig;	/* need the accumulated one! */
			}
		}

		for (id = 0; id < GMRFLib_MAX_THREADS(); id++) {
			if (mo->configs_preopt[id]) {
				if (!header) {
					header = 1;	       /* do this only once */
					fwrite((void *) &(mo->configs_preopt[id]->mnpred), sizeof(int), (size_t) 1, fp);
					fwrite((void *) &(mo->configs_preopt[id]->Npred), sizeof(int), (size_t) 1, fp);
					fwrite((void *) &(mo->configs_preopt[id]->n), sizeof(int), (size_t) 1, fp);
					fwrite((void *) &(mo->configs_preopt[id]->nz), sizeof(int), (size_t) 1, fp);
					fwrite((void *) &(mo->configs_preopt[id]->prior_nz), sizeof(int), (size_t) 1, fp);
					fwrite((void *) &(mo->configs_preopt[id]->ntheta), sizeof(int), (size_t) 1, fp);
					fwrite((void *) mo->configs_preopt[id]->i, sizeof(int), (size_t) mo->configs_preopt[id]->nz, fp);	/* 0-based! 
																		 */
					fwrite((void *) mo->configs_preopt[id]->j, sizeof(int), (size_t) mo->configs_preopt[id]->nz, fp);	/* 0-based! 
																		 */
					fwrite((void *) mo->configs_preopt[id]->iprior, sizeof(int), (size_t) mo->configs_preopt[id]->prior_nz, fp);	/* 0-based! 
																			 */
					fwrite((void *) mo->configs_preopt[id]->jprior, sizeof(int), (size_t) mo->configs_preopt[id]->prior_nz, fp);	/* 0-based! 
																			 */
					fwrite((void *) &nconfig, sizeof(int), (size_t) 1, fp);	/* yes!!! */

					if (mo->configs_preopt[id]->constr) {
						fwrite((void *) &(mo->configs_preopt[id]->constr->nc), sizeof(int), (size_t) 1, fp);
						fwrite((void *) mo->configs_preopt[id]->constr->a_matrix, sizeof(double),
						       (size_t) (mo->configs_preopt[id]->n * mo->configs_preopt[id]->constr->nc), fp);
						fwrite((void *) mo->configs_preopt[id]->constr->e_vector, sizeof(double),
						       (size_t) mo->configs_preopt[id]->constr->nc, fp);
					} else {
						int zero = 0;
						fwrite((void *) &zero, sizeof(int), (size_t) 1, fp);
					}

					double *off = Calloc(mo->configs_preopt[id]->mnpred, double);
					Memcpy(off, &(OFFSET3(0)), mo->configs_preopt[id]->mnpred * sizeof(double));
					fwrite((void *) off, sizeof(double), (size_t) mo->configs_preopt[id]->mnpred, fp);
					Free(off);

					char *A, *pA;
					GMRFLib_sprintf(&A, "%s/%s", nndir, "A.dat");
					GMRFLib_write_fmesher_file(mo->configs_preopt[id]->A, A, (long int) 0, -1);
					GMRFLib_sprintf(&pA, "%s/%s", nndir, "pA.dat");
					GMRFLib_write_fmesher_file(mo->configs_preopt[id]->pA, pA, (long int) 0, -1);
				}

				for (i = 0; i < mo->configs_preopt[id]->nconfig; i++) {
					fwrite((void *) &(mo->configs_preopt[id]->config[i]->log_posterior), sizeof(double), (size_t) 1, fp);
					fwrite((void *) &(mo->configs_preopt[id]->config[i]->log_posterior_orig), sizeof(double), (size_t) 1, fp);
					fwrite((void *) mo->configs_preopt[id]->config[i]->theta, sizeof(double),
					       (size_t) mo->configs_preopt[id]->ntheta, fp);
					fwrite((void *) mo->configs_preopt[id]->config[i]->mean, sizeof(double), (size_t) mo->configs_preopt[id]->n,
					       fp);
					fwrite((void *) mo->configs_preopt[id]->config[i]->improved_mean, sizeof(double),
					       (size_t) mo->configs_preopt[id]->n, fp);
					fwrite((void *) mo->configs_preopt[id]->config[i]->Q, sizeof(double), (size_t) mo->configs_preopt[id]->nz,
					       fp);
					fwrite((void *) mo->configs_preopt[id]->config[i]->Qinv, sizeof(double),
					       (size_t) mo->configs_preopt[id]->nz, fp);
					fwrite((void *) mo->configs_preopt[id]->config[i]->Qprior, sizeof(double),
					       (size_t) mo->configs_preopt[id]->prior_nz, fp);

					double output[2] = {
						(mo->configs_preopt[id]->config[i]->cpodens_moments ? 1.0 : 0.0),
						(mo->configs_preopt[id]->config[i]->gcpodens_moments ? 1.0 : 0.0)
					};

					fwrite((void *) output, sizeof(double), (size_t) 2L, fp);
					if (output[0]) {
						fwrite((void *) mo->configs_preopt[id]->config[i]->cpodens_moments, sizeof(double),
						       (size_t) mo->configs_preopt[id]->Npred * 3, fp);
					}
					if (output[1]) {
						fwrite((void *) mo->configs_preopt[id]->config[i]->gcpodens_moments, sizeof(double),
						       (size_t) mo->configs_preopt[id]->Npred * 3, fp);
					}
				}
			}
		}
		fclose(fp);
	}

	return INLA_OK;
}

int inla_output_detail_mlik(const char *dir, GMRFLib_ai_marginal_likelihood_tp * mlik, int verbose)
{
	/*
	 * output whatever is requested.... 
	 */
	char *ndir = NULL, *msg = NULL, *nndir = NULL;
	if (!mlik) {
		return INLA_OK;
	}
	GMRFLib_sprintf(&ndir, "%s/%s", dir, "marginal-likelihood");
	if (inla_mkdir(ndir) != 0) {
		GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", ndir, strerror(errno));
		inla_error_general(msg);
	}
	GMRFLib_sprintf(&nndir, "%s/%s", ndir, "marginal-likelihood.dat");
	Dinit_s(nndir);
	if (verbose) {
#pragma omp critical (Name_9dd76c0b6445188affe98f4c81bec8e5c5e3a95b)
		{
			printf("\t\tstore marginal-likelihood results in[%s]\n", nndir);
		}
	}
	D2W(mlik->marginal_likelihood_integration, mlik->marginal_likelihood_gaussian_approx);
	Dclose();

	Free(ndir);
	Free(nndir);

	return INLA_OK;
}

int inla_output_gitid(const char *dir)
{
	char *nndir = NULL;
	FILE *fp = NULL;

	GMRFLib_sprintf(&nndir, "%s/%s", dir, ".gitid");
	fp = fopen(nndir, "w");
	if (!fp) {
		inla_error_open_file(nndir);
	}
	fprintf(fp, "GitID [%s]\n", GitID);
	fclose(fp);
	Free(nndir);

	return INLA_OK;
}

int inla_output_linkfunctions(const char *dir, inla_tp * mb)
{
	int i, j;
	char *nndir = NULL;
	FILE *fp = NULL;

	GMRFLib_sprintf(&nndir, "%s/%s", dir, "linkfunctions.names");
	fp = fopen(nndir, "w");
	if (!fp) {
		inla_error_open_file(nndir);
	}

	for (j = 0; j < mb->nds; j++) {
		link_func_tp *lf = mb->data_sections[j].predictor_invlinkfunc;

		if (lf == link_probit) {
			fprintf(fp, "probit\n");
		} else if (lf == link_tan) {
			fprintf(fp, "tan\n");
		} else if (lf == link_cloglog) {
			fprintf(fp, "cloglog\n");
		} else if (lf == link_log) {
			fprintf(fp, "log\n");
		} else if (lf == link_logit) {
			fprintf(fp, "logit\n");
		} else if (lf == link_identity) {
			fprintf(fp, "identity\n");
		} else if (lf == link_inverse) {
			fprintf(fp, "inverse\n");
		} else if (lf == link_sslogit) {
			fprintf(fp, "sslogit\n");
		} else if (lf == link_robit) {
			fprintf(fp, "robit\n");
		} else if (lf == link_sn) {
			fprintf(fp, "sn\n");
		} else if (lf == link_logoffset) {
			fprintf(fp, "logoffset\n");
		} else if (lf == link_logitoffset) {
			fprintf(fp, "logitoffset\n");
		} else if (lf == link_qpoisson) {
			fprintf(fp, "quantile\n");
		} else if (lf == link_qbinomial) {
			fprintf(fp, "quantile\n");
		} else if (lf == link_pqbinomial) {
			fprintf(fp, "pquantile\n");
		} else if (lf == link_qweibull) {
			fprintf(fp, "quantile\n");
		} else if (lf == link_qweibull) {
			fprintf(fp, "quantile\n");
		} else if (lf == link_qgamma) {
			fprintf(fp, "quantile\n");
		} else if (lf == link_loga) {
			fprintf(fp, "loga\n");
		} else if (lf == link_power_logit) {
			fprintf(fp, "powerlogit\n");
		} else {
			fprintf(fp, "invalid-linkfunction\n");
		}
	}
	fclose(fp);
	Free(nndir);

	GMRFLib_sprintf(&nndir, "%s/%s", dir, "linkfunctions.link");
	fp = fopen(nndir, "wb");
	if (!fp) {
		inla_error_open_file(nndir);
	}

	/*
	 * need to use double as we need NAN
	 */
	double *idx = Calloc(mb->predictor_ndata, double);
	for (i = 0; i < mb->predictor_ndata; i++) {
		int found;

		if (!ISNAN(mb->predictor_family[i])) {
			idx[i] = (int) mb->predictor_family[i];
		} else {
			idx[i] = NAN;
			for (j = found = 0; j < mb->nds && !found; j++) {
				if (mb->data_sections[j].predictor_invlinkfunc == mb->predictor_invlinkfunc[i]) {
					found = 1;
					idx[i] = j;
				}
			}
		}
	}

	fwrite((void *) &(mb->predictor_ndata), sizeof(int), 1, fp);
	fwrite((void *) idx, sizeof(double), (size_t) mb->predictor_ndata, fp);
	Free(idx);

	fclose(fp);
	Free(nndir);

	return INLA_OK;
}

int inla_output_ok(const char *dir)
{
	char *nndir = NULL;
	FILE *fp = NULL;

	GMRFLib_sprintf(&nndir, "%s/%s", dir, ".ok");
	fp = fopen(nndir, "w");
	if (!fp) {
		inla_error_open_file(nndir);
	}
	fprintf(fp, "1");
	fclose(fp);
	Free(nndir);

	return INLA_OK;
}

int inla_output_detail_theta(const char *dir, double ***theta, int n_theta)
{
	/*
	 * write the mode of theta to the file DIR/.theta_mode. This is used only internally... 
	 */
	int i;
	char *nndir = NULL;

	GMRFLib_sprintf(&nndir, "%s/%s", dir, ".theta_mode");
	Dinit_s(nndir);
	D1W(n_theta);
	for (i = 0; i < n_theta; i++) {
		D1W(theta[i][0][0]);
	}
	Dclose();
	Free(nndir);

	return INLA_OK;
}

int inla_output_detail_x(const char *dir, double *x, int n_x)
{
	/*
	 * write the mode of x to the file DIR/.x_mode. This is used only internally... 
	 */
	int i;
	char *nndir = NULL;

	GMRFLib_sprintf(&nndir, "%s/%s", dir, ".x_mode");
	Dinit(nndir);
	D1W(n_x);
	for (i = 0; i < n_x; i++) {
		D1W(x[i]);
	}
	Dclose();
	Free(nndir);

	return INLA_OK;
}

forceinline int inla_integrate_func(double *d_mean, double *d_stdev, double *d_mode, GMRFLib_density_tp * density, map_func_tp * func,
				    void *func_arg, GMRFLib_transform_array_func_tp * tfunc)
{
	// this require 'i_max', 'np', 'z' and 'ldz'
#define COMPUTE_MODE()							\
	if (d_mode) {							\
		int ii = i_max;						\
		if (ii > 0 && ii < np - 1) {				\
			ii--;						\
		} else if (ii == np - 1) {				\
			ii -= 2;					\
		}							\
		double zm = inla_interpolate_mode(z + ii, ldz + ii);	\
		double zm_orig = zm;					\
		int m = 5;						\
		int low = IMAX(0, i_max - m);				\
		int high = IMIN(np-1, i_max + m);			\
		int len = high - low + 1;				\
		GMRFLib_spline_tp *lds = GMRFLib_spline_create(z + low, ldz + low, len); \
		if (lds == NULL) {					\
			*d_mode = zm_orig;				\
		} else {						\
			double step_size[] = {0.0, 0.0};		\
			for(int iter = 0; iter < 2; iter++) {		\
				step_size[iter] = GMRFLib_spline_eval_deriv(zm, lds) / GMRFLib_spline_eval_deriv2(zm, lds); \
				zm -= step_size[iter];			\
			}						\
			if ((ABS(step_size[0]) >= ABS(step_size[1]))) {	\
				*d_mode = zm;				\
			} else {					\
				/* emergency option */			\
				*d_mode = zm_orig;			\
			}						\
			GMRFLib_spline_free(lds);			\
			}						\
	}

#define _MAP_X(_x_user) (func ? func(_x_user, MAP_FORWARD, func_arg) :	\
			 (tfunc ? tfunc->func(thread_id, _x_user, GMRFLib_TRANSFORM_FORWARD, tfunc->arg, tfunc->cov) : \
			  (_x_user)))

#define _MAP_DX(_x_user) (func ? func(_x_user, MAP_DFORWARD, func_arg) :	\
			  (tfunc ? tfunc->func(thread_id, _x_user, GMRFLib_TRANSFORM_DFORWARD, tfunc->arg, tfunc->cov) : \
			   SIGN(_x_user)))

	int thread_id = 0;

	/*
	 * We need to integrate to get the transformed mean and variance. Use a simple Simpsons-rule.  The simple mapping we did before was not good enough,
	 * obviously... 
	 */
	if (!func && !tfunc) {
		*d_mean = density->user_mean;
		*d_stdev = density->user_stdev;
		if (d_mode) {
			*d_mode = density->user_mode;
		}
		return GMRFLib_SUCCESS;
	}

	if (!density) {
		*d_mean = NAN;
		*d_stdev = NAN;
		if (d_mode) {
			*d_mode = NAN;
		}
		return GMRFLib_SUCCESS;
	}

	int i;
	int np = GMRFLib_INT_NUM_POINTS;
	int npm = GMRFLib_INT_NUM_INTERPOL * np - (GMRFLib_INT_NUM_INTERPOL - 1);
	double low = 0.0, high = 0.0, xval, *xpm = NULL, *ld = NULL, *ldm = NULL, *xp = NULL, *xx = NULL, dx = 0.0, m0, m1, m2, x0, x1, d0, d1;
	double w[2] = { 4.0, 2.0 };

	GMRFLib_ENTER_ROUTINE;

	if (density->type == GMRFLib_DENSITY_TYPE_GAUSSIAN) {
		// then we can do better
		int np = GMRFLib_INT_GHQ_POINTS;
		double *xp = NULL, *wp = NULL;
		double mean = density->user_mean;
		double stdev = density->user_stdev;

		GMRFLib_ghq(&xp, &wp, np);

		Calloc_init(2 * np, 2);
		double *ldz = Calloc_get(np);
		double *z = Calloc_get(np);

		int i_max = 0;
		m1 = 0.0;
		m2 = 0.0;

		if (d_mode) {
			for (int i = 0; i < np; i++) {
				double x = xp[i] * stdev + mean;
				double f = _MAP_X(x);
				double df = _MAP_DX(x);
				m1 += wp[i] * f;
				m2 += wp[i] * SQR(f);

				z[i] = f;
				ldz[i] = -0.5 * SQR(xp[i]) - log(ABS(df));
				if ((i == 0) || ldz[i] > ldz[i_max]) {
					i_max = i;
				}
			}
		} else {
			for (int i = 0; i < np; i++) {
				double x = xp[i] * stdev + mean;
				double f = _MAP_X(x);
				m1 += wp[i] * f;
				m2 += wp[i] * SQR(f);
			}
		}

		*d_mean = m1;
		*d_stdev = sqrt(DMAX(0.0, m2 - SQR(m1)));

		COMPUTE_MODE();
		Calloc_free();
	} else {
		Calloc_init(3 * npm + 4 * np, 7);
		low = density->x_min;
		high = density->x_max;
		dx = (high - low) / (np - 1.0);
		xp = Calloc_get(np);
		ld = Calloc_get(np);

#pragma GCC ivdep
		for (xval = low, i = 0; i < np; xval += dx, i++) {
			xp[i] = xval;
		}
		GMRFLib_evaluate_nlogdensity(ld, xp, np, density);

		int i_max = 0;
		double *z = Calloc_get(np);
		double *ldz = Calloc_get(np);

		if (d_mode) {
			// reusing 'z' for x_user here
			GMRFLib_density_std2user_n(z, xp, np, density);
			for (i = 0; i < np; i++) {
				ldz[i] = ld[i] - log(ABS(_MAP_DX(z[i])));
				z[i] = _MAP_X(z[i]);
				if (i == 0 || ldz[i] > ldz[i_max]) {
					i_max = i;
				}
			}
		}

		// interpolate
		xpm = Calloc_get(npm);
		ldm = Calloc_get(npm);

		if (GMRFLib_INT_NUM_INTERPOL == 3) {
#pragma GCC ivdep
			for (i = 0; i < np - 1; i++) {
				xpm[3 * i + 0] = xp[i];
				xpm[3 * i + 1] = (2.0 * xp[i] + xp[i + 1]) / 3.0;
				xpm[3 * i + 2] = (xp[i] + 2.0 * xp[i + 1]) / 3.0;
			}
#pragma GCC ivdep
			for (i = 0; i < np - 1; i++) {
				ldm[3 * i + 0] = ld[i];
				ldm[3 * i + 1] = (2.0 * ld[i] + ld[i + 1]) / 3.0;
				ldm[3 * i + 2] = (ld[i] + 2.0 * ld[i + 1]) / 3.0;
			}
			xpm[3 * (np - 2) + 3] = xp[np - 1];
			ldm[3 * (np - 2) + 3] = ld[np - 1];
			assert(3 * (np - 2) + 3 == npm - 1);
		} else if (GMRFLib_INT_NUM_INTERPOL == 2) {
#pragma GCC ivdep
			for (i = 0; i < np - 1; i++) {
				xpm[2 * i + 0] = xp[i];
				xpm[2 * i + 1] = (xp[i] + xp[i + 1]) / 2.0;
			}
#pragma GCC ivdep
			for (i = 0; i < np - 1; i++) {
				ldm[2 * i + 0] = ld[i];
				ldm[2 * i + 1] = (ld[i] + ld[i + 1]) / 2.0;
			}
			xpm[2 * (np - 2) + 2] = xp[np - 1];
			ldm[2 * (np - 2) + 2] = ld[np - 1];
			assert(2 * (np - 2) + 2 == npm - 1);
		} else {
			assert(GMRFLib_INT_NUM_INTERPOL == 2 || GMRFLib_INT_NUM_INTERPOL == 3);
		}

		// convert scale
		for (i = 0; i < npm; i++) {
			ldm[i] = exp(ldm[i]);
		}

		xx = Calloc_get(npm);
		GMRFLib_density_std2user_n(xx, xpm, npm, density);
#pragma GCC ivdep
		for (i = 0; i < npm - 1; i++) {
			xx[i] = _MAP_X(xx[i]);
		}

		// compute moments
		d0 = ldm[0];
		d1 = ldm[npm - 1];
		x0 = xx[0];
		x1 = xx[npm - 1];
		m0 = d0 + d1;
		m1 = x0 * d0 + x1 * d1;
		m2 = SQR(x0) * d0 + SQR(x1) * d1;

#pragma GCC ivdep
		for (i = 1; i < npm - 1; i++) {
			double d = ldm[i] * w[(i - 1) % 2];
			double x = xx[i];
			double x2 = x * x;

			m0 += d;
			m1 += x * d;
			m2 += x2 * d;
		}
		m1 /= m0;
		m2 /= m0;

		*d_mean = m1;
		*d_stdev = sqrt(DMAX(0.0, m2 - SQR(m1)));

		COMPUTE_MODE();
		Calloc_free();
	}

#undef COMPUTE_MODE
#undef _MAP_X

	GMRFLib_LEAVE_ROUTINE;
	return GMRFLib_SUCCESS;
}

int inla_output_detail(const char *dir, GMRFLib_density_tp ** density, double *locations, int n, int nrep, Output_tp * output, const char *sdir,
		       int return_marginals,
		       // Either this
		       map_func_tp * func, void *func_arg,
		       // .. or this
		       GMRFLib_transform_array_func_tp ** tfunc,
		       // 
		       const char *tag, const char *modelname, int UNUSED(verbose))
{
	int thread_id = 0;

#define _FUNC (func ? func : NULL)
#define _FUNC_ARG (func ? func_arg : NULL)
#define _TFUNC(_idx) (tfunc ? tfunc[_idx] : NULL)
#define _MAP_DENS(_dens, _x_user, _idx) (func ? (_dens)/(ABS(func(_x_user, MAP_DFORWARD, func_arg))) : \
					(tfunc ? (_dens)/(ABS(tfunc[_idx]->func(thread_id, _x_user, GMRFLib_TRANSFORM_DFORWARD, tfunc[_idx]->arg, tfunc[_idx]->cov))) : \
					 (_dens)))
#define _MAP_X(_x_user, _idx) (func ? func(_x_user, MAP_FORWARD, func_arg) : \
			      (tfunc ? tfunc[_idx]->func(thread_id, _x_user, GMRFLib_TRANSFORM_FORWARD, tfunc[_idx]->arg, tfunc[_idx]->cov) : \
			       (_x_user)))
#define _MAP_INCREASING(_idx) (func ? func(0.0, MAP_INCREASING, func_arg) : \
			      (tfunc ? tfunc[_idx]->func(thread_id, 0.0, GMRFLib_TRANSFORM_INCREASING, tfunc[_idx]->arg, tfunc[_idx]->cov) : 1))
#define _MAP_DECREASING(_idx) (!_MAP_INCREASING(_idx))
#define GMRFLib_MAX_THREADS_LOCAL() (n > 1024 ? GMRFLib_MAX_THREADS() : 1)

	GMRFLib_ENTER_ROUTINE;

	char *ndir = NULL, *ssdir = NULL, *msg = NULL, *nndir = NULL;
	double x, p = 0.0, xp;
	int i, j, ndiv;
	int add_empty = 1;
	int plain = ((func || tfunc) ? 0 : 1);

	assert(nrep > 0);
	ndiv = n / nrep;

	double *d_mode = Calloc(n, double);
	for (int i = 0; i < n; i++)
		d_mode[i] = NAN;

	ssdir = GMRFLib_strdup(sdir);
	GMRFLib_sprintf(&ndir, "%s/%s", dir, ssdir);
	if (inla_mkdir(ndir) != 0) {
		GMRFLib_sprintf(&msg, "fail to create directory [%s]: %s", ndir, strerror(errno));
		inla_error_general(msg);
	}
	Free(ssdir);

	if (1) {
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "N");
		FILE *fp = fopen(nndir, "w");
		if (!fp) {
			inla_error_open_file(nndir);
		}
		fprintf(fp, "%d\n", n);
		fclose(fp);
		Free(nndir);
	}

	if (tag) {
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "TAG");
		FILE *fp = fopen(nndir, "w");
		if (!fp) {
			inla_error_open_file(nndir);
		}
		fprintf(fp, "%s\n", tag);
		fclose(fp);
		Free(nndir);
	}

	if (modelname) {
		GMRFLib_sprintf(&nndir, "%s/%s", ndir, "MODEL");
		FILE *fp = fopen(nndir, "w");
		if (!fp) {
			inla_error_open_file(nndir);
		}
		fprintf(fp, "%s\n", modelname);
		fclose(fp);
		Free(nndir);
	}

	if (output->summary) {
		if (inla_computed(density, n)) {
			GMRFLib_sprintf(&nndir, "%s/%s", ndir, "summary.dat");
			Dinit_r(n, 3, nndir);
#define CODE_BLOCK							\
			for (int i = 0; i < n; i++) {			\
				double dm = 0.0, ds = 0.0;		\
				if (density[i]) {			\
					inla_integrate_func(&dm, &ds, &d_mode[i], density[i], _FUNC, _FUNC_ARG, _TFUNC(i)); \
					if (locations) {		\
						D3W_r(i, 0, locations[i % ndiv], dm, ds); \
					} else {			\
						D3W_r(i, 0, i, dm, ds);	\
					}				\
				} else {				\
					if (locations) {		\
						D3W_r(i, 0, locations[i % ndiv], NAN, NAN); \
					} else {			\
						D3W_r(i, 0, i, NAN, NAN); \
					}				\
				}					\
			}

			RUN_CODE_BLOCK(GMRFLib_MAX_THREADS_LOCAL(), 0, 0);
#undef CODE_BLOCK

			Dclose_r();
			Free(nndir);
		}
	}

	if (return_marginals || strncmp("hyperparameter", sdir, 13) == 0) {
		if (inla_computed(density, n)) {
			GMRFLib_sprintf(&nndir, "%s/%s", ndir, "marginal-densities.dat");
			int mm = 0;
			GMRFLib_density_layout_x(NULL, &mm, NULL);
			Dinit_r(n, 2 + mm * 2, nndir);
#define CODE_BLOCK							\
			for (int i = 0; i < n; i++) {			\
				int off = 0;				\
				int nn = mm;				\
				int nn_new;				\
				double *x_user = CODE_BLOCK_WORK_PTR(0); \
				double *dens = CODE_BLOCK_WORK_PTR(1); \
				double *xx = CODE_BLOCK_WORK_PTR(2); \
				if (density[i]) {			\
					if (locations) {		\
						D1W_r(i, off, locations[i % ndiv]); \
					} else {			\
						D1W_r(i, off, i);	\
					}				\
					off++;				\
									\
					GMRFLib_density_layout_x(xx, &nn_new, density[i]); assert(nn_new == nn); \
					GMRFLib_density_std2user_n(x_user, xx, nn, density[i]); \
					GMRFLib_evaluate_ndensity(dens, xx, nn, density[i]); \
					D1W_r(i, off, nn);		\
					off++;				\
									\
					if (plain) {			\
						for (int ii = 0; ii < nn; ii++) { \
							double dens_user = dens[ii] / density[i]->std_stdev; \
							D2W_r(i, off, x_user[ii], dens_user); \
							off += 2;	\
						}			\
					} else {			\
						for (int ii = 0; ii < nn; ii++) { \
							double dens_user = dens[ii] / density[i]->std_stdev; \
							D2W_r(i, off, _MAP_X(x_user[ii], i), _MAP_DENS(dens_user, x_user[ii], i)); \
							off += 2;	\
						}			\
					}				\
				} else {				\
					if (locations) {		\
						D1W_r(i, off, locations[i % ndiv]); \
					} else {			\
						D1W_r(i, off, i);	\
					}				\
					off++;				\
									\
					D1W_r(i, off, nn);		\
					off++;				\
									\
					for (int ii = 0; ii < nn; ii++) { \
						D2W_r(i, off, NAN, NAN); \
						off += 2;		\
					}				\
				}					\
			}

			// RUN_CODE_BLOCK(GMRFLib_MAX_THREADS_LOCAL(), 3, mm);
			RUN_CODE_BLOCK(1, 3, mm);
#undef CODE_BLOCK
			Dclose_r();
			Free(nndir);
		}
	}

	if (output->kld) {
		/*
		 * this is ok for _FUNC as well, since the the KL is invariant for parameter transformations. 
		 */
		if (inla_computed(density, n)) {
			GMRFLib_sprintf(&nndir, "%s/%s", ndir, "symmetric-kld.dat");
			Dinit(nndir);
			for (i = 0; i < n; i++) {
				GMRFLib_density_tp *gd = NULL;
				if (density[i]) {
					double kld;
					GMRFLib_density_create_normal(&gd, 0.0, 1.0, density[i]->std_mean, density[i]->std_stdev, GMRFLib_FALSE);

					if (G.fast_mode) {
						GMRFLib_mkld_sym(&kld, gd, density[i]);
					} else {
						GMRFLib_kld_sym(&kld, gd, density[i]);
					}
					if (locations) {
						D1W(locations[i % ndiv]);
					} else {
						D1W(i);
					}
					D1W(kld);
				} else {
					if (add_empty) {
						if (locations) {
							D1W(locations[i % ndiv]);
						} else {
							D1W(i);
						}
						D1W(NAN);
					}
				}
				GMRFLib_free_density(gd);
			}
			Dclose();
			Free(nndir);
		}
	}

	if (output->nquantiles) {
		if (inla_computed(density, n)) {
			double x_user;
			GMRFLib_sprintf(&nndir, "%s/%s", ndir, "quantiles.dat");
			Dinit(nndir);
			for (i = 0; i < n; i++) {
				if (density[i]) {
					if (locations) {
						D1W(locations[i % ndiv]);
					} else {
						D1W(i);
					}
					D1W(output->nquantiles);
					for (j = 0; j < output->nquantiles; j++) {
						p = output->quantiles[j];
						if (_MAP_INCREASING(i)) {
							GMRFLib_density_Pinv(&xp, p, density[i]);
						} else {
							GMRFLib_density_Pinv(&xp, 1.0 - p, density[i]);
						}
						x_user = GMRFLib_density_std2user(xp, density[i]);
						D2W(p, _MAP_X(x_user, i));
					}
				} else {
					if (add_empty) {
						if (locations) {
							D1W(locations[i % ndiv]);
						} else {
							D1W(i);
						}
						D1W(output->nquantiles);
						for (j = 0; j < output->nquantiles; j++) {
							D2W(NAN, NAN);
						}
					}
				}
			}
			Dclose();
			Free(nndir);
		}
	}

	if (output->mode) {
		if (inla_computed(density, n)) {
			GMRFLib_sprintf(&nndir, "%s/%s", ndir, "mode.dat");
			Dinit(nndir);
			for (i = 0; i < n; i++) {
				if (density[i]) {
					if (locations) {
						D1W(locations[i % ndiv]);
					} else {
						D1W(i);
					}
					D3W(1.0, NAN, d_mode[i]);
				} else {
					if (add_empty) {
						if (locations) {
							D1W(locations[i % ndiv]);
						} else {
							D1W(i);
						}
						D3W(1.0, NAN, NAN);
					}
				}
			}
			Dclose();
			Free(nndir);
		}
	}

	if (output->ncdf) {
		if (inla_computed(density, n)) {
			GMRFLib_sprintf(&nndir, "%s/%s", ndir, "cdf.dat");
			Dinit(nndir);
			for (i = 0; i < n; i++) {
				if (density[i]) {
					if (locations) {
						D1W(locations[i % ndiv]);
					} else {
						D1W(i);
					}
					D1W(output->ncdf);
					for (j = 0; j < output->ncdf; j++) {
						xp = output->cdf[j];
						x = GMRFLib_density_user2std(xp, density[i]);
						GMRFLib_density_P(&p, x, density[i]);
						if (_MAP_DECREASING(i)) {
							p = 1.0 - p;
						}
						D2W(_MAP_X(xp, i), p);
					}
				} else {
					if (add_empty) {
						if (locations) {
							D1W(locations[i % ndiv]);
						} else {
							D1W(i);
						}
						D1W(output->ncdf);
						for (j = 0; j < output->ncdf; j++) {
							D2W(NAN, NAN);
						}
					}
				}
			}
			Dclose();
			Free(nndir);
		}
	}

	Free(d_mode);

#undef _MAP_DENS
#undef _MAP_X
#undef _MAP_INCREASING
#undef _MAP_DECREASING
#undef _FUNC
#undef _FUNC_ARG
#undef _TFUNC
#undef GMRFLib_MAX_THREADS_LOCAL

	GMRFLib_LEAVE_ROUTINE;

	return INLA_OK;
}

void inla_signal(int sig)
{
#if !defined(WINDOWS)
	fflush(stdout);
	switch (sig) {
	case SIGUSR1:
	case SIGUSR2:
		break;
	default:
		_exit(sig);
		break;
	}
#endif
	return;
}

int inla_endian(void)
{
	int x = 1;
	return ((*(char *) &x) ? INLA_LITTLE_ENDIAN : INLA_BIG_ENDIAN);
}

int inla_divisible(int n, int by)
{
	/*
	 * same function as inla.divisi 
	 */

	if (by == 0)
		return GMRFLib_TRUE;

	if (by > 0)
		return (by * (n / by) == n ? GMRFLib_TRUE : GMRFLib_FALSE);
	else
		return ((-by) * (n / (-by)) == n ? GMRFLib_FALSE : GMRFLib_TRUE);
}

int inla_qinv(const char *filename, const char *constrfile, const char *outfile)
{
	/*
	 * Compute the marginal variances for Cij file in FILENAME and output on stdout, the marginal variances 
	 */
	int i, j, jj, k;

	GMRFLib_tabulate_Qfunc_tp *tab;
	GMRFLib_graph_tp *graph;
	GMRFLib_problem_tp *problem = NULL;
	GMRFLib_constr_tp *constr = NULL;
	GMRFLib_matrix_tp *constr_x = NULL;
	FILE *fp;

	GMRFLib_tabulate_Qfunc_from_file(&tab, &graph, filename, -1, NULL);
	fp = fopen(constrfile, "r");
	if (fp) {
		fclose(fp);
		constr_x = GMRFLib_read_fmesher_file(constrfile, 0L, SEEK_CUR);
		if (constr_x->A[0] > 0) {
			constr = Calloc(1, GMRFLib_constr_tp);
			constr->nc = (int) constr_x->A[0];
			constr->a_matrix = &constr_x->A[1];
			constr->e_vector = &constr_x->A[constr->nc * graph->n + 1];
			GMRFLib_prepare_constr(constr, graph, 1);
		}
	}

	if (GMRFLib_smtp == GMRFLib_SMTP_PARDISO) {
		GMRFLib_reorder = GMRFLib_REORDER_PARDISO;
		GMRFLib_openmp->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
		GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_DEFAULT, NULL, NULL);
	} else if (GMRFLib_smtp == GMRFLib_SMTP_BAND) {
		GMRFLib_reorder = GMRFLib_REORDER_BAND;
	} else {
		GMRFLib_reorder = GMRFLib_REORDER_DEFAULT;
		GMRFLib_optimize_reorder(graph, NULL, NULL, NULL);
	}
	int thread_id = 0;
	assert(omp_get_thread_num() == 0);
	GMRFLib_init_problem(thread_id, &problem, NULL, NULL, NULL, NULL, graph, tab->Qfunc, tab->Qfunc_arg, constr);
	GMRFLib_Qinv(problem);

	/*
	 * write a fmesher file and just pass the filename 
	 */
	GMRFLib_matrix_tp *M = Calloc(1, GMRFLib_matrix_tp);

	M->nrow = graph->n;
	M->ncol = graph->n;
	M->elems = 0;
	for (i = 0; i < graph->n; i++) {
		M->elems += 1 + graph->nnbs[i];
	}

	M->i = Calloc(M->elems, int);
	M->j = Calloc(M->elems, int);
	M->values = Calloc(M->elems, double);

	k = 0;
	for (i = 0; i < graph->n; i++) {
		M->i[k] = i;
		M->j[k] = i;
		M->values[k] = *GMRFLib_Qinv_get(problem, i, i);
		k++;

		for (jj = 0; jj < graph->nnbs[i]; jj++) {
			j = graph->nbs[i][jj];
			M->i[k] = i;
			M->j[k] = j;
			M->values[k] = *GMRFLib_Qinv_get(problem, i, j);
			k++;
		}
	}
	assert(k == M->elems);

	GMRFLib_write_fmesher_file(M, outfile, (long int) 0, -1);

	return 0;
}

int inla_qsolve(const char *Qfilename, const char *Afilename, const char *Bfilename, const char *method)
{
	/*
	 * Solve Q X = B, L^T X = B, or L X = B
	 */

	GMRFLib_tabulate_Qfunc_tp *tab;
	GMRFLib_graph_tp *graph;
	GMRFLib_problem_tp *problem = NULL;

	/*
	 * I need B to be dense 
	 */
	GMRFLib_matrix_tp *B = GMRFLib_read_fmesher_file(Bfilename, (long int) 0, -1);
	assert(B->i == NULL);				       /* I want B as dense matrix */

	GMRFLib_tabulate_Qfunc_from_file(&tab, &graph, Qfilename, -1, NULL);
	if (GMRFLib_smtp == GMRFLib_SMTP_PARDISO) {
		GMRFLib_reorder = GMRFLib_REORDER_PARDISO;
		GMRFLib_pardiso_set_nrhs(IMIN(GMRFLib_MAX_THREADS(), B->ncol));
		GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_DEFAULT, NULL, NULL);
	} else if (GMRFLib_smtp == GMRFLib_SMTP_BAND) {
		GMRFLib_reorder = GMRFLib_REORDER_BAND;
	} else if (GMRFLib_smtp == GMRFLib_SMTP_TAUCS) {
		if (GMRFLib_reorder == GMRFLib_REORDER_DEFAULT) {
			GMRFLib_optimize_reorder(graph, NULL, NULL, NULL);
		}
	} else {
		assert(0 == 1);
	}

	int thread_id = 0;
	assert(omp_get_thread_num() == 0);
	GMRFLib_init_problem(thread_id, &problem, NULL, NULL, NULL, NULL, graph, tab->Qfunc, tab->Qfunc_arg, NULL);
	assert(problem->n == B->nrow);

	if (!strcasecmp(method, "solve")) {
		GMRFLib_solve_llt_sparse_matrix(B->A, B->ncol, &(problem->sub_sm_fact), problem->sub_graph);
	} else if (!strcasecmp(method, "forward")) {
		GMRFLib_solve_l_sparse_matrix(B->A, B->ncol, &(problem->sub_sm_fact), problem->sub_graph);
	} else if (!strcasecmp(method, "backward")) {
		GMRFLib_solve_lt_sparse_matrix(B->A, B->ncol, &(problem->sub_sm_fact), problem->sub_graph);
	} else {
		assert(0 == 1);
	}

	B->iA = NULL;
	GMRFLib_write_fmesher_file(B, Afilename, (long int) 0, -1);

	return 0;
}

int inla_qsample(const char *filename, const char *outfile, const char *nsamples, const char *rngfile,
		 const char *samplefile, const char *bfile, const char *mufile, const char *constrfile,
		 const char *meanfile, const char *selectionfile, int verbose)
{
	int output_every = 100;
	double t_ref = GMRFLib_cpu(), t_reff = GMRFLib_cpu();
	size_t siz, ret;
	char *state;
	FILE *fp;

	if (verbose) {
		fprintf(stderr, "inla_qsample: start pre...\n");
	}
	fp = fopen(rngfile, "rb");
	if (fp) {
		fseek(fp, 0L, SEEK_END);
		siz = ftell(fp) + 1;
		rewind(fp);
		state = Calloc(siz, char);
		ret = fread((void *) state, (size_t) 1, siz, fp);
		if (ret > 0) {
			GMRFLib_uniform_setstate((void *) state);
		}
		fclose(fp);
		Free(state);
	}

	int i, ns;
	GMRFLib_tabulate_Qfunc_tp *tab;
	GMRFLib_graph_tp *graph;
	GMRFLib_problem_tp *problem = NULL;

	GMRFLib_matrix_tp *M = Calloc(1, GMRFLib_matrix_tp), *S = NULL, *b = NULL, *mu = NULL, *constr_x = NULL, *selection = NULL;
	GMRFLib_constr_tp *constr = NULL;

	inla_sread_ints(&ns, 1, nsamples);
	GMRFLib_tabulate_Qfunc_from_file(&tab, &graph, filename, -1, NULL);

	fp = fopen(samplefile, "r");
	if (fp) {
		fclose(fp);				       /* file exists */
		S = GMRFLib_read_fmesher_file(samplefile, 0L, SEEK_CUR);
	}

	fp = fopen(bfile, "r");
	if (fp) {
		fclose(fp);				       /* file exists */
		b = GMRFLib_read_fmesher_file(bfile, 0L, SEEK_CUR);
	}

	fp = fopen(mufile, "r");
	if (fp) {
		fclose(fp);				       /* file exists */
		mu = GMRFLib_read_fmesher_file(mufile, 0L, SEEK_CUR);
	}

	fp = fopen(selectionfile, "r");
	if (fp) {
		fclose(fp);				       /* file exists */
		selection = GMRFLib_read_fmesher_file(selectionfile, 0L, SEEK_CUR);
	}

	fp = fopen(constrfile, "r");
	if (fp) {
		fclose(fp);
		constr_x = GMRFLib_read_fmesher_file(constrfile, 0L, SEEK_CUR);
		if (constr_x->A[0] > 0) {
			constr = Calloc(1, GMRFLib_constr_tp);
			constr->nc = (int) constr_x->A[0];
			constr->a_matrix = &constr_x->A[1];
			constr->e_vector = &constr_x->A[constr->nc * graph->n + 1];
			GMRFLib_prepare_constr(constr, graph, 1);
		}
	}

	if (GMRFLib_smtp == GMRFLib_SMTP_PARDISO) {
		GMRFLib_reorder = GMRFLib_REORDER_PARDISO;
		GMRFLib_openmp->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
		GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_DEFAULT, NULL, NULL);
	} else if (GMRFLib_smtp == GMRFLib_SMTP_BAND) {
		GMRFLib_reorder = GMRFLib_REORDER_BAND;
	} else {
		GMRFLib_reorder = GMRFLib_REORDER_DEFAULT;
		GMRFLib_optimize_reorder(graph, NULL, NULL, NULL);
	}

	if (verbose) {
		fprintf(stderr, "inla_qsample: end pre %.2fs\n", GMRFLib_cpu() - t_ref);
	}
	t_ref = GMRFLib_cpu();
	if (verbose) {
		fprintf(stderr, "inla_qsample: start prepare the model...\n");
	}

	int thread_id = 0;
	assert(omp_get_thread_num() == 0);
	GMRFLib_init_problem(thread_id, &problem, NULL, (b ? b->A : NULL), NULL, (mu ? mu->A : NULL), graph, tab->Qfunc, tab->Qfunc_arg, constr);

	if (verbose) {
		fprintf(stderr, "inla_qsample: end prepare the model %.2fs\n", GMRFLib_cpu() - t_ref);
	}
	t_ref = GMRFLib_cpu();

	if (selection) {
		M->nrow = selection->nrow + 1;
	} else {
		M->nrow = graph->n + 1;
	}
	M->ncol = ns;
	M->elems = M->ncol * M->nrow;
	M->A = Calloc(M->nrow * M->ncol, double);

	if (verbose) {
		fprintf(stderr, "inla_qsample: start to sample %1d samples...\n", ns);
	}

	if ((GMRFLib_smtp == GMRFLib_SMTP_PARDISO)) {
		for (i = 0; i < ns; i++) {
			if (!S) {
				GMRFLib_sample(problem);
			} else {
				Memcpy(problem->sample, &(S->A[i * S->nrow]), S->nrow * sizeof(double));
			}
			GMRFLib_evaluate(problem);

			if (!selection) {
				Memcpy(&(M->A[i * M->nrow]), problem->sample, graph->n * sizeof(double));
			} else {
				for (int ii = 0; ii < selection->nrow; ii++) {
					M->A[i * M->nrow + ii] = problem->sample[(int) selection->A[ii]];
				}
			}
			M->A[(i + 1) * M->nrow - 1] = problem->sub_logdens;

			if (verbose && (!((i + 1) % output_every) || i == (ns - 1))) {
				fprintf(stderr, "inla_qsample: done with %1d samples, with %.2f samples/s and %.2fs in total\n",
					i + 1, (i + 1.0) / (GMRFLib_cpu() - t_ref), (GMRFLib_cpu() - t_ref));
			}
		}
	} else {
		GMRFLib_problem_tp **problems = Calloc(GMRFLib_openmp->max_threads_outer, GMRFLib_problem_tp *);
#pragma omp parallel for num_threads(GMRFLib_openmp->max_threads_outer)
		for (int i = 0; i < ns; i++) {
			int thread = omp_get_thread_num();
			if (problems[thread] == NULL) {
				problems[thread] = GMRFLib_duplicate_problem(problem, 0, 1, 1);
			}
			if (!S) {
				GMRFLib_sample(problems[thread]);
			} else {
				Memcpy(problems[thread]->sample, &(S->A[i * S->nrow]), S->nrow * sizeof(double));
			}
			GMRFLib_evaluate(problems[thread]);

			if (!selection) {
				Memcpy(&(M->A[i * M->nrow]), problems[thread]->sample, graph->n * sizeof(double));
			} else {
				for (int ii = 0; ii < selection->nrow; ii++) {
					M->A[i * M->nrow + ii] = problems[thread]->sample[(int) selection->A[ii]];
				}
			}
			M->A[(i + 1) * M->nrow - 1] = problems[thread]->sub_logdens;
		}
	}

	if (verbose) {
		fprintf(stderr, "inla_qsample: end in %.2fs with %.2f samples/s\n", GMRFLib_cpu() - t_ref, (double) ns / (GMRFLib_cpu() - t_ref));
	}
	t_ref = GMRFLib_cpu();
	if (verbose) {
		fprintf(stderr, "inla_qsample: start post...\n");
	}

	GMRFLib_write_fmesher_file(M, outfile, (long int) 0, -1);

	GMRFLib_matrix_tp *CM = Calloc(1, GMRFLib_matrix_tp);
	CM->nrow = M->nrow - 1;
	CM->ncol = 1;
	CM->elems = CM->ncol * CM->nrow;
	CM->A = Calloc(CM->nrow * CM->ncol, double);
	if (!selection) {
		Memcpy(CM->A, problem->mean_constr, graph->n * sizeof(double));
	} else {
		for (int ii = 0; ii < selection->nrow; ii++) {
			CM->A[ii] = problem->mean_constr[(int) selection->A[ii]];
		}
	}
	GMRFLib_write_fmesher_file(CM, meanfile, (long int) 0, -1);

	state = (char *) GMRFLib_rng_getstate(&siz);
	fp = fopen(rngfile, "wb");
	fwrite((void *) state, (size_t) 1, siz, fp);
	fclose(fp);

	if (verbose) {
		fprintf(stderr, "inla_qsample: end post %.2fs\n", GMRFLib_cpu() - t_ref);
		fprintf(stderr, "inla_qsample: total time %.2fs\n", GMRFLib_cpu() - t_reff);
	}

	return 0;
}

int inla_finn(const char *UNUSED(filename))
{
	return 0;
}

int inla_qreordering(const char *filename)
{
	/*
	 * return the rordering either given or computed
	 */
	int i;
	GMRFLib_graph_tp *graph;

	if (GMRFLib_is_fmesher_file(filename, (long int) 0, -1) == GMRFLib_SUCCESS) {
		GMRFLib_tabulate_Qfunc_tp *qtab = NULL;
		GMRFLib_tabulate_Qfunc_from_file(&qtab, &graph, filename, -1, NULL);
		GMRFLib_free_tabulate_Qfunc(qtab);
	} else {
		GMRFLib_graph_read(&graph, filename);
	}

	if (G.reorder < 0) {
		GMRFLib_optimize_reorder(graph, NULL, NULL, NULL);
	}
	GMRFLib_sm_fact_tp sm_fact;
	sm_fact.smtp = GMRFLib_SMTP_TAUCS;
	GMRFLib_compute_reordering(&sm_fact, graph, NULL);

	printf("QREORDERING\n");			       /* code used when the output is parsed */
	printf("%s\n", GMRFLib_reorder_name(GMRFLib_reorder));
	printf("%1d\n", GMRFLib_reorder);
	for (i = 0; i < graph->n; i++) {
		printf("%1d\n", sm_fact.remap[i]);
	}

	return 0;
}

int inla_read_graph(const char *filename)
{
	/*
	 * Read a graph and print it on stdio. Compute also the connected components.
	 */
	GMRFLib_graph_tp *graph = NULL;

	GMRFLib_graph_read(&graph, filename);
	GMRFLib_graph_write2(stdout, graph);

	int *cc, i;
	cc = GMRFLib_graph_cc(graph);
	for (i = 0; i < graph->n; i++)
		printf("%d\n", cc[i]);
	Free(cc);

	return 0;
}

inla_file_contents_tp *inla_read_file_contents(const char *filename)
{
	/*
	 * just read the hole file into on long character vector 
	 */

	FILE *fp;
	long len;

	if (!filename) {
		return NULL;
	}
	fp = fopen(filename, "rb");
	if (!fp) {
		return NULL;
	}
	fseek(fp, 0L, SEEK_END);
	len = ftell(fp);
	assert(len > 0L);

	inla_file_contents_tp *fc = Calloc(1, inla_file_contents_tp);
	fc->contents = Calloc((size_t) len, char);

	rewind(fp);
	fc->len = fread(fc->contents, (size_t) 1, (size_t) len, fp);
	assert(fc->len == (size_t) len);
	fclose(fp);

	return fc;
}

int inla_write_file_contents(const char *filename, inla_file_contents_tp * fc)
{
	/*
	 * just dump the file contents to the new file 
	 */

	if (!fc) {
		return INLA_OK;
	}

	FILE *fp;
	size_t len;

	fp = fopen(filename, "wb");
	assert(fp);
	len = fwrite(fc->contents, (size_t) 1, fc->len, fp);
	assert(len == fc->len);

	fclose(fp);
	return INLA_OK;
}

int inla_besag_scale(int thread_id, inla_besag_Qfunc_arg_tp * arg, int adj, int verbose)
{
	// if VERBOSE, write out the scalings.
	inla_besag_Qfunc_arg_tp *def = Calloc(1, inla_besag_Qfunc_arg_tp);
	int i, k, *cc = NULL, n = arg->graph->n;
	const int debug = 0;
	arg->prec_scale = Calloc(arg->graph->n, double);

	if (debug)
		P(adj);

	if (adj) {
		// use the cc in the graph
		cc = GMRFLib_graph_cc(arg->graph);
	} else {
		// treat the whole graph as one cc, with index 0
		cc = Calloc(n, int);
	}

	if (!adj) {
		// special for nnbs=0
		for (i = 0; i < n; i++) {
			if (arg->graph->nnbs[i] == 0) {
				cc[i] = 1;		       // so it will be disabled in the computations below
			}
		}
	}
	// if !adj, then we will not use the nodes where nnbs=0, and we do this by forcing ncc=0,
	// since cc[i]=1 for those nodes as set above.
	int ncc;
	ncc = (adj ? 1 + GMRFLib_imax_value(cc, arg->graph->n, NULL) : 1);
	if (debug)
		P(ncc);

	// work with each cc at the time
	for (k = 0; k < ncc; k++) {
		if (debug) {
			printf("Working with cc %d\n", k);
		}

		GMRFLib_constr_tp *constr = NULL;
		GMRFLib_make_empty_constr(&constr);

		char *remove = Calloc(n, char);
		int num = 0;
		for (i = num = 0; i < n; i++) {
			if (cc[i] == k) {
				remove[i] = 0;
				num++;
			} else {
				remove[i] = 1;
			}
		}
		if (debug) {
			printf("\tsize is %d\n", num);
		}

		if (num == 1) {
			// only one node in this component. then we know that the precision i 1.
			for (i = 0; i < n; i++) {
				if (cc[i] == k) {
					arg->prec_scale[i] = -1.0;	/* this is code for treating this case specially */
				}
			}
			if (verbose)
				printf("\t\tconnected component[%1d] size[%1d] scale[%.6g]\n", k, num, -1.0);
		} else {
			// compute the subgraph and find the scaling for this connected component
			GMRFLib_graph_comp_subgraph(&(def->graph), arg->graph, remove, NULL);

			constr->nc = 1;
			constr->a_matrix = Calloc(def->graph->n, double);
			for (i = 0; i < def->graph->n; i++) {
				constr->a_matrix[i] = 1.0;
			}
			constr->e_vector = Calloc(1, double);
			GMRFLib_prepare_constr(constr, def->graph, GMRFLib_TRUE);

			GMRFLib_problem_tp *problem = NULL;
			int retval = GMRFLib_SUCCESS, ok = 0, num_try = 0, num_try_max = 100;
			GMRFLib_error_handler_tp *old_handler = GMRFLib_set_error_handler_off();

			double *c = Calloc(def->graph->n, double), eps = GMRFLib_eps(0.5);
			for (i = 0; i < def->graph->n; i++) {
				c[i] = eps;
			}

			while (!ok) {
				retval =
				    GMRFLib_init_problem(thread_id, &problem, NULL, NULL, c, NULL, def->graph, Qfunc_besag, (void *) def, constr);
				switch (retval) {
				case GMRFLib_EPOSDEF:
				{
					for (i = 0; i < def->graph->n; i++) {
						c[i] *= 10.0;
					}
					problem = NULL;
				}
					break;

				case GMRFLib_SUCCESS:
				{
					ok = 1;
				}
					break;
				default:
				{
					GMRFLib_set_error_handler(old_handler);
					GMRFLib_ERROR(retval);
					abort();
				}
					break;
				}

				if (++num_try >= num_try_max) {
					FIXME("This should not happen. Contact developers...");
					abort();
				}
			}
			GMRFLib_set_error_handler(old_handler);
			GMRFLib_Qinv(problem);

			if (debug)
				P(def->graph->n);
			double sum = 0.0, value;

			for (i = 0; i < def->graph->n; i++) {
				sum += log(*(GMRFLib_Qinv_get(problem, i, i)));
			}
			value = exp(sum / def->graph->n);
			if (debug) {
				printf("\tprec_scale is %f\n", value);
			}
			for (i = 0; i < n; i++) {
				if (cc[i] == k) {
					arg->prec_scale[i] = value;
				}
			}
			if (verbose)
				printf("\t\tconnected component[%1d] size[%1d] scale[%.6g]\n", k, def->graph->n, value);

			GMRFLib_graph_free(def->graph);
			GMRFLib_free_problem(problem);
			GMRFLib_free_constr(constr);
			Free(c);
		}
	}

	if (!adj) {
		for (i = 0; i < n; i++) {
			if (cc[i] > 0) {
				assert(arg->graph->nnbs[i] == 0);
				arg->prec_scale[i] = -1.0;     /* this is code for treating this case specially */
			}
		}
	}

	Free(def);
	Free(cc);

	return GMRFLib_SUCCESS;
}

double inla_update_density(double *theta, inla_update_tp * arg)
{
	/*
	 * joint posterior for theta
	 */

	int i, corr = (arg->stdev_corr_pos && arg->stdev_corr_neg);
	double value = 0.0, sd, log_nc, update_dens, *z;

	z = Calloc(arg->ntheta, double);
	GMRFLib_ai_theta2z(z, arg->ntheta, arg->theta_mode, theta, arg->sqrt_eigen_values, arg->eigen_vectors);

	for (i = 0; i < arg->ntheta; i++) {
		if (corr) {
			sd = (z[i] > 0 ? arg->stdev_corr_pos[i] : arg->stdev_corr_neg[i]);
		} else {
			sd = 1.0;
		}
		value += -0.5 * SQR(z[i] / sd);
	}

	/*
	 * this is the normalizing constant
	 */
	log_nc = 0.5 * arg->ntheta * log(2.0 * M_PI);
	for (i = 0; i < arg->ntheta; i++) {
		if (corr) {
			log_nc += -0.5 * (2.0 * log(gsl_vector_get(arg->sqrt_eigen_values, (unsigned int) i)) +
					  0.5 * (log(SQR(arg->stdev_corr_pos[i])) + log(SQR(arg->stdev_corr_neg[i]))));
		} else {
			log_nc += -0.5 * (2.0 * log(gsl_vector_get(arg->sqrt_eigen_values, (unsigned int) i)));
		}
	}

	/*
	 * and then the log-joint-posterior-density
	 */
	update_dens = value - log_nc;

	Free(z);
	return update_dens;
}

double inla_dmatern_cf(double dist, double range, double nu)
{
	double kappa = sqrt(8.0 * nu) / range;
	double dd = kappa * dist;
	double cf;

	cf = (dist <= 1e-12 ? 1.0 : 1.0 / pow(2.0, nu - 1.0) / MATHLIB_FUN(gammafn) (nu) * pow(dd, nu) * MATHLIB_FUN(bessel_k) (dd, nu, 1.0));

	return (cf);
}

int inla_R(char **argv)
{
	while (*argv) {
		fprintf(stderr, "R> source file [%s]...\n", *argv);
		inla_R_source(*argv);
		argv++;
	}
	exit(0);

	return GMRFLib_SUCCESS;
}

int inla_fgn(char *infile, char *outfile)
{
	double H, H_intern, *res;
	int i, k, len, K, nH;

	GMRFLib_matrix_tp *Hm = GMRFLib_read_fmesher_file(infile, 0, -1);
	assert(Hm->ncol == 1);
	nH = Hm->nrow - 1;
	assert(nH >= 1);
	K = (int) GMRFLib_matrix_get(0, 0, Hm);		       // first element is K, then H's.
	len = 2 * K + 1;
	res = Calloc(nH * len, double);
	for (i = k = 0; i < nH; i++, k += len) {
		H = res[k] = GMRFLib_matrix_get(i + 1, 0, Hm);
		H_intern = map_H(H, MAP_BACKWARD, NULL);
		inla_fgn_get(&res[k + 1], &res[k + 1 + K], H_intern, K);
	}
	GMRFLib_matrix_tp *M = Calloc(1, GMRFLib_matrix_tp), *M_t;
	M->ncol = nH;
	M->nrow = len;
	M->elems = M->nrow * M->ncol;
	M->A = res;
	M_t = GMRFLib_matrix_transpose(M);
	GMRFLib_write_fmesher_file(M_t, outfile, 0L, -1);
	GMRFLib_matrix_free(M);
	GMRFLib_matrix_free(M_t);

	return GMRFLib_SUCCESS;
}

int loglikelihood_testit(int UNUSED(thread_id), double *logll, double *x, int m, int UNUSED(idx), double *x_vec, double *UNUSED(y_cdf),
			 void *UNUSED(arg))
{
	if (m == 0) {
		return GMRFLib_LOGL_COMPUTE_CDF;
	}

	int i;
	double a = 1.0, b = 2.0, c = 3.0, d = 4.0, x0;
	x0 = x_vec[0];

	if (m > 0) {
		for (i = 0; i < m; i++) {
			double xx = x[i] - x0;
			logll[i] = a + b * xx - c / 2.0 * SQR(xx) + d / 6.0 * gsl_pow_3(xx);
		}
	} else {
		abort();
	}
	return GMRFLib_SUCCESS;
}

int inla_testit_timer(void)
{
	GMRFLib_ENTER_ROUTINE;
	int ret = system("sleep 1");
	if (ret != 0)
		exit(1);
	GMRFLib_LEAVE_ROUTINE;
	return 0;
}

int inla_check_pardiso(void)
{
	// check if PARDISO-lib is installed and working
	if (GMRFLib_pardiso_check_install(1, 1) == GMRFLib_SUCCESS) {
		printf("SUCCESS: PARDISO IS INSTALLED AND WORKING\n");
		fflush(stdout);
	} else {
		printf("FAILURE: PARDISO IS NOT INSTALLED OR NOT WORKING\n");
		fflush(stdout);
		GMRFLib_pardiso_check_install(0, 0);
	}
	return GMRFLib_SUCCESS;
}

double inla_sn_intercept(double intern_quantile, double skew)
{
	// testing only
	double a3[2] = { 0.0, 0.0 }, val;
	a3[0] = gsl_pow_3(inla_pc_sn_skew2alpha(skew));
	val = map_invsn(intern_quantile, MAP_BACKWARD, (void *) a3);
	P(intern_quantile);
	P(skew);
	P(inla_pc_sn_skew2alpha(skew));
	P(a3[0]);
	P(val);

	return (0);

	a3[0] = gsl_pow_3(inla_pc_sn_skew2alpha(skew));
	return (map_invsn(intern_quantile, MAP_FORWARD, (void *) a3));
}

int inla_reset(void)
{
	// reset static variables various places as need need to call _ai_INLA() twice in preopt_mode

	GMRFLib_opt_exit();
	GMRFLib_pardiso_exit();
	R_rgeneric_cputime = 0.0;

	return GMRFLib_SUCCESS;
}

double testit_Qfunc(int UNUSED(thread_id), int i, int j, double *UNUSED(values), void *UNUSED(arg))
{
	return (i == j ? 100.0 : -1.0);
}

int testit(int argc, char **argv)
{
	int test_no = -1;
	char **args = NULL;
	int nargs = 0, i, j;

	if (argc > 0) {
		test_no = atoi(argv[0]);
		nargs = argc - 1;
		args = &(argv[1]);
	}
	printf("test_no = %1d  nargs = %1d\n", test_no, nargs);
	for (i = 0; i < nargs; i++) {
		printf("\targs[%d] = %s\n", i, args[i]);
	}

	switch (test_no) {
	case -1:
	case 0:
	{
		double s, phi, mu, y, shape, rate, q, mmu, scale, alpha;
		s = 1.2;
		phi = 2.3;
		mu = 3.4;
		y = 4.5;
		shape = s * phi;
		rate = s * phi / mu;
		scale = 1.0 / rate;
		alpha = 0.5;
		alpha = MATHLIB_FUN(pgamma) (y, shape, scale, 1, 0);
		q = MATHLIB_FUN(qgamma) (alpha, shape, 1.0, 1, 0);
		mmu = y * s * phi / q;
		printf("alpha %f q %f mu %f mmu %f diff %f\n", alpha, q, mu, mmu, mu - mmu);

		P(MATHLIB_FUN(pgamma) (y, shape, scale, 1, 0));
		P(MATHLIB_FUN(qgamma) (alpha, shape, 1.0, 1, 0));
		P(gsl_cdf_gamma_P(y, shape, scale));
		P(gsl_cdf_gamma_Pinv(alpha, shape, 1.0));

		exit(0);
	}
		break;

	case 1:
	{
		for (int i = 0; i < 10; i++) {
			P(GMRFLib_rng_uniform());
		}
	}
		break;

	case 2:
	{
		double par[] = { 0.8, 0.5 };
		double theta = 1.234;

		P(priorfunc_pc_cor1(&theta, par));
		exit(0);
	}
		break;

	case 3:
	{
		double x;
		double lambda = 1.2345;
		P(lambda);
		for (x = 0.1; x < 10; x += 0.1) {
			printf("F(%g) = %.12g\n", x, gsl_sf_gamma_inc_Q(x, lambda));
			printf("F(%g) = %.12g\n", x, gsl_sf_gamma_inc(x, lambda) / gsl_sf_gamma(x));
			printf("F(%g) = %.12g\n", x, gsl_sf_gamma_inc(x, lambda) / exp(gsl_sf_lngamma(x)));
		}
		exit(0);
	}
		break;

	case 4:
	{
		double lambda = 1.234;
		double x;
		for (x = -5; x < 5; x += 0.1) {
			printf("%f %f\n", x, priorfunc_pc_gammacount(&x, &lambda));
		}
		exit(0);
	}
		break;

	case 5:
	{
		// this force a race-condition
#define NN 10
		int x[NN];
#pragma omp parallel for
		for (int i = 0; i < NN; i++) {
			*(x + i) = i;
		}
		P((double) x[0]);
		P((double) x[NN - 1]);
#undef NN
	}
		break;

	case 6:
	{
		double y, lambda;
		for (lambda = 1.1; lambda < 5.1; lambda++) {
			for (y = 2.2; y < 8.3; y++) {
				printf("y %f lambda %f cdf cdf.deriv = %f %f\n",
				       y, lambda, inla_pcontpois(y, lambda), inla_pcontpois_deriv(y, lambda));
			}
		}

		double quantile, alpha;
		for (quantile = 1.1; quantile < 10; quantile++) {
			for (alpha = 0.1; alpha < 0.99; alpha += 0.1) {
				printf("quantile=%f alpha=%f eta=%f\n", quantile, alpha, inla_qcontpois_eta(quantile, alpha, NULL));
			}
		}

		exit(0);
	}
		break;

	case 7:
	{

		inla_fgn_arg_tp *arg = Calloc(1, inla_fgn_arg_tp);
		arg->n = 10;
		arg->k = 3;
		arg->N = arg->n * (arg->k + 1);
		arg->prec_eps = 100;

		GMRFLib_graph_tp *g;
		inla_make_fgn_graph(&g, arg);
		GMRFLib_printf_graph(stdout, g);
		exit(0);
	}
		break;

	case 8:
	{
#pragma omp critical (Name_5f0e63e7e6c4127b4e2e50c9002880440da56212)
		{
#define _MODEL "rgeneric.model"
			printf("test rgeneric\n");
			inla_R_library("INLA");
			inla_R_load("rgeneric.RData");
			inla_R_source("/home/hrue/p/inla/r-inla/rinla/R/rgeneric.R");

			double theta[] = { 1.0, 2.0 };
			int ntheta = sizeof(theta) / sizeof(double);
			int i;

			int n_out;
			double *x_out;

#define _PPP(cmd)							\
			printf("\ncmd [%s] n_out [%1d]\n", cmd, n_out);	\
			for(i=0; i<n_out; i++) {			\
				printf("x[ %1d ] = %g\n", i, x_out[i]);	\
			};						\
			Free(x_out)

			inla_R_rgeneric(&n_out, &x_out, "graph", _MODEL, &ntheta, theta);
			_PPP("graph");

			inla_R_rgeneric(&n_out, &x_out, "Q", _MODEL, &ntheta, theta);
			_PPP("Q");

			inla_R_rgeneric(&n_out, &x_out, "initial", _MODEL, &ntheta, theta);
			_PPP("initial");

			inla_R_rgeneric(&n_out, &x_out, "log.norm.const", _MODEL, &ntheta, theta);
			_PPP("log.norm.const");

			inla_R_rgeneric(&n_out, &x_out, "log.prior", _MODEL, &ntheta, theta);
			_PPP("log.prior");

			inla_R_rgeneric(&n_out, &x_out, "quit", _MODEL, &ntheta, theta);
			_PPP("quit");
		}

#undef _MODEL
#undef _PPP
	}
		break;

	case 9:
	{
		printf("test R, source %s\n", argv[0]);
		inla_R_source(argv[0]);

		double x[] = { 1.123, 2.234, 3.345 };
		int nx = sizeof(x) / sizeof(x[1]);

		double *xx = NULL;
		int nxx;
		int i;

		inla_R_assign("x", &nx, x);
		inla_R_get(&nxx, &xx, "x");
		for (i = 0; i < nxx; i++) {
			printf("xx[%1d] = %f\n", i, xx[i]);
		}

		exit(0);
	}
		break;

	case 10:
	{
		// checking the expression and the jacobian for this prior
		double x, xx, xxx, dx = 0.01, sum = 0.0, parameters[2], low = -4.001, high = 4.0;
		int i;

		parameters[0] = 2.123;			       /* lambda */
		parameters[1] = 1;			       /* p */
		sum = 0;
#pragma omp parallel for private(i, x, xx) reduction(+: sum)
		for (i = 0; i < (int) ((high - low) / dx + 1); i++) {
			x = low + dx * i;
			double x2[1];
			x2[0] = x;
			sum += exp(priorfunc_pc_ar(x2, parameters));
		}
		P(sum * pow(dx, 1.0));

		parameters[0] = 2.123;			       /* lambda */
		parameters[1] = 2;			       /* p */
		sum = 0;
#pragma omp parallel for private(i, x, xx) reduction(+: sum)
		for (i = 0; i < (int) ((high - low) / dx + 1); i++) {
			x = low + dx * i;
			for (xx = low; xx < high; xx += dx) {
				double x2[2];
				x2[0] = x;
				x2[1] = xx;
				sum += exp(priorfunc_pc_ar(x2, parameters));
			}
		}
		P(sum * pow(dx, 2.0));

		parameters[0] = 3.123;			       /* lambda */
		parameters[1] = 3;			       /* p */
		sum = 0;
#pragma omp parallel for private(i, x, xx, xxx) reduction(+: sum)
		for (i = 0; i < (int) ((high - low) / dx + 1); i++) {
			x = low + dx * i;
			for (xx = low; xx < high; xx += dx) {
				for (xxx = low; xxx < high; xxx += dx) {
					double x2[3];
					x2[0] = x;
					x2[1] = xx;
					x2[2] = xxx;
					sum += exp(priorfunc_pc_ar(x2, parameters));
				}
			}
		}
		P(sum * pow(dx, 3.0));
	}
		break;

	case 11:
	{
		// test the new R-interface

		printf("TESTIT!\n");
		inla_R_source("example-code.R");
		double x[] = { 1, 2, 3 };
		int nx = sizeof(x) / sizeof(x[1]);

		double *xx = NULL;
		int nxx;
		int i;
#pragma omp parallel for
		for (int i = 0; i < 10; i++) {
			inla_R_funcall2(&nxx, &xx, "lprior2", "ThisIsTheTag", &nx, x);
		}
		inla_R_funcall2(&nxx, &xx, "lprior2", NULL, &nx, x);

		for (i = 0; i < nxx; i++) {
			printf("lprior2[%1d] = %f\n", i, xx[i]);
		}

		exit(0);
	}
		break;

	case 12:
	{
		// testing spde3

		inla_spde3_tp *smodel = NULL;
		int i, j, jj, n, t, p;
		int thread_id = 0;

		inla_spde3_build_model(thread_id, &smodel, "./", "identity");
		n = smodel->graph->n;
		p = smodel->ntheta;

		GMRFLib_matrix_tp *theta = GMRFLib_read_fmesher_file("theta", 0, -1);

		for (i = 0; i < p; i++) {
			printf("theta[%1d] = %g\n", i, GMRFLib_matrix_get(i, 0, theta));
			for (t = 0; t < GMRFLib_MAX_THREADS(); t++) {
				smodel->theta[i][t][0] = GMRFLib_matrix_get(i, 0, theta);
			}
		}

		GMRFLib_matrix_tp *Q = Calloc(1, GMRFLib_matrix_tp);
		Q->nrow = Q->ncol = n;
		Q->elems = ISQR(n);
		Q->A = Calloc(ISQR(n), double);

		int ntimes = 10, itim;

		for (itim = 0; itim < ntimes; itim++) {
#pragma omp parallel for private(i, jj, j)
			for (i = 0; i < n; i++) {
				int thread_id = omp_get_thread_num();
				Q->A[i + i * n] = inla_spde3_Qfunction(thread_id, i, i, NULL, (void *) smodel);
				for (jj = 0; jj < smodel->graph->nnbs[i]; jj++) {
					j = smodel->graph->nbs[i][jj];
					Q->A[i + j * n] = Q->A[j + i * n] = inla_spde3_Qfunction(thread_id, i, j, NULL, (void *) smodel);
				}
			}
		}
		GMRFLib_write_fmesher_file(Q, "Q", 0, -1);
	}
		break;

	case 13:
	{
		int n = 100;
		if (nargs) {
			n = atoi(args[0]);
		}

		printf("Build matrix with dim = %1d\n", n);
		double *A = Calloc(SQR(n), double);
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				int k = i + j * n;
				int kk = j + i * n;
				A[k] = A[kk] = GMRFLib_uniform();
			}
		}
		for (int i = 0; i < n; i++) {
			int k = i + i * n;
			A[k] = n + 1.0;
		}

		printf("Call ...ensure_spd ");
		double tref = GMRFLib_cpu();
		GMRFLib_ensure_spd(A, n, FLT_EPSILON, NULL);
		printf("%f seconds\n", GMRFLib_cpu() - tref);

		printf("Call ...chol ");
		tref = GMRFLib_cpu();
		double *chol = NULL;
		GMRFLib_comp_chol_general(&chol, A, n, NULL, 1);
		printf("%f seconds\n", GMRFLib_cpu() - tref);

		Free(A);
		Free(chol);
	}
		break;

	case 14:
	{
		double a_data[] = { 0.18, 0.41, 0.14, 0.51,
			0.60, 0.24, 0.30, 0.13,
			0.57, 0.99, 0.97, 0.19,
			0.96, 0.58, 0.66, 0.85
		};

		gsl_matrix_view m = gsl_matrix_view_array(a_data, 4, 4);
		gsl_matrix *A = GMRFLib_gsl_duplicate_matrix(&m.matrix);

		GMRFLib_printf_gsl_matrix(stdout, A, " %.12f");
		printf("\n");
		GMRFLib_gsl_ginv(A, GMRFLib_eps(0.5), -1);
		GMRFLib_printf_gsl_matrix(stdout, A, " %.12f");

		exit(EXIT_SUCCESS);
	}
		break;

	case 15:
	{
		P(sizeof(void *));
		P(sizeof(double));
		P(sizeof(double *));
		P(sizeof(int *));
	}
		break;

	case 16:
	{
		ar_test1();
		exit(EXIT_SUCCESS);
	}
		break;

	case 17:
		break;

	case 18:
	{
		double x[] = { -2, -1, 0, 1, 2 };
		double ld[] = { -2.0, -0.5, 0.0, -0.5, -2.0 };
		double m = 0.0, sd = 0.0;
		GMRFLib_vb_fit_gaussian(5, x, ld, &m, &sd);
		P(m);
		P(sd);
	}
		break;

	case 19:
	{
		printf("physical= %1d logical= %1d\n", UTIL_countPhysicalCores(), UTIL_countLogicalCores());
	}
		break;

	case 20:
	{
		inla_file_contents_tp *fc;

		fc = inla_read_file_contents("aa.dat");
		inla_write_file_contents("bb.dat", fc);
		exit(EXIT_SUCCESS);
	}
		break;

	case 21:
	{
		GMRFLib_matrix_tp *M = NULL;

		int i, j, k, kk;

		printf("read file %s\n", argv[3]);
		M = GMRFLib_read_fmesher_file(argv[3], 0L, -1);

		if (1)
			if (M->i)
				for (k = 0; k < M->elems; k++)
					printf("k %d %d %d %g\n", k, M->i[k], M->j[k], M->values[k]);

		if (M->graph) {
			printf("n %d\n", M->graph->n);
			for (k = 0; k < M->graph->n; k++) {
				printf("%d nnbs %d:\n", k, M->graph->nnbs[k]);
				for (kk = 0; kk < M->graph->nnbs[k]; kk++)
					printf("\t\t%d\n", M->graph->nbs[k][kk]);
			}
		}

		for (i = 0; i < M->nrow; i++)
			for (j = 0; j < M->ncol; j++)
				printf("%d %d %g\n", i, j, GMRFLib_matrix_get(i, j, M));

		printf("\n\ntranspose...\n\n\n");
		GMRFLib_matrix_tp *N = GMRFLib_matrix_transpose(M);

		if (1)
			if (N->i)
				for (k = 0; k < N->elems; k++)
					printf("k %d %d %d %g\n", k, N->i[k], N->j[k], N->values[k]);

		if (1)
			for (i = 0; i < N->nrow; i++)
				for (j = 0; j < N->ncol; j++)
					printf("%d %d %g\n", i, j, GMRFLib_matrix_get(i, j, N));

		if (N->graph) {
			printf("n %d\n", N->graph->n);
			for (k = 0; k < N->graph->n; k++) {
				printf("%d nnbs %d:\n", k, N->graph->nnbs[k]);
				for (kk = 0; kk < N->graph->nnbs[k]; kk++)
					printf("\t\t%d\n", N->graph->nbs[k][kk]);
			}
		}
		GMRFLib_matrix_free(M);
		GMRFLib_matrix_free(N);
	}
		break;

	case 22:
	{
		double x;
		for (x = -100.0; x < 100.0; x = x + 0.1) {
			printf("x %.12g log(Phi(x)) %.12g %.12g\n", x, inla_log_Phi_fast(x), inla_log_Phi(x));
		}
		exit(0);
	}
		break;

	case 23:
	{
		// test ghq
#define FUN0(x) (1)
#define FUN1(x) (x)
#define FUN2(x) SQR(x)
#define FUN3(x) (SQR(x)*(x))
#define FUN4(x) SQR(SQR(x))

		double *xp, *wp, integral0 = 0, integral1 = 0, integral2 = 0, integral3 = 0, integral4 = 0.0;
		int np = GMRFLib_INT_GHQ_POINTS, i;
		if (nargs) {
			np = atoi(args[0]);
		}
		GMRFLib_ghq(&xp, &wp, np);
		for (i = 0; i < np; i++) {
			integral0 += wp[i] * FUN0(xp[i]);
			integral1 += wp[i] * FUN1(xp[i]);
			integral2 += wp[i] * FUN2(xp[i]);
			integral3 += wp[i] * FUN3(xp[i]);
			integral4 += wp[i] * FUN4(xp[i]);
			printf("x[%1d]= %.12f  w[%1d] = %.12f\n", i, xp[i], i, wp[i]);
		}
		printf("integral of x^0 = 1 ?  %.12f\n", integral0);
		printf("integral of x^1 = 0 ?  %.12f\n", integral1);
		printf("integral of x^2 = 1 ?  %.12f\n", integral2);
		printf("integral of x^3 = 0 ?  %.12f\n", integral3);
		printf("integral of x^4 = 3 ?  %.12f\n", integral4);

		double mean = GMRFLib_uniform();
		double stdev = exp(GMRFLib_uniform());
		GMRFLib_ghq_ms(&xp, &wp, np, mean, stdev);
		integral0 = 0;
		integral1 = 0;
		integral2 = 0;
		integral3 = 0;
		integral4 = 0;
		for (i = 0; i < np; i++) {
			double xx = (xp[i] - mean) / stdev;
			integral0 += wp[i] * FUN0(xx);
			integral1 += wp[i] * FUN1(xx);
			integral2 += wp[i] * FUN2(xx);
			integral3 += wp[i] * FUN3(xx);
			integral4 += wp[i] * FUN4(xx);
			printf("x[%1d]= %.12f  w[%1d] = %.12f\n", i, xp[i], i, wp[i]);
		}
		printf("integral of z^0 = %.12f ?  %.12f\n", 1.0, integral0);
		printf("integral of z^1 = %.12f ?  %.12f\n", 0.0, integral1);
		printf("integral of z^2 = %.12f ?  %.12f\n", 1.0, integral2);
		printf("integral of z^3 = %.12f ?  %.12f\n", 0.0, integral3);
		printf("integral of z^4 = %.12f ?  %.12f\n", 3.0, integral4);

		double xx = 2 * (GMRFLib_uniform() - 0.5);

		printf("compute CDF xx=%f true = %.12f\n", xx, inla_Phi(xx));

		integral0 = 0.0;
		for (i = 0; i < np; i++) {
			if (xp[i] < xx) {
				integral0 += wp[i];
			} else {
				integral0 += wp[i] * (1.0 - (xx - xp[i - 1]) / (xp[i] - xp[i - 1]));
				break;
			}
		}
		printf("estimate %.12f\n", integral0);

		exit(0);
#undef FUN2
#undef FUN4
	}
		break;

	case 24:
	{
		int n = 1024 * 1024 * 32;
		double *xx = Calloc(n, double);
		double *yy = Calloc(n, double);

		for (int i = 0; i < n; i++) {
			xx[i] = GMRFLib_uniform();
			yy[i] = GMRFLib_uniform();
		}

		int one = 1;
		double sum1 = 0.0, sum2 = 0.0;
		double tref1 = 0.0, tref2 = 0.0;
		for (int k = 0; k < 10; k++) {
			sum1 = sum2 = 0.0;
			tref1 -= GMRFLib_cpu();
#pragma GCC ivdep
			for (int i = 0; i < n; i++) {
				sum1 += xx[i] * yy[i];
			}
			tref1 += GMRFLib_cpu();
			tref2 -= GMRFLib_cpu();
			sum2 += ddot_(&n, xx, &one, yy, &one);
			tref2 += GMRFLib_cpu();
			if (k == 0)
				P(sum1 - sum2);
		}
		printf("loop %.3f ddot %.3f (%.3f, %.3f)\n", tref1, tref2, tref1 / (tref1 + tref2), tref2 / (tref1 + tref2));
		Free(xx);
		Free(yy);
	}
		break;

	case 25:
	{
		int n = 256 * 512;
		double *xx = Calloc(n, double);

		for (int i = 0; i < n; i++) {
			xx[i] = GMRFLib_uniform();
		}

		GMRFLib_idxval_tp *h = NULL;
		for (int i = 0, j = 0; i < n; i++) {
			j += 1 + (GMRFLib_uniform() < 0.9 ? 0.0 : (int) (GMRFLib_uniform() * 8));
			if (j >= n)
				break;
			GMRFLib_idxval_add(&h, j, xx[j]);
		}
		GMRFLib_idxval_sort(h);
		assert(h);
		P(h->g_n);
		P(h->n / h->g_n);
		double sum1 = 0.0, sum2 = 0.0;
		double tref1 = 0.0, tref2 = 0.0;
		for (int k = 0; k < 10000; k++) {
			sum1 = sum2 = 0.0;
			tref1 -= GMRFLib_cpu();
			sum1 = GMRFLib_dot_product_serial(h, xx);
			tref1 += GMRFLib_cpu();
			tref2 -= GMRFLib_cpu();
			sum2 = GMRFLib_dot_product_group(h, xx);
			tref2 += GMRFLib_cpu();
			if (ABS(sum1 - sum2) > 1e-8) {
				P(sum1);
				P(sum2);
				exit(88);
			}
		}
		printf("serial %.3f group %.3f (%.3f, %.3f)\n", tref1, tref2, tref1 / (tref1 + tref2), tref2 / (tref1 + tref2));
		Free(xx);
	}
		break;

	case 26:
	{
		int nrow = 10;
		GMRFLib_vmatrix_tp *m = NULL;
		GMRFLib_vmatrix_init(&m, nrow, NULL);

		for (int i = 0; i < nrow; i++) {
			for (int j = i; j < nrow; j++) {
				double *val = Calloc(1, double);
				*val = (double) j;
				GMRFLib_vmatrix_set(m, i, j, val);
			}
		}
		for (int i = 0; i < nrow; i++) {
			for (int j = i; j < nrow; j++) {
				double *val = GMRFLib_vmatrix_get(m, i, j);
				printf("i %d j %d val %g\n", i, j, *val);
			}
		}
		GMRFLib_vmatrix_free(m, 1);
	}
		break;

	case 27:
	{
		double eps = atof(args[0]);
		for (double val = 0.99; val < 1.0; val += eps / 1000.0) {
			int eq = ISEQUAL_x(val, 1.0, eps);
			if (eq) {
				printf("eps %.12f val %.12f %d\n", eps, val, ISEQUAL_x(val, 1.0, eps));
				break;
			}
		}
	}
		break;

	case 28:
	{
		double range = 1.9;
		double nu = 0.94;
		double kappa = sqrt(8.0 * nu) / range;
		double d, dd;
		double corf;

		for (d = 0.0; d < 3.0 * range; d += range / 10.0) {
			dd = kappa * d;
			corf = (dd <= 0.0 ? 1.0 : 1.0 / pow(2.0, nu - 1.0) / MATHLIB_FUN(gammafn) (nu) *
				pow(dd, nu) * MATHLIB_FUN(bessel_k) (dd, nu, 1.0));
			printf("dmatern nu %.3f range %.3f dist %.3f dd %.5f corf %.5f\n", nu, range, d, dd, corf);
		}
	}
		break;

	case 29:
	{
		GMRFLib_idx_tp *h = NULL;
		int i;

		for (i = 0; i < 10; i++)
			GMRFLib_idx_add(&h, i);
		GMRFLib_idx_prune(h);
		GMRFLib_idx_printf(stdout, h, "IDX-test");
		GMRFLib_idx_free(h);

		GMRFLib_idx2_tp *h2 = NULL;
		GMRFLib_idx2_create(&h2);
		for (i = 0; i < 10; i++)
			GMRFLib_idx2_add(&h2, i, -i);
		GMRFLib_idx2_prune(h2);
		GMRFLib_idx2_printf(stdout, h2, "IDX2-test");
		GMRFLib_idx2_free(h2);

		GMRFLib_val_tp *hh = NULL;
		for (i = 0; i < 10; i++)
			GMRFLib_val_add(&hh, (double) i);
		GMRFLib_val_prune(hh);
		GMRFLib_val_printf(stdout, hh, "VAL-test");
		GMRFLib_val_free(hh);

		GMRFLib_idxval_tp *h3 = NULL;
		for (i = 0; i < 10; i++)
			GMRFLib_idxval_add(&h3, i, (double) i);
		GMRFLib_idxval_prune(h3);
		GMRFLib_idxval_printf(stdout, h3, "VAL-test");
		GMRFLib_idxval_free(h3);
	}
		break;

	case 30:
	{
		double ta[] = {
			2.8457954755, -0.4965452301, -1.645446141, -1.128319792, 1.262602638,
			-0.4965452301, 9.5273534221, 6.998890429, 4.924730852, -2.979131713,
			-1.6454461413, 6.9988904291, 6.648388858, 3.208607495, -2.034296532,
			-1.1283197920, 4.9247308523, 3.208607495, 3.515410801, -2.453892405,
			1.2626026384, -2.9791317133, -2.034296532, -2.453892405, 1.833029623
		};

		gsl_matrix_view m = gsl_matrix_view_array(ta, 5, 5);
		gsl_matrix *A = GMRFLib_gsl_duplicate_matrix(&m.matrix);

		GMRFLib_printf_gsl_matrix(stdout, A, " %.12f");
		printf("\n");
		gsl_matrix *B = GMRFLib_gsl_low_rank(A, 1.0E-8);
		GMRFLib_printf_gsl_matrix(stdout, B, " %.12f");
		gsl_matrix_free(A);
		gsl_matrix_free(B);
	}
		break;

	case 31:
	{
		double xx, df;
		Link_param_tp *param = Calloc(1, Link_param_tp);
		int thread_id = 0;
		assert(omp_get_thread_num() == 0);

		for (df = 4.0; df <= 125; df += 60.0) {
			printf("df = %.4g\n", df);
			for (xx = 0.01; xx <= 0.99; xx += 0.1) {
				double cdf = MATHLIB_FUN(pt) (xx, df, 1, 0);
				double icdf = MATHLIB_FUN(qt) (cdf, df, 1, 0);
				double ldens = MATHLIB_FUN(dt) (xx, df, 1);
				printf("\txx= %.6f  cdf= %.6f icdf= %.6f ldens = %.6f\n", xx, cdf, icdf, ldens);
			}
		}
		for (df = 4.0; df <= 125; df += 60.0) {
			double scale = sqrt(df / (df - 2.0));
			printf("Normalized df = %.4g\n", df);
			for (xx = 0.01; xx <= 0.99; xx += 0.1) {
				double cdf = MATHLIB_FUN(pt) (xx / scale, df, 1, 0);
				double icdf = MATHLIB_FUN(qt) (cdf, df, 1, 0) * scale;
				double ldens = MATHLIB_FUN(dt) (xx / scale, df, 1) - log(scale);
				printf("\txx= %.6f  cdf= %.6f icdf= %.6f ldens = %.6f\n", xx, cdf, icdf, ldens);
			}
		}

		for (df = 4.0; df <= 125; df += 60.0) {
			printf("Link probit\n");
			HYPER_NEW(param->dof_intern, log(df - 2.0));

			for (xx = 0.01; xx <= 0.99; xx += 0.1) {
				double back, forw, dforw;
				back = link_probit(thread_id, xx, MAP_BACKWARD, (void *) param, NULL);
				forw = link_probit(thread_id, back, MAP_FORWARD, (void *) param, NULL);
				dforw = link_probit(thread_id, back, MAP_DFORWARD, (void *) param, NULL);
				printf("\txx= %.6f  back= %.6f forw= %.6f dforw = %.6f\n", xx, back, forw, dforw);
			}

			printf("Link df = %.4g\n", df);
			for (xx = 0.01; xx <= 0.99; xx += 0.1) {
				double back, forw, dforw;
				back = link_robit(thread_id, xx, MAP_BACKWARD, (void *) param, NULL);
				forw = link_robit(thread_id, back, MAP_FORWARD, (void *) param, NULL);
				dforw = link_robit(thread_id, back, MAP_DFORWARD, (void *) param, NULL);
				printf("\txx= %.6f  back= %.6f forw= %.6f dforw = %.6f\n", xx, back, forw, dforw);
			}
		}
	}
		break;

	case 32:
	{
		double xx, skew, intercept;
		skew = (!args[0] ? 0.25 : atof(args[0]));
		intercept = (!args[1] ? 0.5 : atof(args[1]));
		printf("skew = %g\n", skew);
		printf("intercept = %g\n", intercept);
		double range = 9.0, dx = 0.1;
		double *arg[2];
		arg[0] = &skew;
		arg[1] = &intercept;

		for (int i = 0; i < (int) (2.0 * range / dx); i++) {
			xx = -range + i * dx;
			double a, b, c, d, h = 1e-6;
			a = map_invsn(xx, MAP_FORWARD, (void *) arg);
			b = map_invsn(a, MAP_BACKWARD, (void *) arg);
			c = map_invsn(xx, MAP_DFORWARD, (void *) arg);
			d = (map_invsn(xx + h, MAP_FORWARD, (void *) arg) - map_invsn(xx - h, MAP_FORWARD, (void *) arg)) / (2.0 * h);
			printf("xx = %.8g forw=%.8g backw=%.8g dforw=%.8g fdiff=%.8g (derr=%.8g)\n", xx, a, b, c, d, c - d);

		}
	}
		break;

	case 33:
	{
		double xx, yy, h = 1.0e-4, range = 1.123;

		for (xx = 1.2; xx < 3.0; xx += 0.35) {
			yy = map_phi(xx, MAP_FORWARD, NULL);
			printf("xx %g yy %g  xx.inv %g deriv %g dderiv %g\n",
			       xx, yy,
			       map_phi(yy, MAP_BACKWARD, NULL),
			       map_phi(xx, MAP_DFORWARD, NULL),
			       (map_phi(xx + h, MAP_FORWARD, NULL) - map_phi(xx - h, MAP_FORWARD, NULL)) / 2.0 / h);
		}
		for (xx = 1.2; xx < 3.0; xx += 0.35) {
			yy = map_phi(xx, MAP_FORWARD, (void *) &range);
			printf("xx %g yy %g  xx.inv %g deriv %g dderiv %g\n",
			       xx, yy,
			       map_phi(yy, MAP_BACKWARD, (void *) &range),
			       map_phi(xx, MAP_DFORWARD, (void *) &range),
			       (map_phi(xx + h, MAP_FORWARD, (void *) &range) - map_phi(xx - h, MAP_FORWARD, (void *) &range)) / 2.0 / h);
		}
	}
		break;

	case 34:
	{
		double theta, lambda = 40;

		for (theta = -5; theta <= 5; theta += 0.01) {
			printf("theta %g logprior %g\n", theta, priorfunc_pc_sn(&theta, &lambda));
		}
	}
		break;

	case 35:
	{
		double y, lambda = 1.234;

		for (y = 0.0; y <= 3.0; y += 0.1) {
			printf("y=%g  eval_log_contpoisson= %g\n", y, eval_log_contpoisson(y + 1, lambda));
		}
	}
		break;

	case 36:
	{
		GMRFLib_design_tp *design = Calloc(1, GMRFLib_design_tp);
		int nf = atoi(args[0]);

		GMRFLib_design_ccd(&design, nf);
		GMRFLib_design_print(stdout, design);

		GMRFLib_design_eb(&design, nf);
		GMRFLib_design_print(stdout, design);
	}
		break;

	case 37:
	{
		double xx, aa;
		aa = (!args[0] ? 1.0 : atof(args[0]));
		printf("aa = %g\n", aa);
		double range = 23.0, dx = 0.1;
		Link_param_tp *arg = Calloc(1, Link_param_tp);
		arg->a = aa;
		// paralle for must have int as loop-index
		// #pragma omp parallel for private(xx)
		for (int i = 0; i < (int) (2.0 * range / dx); i++) {
			int thread_id = 0;
			xx = -range + i * dx;
			double a, b, c, d, h = 1e-6;
			a = link_loga(thread_id, xx, MAP_FORWARD, (void *) arg, NULL);
			b = link_loga(thread_id, a, MAP_BACKWARD, (void *) arg, NULL);
			c = link_loga(thread_id, xx, MAP_DFORWARD, (void *) arg, NULL);
			d = (link_loga(thread_id, xx + h, MAP_FORWARD, (void *) arg, NULL) -
			     link_loga(thread_id, xx - h, MAP_FORWARD, (void *) arg, NULL)) / (2.0 * h);
			printf("xx = %.8f forw=%.12f backw=%.8f dforw=%.12f fdiff=%.12f (derr=%.12f)\n", xx, a, b, c, d, c - d);
		}
	}
		break;

	case 38:
		break;

	case 39:
	{
		double a, b, c, dd, x0 = 2.0;
		int stencil;
		int thread_id = 0;

		stencil = 5;
		GMRFLib_2order_taylor(thread_id, &a, &b, &c, &dd, 1.0, x0, 0, &x0, loglikelihood_testit, NULL, NULL, &stencil);
		printf("taylor: stencil= %d a= %.10g b= %.10g c= %.10g dd= %.10g\n", stencil, a, b, c, dd);
		stencil = 7;
		GMRFLib_2order_taylor(thread_id, &a, &b, &c, &dd, 1.0, x0, 0, &x0, loglikelihood_testit, NULL, NULL, &stencil);
		printf("taylor: stencil= %d a= %.10g b= %.10g c= %.10g dd= %.10g\n", stencil, a, b, c, dd);
		stencil = 9;
		GMRFLib_2order_taylor(thread_id, &a, &b, &c, &dd, 1.0, x0, 0, &x0, loglikelihood_testit, NULL, NULL, &stencil);
		printf("taylor: stencil= %d a= %.10g b= %.10g c= %.10g dd= %.10g\n", stencil, a, b, c, dd);

		stencil = 5;
		GMRFLib_2order_approx(thread_id, &a, &b, &c, &dd, 1.0, x0, 0, &x0, loglikelihood_testit, NULL, NULL, &stencil, NULL);
		printf("approx: stencil= %d a= %.10g b= %.10g c= %.10g dd= %.10g\n", stencil, a, b, c, dd);
		stencil = 7;
		GMRFLib_2order_approx(thread_id, &a, &b, &c, &dd, 1.0, x0, 0, &x0, loglikelihood_testit, NULL, NULL, &stencil, NULL);
		printf("approx: stencil= %d a= %.10g b= %.10g c= %.10g dd= %.10g\n", stencil, a, b, c, dd);
		stencil = 9;
		GMRFLib_2order_approx(thread_id, &a, &b, &c, &dd, 1.0, x0, 0, &x0, loglikelihood_testit, NULL, NULL, &stencil, NULL);
		printf("approx: stencil= %d a= %.10g b= %.10g c= %.10g dd= %.10g\n", stencil, a, b, c, dd);
	}
		break;

	case 40:
	{
		printf("eps= %.12g\n", GMRFLib_eps(1.0));
	}
		break;

	case 41:
	{
		inla_sn_intercept(0.43, 0.123);
		inla_sn_intercept(0.823, -0.123);
	}
		break;

	case 42:
		break;

	case 43:
	{
		gsl_matrix *A;
		A = gsl_matrix_alloc(3, 3);
		gsl_matrix_set(A, 0, 0, 1.0);
		gsl_matrix_set(A, 1, 0, 2.0);
		gsl_matrix_set(A, 2, 0, 2.0);

		gsl_matrix_set(A, 0, 1, -1.0);
		gsl_matrix_set(A, 1, 1, 0.0);
		gsl_matrix_set(A, 2, 1, 2.0);

		gsl_matrix_set(A, 0, 2, 0.0);
		gsl_matrix_set(A, 1, 2, 0.0);
		gsl_matrix_set(A, 2, 2, 1.0);

		GMRFLib_printf_gsl_matrix(stdout, A, " %.4f");
		GMRFLib_gsl_mgs(A);
		printf("\n");
		GMRFLib_printf_gsl_matrix(stdout, A, " %.4f");
	}
		break;

	case 44:
	{
		double a, b, y;
		int i;

		for (i = 0; i < 10; i++) {

			a = 2.0 * GMRFLib_uniform();
			b = 2.0 * GMRFLib_uniform();
			y = GMRFLib_uniform();

			printf("a %f b %f y %f", a, b, y);
			printf("  pbeta %f ", MATHLIB_FUN(pbeta) (y, a, b, 1, 1));
			printf("  1-pbeta %f\n", MATHLIB_FUN(pbeta) (y, a, b, 0, 1));
		}
	}
		break;

	case 45:
	{
		int n = 10;
		GMRFLib_idxval_tp *h = NULL;
		for (int i = 0, j = 0; i < n; i++) {
			j = (i < n / 2 ? 0 : 1);
			GMRFLib_idxval_add(&h, j, (double) j);
		}
		GMRFLib_idxval_sort(h);
		GMRFLib_idxval_printf(stdout, h, "case 45");
	}
		break;

	case 46:
	{
		GMRFLib_crwdef_tp *rw = Calloc(1, GMRFLib_crwdef_tp);
		GMRFLib_graph_tp *g;
		int n = 10, i, j;
		int thread_id = 0;
		assert(omp_get_thread_num() == 0);

		rw->n = n;
		rw->order = 2;
		rw->layout = GMRFLib_CRW_LAYOUT_SIMPLE;
		rw->position = Calloc(n, double);
		rw->position[0] = 0;
		for (i = 1; i < n; i++) {
			rw->position[i] = rw->position[i - 1] + i;
		}

		GMRFLib_make_crw_graph(&g, rw);

		double *len = Calloc(n, double);
		double *null = Calloc(n, double);
		double *res = Calloc(n, double);

		null[0] = 1.0;
		null[n - 1] = 1.0;
		len[0] = (rw->position[1] - rw->position[0]) / 1.0;
		len[n - 1] = (rw->position[n - 1] - rw->position[n - 2]) / 1.0;
		for (i = 1; i < n - 1; i++) {
			null[i] = 1.0;
			len[i] = (rw->position[i + 1] - rw->position[i]);
		}
		GMRFLib_Qx(thread_id, res, null, g, GMRFLib_crw, (void *) rw);
		for (i = 0; i < n; i++)
			printf("constr i %1d  x %f null %f Qnull %f\n", i, rw->position[i], null[i], res[i]);
		if (rw->order > 1) {
			Memcpy(null, rw->position, n * sizeof(double));
			GMRFLib_Qx(thread_id, res, null, g, GMRFLib_crw, (void *) rw);
			for (i = 0; i < n; i++)
				printf("linear i %1d  x %f null %f Qnull %f\n", i, rw->position[i], null[i], res[i]);
		}

		if (0) {
			gsl_matrix *Q = gsl_matrix_calloc(n, n);
			for (i = 0; i < n; i++)
				for (j = 0; j < n; j++) {
					if (i == j || GMRFLib_graph_is_nb(i, j, g)) {
						gsl_matrix_set(Q, i, j, GMRFLib_crw(thread_id, i, j, rw->position, rw));
					} else {
						gsl_matrix_set(Q, i, j, 0.0);
					}
				}

			gsl_matrix *vec = gsl_matrix_calloc(n, n);
			gsl_vector *val = gsl_vector_calloc(n);
			gsl_eigen_symmv_workspace *work = gsl_eigen_symmv_alloc(n);
			gsl_eigen_symmv(Q, val, vec, work);

			GMRFLib_printf_gsl_matrix(stdout, Q, " %8.4f");
			printf("\n");
			GMRFLib_printf_gsl_matrix(stdout, vec, " %8.4f");
			printf("\n");
			GMRFLib_printf_gsl_vector(stdout, val, " %8.4f");
		}
	}
		break;

	case 47:
	{
		GMRFLib_idxval_tp *h = NULL;
		GMRFLib_idxval_add(&h, 23, 1.000000);
		GMRFLib_idxval_add(&h, 61, 1.000000);
		GMRFLib_idxval_add(&h, 67, 1.000000);
		GMRFLib_idxval_add(&h, 127, 1.000000);
		GMRFLib_idxval_add(&h, 128, 1.000000);
		GMRFLib_idxval_add(&h, 162, 1.000000);
		GMRFLib_idxval_add(&h, 177, 1.000000);
		if (1) {
			GMRFLib_idxval_add(&h, 189, 1.000000);
			GMRFLib_idxval_add(&h, 223, 1.000000);
			GMRFLib_idxval_add(&h, 235, 1.000000);
			GMRFLib_idxval_add(&h, 360, 1.000000);
			GMRFLib_idxval_add(&h, 423, 1.000000);
			GMRFLib_idxval_add(&h, 432, 1.000000);
			GMRFLib_idxval_add(&h, 433, 1.000000);
			GMRFLib_idxval_add(&h, 443, 1.000000);
			GMRFLib_idxval_add(&h, 455, 1.000000);
			GMRFLib_idxval_add(&h, 492, 1.000000);
			GMRFLib_idxval_add(&h, 581, 1.000000);
			GMRFLib_idxval_add(&h, 620, 1.000000);
			GMRFLib_idxval_add(&h, 646, 1.000000);
			GMRFLib_idxval_add(&h, 675, 1.000000);
			GMRFLib_idxval_add(&h, 694, 1.000000);
			GMRFLib_idxval_add(&h, 730, 1.000000);
			GMRFLib_idxval_add(&h, 734, 1.000000);
			GMRFLib_idxval_add(&h, 754, 1.000000);
			GMRFLib_idxval_add(&h, 769, 1.000000);
			GMRFLib_idxval_add(&h, 781, 1.000000);
			GMRFLib_idxval_add(&h, 792, 1.000000);
			GMRFLib_idxval_add(&h, 822, 1.000000);
			GMRFLib_idxval_add(&h, 826, 1.000000);
			GMRFLib_idxval_add(&h, 896, 1.000000);
			GMRFLib_idxval_add(&h, 947, 1.000000);
			GMRFLib_idxval_add(&h, 966, 1.000000);
			GMRFLib_idxval_add(&h, 998, 1.000000);
			GMRFLib_idxval_add(&h, 1013, 1.000000);
		}

		GMRFLib_idxval_sort(h);
		GMRFLib_idxval_printf(stdout, h, "test47");
	}
		break;

	case 48:
	{
		for (double x = 1.0;; x *= 10.0) {
			printf("x= %f log(gsl_sf_psi_1(x)= %f  -log(x)= %f diff= %f\n",
			       x, log(gsl_sf_psi_1(x)), -log(x), log(gsl_sf_psi_1(x)) + log(x));
		}
	}
		break;

	case 49:
	{
#define SPECIAL(x) ((x > 0 ?						\
		     -2.0 * log(x) - log(2.0) + 1.0/(3.0*(x)) - 1.0/(18.0*SQR(x)) : \
		     log(gsl_sf_psi_1(x) - 1.0/(x))))

		for (double x = 1.0;; x *= 10.0) {
			printf("x= %f log(gsl_sf_psi_1(x)-1/x)= %f  %f %f\n",
			       x, log(gsl_sf_psi_1(x) - 1 / x), SPECIAL(x), log(gsl_sf_psi_1(x) - 1 / x) - SPECIAL(x));
		}
	}
		break;

	case 50:
	{
		if (nargs != 3) {
			printf("X DF NCP\n");
			exit(1);
		}
		double x = atof(args[0]);
		double df = atof(args[1]);
		double ncp = atof(args[2]);
		printf("R --vanilla --quiet -e 'df=%.8f; x= %.8f; ncp= %.8f; dchisq(x,df,ncp,log=TRUE); pchisq(x,df,ncp)'\n", df, x, ncp);
		printf("log.density= %.8f\n", MATHLIB_FUN(dnchisq) (x, df, ncp, 1));
		printf("CDF(%.8f)= %.8f\n", x, MATHLIB_FUN(pnchisq) (x, df, ncp, 1, 0));
		printf("iCDF(CDF(%.8f))= %.8f\n", x, MATHLIB_FUN(qnchisq) (MATHLIB_FUN(pnchisq) (x, df, ncp, 1, 0), df, ncp, 1, 0));

	}
		break;

	case 51:
	{

		if (1) {
			double phi = 1.0;
			double xi = 1.5;
			double mu = 1.234;
			double y = 2.345;
			double ldens;

			printf("R --vanilla --quiet -e 'library(tweedie);phi=%f;xi=%f;mu=%f;y=%f;dtweedie(y,xi,mu,phi);ptweedie(y,xi,mu,phi)'",
			       phi, xi, mu, y);
			dtweedie(1, y, &mu, phi, xi, &ldens);
			P(exp(ldens));
			P(ptweedie(y, mu, phi, xi));

			break;
		}

		double mu = 7.986;
		double phi = 1.717755;
		double p = 1.476;
		double ldens;
		double y, dy = 0.001, sum = 0.0;
		int iy;

#pragma omp parallel for private(iy, y, ldens) reduction(+:sum)
		for (iy = 0; iy < 100000; iy++) {
			double y = SQR(dy) + iy * dy;
			dtweedie(1, y, &mu, phi, p, &ldens);
			printf("LDENS %f %f\n", y, ldens);
			sum += dy * exp(ldens);
		}
		y = 0.0;
		dtweedie(1, y, &mu, phi, p, &ldens);
		P(sum);
		P(exp(ldens));
		P(sum + exp(ldens));

		double lmu;
		y = 1;
		p = 1.51;
		for (lmu = -10; lmu < 10; lmu += 0.01) {
			mu = exp(lmu);
			dtweedie(1, y, &mu, phi, p, &ldens);
			printf("LMU %f %f\n", lmu, ldens);
		}

	}
		break;

	case 52:
	{
		for (double x = 0.1; x < 20; x += 0.1) {
			printf("x %f lgamma %f lgamma.fast %f diff %f\n",
			       x, gsl_sf_lngamma(x), inla_lgamma_fast(x), gsl_sf_lngamma(x) - inla_lgamma_fast(x));
		}

	}
		break;

	case 53:
	{
		double mu = 17.986;
		double phi = 1.717755;
		double p = 1.476;
		double ldens;
		int iy;

		for (iy = 10; iy < 100; iy += 10) {
			double pphi = phi / iy;
			double y = (double) iy;
			dtweedie(1, y, &mu, pphi, p, &ldens);
			printf("LDENS %f %f %f\n", y, pphi, ldens);
		}

	}
		break;

	case 54:
	{

		double x0 = 0, v;
		for (v = 0.0; v <= 1.0; v += 0.1) {
			printf("x %f exp %.12f exp_taylor %.12f %.12f\n", v, exp(v), exp_taylor(v, x0, 6), exp_taylor(v, x0, 12));
		}

	}
		break;

	case 55:
	{
		double skew3 = GMRFLib_skew_to_skew3(0.3);
		GMRFLib_snq_tp *q;
		int n = 31;

		q = GMRFLib_snq(n, skew3);
		for (int i = 0; i < q->n; i++) {
			printf("i %d x %.8f w %.8f ww %.8f www %.8f\n", i, q->nodes[i], q->w[i], q->w_grad[i], q->w_hess[i]);
		}

		double fun = 0, fund = 0, fundd = 0, fval = 0;
		for (int i = 0; i < q->n; i++) {
			fval = sin(q->nodes[i]);
			fun += fval * q->w[i];
			fund += fval * q->w_grad[i];
			fundd += fval * q->w_hess[i];
		}
		printf("sin(x): value= %.8f deriv= %.8f dderiv= %.8f\n", fun, fund, fundd);

		GMRFLib_snq_free(q);
	}
		break;

	case 56:
	{
		for (i = 0, j = 1; i < 10; i++, j = j + 2) {
			double lambda = exp(-1 + GMRFLib_uniform());
			double nnew = inla_poisson_interval(lambda, i, j);
			double gsl = (gsl_cdf_poisson_P((unsigned) j, lambda) - (i <= 0 ? 0.0 : gsl_cdf_poisson_P((unsigned) (i - 1), lambda)));
			printf("lambda %f from= %d to= %d: nnew %f gsl %f diff %.12f\n", lambda, i, j, nnew, gsl, nnew - gsl);
		}
		// j < 0 <==> j=INF
		for (i = 0, j = -1; i < 10; i++) {
			double lambda = exp(-1 + GMRFLib_uniform());
			double nnew = inla_poisson_interval(lambda, i, j);
			double gsl = (gsl_cdf_poisson_P((unsigned) 1000, lambda) - (i <= 0 ? 0.0 : gsl_cdf_poisson_P((unsigned) (i - 1), lambda)));
			printf("lambda %f from= %d to= %d: nnew %f gsl %f diff %.12f\n", lambda, i, j, nnew, gsl, nnew - gsl);
		}
	}
		break;

	case 57:
	{
		// testing qpoisson

		double eta, shape;
		Link_param_tp *lparam = Calloc(1, Link_param_tp);
		lparam->quantile = 0.87;
		int thread_id = 0;
		assert(omp_get_thread_num() == 0);

		P(lparam->quantile);
		for (eta = 1.0; eta < 10.0; eta += 0.5) {
			shape = exp(eta) + 1;
			printf("eta %f shape %f qpoisson %f qgamma %f\n", eta, shape,
			       link_qpoisson(thread_id, eta, INVLINK, lparam, NULL), MATHLIB_FUN(qgamma) (lparam->quantile, shape, 1.0, 0, 0));
		}
	}
		break;

	case 58:
	{
		double df = 3.0;
		double x = SQR(50);
		double ncp, ncp_sqrt;

		for (ncp_sqrt = 0.0; ncp_sqrt < 2 * sqrt(x); ncp_sqrt += 2.0 * sqrt(x) / 1.0E4) {
			ncp = SQR(ncp_sqrt);
			printf("sqrt(ncp) inla_dnchisq %f %f\n", sqrt(ncp), inla_dnchisq(x, df, ncp));
		}
	}
		break;

	case 59:
	{
		double x = GMRFLib_uniform();

		printf("x= %.12f\n", x);
		printf("Phi= %.12f\n", GMRFLib_Phi(x));
		printf("Phi_inv = %.12f\n", GMRFLib_Phi_inv(x));
		printf("erf = %.12f\n", GMRFLib_erf(x));
		printf("erfinv = %.12f\n", GMRFLib_erf_inv(x));
		printf("erfc = %.12f\n", GMRFLib_erfc(x));
		printf("erfcinv = %.12f\n", GMRFLib_erfc_inv(x));

		printf("%s%.12f%s%s\n", "R --vanilla --quiet -e 'library(pracma);x=",
		       x, ";print(x); print(pnorm(x)); print(qnorm(x)); print(erf(x));", "print(erfinv(x)); print(erfc(x)); print(erfcinv(x))'\n");
	}
		break;

	case 60:
	{
		double x = GMRFLib_uniform();
		double a = GMRFLib_uniform() - 0.5;

		printf("x= %.12f\n", x);
		printf("a= %.12f\n", a);
		printf("sn_inv= %.12f\n", GMRFLib_sn_Pinv(x, a));

		printf("%s%.12f%s%.12f%s\n", "R --vanilla --quiet -e 'library(sn);x=", x, "; a=", a, "; print(qsn(x,alpha=a))'\n");
	}
		break;

	case 61:
	{
		GMRFLib_problem_tp *problem;
		GMRFLib_graph_tp *g;
		GMRFLib_graph_mk_linear(&g, 5, 5, 0);

		int thread_id = 0;
		assert(omp_get_thread_num() == 0);
		GMRFLib_init_problem(thread_id, &problem, NULL, NULL, NULL, NULL, g, testit_Qfunc, NULL, NULL);
		GMRFLib_evaluate(problem);
		GMRFLib_Qinv(problem);

		for (int i = 0; i < g->n; i++) {
			printf("Qinv[%1d]=  %f\n", i, *GMRFLib_Qinv_get(problem, i, i));
		}
	}
		break;

	case 62:
	{
		double mom[3] = { 1.123, 0.123, -0.213 };
		GMRFLib_sn_param_tp p;

		printf("mom %f %f %f\n", mom[0], mom[1], mom[2]);
		GMRFLib_sn_moments2par(&p, mom, mom + 1, mom + 2);
		GMRFLib_sn_par2moments(mom, mom + 1, mom + 2, &p);
		printf("sn  %f %f %f\n", p.xi, p.omega, p.alpha);
		printf("mom %f %f %f\n", mom[0], mom[1], mom[2]);
	}
		break;

	case 63:
	{
		int n = atoi(args[0]);
		P(n);
		double *x = Calloc(n, double);
		double tref;
		for (int i = 0; i < n; i++) {
			x[i] = GMRFLib_uniform();
		}

		tref = GMRFLib_cpu();
		FILE *fp = fopen("REMOVE_ME_1.dat", "wb");
		fwrite((void *) x, sizeof(double), (size_t) n, fp);
		fclose(fp);
		printf("Optimal %f\n", (GMRFLib_cpu() - tref));

		tref = GMRFLib_cpu();
		fp = fopen("REMOVE_ME_2.dat", "wb");
		for (int i = 0; i < n; i++)
			fwrite((void *) &x[i], sizeof(double), (size_t) 1, fp);
		fclose(fp);
		printf("One-by-one %f\n", (GMRFLib_cpu() - tref));

		tref = GMRFLib_cpu();
		{
			Dinit("REMOVE_ME_3.dat");
			for (int i = 0; i < n; i++) {
				D1W(x[i]);
			}
			Dclose();
			printf("D-cache %f\n", (GMRFLib_cpu() - tref));
		}

		tref = GMRFLib_cpu();
		{
			Dinit_s("REMOVE_ME_4.dat");
			for (int i = 0; i < n; i++) {
				D1W(x[i]);
			}
			Dclose();
			printf("D-cache short %f\n", (GMRFLib_cpu() - tref));
		}

		tref = GMRFLib_cpu();
		{
			fp = fopen("REMOVE_ME_5.dat", "wb");
			char *buff = (char *) Calloc(1048576, double);
			setvbuf(stdout, buff, _IOFBF, 1048576 * sizeof(double));
			for (int i = 0; i < n; i++) {
				fwrite(x + i, sizeof(double), (size_t) 1, fp);
			}
			fclose(fp);
			printf("setvbuf %f\n", (GMRFLib_cpu() - tref));
		}
	}
		break;

	case 64:
	{
		int n = atoi(args[0]);
		gsl_bfgs4_test1((size_t) n);
	}
		break;

	case 65:
	{
		double x[] = { -0.200, -0.075, 0.000, 0.040, 0.160, 0.360, 0.640, 1.000 };
		double y[] = { 14960.675457, 14934.327851, 14927.976542, 14943.616530, 14945.530949, 15000.597367, 15140.861227, 15412.165108 };
		int n = sizeof(y) / sizeof(double);

		double xmin;
		double ymin;

		for (int order = 2; order <= 4; order += 2) {
			bfgs4_robust_minimize(&xmin, &ymin, n, x, y, 0, NULL, NULL, order);
			printf("xmin = %f ymin= %f when order = %d\n", xmin, ymin, order);
		}
	}
		break;

	case 66:
	{
		double power, power_intern;
		double intercept, intercept_intern;
		double **param;
		param = Calloc(2, double *);

		power = 1.5;
		power_intern = map_exp(power, MAP_BACKWARD, NULL);
		intercept = 0.75;
		intercept_intern = map_probability(intercept, MAP_BACKWARD, NULL);

		param[0] = &power_intern;
		param[1] = &intercept_intern;

		map_inv_powerlink_core(0.0, MAP_FORWARD, (void *) param, NULL);
	}
		break;

	case 67:
	{
		double xx, power, intercept;
		power = (!args[0] ? 0.01 : atof(args[0]));
		intercept = (!args[1] ? 0.01 : atof(args[1]));
		printf("power = %g\n", power);
		printf("intercept = %g\n", intercept);
		double range = 2.0, dx = 0.2;
		double *arg[2];
		arg[0] = &power;
		arg[1] = &intercept;

		for (int i = 0; i < (int) (2.0 * range / dx); i++) {
			xx = -range + i * dx;
			double a, b, c, d, h = 1e-6;
			a = map_inv_powerlink_core(xx, MAP_FORWARD, (void *) arg, NULL);
			b = map_inv_powerlink_core(a, MAP_BACKWARD, (void *) arg, NULL);
			c = map_inv_powerlink_core(xx, MAP_DFORWARD, (void *) arg, NULL);
			d = (map_inv_powerlink_core(xx + h, MAP_FORWARD, (void *) arg, NULL)
			     - map_inv_powerlink_core(xx - h, MAP_FORWARD, (void *) arg, NULL)) / (2.0 * h);
			printf("xx = %.8g forw=%.8g backw=%.8g dforw=%.8g fdiff=%.8g (derr=%.8g)\n", xx, a, b, c, d, c - d);

		}
	}
		break;

	case 68:
	{
		assert(nargs == 3);
		printf("Call 'double (*fun)(double)' function [%s] in [%s] with argument [%s]\n", args[0], args[1], args[2]);
		lt_dlhandle handle;
		typedef double fun_tp(double);
		fun_tp *fun = NULL;
		const char *error;

		lt_dlinit();
		handle = lt_dlopen(args[1]);
		if (!handle) {
			fprintf(stderr, "%s\n", lt_dlerror());
			exit(1);
		}
		lt_dlerror();

		fun = (fun_tp *) lt_dlsym(handle, args[0]);
		if ((error = lt_dlerror()) != NULL) {
			fprintf(stderr, "%s\n", error);
			exit(1);
		}
		lt_dlerror();

		double x = atof(args[2]);
		printf("fun(%g) = %g\n", x, fun(x));
		lt_dlclose(handle);
	}
		break;

	case 69:
	{
		int n = 10;

		printf("\n\n");
		FIXME("run with 4 threads");
#pragma omp parallel for num_threads(4)
		for (int i = 0; i < n; i++) {
			P(GMRFLib_OPENMP_IN_SERIAL());
			P(GMRFLib_OPENMP_IN_PARALLEL());
			P(GMRFLib_OPENMP_IN_PARALLEL_ONE_THREAD());
			P(GMRFLib_OPENMP_IN_PARALLEL_ONEPLUS_THREAD());
		}

		printf("\n\n");
		FIXME("run with 1 threads");
#pragma omp parallel for num_threads(1)
		for (int i = 0; i < n; i++) {
			P(GMRFLib_OPENMP_IN_SERIAL());
			P(GMRFLib_OPENMP_IN_PARALLEL());
			P(GMRFLib_OPENMP_IN_PARALLEL_ONE_THREAD());
			P(GMRFLib_OPENMP_IN_PARALLEL_ONEPLUS_THREAD());
		}

		printf("\n\n");
		FIXME("run serial");
		for (int i = 0; i < n; i++) {
			P(GMRFLib_OPENMP_IN_SERIAL());
			P(GMRFLib_OPENMP_IN_PARALLEL());
			P(GMRFLib_OPENMP_IN_PARALLEL_ONE_THREAD());
			P(GMRFLib_OPENMP_IN_PARALLEL_ONEPLUS_THREAD());
		}
	}
		break;

	case 70:
	{
		GMRFLib_design_tp *design = Calloc(1, GMRFLib_design_tp);
		int nf = atoi(args[0]);
		GMRFLib_design_grid(&design, nf);
		GMRFLib_design_print(stdout, design);
	}
		break;

	case 71:
	{
		const int n = 51;
		double x[n];
		double ld[n];

		for (int i = 0; i < n; i++) {
			x[i] = -5 + (double) i / (n - 1.0) * 10;
			ld[i] = (-0.5 * SQR(x[i]));
		}

		GMRFLib_density_tp *dens = NULL;
		GMRFLib_density_create(&dens, GMRFLib_DENSITY_TYPE_SCGAUSSIAN, n, x, ld, 0.0, 1.0, 1);
		GMRFLib_density_printf(stdout, dens);
	}
		break;

	case 72:
	{
		P(omp_get_num_threads());
		P(omp_get_max_threads());
		P(omp_get_thread_num());
		P(GMRFLib_OPENMP_IN_SERIAL());
	}
		break;

	case 73:
	{
		const int n = 51;
		double x[n];
		double ld[n];

		for (int i = 0; i < n; i++) {
			x[i] = (double) i / (n - 1.0) * 10;
			ld[i] = -0.5 * SQR(x[i]);
		}

		GMRFLib_density_tp *dens = NULL;
		GMRFLib_density_tp *dens_dup = NULL;
		GMRFLib_sn_param_tp sn_par = { 0., 1.0, 0.4 };

		GMRFLib_density_create_sn(&dens, sn_par, 1.1, 2.2, 1);
		FIXME("SN");
		GMRFLib_density_printf(stdout, dens);
		GMRFLib_density_duplicate(&dens_dup, dens);
		FIXME("SN dup");
		GMRFLib_density_printf(stdout, dens_dup);

		GMRFLib_free_density(dens);
		GMRFLib_free_density(dens_dup);

		GMRFLib_density_create(&dens, GMRFLib_DENSITY_TYPE_SCGAUSSIAN, n, x, ld, 0.0, 1.0, 1);
		FIXME("SC Gaussian");
		GMRFLib_density_duplicate(&dens_dup, dens);
		GMRFLib_density_printf(stdout, dens);
		FIXME("SC Gaussian dup");
		GMRFLib_density_printf(stdout, dens_dup);

		GMRFLib_free_density(dens);
		GMRFLib_free_density(dens_dup);
	}
		break;

	case 74:
	{
		double x[100];
		double *p, *pp;

		p = &x[0];
		pp = &x[10];
		P(OVERLAP(p, pp, 5));
		P(OVERLAP(p, pp, 9));
		P(OVERLAP(p, pp, 10));
		P(OVERLAP(p, pp, 11));
		P(OVERLAP(p, pp, 15));
	}
		break;

	case 75:
	{
		int n = 100, i;
		double *x = Calloc(n, double);
		double *pp = Calloc(n, double);
		double xx, dx;
		double xmax = 5;
		dx = 2.0 * xmax / (n - 1);

		for (i = 0; i < n; i++) {
			xx = -xmax + dx * i;
			x[i] = xx;
			pp[i] = inla_Phi(xx);
			// printf("%d %.20f %.20f\n", i, x[i], pp[i]); 
		}

		GMRFLib_spline_tp *P, *Pinv;

		P = GMRFLib_spline_create_x(x, pp, n, GMRFLib_INTPOL_TRANS_P);
		Pinv = GMRFLib_spline_create_x(pp, x, n, GMRFLib_INTPOL_TRANS_Pinv);

		for (xx = -(xmax + 2); xx <= (xmax + 2); xx += 0.5) {
			double p1 = inla_Phi(xx);
			double p2 = GMRFLib_spline_eval(xx, P);
			double xx2 = GMRFLib_spline_eval(p2, Pinv);
			printf("XX %.20f %.20f %.20f %.20f\n", xx, p1, p2, xx2);
		}
	}
		break;

	case 76:
	{
		for (int i = 0; i < 10; i++) {
			printf("%d %f %f\n", i, gsl_sf_lnfact((unsigned int) i), my_gsl_sf_lnfact(i));
		}
	}
		break;

	case 77:
	{
		int n = 111;
		double dx = 12.0 / (n - 1);
		Calloc_init(2 * n, 2);
		double *x = Calloc_get(n);
		double *y = Calloc_get(n);

		double z = 0.0;
		for (i = 0; i < n; i++) {
			x[i] = -6.0 + i * dx;
			// this one is normalized
			y[i] = log(2.0) + log(1.0 / sqrt(2.0 * M_PI)) - 0.5 * SQR(x[i]) + inla_log_Phi(1.0 * x[i]);
			z += dx * exp(y[i]);
		}
		P(z);					       /* should be 1 */
		GMRFLib_density_tp *density;
		GMRFLib_density_create(&density, GMRFLib_DENSITY_TYPE_SCGAUSSIAN, n, x, y, 0.0, 1.0, 1);
		GMRFLib_density_printf(stdout, density);

		for (i = 0; i < n; i++) {
			x[i] = -6.0 + i * dx;
			double yy;
			GMRFLib_evaluate_logdensity(&yy, x[i], density);
			printf("Evaluate x %f true %f scg %f\n", x[i], y[i], yy);
		}
	}
		break;

	case 78:
	{
		/*
		 * 
		 * library(mvtnorm) Q <- matrix(c(17, -1, -2, -1, 15, -3, -2, -3, 14), 3, 3) S <- solve(Q) x <- c(0.55, 1.55, 2.55) m <- c(2.05,
		 * 3.45, 1.25) zero <- rep(0, length(x)) print(dmvnorm(x = x, mean = m, sigma = S, log = TRUE)) print(dmvnorm(x = x, mean = zero,
		 * sigma = S, log = TRUE)) print(dmvnorm(x = zero, mean = m, sigma = S, log = TRUE)) print(dmvnorm(x = zero, mean = zero, sigma =
		 * S, log = TRUE))
		 * 
		 */

		gsl_matrix *Q = gsl_matrix_alloc(3, 3);
		gsl_matrix_set(Q, 0, 0, 17);
		gsl_matrix_set(Q, 1, 1, 15);
		gsl_matrix_set(Q, 2, 2, 14);
		gsl_matrix_set(Q, 0, 1, -1);
		gsl_matrix_set(Q, 1, 0, -1);
		gsl_matrix_set(Q, 0, 2, -2);
		gsl_matrix_set(Q, 2, 0, -2);
		gsl_matrix_set(Q, 1, 2, -3);
		gsl_matrix_set(Q, 2, 1, -3);

		gsl_matrix *S = GMRFLib_gsl_duplicate_matrix(Q);
		GMRFLib_gsl_spd_inverse(S);

		gsl_vector *x = gsl_vector_alloc(3);
		gsl_vector_set(x, 0, 0.55);
		gsl_vector_set(x, 1, 1.55);
		gsl_vector_set(x, 2, 2.55);

		gsl_vector *mean = gsl_vector_alloc(3);
		gsl_vector_set(mean, 0, 2.05);
		gsl_vector_set(mean, 1, 3.45);
		gsl_vector_set(mean, 2, 1.25);

		P(GMRFLib_gsl_log_dnorm(x, mean, NULL, S, 0));
		P(GMRFLib_gsl_log_dnorm(x, mean, Q, NULL, 0));

		P(GMRFLib_gsl_log_dnorm(x, NULL, NULL, S, 0));
		P(GMRFLib_gsl_log_dnorm(x, NULL, Q, NULL, 0));

		P(GMRFLib_gsl_log_dnorm(NULL, mean, NULL, S, 0));
		P(GMRFLib_gsl_log_dnorm(NULL, mean, Q, NULL, 0));

		P(GMRFLib_gsl_log_dnorm(NULL, NULL, NULL, S, 0));
		P(GMRFLib_gsl_log_dnorm(NULL, NULL, Q, NULL, 0));
	}
		break;

	case 79:
	{
		/*
		 * Q <- matrix(c(0.1, -1, -2, -1, 15, -3, -2, -3, 14), 3, 3) 
		 */

		gsl_matrix *Q = gsl_matrix_alloc(3, 3);
		gsl_matrix_set(Q, 0, 0, .1);
		gsl_matrix_set(Q, 1, 1, 15);
		gsl_matrix_set(Q, 2, 2, 14);
		gsl_matrix_set(Q, 0, 1, -1);
		gsl_matrix_set(Q, 1, 0, -1);
		gsl_matrix_set(Q, 0, 2, -2);
		gsl_matrix_set(Q, 2, 0, -2);
		gsl_matrix_set(Q, 1, 2, -3);
		gsl_matrix_set(Q, 2, 1, -3);

		gsl_matrix *S = GMRFLib_gsl_duplicate_matrix(Q);
		GMRFLib_gsl_ensure_spd_inverse(S, GMRFLib_eps(0.5), NULL);
		GMRFLib_printf_gsl_matrix(stdout, Q, " %.8f");
		GMRFLib_printf_gsl_matrix(stdout, S, " %.8f");
		GMRFLib_gsl_ensure_spd_inverse(S, GMRFLib_eps(0.5), NULL);
		GMRFLib_printf_gsl_matrix(stdout, S, " %.8f");
	}
		break;

	case 80:
	{
		/*
		 * fun = function(x) -x^2 + (x-1)^3 - 0.5 * (x+1)^4 plot(xx, fun(xx)) xx[which.max(fun(xx))] [1] 0.07507507508 
		 */

		double xx1[] = { 0, 1, 2 };
		double yy1[] = { -1.5, -9.0, -43.5 };
		double xm;
		xm = inla_interpolate_mode(xx1, yy1);
		P(xm);

		double xx2[] = { -1, 0, 0.5 };
		double yy2[] = { -9.00000, -1.50000, -2.90625 };

		xm = inla_interpolate_mode(xx2, yy2);
		P(xm);

		double xx3[] = { 0, 0.1, 0.12 };
		double yy3[] = { -1.50000000, -1.47105000, -1.48263168 };

		xm = inla_interpolate_mode(xx3, yy3);
		P(xm);

		double xx4[] = { 0.12, 0.0, 0.1 };
		double yy4[] = { -1.48263168, -1.50000000, -1.47105000 };

		xm = inla_interpolate_mode(xx4, yy4);
		P(xm);
	}
		break;

	case 81:
	{
		GMRFLib_idxval_tp *h = NULL;
		GMRFLib_idxval_add(&h, 22830, 1);
		GMRFLib_idxval_add(&h, 22832, 1);
		GMRFLib_idxval_add(&h, 22847, 1);
		GMRFLib_idxval_add(&h, 22850, 1);
		GMRFLib_idxval_add(&h, 22856, 1);
		GMRFLib_idxval_add(&h, 22861, 1);
		GMRFLib_idxval_add(&h, 22869, 1);
		GMRFLib_idxval_add(&h, 22877, 1);
		GMRFLib_idxval_add(&h, 22885, 1);
		GMRFLib_idxval_add(&h, 22892, 1);
		GMRFLib_idxval_add(&h, 22893, 1);
		GMRFLib_idxval_add(&h, 22904, 1);
		GMRFLib_idxval_add(&h, 22905, 1);
		GMRFLib_idxval_add(&h, 22918, 1);
		GMRFLib_idxval_add(&h, 22922, 1);
		GMRFLib_idxval_add(&h, 22933, 1);
		GMRFLib_idxval_add(&h, 22946, 1);
		GMRFLib_idxval_add(&h, 22949, 1);
		GMRFLib_idxval_add(&h, 22950, 1);
		GMRFLib_idxval_add(&h, 22965, 1);
		GMRFLib_idxval_add(&h, 22969, 1);
		GMRFLib_idxval_add(&h, 22980, 1);
		GMRFLib_idxval_add(&h, 22982, 1);
		GMRFLib_idxval_add(&h, 22983, 1);
		GMRFLib_idxval_add(&h, 22995, 1);
		GMRFLib_idxval_add(&h, 23009, 1);
		GMRFLib_idxval_add(&h, 23014, 1);
		GMRFLib_idxval_add(&h, 23015, 1);
		GMRFLib_idxval_add(&h, 23017, 1);
		GMRFLib_idxval_add(&h, 23032, 1);
		GMRFLib_idxval_add(&h, 23033, 1);
		GMRFLib_idxval_add(&h, 23045, 1);
		GMRFLib_idxval_add(&h, 23060, 1);
		GMRFLib_idxval_add(&h, 23070, 1);
		GMRFLib_idxval_add(&h, 23084, 1);
		GMRFLib_idxval_add(&h, 23093, 1);
		GMRFLib_idxval_add(&h, 23106, 1);
		GMRFLib_idxval_add(&h, 23107, 1);
		GMRFLib_idxval_add(&h, 23117, 1);
		GMRFLib_idxval_add(&h, 23124, 1);
		GMRFLib_idxval_add(&h, 23139, 1);
		GMRFLib_idxval_add(&h, 23143, 1);
		GMRFLib_idxval_add(&h, 23158, 1);
		GMRFLib_idxval_add(&h, 23173, 1);
		GMRFLib_idxval_add(&h, 23183, 1);
		GMRFLib_idxval_add(&h, 23197, 1);
		GMRFLib_idxval_add(&h, 23204, 1);
		GMRFLib_idxval_add(&h, 23214, 1);
		GMRFLib_idxval_add(&h, 23229, 1);
		GMRFLib_idxval_add(&h, 23232, 1);
		GMRFLib_idxval_add(&h, 23240, 1);
		GMRFLib_idxval_add(&h, 23252, 1);
		GMRFLib_idxval_add(&h, 23259, 1);
		GMRFLib_idxval_add(&h, 23262, 1);
		GMRFLib_idxval_add(&h, 23267, 1);
		GMRFLib_idxval_add(&h, 23271, 1);
		GMRFLib_idxval_add(&h, 23277, 1);
		GMRFLib_idxval_add(&h, 23287, 1);
		GMRFLib_idxval_add(&h, 23302, 1);
		GMRFLib_idxval_add(&h, 23309, 1);
		GMRFLib_idxval_add(&h, 23324, 1);
		GMRFLib_idxval_add(&h, 23339, 1);
		GMRFLib_idxval_add(&h, 23348, 1);
		GMRFLib_idxval_add(&h, 23351, 1);
		GMRFLib_idxval_add(&h, 23356, 1);
		GMRFLib_idxval_add(&h, 23370, 1);
		GMRFLib_idxval_add(&h, 23383, 1);
		GMRFLib_idxval_add(&h, 23391, 1);
		GMRFLib_idxval_add(&h, 23405, 1);
		GMRFLib_idxval_add(&h, 23409, 1);
		GMRFLib_idxval_add(&h, 23420, 1);
		GMRFLib_idxval_add(&h, 23434, 1);
		GMRFLib_idxval_add(&h, 23448, 1);
		GMRFLib_idxval_add(&h, 23462, 1);
		GMRFLib_idxval_add(&h, 23468, 1);
		GMRFLib_idxval_add(&h, 23472, 1);
		GMRFLib_idxval_add(&h, 23473, 1);
		GMRFLib_idxval_add(&h, 23474, 1);
		GMRFLib_idxval_add(&h, 23479, 1);
		GMRFLib_idxval_add(&h, 23492, 1);
		GMRFLib_idxval_add(&h, 23495, 1);
		GMRFLib_idxval_add(&h, 23503, 1);
		GMRFLib_idxval_add(&h, 23514, 1);
		GMRFLib_idxval_add(&h, 23528, 1);
		GMRFLib_idxval_add(&h, 23542, 1);
		GMRFLib_idxval_add(&h, 23552, 1);
		GMRFLib_idxval_add(&h, 23557, 1);
		GMRFLib_idxval_add(&h, 23558, 1);
		GMRFLib_idxval_add(&h, 23567, 1);
		GMRFLib_idxval_add(&h, 23572, 1);
		GMRFLib_idxval_add(&h, 23580, 1);
		GMRFLib_idxval_add(&h, 23582, 1);
		GMRFLib_idxval_add(&h, 23584, 1);
		GMRFLib_idxval_add(&h, 23598, 1);
		GMRFLib_idxval_add(&h, 23601, 1);
		GMRFLib_idxval_add(&h, 23602, 1);
		GMRFLib_idxval_add(&h, 23615, 1);
		GMRFLib_idxval_add(&h, 23617, 1);
		GMRFLib_idxval_add(&h, 23630, 1);
		GMRFLib_idxval_add(&h, 23643, 1);
		GMRFLib_idxval_add(&h, 23645, 1);
		GMRFLib_idxval_add(&h, 23658, 1);
		GMRFLib_idxval_add(&h, 23669, 1);
		GMRFLib_idxval_add(&h, 23670, 1);
		GMRFLib_idxval_add(&h, 23679, 1);
		GMRFLib_idxval_add(&h, 23688, 1);
		GMRFLib_idxval_add(&h, 23698, 1);
		GMRFLib_idxval_add(&h, 23710, 1);
		GMRFLib_idxval_add(&h, 23718, 1);
		GMRFLib_idxval_add(&h, 23728, 1);
		GMRFLib_idxval_add(&h, 23734, 1);
		GMRFLib_idxval_add(&h, 23741, 1);
		GMRFLib_idxval_add(&h, 23751, 1);
		GMRFLib_idxval_add(&h, 23754, 1);
		GMRFLib_idxval_add(&h, 23764, 1);
		GMRFLib_idxval_add(&h, 23776, 1);
		GMRFLib_idxval_add(&h, 23788, 1);
		GMRFLib_idxval_add(&h, 23792, 1);
		GMRFLib_idxval_add(&h, 23799, 1);
		GMRFLib_idxval_add(&h, 23801, 1);
		GMRFLib_idxval_add(&h, 23807, 1);
		GMRFLib_idxval_add(&h, 23808, 1);
		GMRFLib_idxval_add(&h, 23820, 1);
		GMRFLib_idxval_add(&h, 23823, 1);
		GMRFLib_idxval_add(&h, 23835, 1);
		GMRFLib_idxval_add(&h, 23843, 1);
		GMRFLib_idxval_add(&h, 23846, 1);
		GMRFLib_idxval_add(&h, 23858, 1);
		GMRFLib_idxval_add(&h, 23861, 1);
		GMRFLib_idxval_add(&h, 23873, 1);
		GMRFLib_idxval_add(&h, 23878, 1);
		GMRFLib_idxval_add(&h, 23881, 1);
		GMRFLib_idxval_add(&h, 23892, 1);
		GMRFLib_idxval_add(&h, 23901, 1);
		GMRFLib_idxval_add(&h, 23912, 1);
		GMRFLib_idxval_add(&h, 23923, 1);
		GMRFLib_idxval_add(&h, 23934, 1);
		GMRFLib_idxval_add(&h, 23945, 1);
		GMRFLib_idxval_add(&h, 23949, 1);
		GMRFLib_idxval_add(&h, 23956, 1);
		GMRFLib_idxval_add(&h, 23967, 1);
		GMRFLib_idxval_add(&h, 23978, 1);
		GMRFLib_idxval_add(&h, 23985, 1);
		GMRFLib_idxval_add(&h, 23988, 1);
		GMRFLib_idxval_add(&h, 23991, 1);
		GMRFLib_idxval_add(&h, 24002, 1);
		GMRFLib_idxval_add(&h, 24011, 1);
		GMRFLib_idxval_add(&h, 24021, 1);
		GMRFLib_idxval_add(&h, 24026, 1);
		GMRFLib_idxval_add(&h, 24029, 1);
		GMRFLib_idxval_add(&h, 24040, 1);
		GMRFLib_idxval_add(&h, 24051, 1);
		GMRFLib_idxval_add(&h, 24055, 1);
		GMRFLib_idxval_add(&h, 24066, 1);
		GMRFLib_idxval_add(&h, 24067, 1);
		GMRFLib_idxval_add(&h, 24078, 1);
		GMRFLib_idxval_add(&h, 24081, 1);
		GMRFLib_idxval_add(&h, 24092, 1);
		GMRFLib_idxval_add(&h, 24100, 1);
		GMRFLib_idxval_add(&h, 24105, 1);
		GMRFLib_idxval_add(&h, 24115, 1);
		GMRFLib_idxval_add(&h, 24125, 1);
		GMRFLib_idxval_add(&h, 24126, 1);
		GMRFLib_idxval_add(&h, 24132, 1);
		GMRFLib_idxval_add(&h, 24133, 1);
		GMRFLib_idxval_add(&h, 24137, 1);
		GMRFLib_idxval_add(&h, 24147, 1);
		GMRFLib_idxval_add(&h, 24152, 1);
		GMRFLib_idxval_add(&h, 24162, 1);
		GMRFLib_idxval_add(&h, 24166, 1);
		GMRFLib_idxval_add(&h, 24176, 1);
		GMRFLib_idxval_add(&h, 24186, 1);
		GMRFLib_idxval_add(&h, 24195, 1);
		GMRFLib_idxval_add(&h, 24205, 1);
		GMRFLib_idxval_add(&h, 24215, 1);
		GMRFLib_idxval_add(&h, 24225, 1);
		GMRFLib_idxval_add(&h, 24230, 1);
		GMRFLib_idxval_add(&h, 24240, 1);
		GMRFLib_idxval_add(&h, 24250, 1);
		GMRFLib_idxval_add(&h, 24260, 1);
		GMRFLib_idxval_add(&h, 24270, 1);
		GMRFLib_idxval_add(&h, 24280, 1);
		GMRFLib_idxval_add(&h, 24290, 1);
		GMRFLib_idxval_add(&h, 24297, 1);
		GMRFLib_idxval_add(&h, 24300, 1);
		GMRFLib_idxval_add(&h, 24309, 1);
		GMRFLib_idxval_add(&h, 24314, 1);
		GMRFLib_idxval_add(&h, 24317, 1);
		GMRFLib_idxval_add(&h, 24325, 1);
		GMRFLib_idxval_add(&h, 24334, 1);
		GMRFLib_idxval_add(&h, 24344, 1);
		GMRFLib_idxval_add(&h, 24345, 1);
		GMRFLib_idxval_add(&h, 24354, 1);
		GMRFLib_idxval_add(&h, 24357, 1);
		GMRFLib_idxval_add(&h, 24366, 1);
		GMRFLib_idxval_add(&h, 24375, 1);
		GMRFLib_idxval_add(&h, 24383, 1);
		GMRFLib_idxval_add(&h, 24392, 1);
		GMRFLib_idxval_add(&h, 24401, 1);
		GMRFLib_idxval_add(&h, 24410, 1);
		GMRFLib_idxval_add(&h, 24419, 1);
		GMRFLib_idxval_add(&h, 24428, 1);
		GMRFLib_idxval_add(&h, 24437, 1);
		GMRFLib_idxval_add(&h, 24446, 1);
		GMRFLib_idxval_add(&h, 24452, 1);
		GMRFLib_idxval_add(&h, 24458, 1);
		GMRFLib_idxval_add(&h, 24467, 1);
		GMRFLib_idxval_add(&h, 24476, 1);
		GMRFLib_idxval_add(&h, 24479, 1);
		GMRFLib_idxval_add(&h, 24488, 1);
		GMRFLib_idxval_add(&h, 24497, 1);
		GMRFLib_idxval_add(&h, 24506, 1);
		GMRFLib_idxval_add(&h, 24515, 1);
		GMRFLib_idxval_add(&h, 24522, 1);
		GMRFLib_idxval_add(&h, 24528, 1);
		GMRFLib_idxval_add(&h, 24532, 1);
		GMRFLib_idxval_add(&h, 24539, 1);
		GMRFLib_idxval_add(&h, 24542, 1);
		GMRFLib_idxval_add(&h, 24551, 1);
		GMRFLib_idxval_add(&h, 24560, 1);
		GMRFLib_idxval_add(&h, 24564, 1);
		GMRFLib_idxval_add(&h, 24572, 1);
		GMRFLib_idxval_add(&h, 24574, 1);
		GMRFLib_idxval_add(&h, 24575, 1);
		GMRFLib_idxval_add(&h, 24583, 1);
		GMRFLib_idxval_add(&h, 24591, 1);
		GMRFLib_idxval_add(&h, 24599, 1);
		GMRFLib_idxval_add(&h, 24602, 1);
		GMRFLib_idxval_add(&h, 24610, 1);
		GMRFLib_idxval_add(&h, 24611, 1);
		GMRFLib_idxval_add(&h, 24619, 1);
		GMRFLib_idxval_add(&h, 24623, 1);
		GMRFLib_idxval_add(&h, 24631, 1);
		GMRFLib_idxval_add(&h, 24639, 1);
		GMRFLib_idxval_add(&h, 24647, 1);
		GMRFLib_idxval_add(&h, 24654, 1);
		GMRFLib_idxval_add(&h, 24662, 1);
		GMRFLib_idxval_add(&h, 24668, 1);
		GMRFLib_idxval_add(&h, 24674, 1);
		GMRFLib_idxval_add(&h, 24676, 1);
		GMRFLib_idxval_add(&h, 24684, 1);
		GMRFLib_idxval_add(&h, 24687, 1);
		GMRFLib_idxval_add(&h, 24694, 1);
		GMRFLib_idxval_add(&h, 24697, 1);
		GMRFLib_idxval_add(&h, 24702, 1);
		GMRFLib_idxval_add(&h, 24710, 1);
		GMRFLib_idxval_add(&h, 24715, 1);
		GMRFLib_idxval_add(&h, 24718, 1);
		GMRFLib_idxval_add(&h, 24726, 1);
		GMRFLib_idxval_add(&h, 24734, 1);
		GMRFLib_idxval_add(&h, 24741, 1);
		GMRFLib_idxval_add(&h, 24748, 1);
		GMRFLib_idxval_add(&h, 24756, 1);
		GMRFLib_idxval_add(&h, 24763, 1);
		GMRFLib_idxval_add(&h, 24766, 1);
		GMRFLib_idxval_add(&h, 24773, 1);
		GMRFLib_idxval_add(&h, 24780, 1);
		GMRFLib_idxval_add(&h, 24787, 1);
		GMRFLib_idxval_add(&h, 24794, 1);
		GMRFLib_idxval_add(&h, 24801, 1);
		GMRFLib_idxval_add(&h, 24806, 1);
		GMRFLib_idxval_add(&h, 24813, 1);
		GMRFLib_idxval_add(&h, 24819, 1);
		GMRFLib_idxval_add(&h, 24823, 1);
		GMRFLib_idxval_add(&h, 24828, 1);
		GMRFLib_idxval_add(&h, 24832, 1);
		GMRFLib_idxval_add(&h, 24839, 1);
		GMRFLib_idxval_add(&h, 24840, 1);
		GMRFLib_idxval_add(&h, 24844, 1);
		GMRFLib_idxval_add(&h, 24850, 1);
		GMRFLib_idxval_add(&h, 24856, 1);
		GMRFLib_idxval_add(&h, 24863, 1);
		GMRFLib_idxval_add(&h, 24870, 1);
		GMRFLib_idxval_add(&h, 24875, 1);
		GMRFLib_idxval_add(&h, 24880, 1);
		GMRFLib_idxval_add(&h, 24886, 1);
		GMRFLib_idxval_add(&h, 24893, 1);
		GMRFLib_idxval_add(&h, 24900, 1);
		GMRFLib_idxval_add(&h, 24906, 1);
		GMRFLib_idxval_add(&h, 24913, 1);
		GMRFLib_idxval_add(&h, 24919, 1);
		GMRFLib_idxval_add(&h, 24920, 1);
		GMRFLib_idxval_add(&h, 24925, 1);
		GMRFLib_idxval_add(&h, 24932, 1);
		GMRFLib_idxval_add(&h, 24938, 1);
		GMRFLib_idxval_add(&h, 24944, 1);
		GMRFLib_idxval_add(&h, 24950, 1);
		GMRFLib_idxval_add(&h, 24955, 1);
		GMRFLib_idxval_add(&h, 24959, 1);
		GMRFLib_idxval_add(&h, 24962, 1);
		GMRFLib_idxval_add(&h, 24968, 1);
		GMRFLib_idxval_add(&h, 24971, 1);
		GMRFLib_idxval_add(&h, 24977, 1);
		GMRFLib_idxval_add(&h, 24983, 1);
		GMRFLib_idxval_add(&h, 24989, 1);
		GMRFLib_idxval_add(&h, 24992, 1);
		GMRFLib_idxval_add(&h, 24998, 1);
		GMRFLib_idxval_add(&h, 25000, 1);
		GMRFLib_idxval_add(&h, 25006, 1);
		GMRFLib_idxval_add(&h, 25012, 1);
		GMRFLib_idxval_add(&h, 25013, 1);
		GMRFLib_idxval_add(&h, 25019, 1);
		GMRFLib_idxval_add(&h, 25025, 1);
		GMRFLib_idxval_add(&h, 25030, 1);
		GMRFLib_idxval_add(&h, 25036, 0);
		GMRFLib_idxval_add(&h, 25037, 0);
		GMRFLib_idxval_add(&h, 25038, 0);
		GMRFLib_idxval_add(&h, 25039, 0);
		GMRFLib_idxval_add(&h, 25040, 0);
		GMRFLib_idxval_add(&h, 25042, 1);
		GMRFLib_idxval_add(&h, 25048, 1);
		GMRFLib_idxval_add(&h, 25054, 1);
		GMRFLib_idxval_add(&h, 25060, 1);
		GMRFLib_idxval_add(&h, 25065, 1);
		GMRFLib_idxval_add(&h, 25070, 1);
		GMRFLib_idxval_add(&h, 25075, 1);

		GMRFLib_idxval_nsort_x(&h, 1, 1, -1);
	}
		break;

	case 82:
	{
		int n = atoi(args[0]);
		int ntimes = atoi(args[1]);
		double *x = Calloc(n, double);
		for (int i = 0; i < n; i++) {
			x[i] = GMRFLib_uniform();
			// x[i] = i+1;
		}

		P(n);
		P(ntimes);

		double tref[2] = { 0.0, 0.0 };
		double r = 0.0, rr = 0.0;

		for (int time = 0; time < ntimes; time++) {

			tref[0] -= GMRFLib_cpu();
			r += GMRFLib_dsum(n, x);
			tref[0] += GMRFLib_cpu();

			tref[1] -= GMRFLib_cpu();
#pragma GCC ivdep
			for (int i = 0; i < n; i++) {
				rr += x[i];
			}
			tref[1] += GMRFLib_cpu();
		}

		printf("dsum %.3f plain %.3f (r-rr=%.12f, %1d)\n", tref[0] / (tref[0] + tref[1]), tref[1] / (tref[0] + tref[1]), r - rr, r == rr);

		Free(x);
	}
		break;

	case 83:
	{
		FIXME("FREE in idxval.c needs to disabled for this to run");
		int n = atoi(args[0]);
		int ntimes = atoi(args[1]);
		double *xx = Calloc(n, double);

		for (int i = 0; i < n; i++) {
			xx[i] = GMRFLib_uniform();
		}

		GMRFLib_idxval_tp *h = NULL;
		for (int i = 0, j = 0; i < n; i++) {
			j += 1 + (GMRFLib_uniform() < 0.9 ? 0.0 : 1 + (int) (GMRFLib_uniform() * 31));
			if (j >= n)
				break;
			GMRFLib_idxval_add(&h, j, xx[j]);
		}
		GMRFLib_idxval_nsort_x(&h, 1, 1, 0);
		assert(h);
		P(n);
		P(h->g_n);
		P(h->n / h->g_n);

		double sum1 = 0.0, sum2 = 0.0;
		double tref1 = 0.0, tref2 = 0.0;
		for (int k = 0; k < ntimes; k++) {
			sum1 = sum2 = 0.0;
			tref1 -= GMRFLib_cpu();
			sum1 = GMRFLib_dot_product_serial(h, xx);
			tref1 += GMRFLib_cpu();

			tref2 -= GMRFLib_cpu();
			sum2 = GMRFLib_dot_product_group(h, xx);
			tref2 += GMRFLib_cpu();
			if (ABS(sum1 - sum2) > 1e-8) {
				P(sum1);
				P(sum2);
				exit(88);
			}
		}
		printf("serial %.3f group %.3f (%.3f, %.3f)\n", tref1, tref2, tref1 / (tref1 + tref2), tref2 / (tref1 + tref2));
		Free(xx);
	}
		break;

	case 84:
	{
		FIXME("FREE in idxval.c needs to disabled for this to run");
		int n = atoi(args[0]);
		int m = atoi(args[1]);
		double *xx = Calloc(n, double);

		for (int i = 0; i < n; i++) {
			xx[i] = GMRFLib_uniform();
		}

		GMRFLib_idxval_tp *h = NULL;
		for (int i = 0, j = 0; i < n; i++) {
			j += 1 + (GMRFLib_uniform() < 0.9 ? 0.0 : 1 + (int) (GMRFLib_uniform() * 31));
			if (j >= n)
				break;
			GMRFLib_idxval_add(&h, j, xx[j]);
		}
		GMRFLib_idxval_nsort_x(&h, 1, 1, 0);
		P(n);
		P(m);
		P(h->g_n);
		P(h->n / h->g_n);

		double sum1 = 0.0, sum2 = 0.0;
		double tref1 = 0.0, tref2 = 0.0;
		for (int k = 0; k < m; k++) {
			sum1 = sum2 = 0.0;
			tref1 -= GMRFLib_cpu();
			sum1 = GMRFLib_ddot_idx(h->n, h->val, xx, h->idx);
			tref1 += GMRFLib_cpu();

			tref2 -= GMRFLib_cpu();
			for (int i = 0; i < h->n; i++) {
				sum2 += h->val[i] * xx[h->idx[i]];
			}
			tref2 += GMRFLib_cpu();
			if (ABS(sum1 - sum2) > 1e-8) {
				P(sum1);
				P(sum2);
				exit(88);
			}
		}
		printf("dot_idx %.3f serial %.3f (%.3f, %.3f)\n", tref1, tref2, tref1 / (tref1 + tref2), tref2 / (tref1 + tref2));
		Free(xx);
	}
		break;

	case 85:
	{
		int n = atoi(args[0]);
		int m = atoi(args[1]);

		double time = -GMRFLib_cpu();
		double sum = 0.0;
		int imin, imax;
		for (int k = 0; k < m; k++) {
			for (int i = 0; i < n; i++) {
				int ii = GMRFLib_uniform() * n;
				for (int j = 0; j < n; j++) {
					int jj = GMRFLib_uniform() * n;
					imin = IMIN(ii, jj);
					imax = IMAX(ii, jj);
					sum += imin - imax;
				}
			}
		}
		time += GMRFLib_cpu();
		printf("IMAX/MIN %.12f\n", time);

		sum = 0.0;
		time = -GMRFLib_cpu();
		for (int k = 0; k < m; k++) {
			for (int i = 0; i < n; i++) {
				int ii = GMRFLib_uniform() * n;
				for (int j = 0; j < n; j++) {
					int jj = GMRFLib_uniform() * n;
					if (ii <= jj) {
						imin = ii;
						imax = jj;
					} else {
						imin = jj;
						imax = ii;
					}
					sum += imin - imax;
				}
			}
		}
		time += GMRFLib_cpu();
		printf("if/ %.12f\n", time);
	}
		break;

	case 86:
	{
		double x = 0.0;
		double param[] = { 1, 0.001 };
		for (x = 0;; x++) {
			printf("x %f ldens %f\n", x, priorfunc_loggamma(&x, param));
		}
	}
		break;

	case 87:
	{
		int n = atoi(args[0]);
		int ntimes = atoi(args[1]);
		double *x = Calloc(n, double);
		for (int i = 0; i < n; i++) {
			x[i] = GMRFLib_uniform();
		}

		P(n);
		P(ntimes);

		double tref[2] = { 0.0, 0.0 };
		double r = 0.0, rr = 0.0;

		for (int time = 0; time < ntimes; time++) {

			tref[0] -= GMRFLib_cpu();
			r += GMRFLib_dsum(n, x);
			tref[0] += GMRFLib_cpu();

			tref[1] -= GMRFLib_cpu();
			rr += GMRFLib_dsum2(n, x);
			tref[1] += GMRFLib_cpu();
		}

		printf("dsum %.3f dsum2 %.3f\n", tref[0] / (tref[0] + tref[1]), tref[1] / (tref[0] + tref[1]));
		P((r - rr) / r);

		Free(x);
	}
		break;

	case 88:
	{
		int n = atoi(args[0]);
		int m = atoi(args[1]);
		double *xx = Calloc(n, double);

		for (int i = 0; i < n; i++) {
			xx[i] = GMRFLib_uniform();
		}

		P(n);
		P(m);

		double tref1 = 0.0, tref2 = 0.0;
		for (int k = 0; k < m; k++) {
			tref1 -= GMRFLib_cpu();
			double s = GMRFLib_uniform();
#pragma omp simd reduction(+: s)
			for (int i = 0; i < n; i++) {
				s += xx[i];
			}
			tref1 += GMRFLib_cpu();
			tref2 -= GMRFLib_cpu();
#pragma GCC ivdep
			for (int i = 0; i < n; i++) {
				s += xx[i];
			}
			tref2 += GMRFLib_cpu();
		}
		printf("simd %.3f opt %.3f (%.3f, %.3f)\n", tref1, tref2, tref1 / (tref1 + tref2), tref2 / (tref1 + tref2));
		Free(xx);
	}
		break;

	case 89:
	{
		FIXME("FREE in idxval.c needs to disabled for this to run");
		int n = atoi(args[0]);
		int m = atoi(args[1]);
		GMRFLib_idxval_tp *h = NULL;
		double *xx = Calloc(n, double);
		for (int i = 0; i < n; i++) {
			xx[i] = GMRFLib_uniform();
		}

		for (int i = 0, j = 0; i < n; i++) {
			j += 1 + (GMRFLib_uniform() < 0.9 ? 0 : 1 + (int) (GMRFLib_uniform() * 31));
			if (j >= n) {
				break;
			}
			GMRFLib_idxval_add(&h, j, GMRFLib_uniform());
		}
		GMRFLib_idxval_nsort_x(&h, 1, 1, 0);
		if (n == 0) {
			FIXME("n = 0,  try again.");
			exit(0);
		}
		P(n);
		P(m);
		P(h->g_n);
		P(h->n / h->g_n);

		double sum1 = 0.0, sum2 = 0.0;
		double tref1 = 0.0, tref2 = 0.0;
		for (int k = 0; k < m; k++) {
			sum1 = sum2 = 0.0;
			tref1 -= GMRFLib_cpu();
			sum1 = GMRFLib_ddot_idx(h->n, h->val, xx, h->idx);
			tref1 += GMRFLib_cpu();

			tref2 -= GMRFLib_cpu();
			sum2 = GMRFLib_ddot_idx_mkl(h->n, h->val, xx, h->idx);
			tref2 += GMRFLib_cpu();
			if (ABS(sum1 - sum2) > 1e-8) {
				P(sum1);
				P(sum2);
				exit(88);
			}
		}
		printf("dot_idx %.3f dot_idx_mkl %.3f (%.3f, %.3f)\n", tref1, tref2, tref1 / (tref1 + tref2), tref2 / (tref1 + tref2));
		Free(xx);
	}
		break;

	case 90:
	{
		int n = atoi(args[0]);
		int m = atoi(args[1]);
		double *xx = Calloc(n, double);
		for (int i = 0; i < n; i++) {
			xx[i] = GMRFLib_uniform();
		}

		P(n);
		P(m);
		double sum1 = 0.0, sum2 = 0.0;
		double tref1 = 0.0, tref2 = 0.0;
		for (int k = 0; k < m; k++) {
			sum1 = sum2 = 0.0;
			tref1 -= GMRFLib_cpu();
			sum1 = GMRFLib_dsum(n, xx);
			tref1 += GMRFLib_cpu();

			tref2 -= GMRFLib_cpu();
			sum2 = 0.0;
			for(int i = 0; i < n; i++) {
				sum2 += xx[i];
			}
			tref2 += GMRFLib_cpu();
			if (ABS(sum1 - sum2) > 1e-8) {
				P(sum1);
				P(sum2);
				exit(88);
			}
		}
		printf("_dsum %.3f loop %.3f (%.3f, %.3f)\n", tref1, tref2, tref1 / (tref1 + tref2), tref2 / (tref1 + tref2));
		Free(xx);
	}
		break;

	case 91: 
	{
		void *monobound_bsearch(const void *key, const void *array, size_t nmemb, size_t size);

		int n = atoi(args[0]);
		int m = atoi(args[1]);
		P(n);
		P(m);
		double start = 0, finish = 0;
		double start2 = 0, finish2 = 0;
		int * idx = Calloc(n, int);
		int key = 1;
		for(int i = 0; i < n; i++) {
			key += i;
			//printf("%d %d \n", i, key);
			idx[i] = key;
		}
		for(int k = 0; k < m; k++) {
			double sum = 0.0;
			start += omp_get_wtime();
			int low = 0;
			for(int i = 0; i < key+1; i++) {
				int p = GMRFLib_iwhich_sorted_g(i, idx, n, &low);
				if (p >= 0) sum += idx[p];
			}
			finish += omp_get_wtime();

			double sum2 = 0.0;
			start2 += omp_get_wtime();
			int guess[2] = {0, 0};
			for(int i = 0; i < key+1; i++) {
				int p = GMRFLib_iwhich_sorted_g2(i, idx, n, guess);
				if (p >= 0) sum2 += idx[p];
			}
			finish2 += omp_get_wtime();
			if (k == m-1)
				printf("n.lookups= %1d  Time for iwhich_g= %.4g iwhich_g2= %.4g ratio g/g2= %.4f\n",
				       key,
				       (finish-start)/(k+1.0),
				       (finish2 - start2)/(k+1.0),
				       (finish-start)/(finish2-start2));
		}
	}
                break;

	case 999:
	{
		GMRFLib_pardiso_check_install(0, 0);
	}
		break;

	default:
	{
		printf("\nNo such test: %d\n", test_no);
	}
		break;
	}
	exit(EXIT_SUCCESS);
}

int main(int argc, char **argv)
{
#define _USAGE_intern(fp)  fprintf(fp, "\nUsage: %s [-v] [-V] [-h] [-f] [-e var=value] [-t A:B] [-m MODE] FILE.INI\n", program)
#define _USAGE _USAGE_intern(stderr)
#define _HELP _USAGE_intern(stdout);					\
	printf("\t\t-v\t: Verbose output.\n");				\
	printf("\t\t-V\t: Print version and exit.\n");			\
	printf("\t\t-b\t: Use binary output-files.\n");			\
	printf("\t\t-s\t: Be silent.\n");				\
	printf("\t\t-c\t: Create core-file if needed (and allowed). (Linux/MacOSX only.)\n"); \
	printf("\t\t-R\t: Restart using previous mode.\n");		\
	printf("\t\t-e var=value\t: Set variable VAR to VALUE.\n");	\
	printf("\t\t-t A:B\t: the number of threads (A=outer,B=inner), 0 means auto\n"); \
	printf("\t\t-m MODE\t: Enable special mode:\n");		\
	printf("\t\t\tHYPER :  Enable HYPERPARAMETER mode\n");		\
	printf("\t\t-h\t: Print (this) help.\n")

#define _BUGS_intern(fp) fprintf(fp, "Report bugs to <help@r-inla.org>\n")
#define _BUGS _BUGS_intern(stdout)
	int i, verbose = 0, silent = 0, opt, arg, ntt[2] = { 0, 0 }, err;
#if !defined(WINDOWS)
	int enable_core_file = 0;			       /* allow for core files */
#endif
	int blas_num_threads_set = 0;
	int blas_num_threads_default = 1;
	char *program = argv[0];
	double time_used[4] = { -1, -1, -1, -1 };
#if !defined(WINDOWS)
	double eff_nt = 0.0;
#endif
	clock_t atime_used[4] = { 0, 0, 0, 0 };
	inla_tp *mb = NULL;

	int host_max_threads = IMAX(omp_get_max_threads(), omp_get_num_procs());

	GMRFLib_openmp = Calloc(1, GMRFLib_openmp_tp);
	GMRFLib_openmp->max_threads = host_max_threads;
	GMRFLib_openmp->blas_num_threads = blas_num_threads_default;
	GMRFLib_openmp->max_threads_nested = Calloc(2, int);
	GMRFLib_openmp->max_threads_nested[0] = GMRFLib_openmp->max_threads;
	GMRFLib_openmp->max_threads_nested[1] = 1;
	GMRFLib_openmp->adaptive = GMRFLib_FALSE;
	GMRFLib_openmp->strategy = GMRFLib_OPENMP_STRATEGY_DEFAULT;
	GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_DEFAULT, NULL, NULL);

	GMRFLib_bitmap_max_dimension = 512;
	GMRFLib_bitmap_swap = GMRFLib_TRUE;
	GMRFLib_aqat_m_diag_add = GMRFLib_eps(0.5);

	GMRFLib_init_constr_store();
	GMRFLib_init_constr_store_logdet();		       /* no need to reset this with preopt */
	GMRFLib_graph_init_store();			       /* no need to reset this with pretop */
	GMRFLib_csr_init_store();
	GMRFLib_trace_functions(NULL);
	GMRFLib_debug_functions(NULL);
	GMRFLib_reorder = G.reorder;
	GMRFLib_inla_mode = GMRFLib_MODE_CLASSIC;

	/*
	 * special option: if one of the arguments is `--ping', then just return INLA[<VERSION>] IS ALIVE 
	 */
	for (i = 1; i < argc; i++) {
		if (!strcasecmp(argv[i], "-ping") || !strcasecmp(argv[i], "--ping")) {
			printf("INLA[%s] IS ALIVE\n", GitID);
			exit(EXIT_SUCCESS);
		}
	}

#if !defined(WINDOWS)
	signal(SIGUSR1, inla_signal);
	signal(SIGUSR2, inla_signal);
	signal(SIGINT, inla_signal);
#endif
	while ((opt = getopt(argc, argv, "vVe:t:B:m:S:z:hsfr:R:cpLP:")) != -1) {
		switch (opt) {
		case 'P':
		{
			if (!strcasecmp(optarg, "CLASSIC") || !strcasecmp(optarg, "CLASSICAL")) {
				GMRFLib_inla_mode = GMRFLib_MODE_CLASSIC;
			} else if (!strcasecmp(optarg, "TWOSTAGE")) {
				GMRFLib_inla_mode = GMRFLib_MODE_TWOSTAGE;
			} else if (!strcasecmp(optarg, "EXPERIMENTAL")) {
				GMRFLib_inla_mode = GMRFLib_MODE_EXPERIMENTAL;
			} else {
				assert(0 == 1);
			}
		}
			break;

		case 'v':
		{
			silent = 1;
			verbose++;
		}
			break;

		case 'V':
		{
			printf("This program has version:\n\t%s\nand is linked with ", GitID);
			GMRFLib_version(stdout);
			_BUGS;
			exit(EXIT_SUCCESS);
		}
			break;
		case 'e':
		{
			my_setenv(optarg, 1);
		}
			break;

		case 'B':
		{
			if (inla_sread_ints(&blas_num_threads_default, 1, optarg) == INLA_OK) {
				blas_num_threads_default = IMAX(blas_num_threads_default, 1);
				GMRFLib_openmp->blas_num_threads = blas_num_threads_default;
				blas_num_threads_set = 1;
			} else {
				fprintf(stderr, "Fail to read BLAS_NUM_THREADS from %s\n", optarg);
				exit(EXIT_SUCCESS);
			}
		}
			break;

		case 'm':
		{
			if (!strncasecmp(optarg, "HYPER", 5)) {
				G.mode = INLA_MODE_HYPER;
			} else if (!strncasecmp(optarg, "QINV", 4)) {
				G.mode = INLA_MODE_QINV;
			} else if (!strncasecmp(optarg, "QSOLVE", 6)) {
				G.mode = INLA_MODE_QSOLVE;
			} else if (!strncasecmp(optarg, "QREORDERING", 11)) {
				G.mode = INLA_MODE_QREORDERING;
			} else if (!strncasecmp(optarg, "QSAMPLE", 7)) {
				G.mode = INLA_MODE_QSAMPLE;
			} else if (!strncasecmp(optarg, "FINN", 4)) {
				G.mode = INLA_MODE_FINN;
			} else if (!strncasecmp(optarg, "GRAPH", 5)) {
				G.mode = INLA_MODE_GRAPH;
			} else if (!strncasecmp(optarg, "R", 1)) {
				G.mode = INLA_MODE_R;
			} else if (!strncasecmp(optarg, "FGN", 3)) {
				G.mode = INLA_MODE_FGN;
			} else if (!strncasecmp(optarg, "PARDISO", 7)) {
				G.mode = INLA_MODE_PARDISO;
			} else if (!strncasecmp(optarg, "OPENMP", 6)) {
				G.mode = INLA_MODE_OPENMP;
			} else if (!strncasecmp(optarg, "TESTIT", 6)) {
				G.mode = INLA_MODE_TESTIT;
			} else {
				fprintf(stderr, "\n*** Error: Unknown mode (argument to '-m') : %s\n", optarg);
				exit(EXIT_FAILURE);
			}
		}
			break;

		case 'S':
		{
			// this option is only used for other MODES than INLA, like qsample
			inla_tolower(optarg);
			if (!strcasecmp(optarg, "default")) {
				if (GMRFLib_pardiso_check_install(1, 1) == GMRFLib_SUCCESS ? 1 : 0) {
					GMRFLib_smtp = GMRFLib_SMTP_PARDISO;
				} else {
					GMRFLib_smtp = GMRFLib_SMTP_TAUCS;
				}
			} else if (!strcasecmp(optarg, "taucs")) {
				GMRFLib_smtp = GMRFLib_SMTP_TAUCS;
			} else if (!strcasecmp(optarg, "band")) {
				GMRFLib_smtp = GMRFLib_SMTP_BAND;
			} else if (!strcasecmp(optarg, "pardiso")) {
				GMRFLib_smtp = GMRFLib_SMTP_PARDISO;
				GMRFLib_openmp->strategy = GMRFLib_OPENMP_STRATEGY_PARDISO;
			}
			GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_EXTERNAL, NULL, &GMRFLib_smtp);
		}
			break;

		case 't':
		{
			if (inla_sread_colon_ints(&ntt[0], &ntt[1], optarg) == INLA_OK || inla_sread(ntt, 1, optarg, 0) == INLA_OK) {

				if (verbose > 0) {
					printf("\tRead ntt %d %d with max.threads %d\n", ntt[0], ntt[1], GMRFLib_openmp->max_threads);
				}

				// a hidden option...  enable also if ntt[1] > 1, not only if < 0.
				if (ntt[1] > 1 || ntt[1] < 0) {
					ntt[1] = IABS(ntt[1]);
					GMRFLib_openmp->adaptive = GMRFLib_TRUE;
				}

				for (i = 0; i < 2; i++) {
					ntt[i] = IMAX(0, ntt[i]);
				}

				// replace 0 with auto-values
				if (ntt[0] == 0 && ntt[1] == 0) {
					ntt[0] = GMRFLib_openmp->max_threads;
					ntt[1] = 1;
				} else if (ntt[0] == 0 && ntt[1] > 0) {
					ntt[0] = GMRFLib_openmp->max_threads / ntt[1];
				} else if (ntt[1] == 0) {
					// let 0 means 1 for the moment. only larger problems gives a speedup,
					// much likely it will slow things down.
					// ntt[1] = GMRFLib_openmp->max_threads / ntt[0];
					ntt[1] = 1;
				}
				if (!blas_num_threads_set) {
					// this happens unless the -B option have been used already
					GMRFLib_openmp->blas_num_threads = 1;
				}

				if (ntt[0] * ntt[1] > GMRFLib_MAX_THREADS()) {
					fprintf(stderr, "\n\n\tYou ask for %1d x %1d = %1d number of threads,\n", ntt[0], ntt[1], ntt[0] * ntt[1]);
					fprintf(stderr, "\twhich is more that I got from the system: %1d\n", GMRFLib_MAX_THREADS());

					if (ntt[0] > GMRFLib_MAX_THREADS()) {
						ntt[0] = GMRFLib_MAX_THREADS();
						ntt[1] = 1;
					} else if (ntt[1] > GMRFLib_MAX_THREADS()) {
						ntt[1] = GMRFLib_MAX_THREADS();
						ntt[0] = 1;
					} else {
						// something gotta give
						while (ntt[0] * ntt[1] > GMRFLib_MAX_THREADS()) {
							ntt[1]--;
						}
					}
					fprintf(stderr, "\tNumber of threads is reduced to %1d:%1d\n\n", ntt[0], ntt[1]);
				}

				for (i = 0; i < 2; i++) {
					ntt[i] = IMAX(1, ntt[i]);
					GMRFLib_openmp->max_threads_nested[i] = ntt[i];
				}
				GMRFLib_openmp->max_threads = IMIN(GMRFLib_MAX_THREADS(), ntt[0] * ntt[1]);
			} else {
				fprintf(stderr, "Fail to read A:B from [%s]\n", optarg);
				fprintf(stderr, "Will continue with '4:1'\n");
				ntt[0] = 4;
				ntt[1] = 1;
				for (i = 0; i < 2; i++) {
					ntt[i] = IMIN(GMRFLib_openmp->max_threads, IMAX(1, ntt[i]));
					GMRFLib_openmp->max_threads_nested[i] = ntt[i];
				}
				GMRFLib_openmp->max_threads = ntt[0] * ntt[1];
			}
			if (verbose > 0) {
				printf("\tFound num.threads = %1d:%1d max_threads = %1d\n", GMRFLib_openmp->max_threads_nested[0],
				       GMRFLib_openmp->max_threads_nested[1], GMRFLib_openmp->max_threads);
			}
			omp_set_num_threads(GMRFLib_MAX_THREADS());
			GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_DEFAULT, NULL, NULL);
		}
			break;

		case 'z':
		{
			if (!(G.mode == INLA_MODE_FINN || G.mode == INLA_MODE_QSAMPLE || G.mode == INLA_MODE_TESTIT)) {
				fprintf(stderr, "\n *** ERROR *** Option `-z seed' only available in selected modes\n");
				exit(EXIT_FAILURE);
			} else {
				int int_seed;
				if (inla_sread_ints(&int_seed, 1, optarg) == INLA_OK) {
					;
				} else {
					fprintf(stderr, "Fail to read FINN_SEED from %s\n", optarg);
					exit(EXIT_SUCCESS);
				}
				if (int_seed != 0) {
					/*
					 * this is only for the main thread...
					 */
					GMRFLib_rng_init((unsigned long int) int_seed);
				}
			}
		}
			break;

		case 'h':
		{
			_HELP;
			_BUGS;
			exit(EXIT_SUCCESS);
		}
			break;

		case 's':
		{
			verbose = 0;
			silent = 1;
		}
			break;

		case 'f':
		{
			GMRFLib_fpe();
		}
			break;

		case 'r':
		{
			int itmp;
			err = inla_sread_ints(&itmp, 1, optarg);
			G.reorder = (GMRFLib_reorder_tp) itmp;
			if (err) {
				itmp = GMRFLib_reorder_id((const char *) optarg);
				G.reorder = (GMRFLib_reorder_tp) itmp;
			}
			GMRFLib_reorder = G.reorder;	       /* yes! */
		}
			break;

		case 'R':
		{
			int nrhs = 0;
			err = inla_sread_ints(&nrhs, 1, optarg);
			if (err || nrhs < 0) {
				GMRFLib_ASSERT(err, GMRFLib_EPARAMETER);
				exit(1);
			}
			GMRFLib_pardiso_set_nrhs(nrhs);
		}
			break;

		case 'c':
		{
#if !defined(WINDOWS)
			enable_core_file = 1;		       /* allow for core files */
#endif
		}
			break;

		case 'p':
		{
#if !defined(WINDOWS)
			long int pid = (long int) getpid();
			FILE *fp_pid = fopen(".inla.pid", "w");
			if (fp_pid) {
				fprintf(fp_pid, "%ld\n", pid);
				fclose(fp_pid);
			}
#endif
		}
			break;

		case 'L':
		{
			// link with vecLib on Mac. this is just dummy option
		}
			break;

		default:
			_USAGE;
			exit(EXIT_FAILURE);
		}
	}

	// I need to set it here as it depends on MAX_THREADS
	GMRFLib_dot_product_optim_report = Calloc(GMRFLib_CACHE_LEN, double *);
	for (int i = 0; i < GMRFLib_CACHE_LEN; i++) {
		GMRFLib_dot_product_optim_report[i] = Calloc(9, double);
	}

#if !defined(WINDOWS)
	/*
	 * disable the creation of core-file, unless explicite asked for by the argument '-c'.
	 */
	struct rlimit rlim;
	getrlimit(RLIMIT_CORE, &rlim);
	rlim.rlim_cur = (enable_core_file ? rlim.rlim_max : (rlim_t) 0L);
	setrlimit(RLIMIT_CORE, (const struct rlimit *) &rlim);
	if (0) {
		getrlimit(RLIMIT_CORE, &rlim);
		printf("NEW cur %lld max %lld\n", (long long) rlim.rlim_cur, (long long) rlim.rlim_max);
	}
#endif

	/*
	 * these options does not belong here in this program, but it makes all easier... and its undocumented.
	 */
	switch (G.mode) {
	case INLA_MODE_OPENMP:
	{
		printf("export OMP_NUM_THREADS=%1d,%1d,1,1; ", GMRFLib_openmp->max_threads_nested[0], GMRFLib_openmp->max_threads_nested[1]);
		printf("export OMP_NESTED=TRUE; ");
		printf("export OMP_MAX_ACTIVE_LEVELS=%1d; ", GMRFLib_MAX_THREADS());
		printf("export MKL_NUM_THREADS=%1d; export OPENBLAS_NUM_THREADS=%1d;", GMRFLib_openmp->blas_num_threads,
		       GMRFLib_openmp->blas_num_threads);
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_QINV:
	{
		inla_qinv(argv[optind], argv[optind + 1], argv[optind + 2]);
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_QSOLVE:
	{
		inla_qsolve(argv[optind], argv[optind + 1], argv[optind + 2], argv[optind + 3]);
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_QREORDERING:
	{
		inla_qreordering(argv[optind]);
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_QSAMPLE:
	{
		inla_qsample(argv[optind], argv[optind + 1], argv[optind + 2], argv[optind + 3], argv[optind + 4], argv[optind + 5],
			     argv[optind + 6], argv[optind + 7], argv[optind + 8], argv[optind + 9], verbose);
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_FINN:
	{
		inla_finn(argv[optind]);
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_GRAPH:
	{
		inla_read_graph(argv[optind]);
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_R:
	{
		inla_R(&(argv[optind]));
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_FGN:
	{
		inla_fgn(argv[optind], argv[optind + 1]);
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_PARDISO:
	{
		inla_check_pardiso();
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_TESTIT:
	{
		testit(argc - optind, &(argv[optind]));
		exit(EXIT_SUCCESS);
	}
		break;

	case INLA_MODE_HYPER:
	case INLA_MODE_DEFAULT:
		break;

	default:
		break;
	}

	if (!silent || verbose) {
		fprintf(stdout, "\n\t%s\n", GitID);
	}
	if (verbose) {
		_BUGS_intern(stdout);
	}
	if (verbose && G.reorder >= 0) {
		printf("Set reordering to id=[%d] and name=[%s]\n", G.reorder, GMRFLib_reorder_name(G.reorder));
	}
	if (optind >= argc) {
		fprintf(stderr, "\n*** Error: Expected argument after options.\n");
		_USAGE;
		exit(EXIT_FAILURE);
	}
	if (optind < argc - 1) {
		fprintf(stderr, "\n");
		for (i = 0; i < argc; i++) {
			fprintf(stderr, "\targv[%1d] = [%s]\n", i, argv[i]);
		}
		fprintf(stderr, "\targc=[%1d] optind=[%1d]\n\n", argc, optind);
		fprintf(stderr, "\n*** Error: Can only process one .INI-file at the time.\n");
		exit(EXIT_SUCCESS);
	}
	if (verbose) {
		if (G.mode == INLA_MODE_HYPER) {
			fprintf(stderr, "\nRun in mode=[%s]\n", "HYPER");
		}
	}

	if (G.mode == INLA_MODE_DEFAULT || G.mode == INLA_MODE_HYPER) {
		for (arg = optind; arg < argc; arg++) {
			if (verbose) {
				printf("Process file[%s] threads[%1d] max.threads[%1d] blas_threads[%1d]",
				       argv[arg], GMRFLib_MAX_THREADS(), host_max_threads, GMRFLib_openmp->blas_num_threads);
				if (GMRFLib_openmp->max_threads_nested) {
					printf(" nested[%1d:%1d]\n", GMRFLib_openmp->max_threads_nested[0], GMRFLib_openmp->max_threads_nested[1]);
				} else {
					printf("\n");
				}
			}
			if (!silent) {
				printf("\nWall-clock time used on [%s] max_threads=[%1d]\n", argv[arg], GMRFLib_MAX_THREADS());
			}
			time_used[0] = GMRFLib_cpu();
			atime_used[0] = clock();

			GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_PARSE_MODEL, NULL, NULL);
			mb = inla_build(argv[arg], verbose, 1);
			GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_BUILD_MODEL, NULL, NULL);
			time_used[0] = GMRFLib_cpu() - time_used[0];
			atime_used[0] = clock() - atime_used[0];
			if (!silent) {
				printf("\tPreparations             : %7.3f seconds\n", time_used[0]);
				fflush(stdout);
			}
			time_used[1] = GMRFLib_cpu();
			atime_used[1] = clock();

			int nfunc[2] = { 0, 0 };
			double rgeneric_cpu[2] = { 0.0, 0.0 };

			if (GMRFLib_inla_mode == GMRFLib_MODE_EXPERIMENTAL) {
				time_used[3] = GMRFLib_cpu();
				inla_INLA_preopt_experimental(mb);
				time_used[3] = GMRFLib_cpu() - time_used[1];
				atime_used[3] = clock() - atime_used[1];
				nfunc[0] = mb->misc_output->nfunc;
				rgeneric_cpu[0] = R_rgeneric_cputime;

				Free(mb->theta_file);
				Free(mb->x_file);
				if (mb->preopt->mode_theta) {
					mb->theta_file = Calloc(mb->ntheta, double);
					Memcpy(mb->theta_file, mb->preopt->mode_theta, mb->ntheta * sizeof(double));
				} else {
					mb->theta_file = NULL;
				}
				mb->x_file = Calloc(mb->preopt->n + mb->preopt->mnpred, double);
				Memcpy(mb->x_file, mb->preopt->mode_x, (mb->preopt->n + mb->preopt->mnpred) * sizeof(double));
				mb->ntheta_file = mb->ntheta;
				mb->nx_file = mb->preopt->n + mb->preopt->mnpred;
				mb->reuse_mode = GMRFLib_TRUE;
				mb->reuse_mode_but_restart = GMRFLib_FALSE;
				mb->ai_par->mode_known = GMRFLib_TRUE;
				inla_reset();
			} else if (GMRFLib_inla_mode == GMRFLib_MODE_TWOSTAGE) {

				GMRFLib_preopt_res_tp *rpreopt = Calloc(1, GMRFLib_preopt_res_tp);

				time_used[3] = GMRFLib_cpu();
				GMRFLib_inla_mode = GMRFLib_MODE_TWOSTAGE_PART1;
				inla_INLA_preopt_stage1(mb, rpreopt);
				time_used[3] = GMRFLib_cpu() - time_used[1];
				atime_used[3] = clock() - atime_used[1];
				nfunc[0] = mb->misc_output->nfunc;
				rgeneric_cpu[0] = R_rgeneric_cputime;

				Free(mb->theta_file);
				Free(mb->x_file);
				if (mb->preopt->mode_theta) {
					mb->theta_file = Calloc(mb->ntheta, double);
					Memcpy(mb->theta_file, mb->preopt->mode_theta, mb->ntheta * sizeof(double));
				} else {
					mb->theta_file = NULL;
				}
				mb->x_file = Calloc(mb->preopt->n + mb->preopt->mnpred, double);
				Memcpy(mb->x_file, mb->preopt->mode_x, (mb->preopt->n + mb->preopt->mnpred) * sizeof(double));
				mb->ntheta_file = mb->ntheta;
				mb->nx_file = mb->preopt->n + mb->preopt->mnpred;
				mb->reuse_mode = GMRFLib_TRUE;
				mb->reuse_mode_but_restart = GMRFLib_FALSE;
				mb->ai_par->mode_known = GMRFLib_TRUE;
				GMRFLib_preopt_free(mb->preopt);
				inla_reset();
				GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_DEFAULT, NULL, NULL);
				GMRFLib_inla_mode = GMRFLib_MODE_TWOSTAGE_PART2;
				inla_INLA_preopt_stage2(mb, rpreopt);
				nfunc[1] = mb->misc_output->nfunc;
				rgeneric_cpu[1] = R_rgeneric_cputime;
			} else if (GMRFLib_inla_mode == GMRFLib_MODE_CLASSIC) {
				GMRFLib_inla_mode = GMRFLib_MODE_CLASSIC;
				inla_INLA(mb);
				nfunc[0] = mb->misc_output->nfunc;
			} else {
				assert(0 == 1);
			}

			time_used[1] = GMRFLib_cpu() - time_used[1];
			atime_used[1] = clock() - atime_used[1];
			if (!silent) {
				if (GMRFLib_inla_mode == GMRFLib_MODE_CLASSIC) {
					printf("\tApprox inference         : %7.3f seconds\n", time_used[1]);
				} else {
					printf("\tApprox inference (stage1): %7.3f seconds\n", time_used[3]);
					printf("\tApprox inference (stage2): %7.3f seconds\n", time_used[1] - time_used[3]);
					printf("\tApprox inference (total) : %7.3f seconds\n", time_used[1]);
				}
				fflush(stdout);
			}
			time_used[2] = GMRFLib_cpu();
			atime_used[2] = clock();
			GMRFLib_openmp_implement_strategy(GMRFLib_OPENMP_PLACES_DEFAULT, NULL, NULL);
			inla_output(mb);
			time_used[2] = GMRFLib_cpu() - time_used[2];
			atime_used[2] = clock() - atime_used[2];

#define PEFF_OUTPUT if (1) {						\
				printf("Total:");			\
				eff_nt = ((double)(atime_used[0] + atime_used[1]))/CLOCKS_PER_SEC/(time_used[0] + time_used[1]);	\
				printf("\tAccumulated CPU-time is equivalent to %.2f threads running at 100%%\n", eff_nt); \
				printf("\tEfficiency using %1d threads = %.2f%%\n", GMRFLib_MAX_THREADS(), \
				       100.0 * eff_nt/GMRFLib_MAX_THREADS()); \
			}
#define PEFF_PREOPT_OUTPUT if (1) {					\
				printf("Stage1:");			\
				eff_nt = ((double)(atime_used[0] + atime_used[3]))/CLOCKS_PER_SEC/(time_used[0] + time_used[3]);	\
				printf("\tAccumulated CPU-time is equivalent to %.2f threads running at 100%%\n", eff_nt); \
				printf("\tEfficiency using %1d threads = %.2f%%\n", GMRFLib_MAX_THREADS(), \
				       100.0 * eff_nt/GMRFLib_MAX_THREADS()); \
				printf("Stage2:");			\
				eff_nt = ((double)(atime_used[0] + atime_used[1] - atime_used[3]))/CLOCKS_PER_SEC/(time_used[0] + time_used[1] - time_used[3]); \
				printf("\tAccumulated CPU-time is equivalent to %.2f threads running at 100%%\n", eff_nt); \
				printf("\tEfficiency using %1d threads = %.2f%%\n", GMRFLib_MAX_THREADS(), \
				       100.0 * eff_nt/GMRFLib_MAX_THREADS()); \
			}

			if (!silent) {
				printf("\tOutput                   : %7.3f seconds\n", time_used[2]);
				printf("\t------------------------------------------\n");
				printf("\tTotal                    : %7.3f seconds\n\n", time_used[0] + time_used[1] + time_used[2]);
#if !defined(WINDOWS)
				if (GMRFLib_inla_mode != GMRFLib_MODE_CLASSIC) {
					PEFF_PREOPT_OUTPUT;
				}
				PEFF_OUTPUT;
#endif
				fflush(stdout);
			}
			if (verbose) {
				printf("\nWall-clock time used on [%s]\n", argv[arg]);
				printf("\tPreparations             : %7.3f seconds\n", time_used[0]);
				if (GMRFLib_inla_mode == GMRFLib_MODE_CLASSIC) {
					printf("\tApprox inference         : %7.3f seconds\n", time_used[1]);
				} else {
					printf("\tApprox inference (stage1): %7.3f seconds\n", time_used[3]);
					printf("\tApprox inference (stage2): %7.3f seconds\n", time_used[1] - time_used[3]);
					printf("\tApprox inference (total) : %7.3f seconds\n", time_used[1]);
				}
				printf("\tOutput                   : %7.3f seconds\n", time_used[2]);
				printf("\t------------------------------------------\n");
				printf("\tTotal                    : %7.3f seconds\n\n", time_used[0] + time_used[1] + time_used[2]);

				if (GMRFLib_inla_mode == GMRFLib_MODE_CLASSIC) {
					printf("\nNumber of fn-calls= %1d with %.4f sec/fn-call\n",
					       mb->misc_output->nfunc, time_used[1] / IMAX(1, mb->misc_output->nfunc));
					if (R_rgeneric_cputime > 0.0) {
						printf("rgeneric-time= %.4f seconds, with %.4f sec/fn-call and %.4f%% of the total time\n",
						       R_rgeneric_cputime,
						       R_rgeneric_cputime / IMAX(1, mb->misc_output->nfunc),
						       R_rgeneric_cputime / time_used[1] * 100.0);
					}
				} else {
					printf("Stage1:");
					printf("\tNumber of fn-calls= %1d with %.4f sec/fn-call\n", nfunc[0], time_used[3] / IMAX(1, nfunc[0]));
					if (rgeneric_cpu[0] > 0.0) {
						printf("\trgeneric-time= %.4f seconds, with %.4f sec/fn-call and %.4f%% of the total time\n",
						       rgeneric_cpu[0],
						       rgeneric_cpu[0] / IMAX(1, nfunc[0]), rgeneric_cpu[0] / time_used[3] * 100.0);
					}
					printf("Stage2:");
					printf("\tNumber of fn-calls= %1d with %.4f sec/fn-call\n", nfunc[1], time_used[1] / IMAX(1, nfunc[1]));
					if (rgeneric_cpu[1] > 0.0) {
						printf("\trgeneric-time= %.4f seconds, with %.4f sec/fn-call and %.4f%% of the total time\n",
						       rgeneric_cpu[1],
						       rgeneric_cpu[1] / IMAX(1, nfunc[1]),
						       rgeneric_cpu[1] / (time_used[1] - time_used[3]) * 100.0);
					}
				}

#if !defined(WINDOWS)
				if (GMRFLib_inla_mode != GMRFLib_MODE_CLASSIC) {
					PEFF_PREOPT_OUTPUT;
				}
				PEFF_OUTPUT;
#endif
				printf("\n");
			}
		}
	}

	/*
	 * final output (if not mcmc mode)
	 */
	if (mb) {
		inla_output_ok(mb->dir);
	}

	return EXIT_SUCCESS;
#undef _USAGE_intern
#undef _USAGE
#undef _HELP
#undef _BUGS_intern
#undef _BUGS
}
