%%
%% WARNING! DO NOT EDIT!
%% This file is automatically generated from posterior.sample.R
%%
 \name{inla.sample}
 \alias{inla.posterior.sample}
 \alias{posterior.sample}
 
 \title{Generate samples from an approximated posterior of a fitted model}
 
 \description{This function generate samples from an approximated posterior
              of a fitted model (an inla-object}
 \usage{
     inla.posterior.sample(n = 1L, result, intern = FALSE, use.improved.mean = TRUE,
                           add.names = TRUE, seed = 0L)
 }
 
 \arguments{
   \item{n}{Number of samples.}
   \item{result}{The inla-object, ie the output from an \code{inla}-call.
       The \code{inla}-object must be created with
       \code{control.compute=list(config=TRUE)}.}
   \item{use.improved.mean}{Logical. If \code{TRUE} then use the
       marginal mean values when constructing samples. If \code{FALSE}
       then use the mean in the Gaussian approximations.}
  \item{intern}{Logical. If \code{TRUE} then produce samples in the
       internal scale for the hyperparmater, if \code{FALSE} then produce
       samples in the user-scale. (For example log-precision (intern)
       and precision (user-scale))}
   \item{add.names}{Logical. If \code{TRUE} then add name for each elements of each
       sample. If \code{FALSE}, only add name for the first sample. 
       (This save space.)}
   \item{seed}{Control the RNG of \code{inla.qsample},
       see \code{?inla.qsample} for further information.
       If \code{seed=0L} then GMRFLib will set the seed intelligently/at 'random'.
       If \code{seed < 0L}  then the saved state of the RNG will be reused if possible, otherwise,
       GMRFLib will set the seed intelligently/at 'random'.
       If \code{seed > 0L} then this value is used as the seed for the RNG.
       If you want reproducible results,  you ALSO need to control the seed for the RNG in R by
       controlling the variable \code{.Random.seed} or using the function \code{set.seed},
       the example for how this can be done. }
}
\details{The hyperparameters are sampled from the configurations used to do the
       numerical integration,  hence if you want a higher resolution,  you need to
       to change the \code{int.stratey} variable and friends. The latent field is
       sampled from the Gaussian approximation conditioned on the hyperparameters,
       but with a correction for the mean (default).
}
\value{A list of the samples, where each sample is a list with
     names \code{hyperpar} and \code{latent}, and with their marginal
     densities in \code{logdens$hyperpar} and \code{logdens$latent}
     and the joint density is in \code{logdens$joint}.
}
\author{Havard Rue \email{hrue@r-inla.org}}
 
\examples{
  r = inla(y ~ 1 ,data = data.frame(y=rnorm(1)), control.compute = list(config=TRUE))
  samples = inla.posterior.sample(2,r)

  ## reproducible results:
  set.seed(1234)
  inla.seed = as.integer(runif(1)*.Machine$integer.max)
  x = inla.posterior.sample(100, r, seed = inla.seed)
  set.seed(1234)
  xx = inla.posterior.sample(100, r, seed = inla.seed)
  all.equal(x, xx)
}
