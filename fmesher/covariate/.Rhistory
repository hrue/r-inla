source("http://www.math.ntnu.no/~hrue/inla/R-INLA/givemeINLA.R")
help.start()
pwd
pwd()
cwd()
wd()
ls
ls()
dir()
!
ls
system.help()
system(ls)
system('ls'()
system
system('ls')
system('gmsh')
inla.help()
import(inla)
source("http://www.math.ntnu.no/~hrue/inla/R-INLA/givemeINLA.R")
inla.help()
inla
inla()
?inla
x<-c(1,2,3,4,5,6)
n <-lenght(x)
n <-length(x)
x[4:6]
x[4:n]
x[n-2:n]
x[(n-2):n]
1-2:n
n-2:n
438000/12
36541/10808
1/[1]
10808/36541
.7*36541
ans
pay<-.7*36541
10000/pay
pay*12
package.get("mgcv")
??package
library(mgcv)
library(soap)
man(soap)
??soap
#
## see ?Predict.matrix.soap.film for lower level examples, showing#
## how to get model matrix and penalties explicitly.#
## see ?smooth.construct.so.smooth.spec for example with island#
#
## create a boundary...#
fsb <- list(fs.boundary())#
 #
## create some internal knots...#
knots <- data.frame(v=rep(seq(-.5,3,by=.5),4),#
                    w=rep(c(-.6,-.3,.3,.6),rep(8,4)))#
#
## Simulate some fitting data, inside boundary...#
n<-1000#
v <- runif(n)*5-1;w<-runif(n)*2-1#
y <- fs.test(v,w,b=1)#
ind <- inSide(fsb,x=v,y=w) ## remove outsiders#
y <- y[ind];v <- v[ind]; w <- w[ind] #
n <- length(y)#
y <- y + rnorm(n)*.3 ## add noise#
#
par(mfrow=c(3,2))#
## plot boundary with knot and data locations#
plot(fsb[[1]],type="l");points(knots,pch=20,col=2)#
points(v,w,pch=".");#
#
names(fsb[[1]]) <- c("v","w") ## correct boundary names#
#
## Now fit the soap film smoother...#
b <- gam(y~s(v,w,k=40,bs="so",xt=list(bnd=fsb)),knots=knots)#
plot(b) ## default plot#
vis.gam(b,plot.type="contour") ## nicer visualization#
#
## Plot the true function...#
m<-100;n<-50 #
xm <- seq(-1,3.5,length=m);yn<-seq(-1,1,length=n)#
xx <- rep(xm,n);yy<-rep(yn,rep(m,n))#
#
tru <- matrix(fs.test(xx,yy),m,n) ## truth#
image(xm,yn,tru,col=heat.colors(100),xlab="v",ylab="w",#
      main="truth")#
lines(fsb[[1]],lwd=3)#
contour(xm,yn,tru,levels=seq(-5,5,by=.25),add=TRUE)#
#
## Do a known boundary example (note no `k' needed)#
## First define the value for the smooth at each #
## supplied boundary point...#
fsb[[1]]$f <- fs.test(fsb[[1]]$v,fsb[[1]]$w,b=1,exclude=FALSE)#
#
## Now fit the smooth...#
bk <- gam(y~s(v,w,bs="so",xt=list(bnd=fsb)),knots=knots)#
plot(bk) ## default plot#
#
## Produce a prettier plot of the fit, by predicting on a fine grid...#
fv <- predict(bk,newdata=data.frame(v=xx,w=yy),block.size=-1)#
## ... `block.size=-1' stops `predict.gam' from splitting `newdata'#
## in to several chuncks for predicting: this would involve expensive#
## duplication of PDE solving.#
#
## The actual plot...#
image(xm,yn,matrix(fv,m,n),col=heat.colors(100),xlab="v",ylab="w",#
      main="known boundary soap film")#
contour(xm,yn,matrix(fv,m,n),levels=seq(-5,5,by=.25),add=TRUE)#
#
#
## tensor product example....#
#
## Simulate some fitting data, inside boundary...#
n<-10000#
v <- runif(n)*5-1;w<-runif(n)*2-1#
t <- runif(n)#
y <- fs.test(v,w,b=1)#
y <- y + 4.2#
y <- y^(.5+t)#
fsb <- list(fs.boundary())#
ind <- inSide(fsb,x=v,y=w) ## remove outsiders#
y <- y[ind];v <- v[ind]; w <- w[ind]; t <- t[ind] #
n <- length(y)#
y <- y + rnorm(n)*.0 ## add noise#
names(fsb[[1]]) <- c("v","w")#
#
bk <- gam(y~ #
 te(v,w,t,bs=c("sf","cr"),k=c(25,4),d=c(2,1),xt=list(list(bnd=fsb),NULL))+#
 te(v,w,t,bs=c("sw","cr"),k=c(25,4),d=c(2,1),xt=list(list(bnd=fsb),NULL))#
          ,knots=knots)#
#
par(mfrow=c(3,2))#
m<-100;n<-50 #
xm <- seq(-1,3.5,length=m);yn<-seq(-1,1,length=n)#
xx <- rep(xm,n);yy<-rep(yn,rep(m,n))#
tru <- matrix(fs.test(xx,yy),m,n)+4.2 ## truth#
#
image(xm,yn,tru^.5,col=heat.colors(100),xlab="v",ylab="w",#
      main="truth")#
lines(fsb[[1]],lwd=3)#
contour(xm,yn,tru^.5,add=TRUE)#
#
vis.gam(bk,view=c("v","w"),cond=list(t=0),plot.type="contour")#
#
image(xm,yn,tru,col=heat.colors(100),xlab="v",ylab="w",#
      main="truth")#
lines(fsb[[1]],lwd=3)#
contour(xm,yn,tru,add=TRUE)#
#
vis.gam(bk,view=c("v","w"),cond=list(t=.5),plot.type="contour")#
#
image(xm,yn,tru^1.5,col=heat.colors(100),xlab="v",ylab="w",#
      main="truth")#
lines(fsb[[1]],lwd=3)#
contour(xm,yn,tru^1.5,add=TRUE)#
#
vis.gam(bk,view=c("v","w"),cond=list(t=1),plot.type="contour")
## This is a lower level example based on the ?soap-package #
## example. The basis and penalties are obtained explicitly #
## and using `magic' is used as the fitting routine...#
#
library(soap)#
set.seed(66)#
#
## create a boundary...#
fsb <- list(fs.boundary())#
#
## create some internal knots...#
knots <- data.frame(x=rep(seq(-.5,3,by=.5),4),#
                    y=rep(c(-.6,-.3,.3,.6),rep(8,4)))#
#
## Simulate some fitting data, inside boundary...#
n<-1000#
x <- runif(n)*5-1;y<-runif(n)*2-1#
z <- fs.test(x,y,b=1)#
ind <- inSide(fsb,x,y) ## remove outsiders#
z <- z[ind];x <- x[ind]; y <- y[ind] #
n <- length(z)#
z <- z + rnorm(n)*.3 ## add noise#
#
## plot boundary with knot and data locations#
plot(fsb[[1]],type="l");points(knots,pch=20,col=2)#
points(x,y,pch=".",col=3);#
#
## set up the basis and penalties...#
sob <- smooth.construct2(s(x,y,bs="so",k=40,xt=list(bnd=fsb)),#
              data=data.frame(x=x,y=y),knots=knots)#
## ... model matrix is element `X' of sob, penalties matrices #
## are in list element `S'.#
#
## fit using `magic'#
um <- magic(z,sob$X,sp=c(-1,-1),sob$S,off=c(1,1))#
beta <- um$b#
#
## produce plots...#
par(mfrow=c(2,2),mar=c(4,4,1,1))#
m<-100;n<-50 #
xm <- seq(-1,3.5,length=m);yn<-seq(-1,1,length=n)#
xx <- rep(xm,n);yy<-rep(yn,rep(m,n))#
#
## plot truth...#
tru <- matrix(fs.test(xx,yy),m,n) ## truth#
image(xm,yn,tru,col=heat.colors(100),xlab="x",ylab="y")#
lines(fsb[[1]],lwd=3)#
contour(xm,yn,tru,levels=seq(-5,5,by=.25),add=TRUE)#
#
## Plot soap, by first predicting on a fine grid...#
#
## First get prediction matrix...#
X <- Predict.matrix2(sob,data=list(x=xx,y=yy))#
#
## Now the predictions...#
fv <- X%*%beta#
#
## Plot the estimated function...#
image(xm,yn,matrix(fv,m,n),col=heat.colors(100),xlab="x",ylab="y")#
lines(fsb[[1]],lwd=3)#
points(x,y,pch=".")#
contour(xm,yn,matrix(fv,m,n),levels=seq(-5,5,by=.25),add=TRUE)#
#
## Plot TPRS...#
b <- gam(z~s(x,y,k=100))#
fv.gam <- predict(b,newdata=data.frame(x=xx,y=yy))#
ind <- inSide(sob$G$bnd,xx,yy)#
fv.gam[!ind]<-NA#
image(xm,yn,matrix(fv.gam,m,n),col=heat.colors(100),xlab="x",ylab="y")#
lines(fsb[[1]],lwd=3)#
points(x,y,pch=".")#
contour(xm,yn,matrix(fv.gam,m,n),levels=seq(-5,5,by=.25),add=TRUE)#
#
## now do a known boundary example....#
#
## First specify the known boundary values...#
fsb[[1]]$f <- fs.test(fsb[[1]]$x,fsb[[1]]$y,b=1,exclude=FALSE)#
#
## Get the basis and penalties...#
sob <- smooth.construct2(s(x,y,bs="so",xt=list(bnd=fsb)),#
              data=data.frame(x=x,y=y),knots=knots)#
#
## fit, here using `magic'...#
offset <- attr(sob$X,"offset")#
um <- magic(z-offset,sob$X,sp=-1,S=sob$S,off=1)#
beta <- um$b#
#
## Now predict, on a fine grid, for plotting.#
#
## First get prediction matrix...#
X <- Predict.matrix2(sob,data=list(x=xx,y=yy))#
#
## Then use it to get predicted values...#
fv <- X%*%beta+attr(X,"offset")#
#
## Finally plot the estimated function...#
image(xm,yn,matrix(fv,m,n),col=heat.colors(100),xlab="x",ylab="y")#
lines(fsb[[1]],lwd=3)#
points(x,y,pch=".")#
contour(xm,yn,matrix(fv,m,n),levels=seq(-5,5,by=.25),add=TRUE)
## See also ?soap-package#
library(soap)#
## set up  a two loop boundary...#
bnd <- list(list(x=0,y=0),list(x=0,y=0))#
seq(0,2*pi,length=100) -> theta#
bnd[[1]]$x <- sin(theta);bnd[[1]]$y <- cos(theta)#
bnd[[2]]$x <- .3 + .3*sin(theta);#
bnd[[2]]$y <- .3 + .3*cos(theta)#
plot(bnd[[1]],type="l")#
lines(bnd[[2]])#
#
## setup knots#
k <- 8#
xm <- seq(-1,1,length=k);ym <- seq(-1,1,length=k)#
knots <- data.frame(x=rep(xm,k),y=rep(ym,rep(k,k)))#
ind <- inSide(bnd,knots$x,knots$y)#
knots <- knots[ind,]#
points(knots)#
#
## a test function#
#
f1 <- function(x,y) {#
  exp(-(x-.3)^2-(y-.3)^2)#
}#
#
## plot the test function within the domain #
par(mfrow=c(2,3))#
m<-100;n<-100 #
xm <- seq(-1,1,length=m);yn<-seq(-1,1,length=n)#
xx <- rep(xm,n);yy<-rep(yn,rep(m,n))#
ff <- f1(xx,yy)#
ind <- inSide(bnd,xx,yy)#
ff[!ind] <- NA#
image(xm,yn,matrix(ff,m,n),xlab="x",ylab="y")#
contour(xm,yn,matrix(ff,m,n),add=TRUE)#
lines(bnd[[1]],lwd=2);lines(bnd[[2]],lwd=2)#
#
## Simulate data by noisy sampling from test function...#
#
set.seed(1)#
x <- runif(300)*2-1;y <- runif(300)*2-1#
ind <- inSide(bnd,x,y)#
x <- x[ind];y <- y[ind]#
n <- length(x)#
z <- f1(x,y) + rnorm(n)*.1#
#
## Fit a soap film smooth to the noisy data#
b <- gam(z~s(x,y,k=c(30,15),bs="so",xt=list(bnd=bnd)),knots=knots,method="REML")#
plot(b) ## default plot#
vis.gam(b,plot.type="contour") ## prettier version#
#
## trying out separated fits....#
ba <- gam(z~s(x,y,k=c(30,15),bs="sf",xt=list(bnd=bnd))+#
          s(x,y,k=c(30,15),bs="sw",xt=list(bnd=bnd)),knots=knots,method="REML")#
vis.gam(ba,plot.type="contour")#
#
#
## much prettier plot, based on prediction non a fine grid.#
## Note: block.size parameter set to -1 to avoid splitting #
## prediction data into smaller chunks (which would involve#
## duplication of PDE solving).#
fv <- predict(b,newdata=data.frame(x=xx,y=yy),block.size=-1)#
image(xm,yn,matrix(fv,100,100),xlab="x",ylab="y")#
contour(xm,yn,matrix(fv,100,100),add=TRUE)#
lines(bnd[[1]],lwd=2);lines(bnd[[2]],lwd=2)#
#
## repeat fit with p-spline boundary smooth#
b <- gam(z~s(x,y,k=c(30,15),bs="so",xt=list(bnd=bnd,bndSpec=list(bs="cp",m=c(1,2)))),#
         knots=knots,method="REML")#
fv <- predict(b,newdata=data.frame(x=xx,y=yy),block.size=-1)#
image(xm,yn,matrix(fv,100,100),xlab="x",ylab="y")#
contour(xm,yn,matrix(fv,100,100),add=TRUE)#
lines(bnd[[1]],lwd=2);lines(bnd[[2]],lwd=2)
library(inla)
library(INLA)
??inla.upgrade
inla.upgrade(testing=TRUE)
??inla
??[]
library(rgl)
??triangles3d
library(INLA)
??data
??data.frame
data(Tokyo)
Tokyo$time
169 +189+(4*90)+450+8600+2366
library(INLA)
source(run.R)
getwd()
setwd("/Users/danielsimpson/Dropbox/FLDSHR/src")
source("run.R")
source("run.R")
source("run.R")
B1
library(rgl)#
A = inla.read.fmesher.file("cov_test.dat")#
C = inla.read.fmesher.file("cov_test.cov")#
phi = inla.read.fmesher.file("cov_test.phi")#
S = inla.read.fmesher.file("square.io.s")#
TV = inla.read.fmesher.file("square.io.tv")#
G = inla.read.fmesher.file("square.io.g1")#
#
B1 = t(phi)*(phi);#
dim(B1)#
B2 = t(G)*G;#
dim(B2)#
lam = 10.0;#
#
b = A[,3];#
#
weights = solve(B1 + lam*B2,b);#
#
S[,3] = weights;#
#
plot.inla.trimesh(TV,S)
B1 = t(phi.asmatrix())*(phi.asmatrix());
phi
BB = matrix(phi)
class(phi)
dgCMatrix
help("Matrix")
BB = phi.coerce(from="dgCMatrix",to="matrix")
BB = coerce(phi,from="dgCMatrix",to="matrix")
?coerce
class(BB)
t(phi)
t(phi)*phi
help("cgne")
??cgne
class(phi)
as(phi,"Matrix")
BB=as(phi,"Matrix")
class(BB)
BBB=tr(BB)*BB
BBB=t(BB)*BB
full(phi)
BB=as(phi,"denseMatrix")
BB=as(phi,"denseMatrix")
class(BB\)
class(BB)
BBB=t(BB)*BB
dim(BB)
dim(t(BB))
BBB=t(phi)%*%phi
source("run.R")
library(INLA)#
library(rgl)#
A = inla.read.fmesher.file("cov_test.dat")#
C = inla.read.fmesher.file("cov_test.cov")#
phi = inla.read.fmesher.file("cov_test.phi")#
S = inla.read.fmesher.file("square.io.s")#
TV = inla.read.fmesher.file("square.io.tv")#
G = inla.read.fmesher.file("square.io.g1")
B1 = t(phi)%*%(phi);#
dim(B1)#
B2 = t(G)%*%G;#
dim(B2)
dim(phi)
dim(g)
dim(G)
library(INLA)#
library(rgl)#
A = inla.read.fmesher.file("cov_test.dat")#
C = inla.read.fmesher.file("cov_test.cov")#
phi = inla.read.fmesher.file("cov_test.phi")#
S = inla.read.fmesher.file("square.io.s")#
TV = inla.read.fmesher.file("square.io.tv")#
G = inla.read.fmesher.file("cov_test.Q")#
#
B1 = t(phi)%*%(phi);#
dim(B1)#
B2 = t(G)%*%G;#
dim(B2)#
lam = 10.0;#
#
b = A[,3];#
#
weights = solve(B1 + lam*B2,b);#
#
S[,3] = weights;#
#
plot.inla.trimesh(TV,S)
dim(phi)
dim(Q)
dim(G)
getwd()
