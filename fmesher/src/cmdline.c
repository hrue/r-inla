/*
  File autogenerated by gengetopt version 2.23
  generated with the following command:
  gengetopt --file-name=cmdline --conf-parser --unamed-opts=PREFIX --long-help
  --func-name=cmdline

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void)(X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "cmdline.h"

const char *gengetopt_args_info_purpose =
    "Generate triangular meshes and prepare finite element calculations";

const char *gengetopt_args_info_usage =
    "Usage: fmesher [-h|--help] [--detailed-help] [--full-help] "
    "[-V|--version]\n         [-CFILE|--config=FILE] [--dump-config=FILE] "
    "[--io=SPEC]\n         [-iFILE|--ic=FILE] [-oFILE|--oc=FILE] "
    "[--collect=NAME] [--collect-all]\n         [--ir=SPEC] "
    "[-TNAME|--input=NAME] [--cutoff=DISTANCE]\n         "
    "[--spheretolerance=DISTANCE] [-EPARAM|--cet=PARAM]\n         "
    "[-RPARAM|--rcdt=PARAM] [--max_n0=PARAM] [--max_n1=PARAM]\n         "
    "[-QNAME|--quality=NAME] [-BNAME|--boundary=NAME]\n         "
    "[-INAME|--interior=NAME] [--boundarygrp=NAME] [--interiorgrp=NAME]\n      "
    "   [--globe=SUBSEGMENTS] [--smorg] [--fem=ORDER] [--aniso=NAME] "
    "[--grad]\n         [--sph0=ORDER] [--sph=ORDER] [--bspline=PARAM] "
    "[--points2mesh=NAME]\n         [--splitlines=NAME] [-xDELAY|--x11=DELAY] "
    "[PREFIX]...";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description =
    "Examples:\n\nBuild a refined triangulation from a set of points stored in "
    "prefix.s0:\n  fmesher -Ts0 -R prefix.\n  fmesher -Ts0 -R prefix. "
    "output.\n  fmesher collect=-,s,tv prefix.\nThe output is stored in "
    "prefix.s and prefix.tv (and other prefix.* files)\nor output.s and "
    "putput.tv (in the second version).\nIn the third version, only the s and "
    "tv matrices are output, thus\nexcluding any other output "
    "matrices.\n\nJoin separate matrix files into collection files:\n  fmesher "
    "--collect=s0,s,tv,tt,tti,vv prefix. --oc=graph.col\n  fmesher "
    "--collect=c0,c1,g1,g2 prefix. --oc=fem.col\n\nExtract all matrices from "
    "two collection files graph.col and fem.col:\n  fmesher --collect=-- "
    "--ic=graph.col,fem.col - prefix.\n\n--collect=- outputs all files "
    "activated by the program, but since\nwe are only interested in extracting "
    "all the matrices,\n--collect=-- indicates that all matrices should be "
    "read, regardless of\nwhether they are needed or not.\nThe `-' at the end "
    "indicates that no prefix-input is used, only output.\nTo completely "
    "disable prefix I/O, omit the prefixes completely, or\nspecify `-' or `- "
    "-'\n\nConvert a raw ascii matrix from stdin to fmesher format:\n  fmesher "
    "--ir=s0,ddgr,- -R - prefix. < S0.dat\n  fmesher --ir=s0,ddgr,S0.dat -R "
    "--collect=s0 - prefix.\n  fmesher --ir=s0,ddgr,S0.dat --collect=-,s0 - "
    "prefix.\nIn all cases, s0 is read from S0.dat\nIn the first example, s0 "
    "is used for triangulation, but not output.\nIn the second example, s0 is "
    "used for triangulation, and added to the output.\nIn the third and fourth "
    "example, only s0 is output, and no triangulation made.";

const char *gengetopt_args_info_detailed_help[] = {
    "  -h, --help                    Print help and exit",
    "      --detailed-help           Print help, including all details and "
    "hidden\n                                  options, and exit",
    "      --full-help               Print help, including hidden options, and "
    "exit",
    "  -V, --version                 Print version and exit",
    "  -C, --config=FILE             Read options from file",
    "      --dump-config=FILE        Dump options to file",
    "\nI/O options:",
    "      --io=SPEC                 I/O format specification (ascii/binary)\n "
    "                                 (possible values=\"aa\", \"ab\", "
    "\"ba\",\n                                  \"bb\" default=`bb')",
    "  -i, --ic=FILE                 Read input as matrix collections in the "
    "given\n                                  files",
    "  -o, --oc=FILE                 Write output as a matrix collection in "
    "the\n                                  given file",
    "      --collect=NAME            Add named matrices to the output "
    "collection\n                                  (default=`-')",
    "  \n  If only `-' is specified, all loaded matrices are added.\n  If `-' "
    "is followed by other names, only those will be added.\n",
    "      --collect-all             With --collect=-, load all matrices from "
    "the\n                                  input collections  (default=off)",
    "      --ir=SPEC                 Import a raw matrix file in ascii format",
    "  \n  First SPEC is the name of the matrix\n  Second SPEC is a four "
    "letter matrix specification:\n         d/s = dense/sparse\n         i/d = "
    "int/double\n         g/s/d = general/symmetric/diagonal\n         r/c = "
    "row/column major storage\n         Common format for point lists with one "
    "point per line = ddgr\n  Third SPEC the filename, - for standard input\n",
    "\nTriangulation options:",
    "  -T, --input=NAME              Specify triangulation input data, "
    "default=s0.\n                                  A second name indicates a "
    "pre-existing\n                                  triangulation, as in "
    "-Ts0,tv0, further\n                                  indicates additional "
    "data point matrices.\n                                  Use - for tv0 to "
    "only supply additional\n                                  points.",
    "      --cutoff=DISTANCE         Treat points in the input data as unique "
    "only\n                                  if they are further apart than "
    "this value.\n                                  The vector 'idx' in the "
    "output gives the\n                                  resulting vertex "
    "index for each input point.\n                                  "
    "(default=`1.0e-12')",
    "      --spheretolerance=DISTANCE\n                                The "
    "tolerance for determining that the input\n                                "
    "  lies on a sphere.  (default=`1.0e-7')",
    "  -E, --cet=PARAM               Convex encapsulation parameters",
    "  \n  \tThe parameters are n,m, where n is the number of sides of the\n  "
    "encapsulation, and m is the margin.\n  \tFor m>0, the margins are set to "
    "m.\n  \tFor m<0, the margins are set to approximately -m*diam.\n  "
    "\tDefaults are 8,-0.1, adding 10% on all sides\n",
    "  -R, --rcdt[=PARAM]            Generate RCDT, with optional quality "
    "parameters\n                                  (default=`21')",
    "  \n  \tThe parameter order is min_angle, max_edge_length for added "
    "points,\n  max_edge_length for data points. Further values apply to data "
    "points added by\n  extra matrices specified with -T|--input\n  \tWhen "
    "negative values for the edge_length-parameters, a rudimentary\n  scaling "
    "with respect to the initial point density is used.\n  \tPositive values "
    "are absolute.\n  \tThe algorithm is only guaranteed to converge for "
    "min_angle<=21, but values\n  as high as 34 often work in practice.\n  "
    "\tDefaults are 21,-1.,-0.5\n",
    "      --max_n0=PARAM            The desired maximal number of vertices,\n "
    "                                 terminating angle checks  (default=`-1')",
    "      --max_n1=PARAM            The desired maximal number of vertices,\n "
    "                                 terminating edge length checks\n         "
    "                         (default=`-1')",
    "  -Q, --quality=NAME            Per vertex RCDT parameters, as one or "
    "more\n                                  one-column matrices with minimum "
    "edge lengths\n                                  for the points specified "
    "with -T|--input",
    "  -B, --boundary=NAME           Handle triangulation boundary\n           "
    "                       (default=`boundary0')",
    "  -I, --interior=NAME           Handle interior constraints\n             "
    "                     (default=`interior0')",
    "      --boundarygrp=NAME        Group lables for boundary segments",
    "      --interiorgrp=NAME        Group lables for interior segments",
    "      --globe=SUBSEGMENTS       Construct a triangulation of a globe",
    "\nSMORG options:",
    "      --smorg                   Smorgasbord queries for a known "
    "triangulation.\n                                  Uses the given "
    "--input=s,tv directly, without\n                                  any "
    "filtering or refinement.",
    "      --fem=ORDER               Calculate FEM matrices up through order "
    "fem\n                                  (default=`-1')",
    "      --aniso=NAME              Calculate anisotropic Laplacians",
    "      --grad                    Calculate gradient weight matrices",
    "      --sph0=ORDER              Calculate rotationally invariant "
    "spherical\n                                  harmonics up through order "
    "sph0\n                                  (default=`-1')",
    "      --sph=ORDER               Calculate spherical harmonics up through "
    "order\n                                  sph  (default=`-1')",
    "      --bspline=PARAM           Calculate rotationally invariant B-spline "
    "basis\n                                  functions",
    "      --points2mesh=NAME        Calculate barycentric triangle "
    "coordinates for\n                                  a set of points  "
    "(default=`s')",
    "      --splitlines=NAME         Split line segments into within-triangle "
    "parts\n                                  and calculate corresponding "
    "barycentric\n                                  coordinates",
    "\nMiscellaneous options:",
    "  -x, --x11[=DELAY]             Show progress in an x11 window, with "
    "delay\n                                  factor  (default=`1.0')",
    "      --x11-zoom=LIMITS         Zoom into a smaller section of the "
    "graph,\n                                  [minx,maxx,miny,maxy]",
    0};
static void init_full_help_array(void) {
  gengetopt_args_info_full_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_full_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_full_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_full_help[3] = gengetopt_args_info_detailed_help[3];
  gengetopt_args_info_full_help[4] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_full_help[5] = gengetopt_args_info_detailed_help[5];
  gengetopt_args_info_full_help[6] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_full_help[7] = gengetopt_args_info_detailed_help[7];
  gengetopt_args_info_full_help[8] = gengetopt_args_info_detailed_help[8];
  gengetopt_args_info_full_help[9] = gengetopt_args_info_detailed_help[9];
  gengetopt_args_info_full_help[10] = gengetopt_args_info_detailed_help[10];
  gengetopt_args_info_full_help[11] = gengetopt_args_info_detailed_help[12];
  gengetopt_args_info_full_help[12] = gengetopt_args_info_detailed_help[13];
  gengetopt_args_info_full_help[13] = gengetopt_args_info_detailed_help[15];
  gengetopt_args_info_full_help[14] = gengetopt_args_info_detailed_help[16];
  gengetopt_args_info_full_help[15] = gengetopt_args_info_detailed_help[17];
  gengetopt_args_info_full_help[16] = gengetopt_args_info_detailed_help[18];
  gengetopt_args_info_full_help[17] = gengetopt_args_info_detailed_help[19];
  gengetopt_args_info_full_help[18] = gengetopt_args_info_detailed_help[21];
  gengetopt_args_info_full_help[19] = gengetopt_args_info_detailed_help[23];
  gengetopt_args_info_full_help[20] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_full_help[21] = gengetopt_args_info_detailed_help[25];
  gengetopt_args_info_full_help[22] = gengetopt_args_info_detailed_help[26];
  gengetopt_args_info_full_help[23] = gengetopt_args_info_detailed_help[27];
  gengetopt_args_info_full_help[24] = gengetopt_args_info_detailed_help[28];
  gengetopt_args_info_full_help[25] = gengetopt_args_info_detailed_help[29];
  gengetopt_args_info_full_help[26] = gengetopt_args_info_detailed_help[30];
  gengetopt_args_info_full_help[27] = gengetopt_args_info_detailed_help[31];
  gengetopt_args_info_full_help[28] = gengetopt_args_info_detailed_help[32];
  gengetopt_args_info_full_help[29] = gengetopt_args_info_detailed_help[33];
  gengetopt_args_info_full_help[30] = gengetopt_args_info_detailed_help[34];
  gengetopt_args_info_full_help[31] = gengetopt_args_info_detailed_help[35];
  gengetopt_args_info_full_help[32] = gengetopt_args_info_detailed_help[36];
  gengetopt_args_info_full_help[33] = gengetopt_args_info_detailed_help[37];
  gengetopt_args_info_full_help[34] = gengetopt_args_info_detailed_help[38];
  gengetopt_args_info_full_help[35] = gengetopt_args_info_detailed_help[39];
  gengetopt_args_info_full_help[36] = gengetopt_args_info_detailed_help[40];
  gengetopt_args_info_full_help[37] = gengetopt_args_info_detailed_help[41];
  gengetopt_args_info_full_help[38] = gengetopt_args_info_detailed_help[42];
  gengetopt_args_info_full_help[39] = gengetopt_args_info_detailed_help[43];
  gengetopt_args_info_full_help[40] = 0;
}

const char *gengetopt_args_info_full_help[41];

static void init_help_array(void) {
  gengetopt_args_info_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_help[3] = gengetopt_args_info_detailed_help[3];
  gengetopt_args_info_help[4] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_help[5] = gengetopt_args_info_detailed_help[5];
  gengetopt_args_info_help[6] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_help[7] = gengetopt_args_info_detailed_help[7];
  gengetopt_args_info_help[8] = gengetopt_args_info_detailed_help[8];
  gengetopt_args_info_help[9] = gengetopt_args_info_detailed_help[9];
  gengetopt_args_info_help[10] = gengetopt_args_info_detailed_help[10];
  gengetopt_args_info_help[11] = gengetopt_args_info_detailed_help[12];
  gengetopt_args_info_help[12] = gengetopt_args_info_detailed_help[13];
  gengetopt_args_info_help[13] = gengetopt_args_info_detailed_help[15];
  gengetopt_args_info_help[14] = gengetopt_args_info_detailed_help[16];
  gengetopt_args_info_help[15] = gengetopt_args_info_detailed_help[17];
  gengetopt_args_info_help[16] = gengetopt_args_info_detailed_help[18];
  gengetopt_args_info_help[17] = gengetopt_args_info_detailed_help[19];
  gengetopt_args_info_help[18] = gengetopt_args_info_detailed_help[21];
  gengetopt_args_info_help[19] = gengetopt_args_info_detailed_help[23];
  gengetopt_args_info_help[20] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_help[21] = gengetopt_args_info_detailed_help[25];
  gengetopt_args_info_help[22] = gengetopt_args_info_detailed_help[26];
  gengetopt_args_info_help[23] = gengetopt_args_info_detailed_help[27];
  gengetopt_args_info_help[24] = gengetopt_args_info_detailed_help[28];
  gengetopt_args_info_help[25] = gengetopt_args_info_detailed_help[29];
  gengetopt_args_info_help[26] = gengetopt_args_info_detailed_help[30];
  gengetopt_args_info_help[27] = gengetopt_args_info_detailed_help[31];
  gengetopt_args_info_help[28] = gengetopt_args_info_detailed_help[32];
  gengetopt_args_info_help[29] = gengetopt_args_info_detailed_help[33];
  gengetopt_args_info_help[30] = gengetopt_args_info_detailed_help[34];
  gengetopt_args_info_help[31] = gengetopt_args_info_detailed_help[35];
  gengetopt_args_info_help[32] = gengetopt_args_info_detailed_help[36];
  gengetopt_args_info_help[33] = gengetopt_args_info_detailed_help[37];
  gengetopt_args_info_help[34] = gengetopt_args_info_detailed_help[38];
  gengetopt_args_info_help[35] = gengetopt_args_info_detailed_help[39];
  gengetopt_args_info_help[36] = gengetopt_args_info_detailed_help[40];
  gengetopt_args_info_help[37] = gengetopt_args_info_detailed_help[41];
  gengetopt_args_info_help[38] = gengetopt_args_info_detailed_help[42];
  gengetopt_args_info_help[39] = 0;
}

const char *gengetopt_args_info_help[40];

typedef enum {
  ARG_NO,
  ARG_FLAG,
  ARG_STRING,
  ARG_INT,
  ARG_DOUBLE,
  ARG_ENUM
} cmdline_arg_type;

static void clear_given(struct gengetopt_args_info *args_info);
static void clear_args(struct gengetopt_args_info *args_info);

static int cmdline_internal(int argc, char **argv,
                            struct gengetopt_args_info *args_info,
                            struct cmdline_params *params,
                            const char *additional_error);

static int cmdline_required2(struct gengetopt_args_info *args_info,
                             const char *prog_name,
                             const char *additional_error);
struct line_list {
  char *string_arg;
  struct line_list *next;
};

static struct line_list *cmd_line_list = 0;
static struct line_list *cmd_line_list_tmp = 0;

static void free_cmd_list(void) {
  /* free the list of a previous call */
  if (cmd_line_list) {
    while (cmd_line_list) {
      cmd_line_list_tmp = cmd_line_list;
      cmd_line_list = cmd_line_list->next;
      free(cmd_line_list_tmp->string_arg);
      free(cmd_line_list_tmp);
    }
  }
}

const char *cmdline_io_values[] = {"aa", "ab", "ba", "bb",
                                   0}; /*< Possible values for io. */

static char *gengetopt_strdup(const char *s);

static void clear_given(struct gengetopt_args_info *args_info) {
  args_info->help_given = 0;
  args_info->detailed_help_given = 0;
  args_info->full_help_given = 0;
  args_info->version_given = 0;
  args_info->config_given = 0;
  args_info->dump_config_given = 0;
  args_info->io_given = 0;
  args_info->ic_given = 0;
  args_info->oc_given = 0;
  args_info->collect_given = 0;
  args_info->collect_all_given = 0;
  args_info->ir_given = 0;
  args_info->input_given = 0;
  args_info->cutoff_given = 0;
  args_info->spheretolerance_given = 0;
  args_info->cet_given = 0;
  args_info->rcdt_given = 0;
  args_info->max_n0_given = 0;
  args_info->max_n1_given = 0;
  args_info->quality_given = 0;
  args_info->boundary_given = 0;
  args_info->interior_given = 0;
  args_info->boundarygrp_given = 0;
  args_info->interiorgrp_given = 0;
  args_info->globe_given = 0;
  args_info->smorg_given = 0;
  args_info->fem_given = 0;
  args_info->aniso_given = 0;
  args_info->grad_given = 0;
  args_info->sph0_given = 0;
  args_info->sph_given = 0;
  args_info->bspline_given = 0;
  args_info->points2mesh_given = 0;
  args_info->splitlines_given = 0;
  args_info->x11_given = 0;
  args_info->x11_zoom_given = 0;
}

static void clear_args(struct gengetopt_args_info *args_info) {
  FIX_UNUSED(args_info);
  args_info->config_arg = NULL;
  args_info->config_orig = NULL;
  args_info->dump_config_arg = NULL;
  args_info->dump_config_orig = NULL;
  args_info->io_arg = io_arg_bb;
  args_info->io_orig = NULL;
  args_info->ic_arg = NULL;
  args_info->ic_orig = NULL;
  args_info->oc_arg = NULL;
  args_info->oc_orig = NULL;
  args_info->collect_arg = NULL;
  args_info->collect_orig = NULL;
  args_info->collect_all_flag = 0;
  args_info->ir_arg = NULL;
  args_info->ir_orig = NULL;
  args_info->input_arg = NULL;
  args_info->input_orig = NULL;
  args_info->cutoff_arg = 1.0e-12;
  args_info->cutoff_orig = NULL;
  args_info->spheretolerance_arg = 1.0e-7;
  args_info->spheretolerance_orig = NULL;
  args_info->cet_arg = NULL;
  args_info->cet_orig = NULL;
  args_info->rcdt_arg = NULL;
  args_info->rcdt_orig = NULL;
  args_info->max_n0_arg = -1;
  args_info->max_n0_orig = NULL;
  args_info->max_n1_arg = -1;
  args_info->max_n1_orig = NULL;
  args_info->quality_arg = NULL;
  args_info->quality_orig = NULL;
  args_info->boundary_arg = NULL;
  args_info->boundary_orig = NULL;
  args_info->interior_arg = NULL;
  args_info->interior_orig = NULL;
  args_info->boundarygrp_arg = NULL;
  args_info->boundarygrp_orig = NULL;
  args_info->interiorgrp_arg = NULL;
  args_info->interiorgrp_orig = NULL;
  args_info->globe_orig = NULL;
  args_info->fem_arg = -1;
  args_info->fem_orig = NULL;
  args_info->aniso_arg = NULL;
  args_info->aniso_orig = NULL;
  args_info->sph0_arg = -1;
  args_info->sph0_orig = NULL;
  args_info->sph_arg = -1;
  args_info->sph_orig = NULL;
  args_info->bspline_arg = NULL;
  args_info->bspline_orig = NULL;
  args_info->points2mesh_arg = gengetopt_strdup("s");
  args_info->points2mesh_orig = NULL;
  args_info->splitlines_arg = NULL;
  args_info->splitlines_orig = NULL;
  args_info->x11_arg = 1.0;
  args_info->x11_orig = NULL;
  args_info->x11_zoom_arg = NULL;
  args_info->x11_zoom_orig = NULL;
}

static void init_args_info(struct gengetopt_args_info *args_info) {
  init_full_help_array();
  init_help_array();
  args_info->help_help = gengetopt_args_info_detailed_help[0];
  args_info->detailed_help_help = gengetopt_args_info_detailed_help[1];
  args_info->full_help_help = gengetopt_args_info_detailed_help[2];
  args_info->version_help = gengetopt_args_info_detailed_help[3];
  args_info->config_help = gengetopt_args_info_detailed_help[4];
  args_info->dump_config_help = gengetopt_args_info_detailed_help[5];
  args_info->io_help = gengetopt_args_info_detailed_help[7];
  args_info->ic_help = gengetopt_args_info_detailed_help[8];
  args_info->ic_min = 0;
  args_info->ic_max = 0;
  args_info->oc_help = gengetopt_args_info_detailed_help[9];
  args_info->collect_help = gengetopt_args_info_detailed_help[10];
  args_info->collect_min = 0;
  args_info->collect_max = 0;
  args_info->collect_all_help = gengetopt_args_info_detailed_help[12];
  args_info->ir_help = gengetopt_args_info_detailed_help[13];
  args_info->ir_min = 0;
  args_info->ir_max = 0;
  args_info->input_help = gengetopt_args_info_detailed_help[16];
  args_info->input_min = 1;
  args_info->input_max = 0;
  args_info->cutoff_help = gengetopt_args_info_detailed_help[17];
  args_info->spheretolerance_help = gengetopt_args_info_detailed_help[18];
  args_info->cet_help = gengetopt_args_info_detailed_help[19];
  args_info->cet_min = 1;
  args_info->cet_max = 2;
  args_info->rcdt_help = gengetopt_args_info_detailed_help[21];
  args_info->rcdt_min = 0;
  args_info->rcdt_max = 0;
  args_info->max_n0_help = gengetopt_args_info_detailed_help[23];
  args_info->max_n1_help = gengetopt_args_info_detailed_help[24];
  args_info->quality_help = gengetopt_args_info_detailed_help[25];
  args_info->quality_min = 0;
  args_info->quality_max = 0;
  args_info->boundary_help = gengetopt_args_info_detailed_help[26];
  args_info->boundary_min = 0;
  args_info->boundary_max = 0;
  args_info->interior_help = gengetopt_args_info_detailed_help[27];
  args_info->interior_min = 0;
  args_info->interior_max = 0;
  args_info->boundarygrp_help = gengetopt_args_info_detailed_help[28];
  args_info->boundarygrp_min = 0;
  args_info->boundarygrp_max = 0;
  args_info->interiorgrp_help = gengetopt_args_info_detailed_help[29];
  args_info->interiorgrp_min = 0;
  args_info->interiorgrp_max = 0;
  args_info->globe_help = gengetopt_args_info_detailed_help[30];
  args_info->smorg_help = gengetopt_args_info_detailed_help[32];
  args_info->fem_help = gengetopt_args_info_detailed_help[33];
  args_info->aniso_help = gengetopt_args_info_detailed_help[34];
  args_info->aniso_min = 2;
  args_info->aniso_max = 2;
  args_info->grad_help = gengetopt_args_info_detailed_help[35];
  args_info->sph0_help = gengetopt_args_info_detailed_help[36];
  args_info->sph_help = gengetopt_args_info_detailed_help[37];
  args_info->bspline_help = gengetopt_args_info_detailed_help[38];
  args_info->bspline_min = 1;
  args_info->bspline_max = 3;
  args_info->points2mesh_help = gengetopt_args_info_detailed_help[39];
  args_info->splitlines_help = gengetopt_args_info_detailed_help[40];
  args_info->splitlines_min = 2;
  args_info->splitlines_max = 2;
  args_info->x11_help = gengetopt_args_info_detailed_help[42];
  args_info->x11_zoom_help = gengetopt_args_info_detailed_help[43];
  args_info->x11_zoom_min = 3;
  args_info->x11_zoom_max = 4;
}

void cmdline_print_version(void) {
  printf(
      "%s %s\n",
      (strlen(CMDLINE_PACKAGE_NAME) ? CMDLINE_PACKAGE_NAME : CMDLINE_PACKAGE),
      CMDLINE_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  size_t len_purpose = strlen(gengetopt_args_info_purpose);
  size_t len_usage = strlen(gengetopt_args_info_usage);

  if (len_usage > 0) {
    printf("%s\n", gengetopt_args_info_usage);
  }
  if (len_purpose > 0) {
    printf("%s\n", gengetopt_args_info_purpose);
  }

  if (len_usage || len_purpose) {
    printf("\n");
  }

  if (strlen(gengetopt_args_info_description) > 0) {
    printf("%s\n\n", gengetopt_args_info_description);
  }
}

void cmdline_print_help(void) {
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void cmdline_print_full_help(void) {
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_full_help[i])
    printf("%s\n", gengetopt_args_info_full_help[i++]);
}

void cmdline_print_detailed_help(void) {
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_detailed_help[i])
    printf("%s\n", gengetopt_args_info_detailed_help[i++]);
}

void cmdline_init(struct gengetopt_args_info *args_info) {
  clear_given(args_info);
  clear_args(args_info);
  init_args_info(args_info);

  args_info->inputs = 0;
  args_info->inputs_num = 0;
}

void cmdline_params_init(struct cmdline_params *params) {
  if (params) {
    params->override = 0;
    params->initialize = 1;
    params->check_required = 1;
    params->check_ambiguity = 0;
    params->print_errors = 1;
  }
}

struct cmdline_params *cmdline_params_create(void) {
  struct cmdline_params *params =
      (struct cmdline_params *)malloc(sizeof(struct cmdline_params));
  cmdline_params_init(params);
  return params;
}

static void free_string_field(char **s) {
  if (*s) {
    free(*s);
    *s = 0;
  }
}

/** @brief generic value variable */
union generic_value {
  int int_arg;
  double double_arg;
  char *string_arg;
  const char *default_string_arg;
};

/** @brief holds temporary values for multiple options */
struct generic_list {
  union generic_value arg;
  char *orig;
  struct generic_list *next;
};

/**
 * @brief add a node at the head of the list
 */
static void add_node(struct generic_list **list) {
  struct generic_list *new_node =
      (struct generic_list *)malloc(sizeof(struct generic_list));
  new_node->next = *list;
  *list = new_node;
  new_node->arg.string_arg = 0;
  new_node->orig = 0;
}

/**
 * The passed arg parameter is NOT set to 0 from this function
 */
static void free_multiple_field(unsigned int len, void *arg, char ***orig) {
  unsigned int i;
  if (arg) {
    for (i = 0; i < len; ++i) {
      free_string_field(&((*orig)[i]));
    }

    free(arg);
    free(*orig);
    *orig = 0;
  }
}

static void free_multiple_string_field(unsigned int len, char ***arg,
                                       char ***orig) {
  unsigned int i;
  if (*arg) {
    for (i = 0; i < len; ++i) {
      free_string_field(&((*arg)[i]));
      free_string_field(&((*orig)[i]));
    }
    free_string_field(&((*arg)[0])); /* free default string */

    free(*arg);
    *arg = 0;
    free(*orig);
    *orig = 0;
  }
}

static void cmdline_release(struct gengetopt_args_info *args_info) {
  unsigned int i;
  free_string_field(&(args_info->config_arg));
  free_string_field(&(args_info->config_orig));
  free_string_field(&(args_info->dump_config_arg));
  free_string_field(&(args_info->dump_config_orig));
  free_string_field(&(args_info->io_orig));
  free_multiple_string_field(args_info->ic_given, &(args_info->ic_arg),
                             &(args_info->ic_orig));
  free_string_field(&(args_info->oc_arg));
  free_string_field(&(args_info->oc_orig));
  free_multiple_string_field(args_info->collect_given,
                             &(args_info->collect_arg),
                             &(args_info->collect_orig));
  free_multiple_string_field(args_info->ir_given, &(args_info->ir_arg),
                             &(args_info->ir_orig));
  free_multiple_string_field(args_info->input_given, &(args_info->input_arg),
                             &(args_info->input_orig));
  free_string_field(&(args_info->cutoff_orig));
  free_string_field(&(args_info->spheretolerance_orig));
  free_multiple_field(args_info->cet_given, (void *)(args_info->cet_arg),
                      &(args_info->cet_orig));
  args_info->cet_arg = 0;
  free_multiple_field(args_info->rcdt_given, (void *)(args_info->rcdt_arg),
                      &(args_info->rcdt_orig));
  args_info->rcdt_arg = 0;
  free_string_field(&(args_info->max_n0_orig));
  free_string_field(&(args_info->max_n1_orig));
  free_multiple_string_field(args_info->quality_given,
                             &(args_info->quality_arg),
                             &(args_info->quality_orig));
  free_multiple_string_field(args_info->boundary_given,
                             &(args_info->boundary_arg),
                             &(args_info->boundary_orig));
  free_multiple_string_field(args_info->interior_given,
                             &(args_info->interior_arg),
                             &(args_info->interior_orig));
  free_multiple_string_field(args_info->boundarygrp_given,
                             &(args_info->boundarygrp_arg),
                             &(args_info->boundarygrp_orig));
  free_multiple_string_field(args_info->interiorgrp_given,
                             &(args_info->interiorgrp_arg),
                             &(args_info->interiorgrp_orig));
  free_string_field(&(args_info->globe_orig));
  free_string_field(&(args_info->fem_orig));
  free_multiple_string_field(args_info->aniso_given, &(args_info->aniso_arg),
                             &(args_info->aniso_orig));
  free_string_field(&(args_info->sph0_orig));
  free_string_field(&(args_info->sph_orig));
  free_multiple_field(args_info->bspline_given,
                      (void *)(args_info->bspline_arg),
                      &(args_info->bspline_orig));
  args_info->bspline_arg = 0;
  free_string_field(&(args_info->points2mesh_arg));
  free_string_field(&(args_info->points2mesh_orig));
  free_multiple_string_field(args_info->splitlines_given,
                             &(args_info->splitlines_arg),
                             &(args_info->splitlines_orig));
  free_string_field(&(args_info->x11_orig));
  free_multiple_field(args_info->x11_zoom_given,
                      (void *)(args_info->x11_zoom_arg),
                      &(args_info->x11_zoom_orig));
  args_info->x11_zoom_arg = 0;

  for (i = 0; i < args_info->inputs_num; ++i)
    free(args_info->inputs[i]);

  if (args_info->inputs_num)
    free(args_info->inputs);

  clear_given(args_info);
}

/**
 * @param val the value to check
 * @param values the possible values
 * @return the index of the matched value:
 * -1 if no value matched,
 * -2 if more than one value has matched
 */
static int check_possible_values(const char *val, const char *values[]) {
  int i, found, last;
  size_t len;

  if (!val)    /* otherwise strlen() crashes below */
    return -1; /* -1 means no argument for the option */

  found = last = 0;

  for (i = 0, len = strlen(val); values[i]; ++i) {
    if (strncmp(val, values[i], len) == 0) {
      ++found;
      last = i;
      if (strlen(values[i]) == len)
        return i; /* exact macth no need to check more */
    }
  }

  if (found == 1) /* one match: OK */
    return last;

  return (found ? -2 : -1); /* return many values or none matched */
}

static void write_into_file(FILE *outfile, const char *opt, const char *arg,
                            const char *values[]) {
  int found = -1;
  if (arg) {
    if (values) {
      found = check_possible_values(arg, values);
    }
    if (found >= 0)
      fprintf(outfile, "%s=\"%s\" # %s\n", opt, arg, values[found]);
    else
      fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}

static void write_multiple_into_file(FILE *outfile, int len, const char *opt,
                                     char **arg, const char *values[]) {
  int i;

  for (i = 0; i < len; ++i)
    write_into_file(outfile, opt, (arg ? arg[i] : 0), values);
}

int cmdline_dump(FILE *outfile, struct gengetopt_args_info *args_info) {
  int i = 0;

  if (!outfile) {
    fprintf(stderr, "%s: cannot dump options to stream\n", CMDLINE_PACKAGE);
    return EXIT_FAILURE;
  }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0);
  if (args_info->detailed_help_given)
    write_into_file(outfile, "detailed-help", 0, 0);
  if (args_info->full_help_given)
    write_into_file(outfile, "full-help", 0, 0);
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0);
  if (args_info->config_given)
    write_into_file(outfile, "config", args_info->config_orig, 0);
  if (args_info->dump_config_given)
    write_into_file(outfile, "dump-config", args_info->dump_config_orig, 0);
  if (args_info->io_given)
    write_into_file(outfile, "io", args_info->io_orig, cmdline_io_values);
  write_multiple_into_file(outfile, args_info->ic_given, "ic",
                           args_info->ic_orig, 0);
  if (args_info->oc_given)
    write_into_file(outfile, "oc", args_info->oc_orig, 0);
  write_multiple_into_file(outfile, args_info->collect_given, "collect",
                           args_info->collect_orig, 0);
  if (args_info->collect_all_given)
    write_into_file(outfile, "collect-all", 0, 0);
  write_multiple_into_file(outfile, args_info->ir_given, "ir",
                           args_info->ir_orig, 0);
  write_multiple_into_file(outfile, args_info->input_given, "input",
                           args_info->input_orig, 0);
  if (args_info->cutoff_given)
    write_into_file(outfile, "cutoff", args_info->cutoff_orig, 0);
  if (args_info->spheretolerance_given)
    write_into_file(outfile, "spheretolerance", args_info->spheretolerance_orig,
                    0);
  write_multiple_into_file(outfile, args_info->cet_given, "cet",
                           args_info->cet_orig, 0);
  write_multiple_into_file(outfile, args_info->rcdt_given, "rcdt",
                           args_info->rcdt_orig, 0);
  if (args_info->max_n0_given)
    write_into_file(outfile, "max_n0", args_info->max_n0_orig, 0);
  if (args_info->max_n1_given)
    write_into_file(outfile, "max_n1", args_info->max_n1_orig, 0);
  write_multiple_into_file(outfile, args_info->quality_given, "quality",
                           args_info->quality_orig, 0);
  write_multiple_into_file(outfile, args_info->boundary_given, "boundary",
                           args_info->boundary_orig, 0);
  write_multiple_into_file(outfile, args_info->interior_given, "interior",
                           args_info->interior_orig, 0);
  write_multiple_into_file(outfile, args_info->boundarygrp_given, "boundarygrp",
                           args_info->boundarygrp_orig, 0);
  write_multiple_into_file(outfile, args_info->interiorgrp_given, "interiorgrp",
                           args_info->interiorgrp_orig, 0);
  if (args_info->globe_given)
    write_into_file(outfile, "globe", args_info->globe_orig, 0);
  if (args_info->smorg_given)
    write_into_file(outfile, "smorg", 0, 0);
  if (args_info->fem_given)
    write_into_file(outfile, "fem", args_info->fem_orig, 0);
  write_multiple_into_file(outfile, args_info->aniso_given, "aniso",
                           args_info->aniso_orig, 0);
  if (args_info->grad_given)
    write_into_file(outfile, "grad", 0, 0);
  if (args_info->sph0_given)
    write_into_file(outfile, "sph0", args_info->sph0_orig, 0);
  if (args_info->sph_given)
    write_into_file(outfile, "sph", args_info->sph_orig, 0);
  write_multiple_into_file(outfile, args_info->bspline_given, "bspline",
                           args_info->bspline_orig, 0);
  if (args_info->points2mesh_given)
    write_into_file(outfile, "points2mesh", args_info->points2mesh_orig, 0);
  write_multiple_into_file(outfile, args_info->splitlines_given, "splitlines",
                           args_info->splitlines_orig, 0);
  if (args_info->x11_given)
    write_into_file(outfile, "x11", args_info->x11_orig, 0);
  write_multiple_into_file(outfile, args_info->x11_zoom_given, "x11-zoom",
                           args_info->x11_zoom_orig, 0);

  i = EXIT_SUCCESS;
  return i;
}

int cmdline_file_save(const char *filename,
                      struct gengetopt_args_info *args_info) {
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile) {
    fprintf(stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PACKAGE,
            filename);
    return EXIT_FAILURE;
  }

  i = cmdline_dump(outfile, args_info);
  fclose(outfile);

  return i;
}

void cmdline_free(struct gengetopt_args_info *args_info) {
  cmdline_release(args_info);
}

/** @brief replacement of strdup, which is not standard */
char *gengetopt_strdup(const char *s) {
  char *result = 0;
  if (!s)
    return result;

  result = (char *)malloc(strlen(s) + 1);
  if (result == (char *)0)
    return (char *)0;
  strcpy(result, s);
  return result;
}

static char *get_multiple_arg_token(const char *arg) {
  const char *tok;
  char *ret;
  size_t len, num_of_escape, i, j;

  if (!arg)
    return 0;

  tok = strchr(arg, ',');
  num_of_escape = 0;

  /* make sure it is not escaped */
  while (tok) {
    if (*(tok - 1) == '\\') {
      /* find the next one */
      tok = strchr(tok + 1, ',');
      ++num_of_escape;
    } else
      break;
  }

  if (tok)
    len = (size_t)(tok - arg + 1);
  else
    len = strlen(arg) + 1;

  len -= num_of_escape;

  ret = (char *)malloc(len);

  i = 0;
  j = 0;
  while (arg[i] && (j < len - 1)) {
    if (arg[i] == '\\' && arg[i + 1] && arg[i + 1] == ',')
      ++i;

    ret[j++] = arg[i++];
  }

  ret[len - 1] = '\0';

  return ret;
}

static const char *get_multiple_arg_token_next(const char *arg) {
  const char *tok;

  if (!arg)
    return 0;

  tok = strchr(arg, ',');

  /* make sure it is not escaped */
  while (tok) {
    if (*(tok - 1) == '\\') {
      /* find the next one */
      tok = strchr(tok + 1, ',');
    } else
      break;
  }

  if (!tok || strlen(tok) == 1)
    return 0;

  return tok + 1;
}

static int check_multiple_option_occurrences(const char *prog_name,
                                             unsigned int option_given,
                                             unsigned int min, unsigned int max,
                                             const char *option_desc);

int check_multiple_option_occurrences(const char *prog_name,
                                      unsigned int option_given,
                                      unsigned int min, unsigned int max,
                                      const char *option_desc) {
  int error_occurred = 0;

  if (option_given && (min > 0 || max > 0)) {
    if (min > 0 && max > 0) {
      if (min == max) {
        /* specific occurrences */
        if (option_given != (unsigned int)min) {
          fprintf(stderr, "%s: %s option occurrences must be %d\n", prog_name,
                  option_desc, min);
          error_occurred = 1;
        }
      } else if (option_given < (unsigned int)min ||
                 option_given > (unsigned int)max) {
        /* range occurrences */
        fprintf(stderr, "%s: %s option occurrences must be between %d and %d\n",
                prog_name, option_desc, min, max);
        error_occurred = 1;
      }
    } else if (min > 0) {
      /* at least check */
      if (option_given < min) {
        fprintf(stderr, "%s: %s option occurrences must be at least %d\n",
                prog_name, option_desc, min);
        error_occurred = 1;
      }
    } else if (max > 0) {
      /* at most check */
      if (option_given > max) {
        fprintf(stderr, "%s: %s option occurrences must be at most %d\n",
                prog_name, option_desc, max);
        error_occurred = 1;
      }
    }
  }

  return error_occurred;
}
int cmdline(int argc, char **argv, struct gengetopt_args_info *args_info) {
  return cmdline2(argc, argv, args_info, 0, 1, 1);
}

int cmdline_ext(int argc, char **argv, struct gengetopt_args_info *args_info,
                struct cmdline_params *params) {
  int result;
  result = cmdline_internal(argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE) {
    cmdline_free(args_info);
    exit(EXIT_FAILURE);
  }

  return result;
}

int cmdline2(int argc, char **argv, struct gengetopt_args_info *args_info,
             int override, int initialize, int check_required) {
  int result;
  struct cmdline_params params;

  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_internal(argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE) {
    cmdline_free(args_info);
    exit(EXIT_FAILURE);
  }

  return result;
}

int cmdline_required(struct gengetopt_args_info *args_info,
                     const char *prog_name) {
  int result = EXIT_SUCCESS;

  if (cmdline_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE) {
    cmdline_free(args_info);
    exit(EXIT_FAILURE);
  }

  return result;
}

int cmdline_required2(struct gengetopt_args_info *args_info,
                      const char *prog_name, const char *additional_error) {
  int error_occurred = 0;
  FIX_UNUSED(additional_error);

  /* checks for required options */
  if (check_multiple_option_occurrences(prog_name, args_info->ic_given,
                                        args_info->ic_min, args_info->ic_max,
                                        "'--ic' ('-i')"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(prog_name, args_info->collect_given,
                                        args_info->collect_min,
                                        args_info->collect_max, "'--collect'"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(prog_name, args_info->ir_given,
                                        args_info->ir_min, args_info->ir_max,
                                        "'--ir'"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(
          prog_name, args_info->input_given, args_info->input_min,
          args_info->input_max, "'--input' ('-T')"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(prog_name, args_info->cet_given,
                                        args_info->cet_min, args_info->cet_max,
                                        "'--cet' ('-E')"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(prog_name, args_info->rcdt_given,
                                        args_info->rcdt_min,
                                        args_info->rcdt_max, "'--rcdt' ('-R')"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(
          prog_name, args_info->quality_given, args_info->quality_min,
          args_info->quality_max, "'--quality' ('-Q')"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(
          prog_name, args_info->boundary_given, args_info->boundary_min,
          args_info->boundary_max, "'--boundary' ('-B')"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(
          prog_name, args_info->interior_given, args_info->interior_min,
          args_info->interior_max, "'--interior' ('-I')"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(
          prog_name, args_info->boundarygrp_given, args_info->boundarygrp_min,
          args_info->boundarygrp_max, "'--boundarygrp'"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(
          prog_name, args_info->interiorgrp_given, args_info->interiorgrp_min,
          args_info->interiorgrp_max, "'--interiorgrp'"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(prog_name, args_info->aniso_given,
                                        args_info->aniso_min,
                                        args_info->aniso_max, "'--aniso'"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(prog_name, args_info->bspline_given,
                                        args_info->bspline_min,
                                        args_info->bspline_max, "'--bspline'"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(
          prog_name, args_info->splitlines_given, args_info->splitlines_min,
          args_info->splitlines_max, "'--splitlines'"))
    error_occurred = 1;

  if (check_multiple_option_occurrences(
          prog_name, args_info->x11_zoom_given, args_info->x11_zoom_min,
          args_info->x11_zoom_max, "'--x11-zoom'"))
    error_occurred = 1;

  /* checks for dependences among options */
  if (args_info->collect_all_given && !args_info->collect_given) {
    fprintf(stderr,
            "%s: '--collect-all' option depends on option 'collect'%s\n",
            prog_name, (additional_error ? additional_error : ""));
    error_occurred = 1;
  }
  if (args_info->quality_given && !args_info->rcdt_given) {
    fprintf(stderr,
            "%s: '--quality' ('-Q') option depends on option 'rcdt'%s\n",
            prog_name, (additional_error ? additional_error : ""));
    error_occurred = 1;
  }
  if (args_info->x11_zoom_given && !args_info->x11_given) {
    fprintf(stderr, "%s: '--x11-zoom' option depends on option 'x11'%s\n",
            prog_name, (additional_error ? additional_error : ""));
    error_occurred = 1;
  }

  return error_occurred;
}

static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed
 * values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_params.check_ambiguity
 * @param override @see cmdline_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static int update_arg(void *field, char **orig_field, unsigned int *field_given,
                      unsigned int *prev_given, char *value,
                      const char *possible_values[], const char *default_value,
                      cmdline_arg_type arg_type, int check_ambiguity,
                      int override, int no_free, int multiple_option,
                      const char *long_opt, char short_opt,
                      const char *additional_error) {
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED(field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given &&
      (*prev_given || (check_ambiguity && *field_given))) {
    if (short_opt != '-')
      fprintf(stderr, "%s: `--%s' (`-%c') option given more than once%s\n",
              package_name, long_opt, short_opt,
              (additional_error ? additional_error : ""));
    else
      fprintf(stderr, "%s: `--%s' option given more than once%s\n",
              package_name, long_opt,
              (additional_error ? additional_error : ""));
    return 1; /* failure */
  }

  if (possible_values &&
      (found = check_possible_values((value ? value : default_value),
                                     possible_values)) < 0) {
    if (short_opt != '-')
      fprintf(stderr, "%s: %s argument, \"%s\", for option `--%s' (`-%c')%s\n",
              package_name, (found == -2) ? "ambiguous" : "invalid", value,
              long_opt, short_opt, (additional_error ? additional_error : ""));
    else
      fprintf(stderr, "%s: %s argument, \"%s\", for option `--%s'%s\n",
              package_name, (found == -2) ? "ambiguous" : "invalid", value,
              long_opt, (additional_error ? additional_error : ""));
    return 1; /* failure */
  }

  if (field_given && *field_given && !override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch (arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val)
      *((int *)field) = strtol(val, &stop_char, 0);
    break;
  case ARG_DOUBLE:
    if (val)
      *((double *)field) = strtod(val, &stop_char);
    break;
  case ARG_ENUM:
    if (val)
      *((int *)field) = found;
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free(*string_field); /* free previous string */
      *string_field = gengetopt_strdup(val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch (arg_type) {
  case ARG_INT:
  case ARG_DOUBLE:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:;
  };

  /* store the original value */
  switch (arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free(*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup(value);
      }
    }
  };

  return 0; /* OK */
}

/**
 * @brief store information about a multiple option in a temporary list
 * @param list where to (temporarily) store multiple options
 */
static int update_multiple_arg_temp(struct generic_list **list,
                                    unsigned int *prev_given, const char *val,
                                    const char *possible_values[],
                                    const char *default_value,
                                    cmdline_arg_type arg_type,
                                    const char *long_opt, char short_opt,
                                    const char *additional_error) {
  /* store single arguments */
  char *multi_token;
  const char *multi_next;

  if (arg_type == ARG_NO) {
    (*prev_given)++;
    return 0; /* OK */
  }

  multi_token = get_multiple_arg_token(val);
  multi_next = get_multiple_arg_token_next(val);

  while (1) {
    add_node(list);
    if (update_arg((void *)&((*list)->arg), &((*list)->orig), 0, prev_given,
                   multi_token, possible_values, default_value, arg_type, 0, 1,
                   1, 1, long_opt, short_opt, additional_error)) {
      if (multi_token)
        free(multi_token);
      return 1; /* failure */
    }

    if (multi_next) {
      multi_token = get_multiple_arg_token(multi_next);
      multi_next = get_multiple_arg_token_next(multi_next);
    } else
      break;
  }

  return 0; /* OK */
}

/**
 * @brief free the passed list (including possible string argument)
 */
static void free_list(struct generic_list *list, short string_arg) {
  if (list) {
    struct generic_list *tmp;
    while (list) {
      tmp = list;
      if (string_arg && list->arg.string_arg)
        free(list->arg.string_arg);
      if (list->orig)
        free(list->orig);
      list = list->next;
      free(tmp);
    }
  }
}

/**
 * @brief updates a multiple option starting from the passed list
 */
static void
update_multiple_arg(void *field, char ***orig_field, unsigned int field_given,
                    unsigned int prev_given, union generic_value *default_value,
                    cmdline_arg_type arg_type, struct generic_list *list) {
  int i;
  struct generic_list *tmp;

  if (prev_given && list) {
    *orig_field = (char **)realloc(*orig_field,
                                   (field_given + prev_given) * sizeof(char *));

    switch (arg_type) {
    case ARG_INT:
    case ARG_ENUM:
      *((int **)field) = (int *)realloc(
          *((int **)field), (field_given + prev_given) * sizeof(int));
      break;
    case ARG_DOUBLE:
      *((double **)field) = (double *)realloc(
          *((double **)field), (field_given + prev_given) * sizeof(double));
      break;
    case ARG_STRING:
      *((char ***)field) = (char **)realloc(
          *((char ***)field), (field_given + prev_given) * sizeof(char *));
      break;
    default:
      break;
    };

    for (i = (prev_given - 1); i >= 0; --i) {
      tmp = list;

      switch (arg_type) {
      case ARG_INT:
        (*((int **)field))[i + field_given] = tmp->arg.int_arg;
        break;
      case ARG_DOUBLE:
        (*((double **)field))[i + field_given] = tmp->arg.double_arg;
        break;
      case ARG_ENUM:
        (*((int **)field))[i + field_given] = tmp->arg.int_arg;
        break;
      case ARG_STRING:
        (*((char ***)field))[i + field_given] = tmp->arg.string_arg;
        break;
      default:
        break;
      }
      (*orig_field)[i + field_given] = list->orig;
      list = list->next;
      free(tmp);
    }
  } else { /* set the default value */
    if (default_value && !field_given) {
      switch (arg_type) {
      case ARG_INT:
      case ARG_ENUM:
        if (!*((int **)field)) {
          *((int **)field) = (int *)malloc(sizeof(int));
          (*((int **)field))[0] = default_value->int_arg;
        }
        break;
      case ARG_DOUBLE:
        if (!*((double **)field)) {
          *((double **)field) = (double *)malloc(sizeof(double));
          (*((double **)field))[0] = default_value->double_arg;
        }
        break;
      case ARG_STRING:
        if (!*((char ***)field)) {
          *((char ***)field) = (char **)malloc(sizeof(char *));
          (*((char ***)field))[0] = gengetopt_strdup(default_value->string_arg);
        }
        break;
      default:
        break;
      }
      if (!(*orig_field)) {
        *orig_field = (char **)malloc(sizeof(char *));
        (*orig_field)[0] = 0;
      }
    }
  }
}

int cmdline_internal(int argc, char **argv,
                     struct gengetopt_args_info *args_info,
                     struct cmdline_params *params,
                     const char *additional_error) {
  int c; /* Character of the parsed option.  */
  union generic_value multiple_default_value;

  struct generic_list *ic_list = NULL;
  struct generic_list *collect_list = NULL;
  struct generic_list *ir_list = NULL;
  struct generic_list *input_list = NULL;
  struct generic_list *cet_list = NULL;
  struct generic_list *rcdt_list = NULL;
  struct generic_list *quality_list = NULL;
  struct generic_list *boundary_list = NULL;
  struct generic_list *interior_list = NULL;
  struct generic_list *boundarygrp_list = NULL;
  struct generic_list *interiorgrp_list = NULL;
  struct generic_list *aniso_list = NULL;
  struct generic_list *bspline_list = NULL;
  struct generic_list *splitlines_list = NULL;
  struct generic_list *x11_zoom_list = NULL;
  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;

  int override;
  int initialize;
  int check_required;
  int check_ambiguity;

  package_name = argv[0];

  /* TODO: Why is this here? It is not used anywhere. */
  override = params->override;
  FIX_UNUSED(override);

  initialize = params->initialize;
  check_required = params->check_required;

  /* TODO: Why is this here? It is not used anywhere. */
  check_ambiguity = params->check_ambiguity;
  FIX_UNUSED(check_ambiguity);

  if (initialize)
    cmdline_init(args_info);

  cmdline_init(&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1) {
    int option_index = 0;

    static struct option long_options[] = {{"help", 0, NULL, 'h'},
                                           {"detailed-help", 0, NULL, 0},
                                           {"full-help", 0, NULL, 0},
                                           {"version", 0, NULL, 'V'},
                                           {"config", 1, NULL, 'C'},
                                           {"dump-config", 1, NULL, 0},
                                           {"io", 1, NULL, 0},
                                           {"ic", 1, NULL, 'i'},
                                           {"oc", 1, NULL, 'o'},
                                           {"collect", 1, NULL, 0},
                                           {"collect-all", 0, NULL, 0},
                                           {"ir", 1, NULL, 0},
                                           {"input", 1, NULL, 'T'},
                                           {"cutoff", 1, NULL, 0},
                                           {"spheretolerance", 1, NULL, 0},
                                           {"cet", 1, NULL, 'E'},
                                           {"rcdt", 2, NULL, 'R'},
                                           {"max_n0", 1, NULL, 0},
                                           {"max_n1", 1, NULL, 0},
                                           {"quality", 1, NULL, 'Q'},
                                           {"boundary", 1, NULL, 'B'},
                                           {"interior", 1, NULL, 'I'},
                                           {"boundarygrp", 1, NULL, 0},
                                           {"interiorgrp", 1, NULL, 0},
                                           {"globe", 1, NULL, 0},
                                           {"smorg", 0, NULL, 0},
                                           {"fem", 1, NULL, 0},
                                           {"aniso", 1, NULL, 0},
                                           {"grad", 0, NULL, 0},
                                           {"sph0", 1, NULL, 0},
                                           {"sph", 1, NULL, 0},
                                           {"bspline", 1, NULL, 0},
                                           {"points2mesh", 1, NULL, 0},
                                           {"splitlines", 1, NULL, 0},
                                           {"x11", 2, NULL, 'x'},
                                           {"x11-zoom", 1, NULL, 0},
                                           {0, 0, 0, 0}};

    c = getopt_long(argc, argv, "hVC:i:o:T:E:R::Q:B:I:x::", long_options,
                    &option_index);

    if (c == -1)
      break; /* Exit from `while (1)' loop.  */

    switch (c) {
    case 'h': /* Print help and exit.  */
      cmdline_print_help();
      cmdline_free(&local_args_info);
      exit(EXIT_SUCCESS);

    case 'V': /* Print version and exit.  */
      cmdline_print_version();
      cmdline_free(&local_args_info);
      exit(EXIT_SUCCESS);

    case 'C': /* Read options from file.  */

      if (update_arg((void *)&(args_info->config_arg),
                     &(args_info->config_orig), &(args_info->config_given),
                     &(local_args_info.config_given), optarg, 0, 0, ARG_STRING,
                     check_ambiguity, override, 0, 0, "config", 'C',
                     additional_error))
        goto failure;

      break;
    case 'i': /* Read input as matrix collections in the given files.  */

      if (update_multiple_arg_temp(&ic_list, &(local_args_info.ic_given),
                                   optarg, 0, 0, ARG_STRING, "ic", 'i',
                                   additional_error))
        goto failure;

      break;
    case 'o': /* Write output as a matrix collection in the given file.  */

      if (update_arg((void *)&(args_info->oc_arg), &(args_info->oc_orig),
                     &(args_info->oc_given), &(local_args_info.oc_given),
                     optarg, 0, 0, ARG_STRING, check_ambiguity, override, 0, 0,
                     "oc", 'o', additional_error))
        goto failure;

      break;
    case 'T': /* Specify triangulation input data, default=s0.  A second name
                 indicates a pre-existing triangulation, as in -Ts0,tv0, further
                 indicates additional data point matrices.  Use - for tv0 to
                 only supply additional points..  */

      if (update_multiple_arg_temp(&input_list, &(local_args_info.input_given),
                                   optarg, 0, 0, ARG_STRING, "input", 'T',
                                   additional_error))
        goto failure;

      break;
    case 'E': /* Convex encapsulation parameters.  */

      if (update_multiple_arg_temp(&cet_list, &(local_args_info.cet_given),
                                   optarg, 0, 0, ARG_DOUBLE, "cet", 'E',
                                   additional_error))
        goto failure;

      break;
    case 'R': /* Generate RCDT, with optional quality parameters.  */

      if (update_multiple_arg_temp(&rcdt_list, &(local_args_info.rcdt_given),
                                   optarg, 0, "21", ARG_DOUBLE, "rcdt", 'R',
                                   additional_error))
        goto failure;

      break;
    case 'Q': /* Per vertex RCDT parameters, as one or more one-column matrices
                 with minimum edge lengths for the points specified with
                 -T|--input.  */

      if (update_multiple_arg_temp(
              &quality_list, &(local_args_info.quality_given), optarg, 0, 0,
              ARG_STRING, "quality", 'Q', additional_error))
        goto failure;

      break;
    case 'B': /* Handle triangulation boundary.  */

      if (update_multiple_arg_temp(
              &boundary_list, &(local_args_info.boundary_given), optarg, 0,
              "boundary0", ARG_STRING, "boundary", 'B', additional_error))
        goto failure;

      break;
    case 'I': /* Handle interior constraints.  */

      if (update_multiple_arg_temp(
              &interior_list, &(local_args_info.interior_given), optarg, 0,
              "interior0", ARG_STRING, "interior", 'I', additional_error))
        goto failure;

      break;
    case 'x': /* Show progress in an x11 window, with delay factor.  */

      if (update_arg((void *)&(args_info->x11_arg), &(args_info->x11_orig),
                     &(args_info->x11_given), &(local_args_info.x11_given),
                     optarg, 0, "1.0", ARG_DOUBLE, check_ambiguity, override, 0,
                     0, "x11", 'x', additional_error))
        goto failure;

      break;

    case 0: /* Long option with no short option */
      if (strcmp(long_options[option_index].name, "detailed-help") == 0) {
        cmdline_print_detailed_help();
        cmdline_free(&local_args_info);
        exit(EXIT_SUCCESS);
      }

      if (strcmp(long_options[option_index].name, "full-help") == 0) {
        cmdline_print_full_help();
        cmdline_free(&local_args_info);
        exit(EXIT_SUCCESS);
      }

      /* Dump options to file.  */
      if (strcmp(long_options[option_index].name, "dump-config") == 0) {

        if (update_arg((void *)&(args_info->dump_config_arg),
                       &(args_info->dump_config_orig),
                       &(args_info->dump_config_given),
                       &(local_args_info.dump_config_given), optarg, 0, 0,
                       ARG_STRING, check_ambiguity, override, 0, 0,
                       "dump-config", '-', additional_error))
          goto failure;

      }
      /* I/O format specification (ascii/binary).  */
      else if (strcmp(long_options[option_index].name, "io") == 0) {

        if (update_arg((void *)&(args_info->io_arg), &(args_info->io_orig),
                       &(args_info->io_given), &(local_args_info.io_given),
                       optarg, cmdline_io_values, "bb", ARG_ENUM,
                       check_ambiguity, override, 0, 0, "io", '-',
                       additional_error))
          goto failure;

      }
      /* Add named matrices to the output collection.  */
      else if (strcmp(long_options[option_index].name, "collect") == 0) {

        if (update_multiple_arg_temp(
                &collect_list, &(local_args_info.collect_given), optarg, 0, "-",
                ARG_STRING, "collect", '-', additional_error))
          goto failure;

      }
      /* With --collect=-, load all matrices from the input collections.  */
      else if (strcmp(long_options[option_index].name, "collect-all") == 0) {

        if (update_arg((void *)&(args_info->collect_all_flag), 0,
                       &(args_info->collect_all_given),
                       &(local_args_info.collect_all_given), optarg, 0, 0,
                       ARG_FLAG, check_ambiguity, override, 1, 0, "collect-all",
                       '-', additional_error))
          goto failure;

      }
      /* Import a raw matrix file in ascii format.  */
      else if (strcmp(long_options[option_index].name, "ir") == 0) {

        if (update_multiple_arg_temp(&ir_list, &(local_args_info.ir_given),
                                     optarg, 0, 0, ARG_STRING, "ir", '-',
                                     additional_error))
          goto failure;

      }
      /* Treat points in the input data as unique only if they are further apart
         than this value. The vector 'idx' in the output gives the resulting
         vertex index for each input point..  */
      else if (strcmp(long_options[option_index].name, "cutoff") == 0) {

        if (update_arg((void *)&(args_info->cutoff_arg),
                       &(args_info->cutoff_orig), &(args_info->cutoff_given),
                       &(local_args_info.cutoff_given), optarg, 0, "1.0e-12",
                       ARG_DOUBLE, check_ambiguity, override, 0, 0, "cutoff",
                       '-', additional_error))
          goto failure;

      }
      /* The tolerance for determining that the input lies on a sphere..  */
      else if (strcmp(long_options[option_index].name, "spheretolerance") ==
               0) {

        if (update_arg((void *)&(args_info->spheretolerance_arg),
                       &(args_info->spheretolerance_orig),
                       &(args_info->spheretolerance_given),
                       &(local_args_info.spheretolerance_given), optarg, 0,
                       "1.0e-7", ARG_DOUBLE, check_ambiguity, override, 0, 0,
                       "spheretolerance", '-', additional_error))
          goto failure;

      }
      /* The desired maximal number of vertices, terminating angle checks.  */
      else if (strcmp(long_options[option_index].name, "max_n0") == 0) {

        if (update_arg((void *)&(args_info->max_n0_arg),
                       &(args_info->max_n0_orig), &(args_info->max_n0_given),
                       &(local_args_info.max_n0_given), optarg, 0, "-1",
                       ARG_INT, check_ambiguity, override, 0, 0, "max_n0", '-',
                       additional_error))
          goto failure;

      }
      /* The desired maximal number of vertices, terminating edge length checks.
       */
      else if (strcmp(long_options[option_index].name, "max_n1") == 0) {

        if (update_arg((void *)&(args_info->max_n1_arg),
                       &(args_info->max_n1_orig), &(args_info->max_n1_given),
                       &(local_args_info.max_n1_given), optarg, 0, "-1",
                       ARG_INT, check_ambiguity, override, 0, 0, "max_n1", '-',
                       additional_error))
          goto failure;

      }
      /* Group lables for boundary segments.  */
      else if (strcmp(long_options[option_index].name, "boundarygrp") == 0) {

        if (update_multiple_arg_temp(
                &boundarygrp_list, &(local_args_info.boundarygrp_given), optarg,
                0, 0, ARG_STRING, "boundarygrp", '-', additional_error))
          goto failure;

      }
      /* Group lables for interior segments.  */
      else if (strcmp(long_options[option_index].name, "interiorgrp") == 0) {

        if (update_multiple_arg_temp(
                &interiorgrp_list, &(local_args_info.interiorgrp_given), optarg,
                0, 0, ARG_STRING, "interiorgrp", '-', additional_error))
          goto failure;

      }
      /* Construct a triangulation of a globe.  */
      else if (strcmp(long_options[option_index].name, "globe") == 0) {

        if (update_arg((void *)&(args_info->globe_arg),
                       &(args_info->globe_orig), &(args_info->globe_given),
                       &(local_args_info.globe_given), optarg, 0, 0, ARG_INT,
                       check_ambiguity, override, 0, 0, "globe", '-',
                       additional_error))
          goto failure;

      }
      /* Smorgasbord queries for a known triangulation.  Uses the given
         --input=s,tv directly, without any filtering or refinement..  */
      else if (strcmp(long_options[option_index].name, "smorg") == 0) {

        if (update_arg(0, 0, &(args_info->smorg_given),
                       &(local_args_info.smorg_given), optarg, 0, 0, ARG_NO,
                       check_ambiguity, override, 0, 0, "smorg", '-',
                       additional_error))
          goto failure;

      }
      /* Calculate FEM matrices up through order fem.  */
      else if (strcmp(long_options[option_index].name, "fem") == 0) {

        if (update_arg((void *)&(args_info->fem_arg), &(args_info->fem_orig),
                       &(args_info->fem_given), &(local_args_info.fem_given),
                       optarg, 0, "-1", ARG_INT, check_ambiguity, override, 0,
                       0, "fem", '-', additional_error))
          goto failure;

      }
      /* Calculate anisotropic Laplacians.  */
      else if (strcmp(long_options[option_index].name, "aniso") == 0) {

        if (update_multiple_arg_temp(
                &aniso_list, &(local_args_info.aniso_given), optarg, 0, 0,
                ARG_STRING, "aniso", '-', additional_error))
          goto failure;

      }
      /* Calculate gradient weight matrices.  */
      else if (strcmp(long_options[option_index].name, "grad") == 0) {

        if (update_arg(0, 0, &(args_info->grad_given),
                       &(local_args_info.grad_given), optarg, 0, 0, ARG_NO,
                       check_ambiguity, override, 0, 0, "grad", '-',
                       additional_error))
          goto failure;

      }
      /* Calculate rotationally invariant spherical harmonics up through order
         sph0.  */
      else if (strcmp(long_options[option_index].name, "sph0") == 0) {

        if (update_arg((void *)&(args_info->sph0_arg), &(args_info->sph0_orig),
                       &(args_info->sph0_given), &(local_args_info.sph0_given),
                       optarg, 0, "-1", ARG_INT, check_ambiguity, override, 0,
                       0, "sph0", '-', additional_error))
          goto failure;

      }
      /* Calculate spherical harmonics up through order sph.  */
      else if (strcmp(long_options[option_index].name, "sph") == 0) {

        if (update_arg((void *)&(args_info->sph_arg), &(args_info->sph_orig),
                       &(args_info->sph_given), &(local_args_info.sph_given),
                       optarg, 0, "-1", ARG_INT, check_ambiguity, override, 0,
                       0, "sph", '-', additional_error))
          goto failure;

      }
      /* Calculate rotationally invariant B-spline basis functions.  */
      else if (strcmp(long_options[option_index].name, "bspline") == 0) {

        if (update_multiple_arg_temp(
                &bspline_list, &(local_args_info.bspline_given), optarg, 0, 0,
                ARG_DOUBLE, "bspline", '-', additional_error))
          goto failure;

      }
      /* Calculate barycentric triangle coordinates for a set of points.  */
      else if (strcmp(long_options[option_index].name, "points2mesh") == 0) {

        if (update_arg((void *)&(args_info->points2mesh_arg),
                       &(args_info->points2mesh_orig),
                       &(args_info->points2mesh_given),
                       &(local_args_info.points2mesh_given), optarg, 0, "s",
                       ARG_STRING, check_ambiguity, override, 0, 0,
                       "points2mesh", '-', additional_error))
          goto failure;

      }
      /* Split line segments into within-triangle parts and calculate
         corresponding barycentric coordinates.  */
      else if (strcmp(long_options[option_index].name, "splitlines") == 0) {

        if (update_multiple_arg_temp(
                &splitlines_list, &(local_args_info.splitlines_given), optarg,
                0, 0, ARG_STRING, "splitlines", '-', additional_error))
          goto failure;

      }
      /* Zoom into a smaller section of the graph, [minx,maxx,miny,maxy].  */
      else if (strcmp(long_options[option_index].name, "x11-zoom") == 0) {

        if (update_multiple_arg_temp(
                &x11_zoom_list, &(local_args_info.x11_zoom_given), optarg, 0, 0,
                ARG_DOUBLE, "x11-zoom", '-', additional_error))
          goto failure;
      }

      break;
    case '?': /* Invalid option.  */
      /* `getopt_long' already printed an error message.  */
      goto failure;

    default: /* bug: option not considered.  */
      fprintf(stderr, "%s: option unknown: %c%s\n", CMDLINE_PACKAGE, c,
              (additional_error ? additional_error : ""));
      abort();
    } /* switch */
  }   /* while */

  update_multiple_arg((void *)&(args_info->ic_arg), &(args_info->ic_orig),
                      args_info->ic_given, local_args_info.ic_given, 0,
                      ARG_STRING, ic_list);
  multiple_default_value.default_string_arg = "-";
  update_multiple_arg((void *)&(args_info->collect_arg),
                      &(args_info->collect_orig), args_info->collect_given,
                      local_args_info.collect_given, &multiple_default_value,
                      ARG_STRING, collect_list);
  update_multiple_arg((void *)&(args_info->ir_arg), &(args_info->ir_orig),
                      args_info->ir_given, local_args_info.ir_given, 0,
                      ARG_STRING, ir_list);
  update_multiple_arg((void *)&(args_info->input_arg), &(args_info->input_orig),
                      args_info->input_given, local_args_info.input_given, 0,
                      ARG_STRING, input_list);
  update_multiple_arg((void *)&(args_info->cet_arg), &(args_info->cet_orig),
                      args_info->cet_given, local_args_info.cet_given, 0,
                      ARG_DOUBLE, cet_list);
  multiple_default_value.double_arg = 21;
  update_multiple_arg((void *)&(args_info->rcdt_arg), &(args_info->rcdt_orig),
                      args_info->rcdt_given, local_args_info.rcdt_given,
                      &multiple_default_value, ARG_DOUBLE, rcdt_list);
  update_multiple_arg((void *)&(args_info->quality_arg),
                      &(args_info->quality_orig), args_info->quality_given,
                      local_args_info.quality_given, 0, ARG_STRING,
                      quality_list);
  multiple_default_value.default_string_arg = "boundary0";
  update_multiple_arg((void *)&(args_info->boundary_arg),
                      &(args_info->boundary_orig), args_info->boundary_given,
                      local_args_info.boundary_given, &multiple_default_value,
                      ARG_STRING, boundary_list);
  multiple_default_value.default_string_arg = "interior0";
  update_multiple_arg((void *)&(args_info->interior_arg),
                      &(args_info->interior_orig), args_info->interior_given,
                      local_args_info.interior_given, &multiple_default_value,
                      ARG_STRING, interior_list);
  update_multiple_arg(
      (void *)&(args_info->boundarygrp_arg), &(args_info->boundarygrp_orig),
      args_info->boundarygrp_given, local_args_info.boundarygrp_given, 0,
      ARG_STRING, boundarygrp_list);
  update_multiple_arg(
      (void *)&(args_info->interiorgrp_arg), &(args_info->interiorgrp_orig),
      args_info->interiorgrp_given, local_args_info.interiorgrp_given, 0,
      ARG_STRING, interiorgrp_list);
  update_multiple_arg((void *)&(args_info->aniso_arg), &(args_info->aniso_orig),
                      args_info->aniso_given, local_args_info.aniso_given, 0,
                      ARG_STRING, aniso_list);
  update_multiple_arg((void *)&(args_info->bspline_arg),
                      &(args_info->bspline_orig), args_info->bspline_given,
                      local_args_info.bspline_given, 0, ARG_DOUBLE,
                      bspline_list);
  update_multiple_arg(
      (void *)&(args_info->splitlines_arg), &(args_info->splitlines_orig),
      args_info->splitlines_given, local_args_info.splitlines_given, 0,
      ARG_STRING, splitlines_list);
  update_multiple_arg((void *)&(args_info->x11_zoom_arg),
                      &(args_info->x11_zoom_orig), args_info->x11_zoom_given,
                      local_args_info.x11_zoom_given, 0, ARG_DOUBLE,
                      x11_zoom_list);

  args_info->ic_given += local_args_info.ic_given;
  local_args_info.ic_given = 0;
  args_info->collect_given += local_args_info.collect_given;
  local_args_info.collect_given = 0;
  args_info->ir_given += local_args_info.ir_given;
  local_args_info.ir_given = 0;
  args_info->input_given += local_args_info.input_given;
  local_args_info.input_given = 0;
  args_info->cet_given += local_args_info.cet_given;
  local_args_info.cet_given = 0;
  args_info->rcdt_given += local_args_info.rcdt_given;
  local_args_info.rcdt_given = 0;
  args_info->quality_given += local_args_info.quality_given;
  local_args_info.quality_given = 0;
  args_info->boundary_given += local_args_info.boundary_given;
  local_args_info.boundary_given = 0;
  args_info->interior_given += local_args_info.interior_given;
  local_args_info.interior_given = 0;
  args_info->boundarygrp_given += local_args_info.boundarygrp_given;
  local_args_info.boundarygrp_given = 0;
  args_info->interiorgrp_given += local_args_info.interiorgrp_given;
  local_args_info.interiorgrp_given = 0;
  args_info->aniso_given += local_args_info.aniso_given;
  local_args_info.aniso_given = 0;
  args_info->bspline_given += local_args_info.bspline_given;
  local_args_info.bspline_given = 0;
  args_info->splitlines_given += local_args_info.splitlines_given;
  local_args_info.splitlines_given = 0;
  args_info->x11_zoom_given += local_args_info.x11_zoom_given;
  local_args_info.x11_zoom_given = 0;

  if (check_required) {
    error_occurred += cmdline_required2(args_info, argv[0], additional_error);
  }

  cmdline_release(&local_args_info);

  if (error_occurred)
    return (EXIT_FAILURE);

  if (optind < argc) {
    int i = 0;
    int found_prog_name = 0;
    /* whether program name, i.e., argv[0], is in the remaining args
       (this may happen with some implementations of getopt,
        but surely not with the one included by gengetopt) */

    i = optind;
    while (i < argc)
      if (argv[i++] == argv[0]) {
        found_prog_name = 1;
        break;
      }
    i = 0;

    args_info->inputs_num = argc - optind - found_prog_name;
    args_info->inputs =
        (char **)(malloc((args_info->inputs_num) * sizeof(char *)));
    while (optind < argc)
      if (argv[optind++] != argv[0])
        args_info->inputs[i++] = gengetopt_strdup(argv[optind - 1]);
  }

  return 0;

failure:
  free_list(ic_list, 1);
  free_list(collect_list, 1);
  free_list(ir_list, 1);
  free_list(input_list, 1);
  free_list(cet_list, 0);
  free_list(rcdt_list, 0);
  free_list(quality_list, 1);
  free_list(boundary_list, 1);
  free_list(interior_list, 1);
  free_list(boundarygrp_list, 1);
  free_list(interiorgrp_list, 1);
  free_list(aniso_list, 1);
  free_list(bspline_list, 0);
  free_list(splitlines_list, 1);
  free_list(x11_zoom_list, 0);

  cmdline_release(&local_args_info);
  return (EXIT_FAILURE);
}

#ifndef CONFIG_FILE_LINE_SIZE
#define CONFIG_FILE_LINE_SIZE 2048
#endif
#define ADDITIONAL_ERROR " in configuration file "

#define CONFIG_FILE_LINE_BUFFER_SIZE (CONFIG_FILE_LINE_SIZE + 3)
/* 3 is for "--" and "=" */

static int _cmdline_configfile(const char *filename, int *my_argc) {
  FILE *file;
  char my_argv[CONFIG_FILE_LINE_BUFFER_SIZE + 1];
  char linebuf[CONFIG_FILE_LINE_SIZE];
  int line_num = 0;
  int result = 0, equal;
  char *fopt, *farg;
  char *str_index;
  size_t len, next_token;
  char delimiter;

  if ((file = fopen(filename, "r")) == 0) {
    fprintf(stderr, "%s: Error opening configuration file '%s'\n",
            CMDLINE_PACKAGE, filename);
    return EXIT_FAILURE;
  }

  while ((fgets(linebuf, CONFIG_FILE_LINE_SIZE, file)) != 0) {
    ++line_num;
    my_argv[0] = '\0';
    len = strlen(linebuf);
    if (len > (CONFIG_FILE_LINE_BUFFER_SIZE - 1)) {
      fprintf(stderr, "%s:%s:%d: Line too long in configuration file\n",
              CMDLINE_PACKAGE, filename, line_num);
      result = EXIT_FAILURE;
      break;
    }

    /* find first non-whitespace character in the line */
    next_token = strspn(linebuf, " \t\r\n");
    str_index = linebuf + next_token;

    if (str_index[0] == '\0' || str_index[0] == '#')
      continue; /* empty line or comment line is skipped */

    fopt = str_index;

    /* truncate fopt at the end of the first non-valid character */
    next_token = strcspn(fopt, " \t\r\n=");

    if (fopt[next_token] == '\0') /* the line is over */
    {
      farg = 0;
      equal = 0;
      goto noarg;
    }

    /* remember if equal sign is present */
    equal = (fopt[next_token] == '=');
    fopt[next_token++] = '\0';

    /* advance pointers to the next token after the end of fopt */
    next_token += strspn(fopt + next_token, " \t\r\n");

    /* check for the presence of equal sign, and if so, skip it */
    if (!equal)
      if ((equal = (fopt[next_token] == '='))) {
        next_token++;
        next_token += strspn(fopt + next_token, " \t\r\n");
      }
    str_index += next_token;

    /* find argument */
    farg = str_index;
    if (farg[0] == '\"' || farg[0] == '\'') {   /* quoted argument */
      str_index = strchr(++farg, str_index[0]); /* skip opening quote */
      if (!str_index) {
        fprintf(stderr, "%s:%s:%d: unterminated string in configuration file\n",
                CMDLINE_PACKAGE, filename, line_num);
        result = EXIT_FAILURE;
        break;
      }
    } else { /* read up the remaining part up to a delimiter */
      next_token = strcspn(farg, " \t\r\n#\'\"");
      str_index += next_token;
    }

    /* truncate farg at the delimiter and store it for further check */
    delimiter = *str_index, *str_index++ = '\0';

    /* everything but comment is illegal at the end of line */
    if (delimiter != '\0' && delimiter != '#') {
      str_index += strspn(str_index, " \t\r\n");
      if (*str_index != '\0' && *str_index != '#') {
        fprintf(stderr, "%s:%s:%d: malformed string in configuration file\n",
                CMDLINE_PACKAGE, filename, line_num);
        result = EXIT_FAILURE;
        break;
      }
    }

  noarg:
    if (!strcmp(fopt, "include")) {
      if (farg && *farg) {
        result = _cmdline_configfile(farg, my_argc);
      } else {
        fprintf(stderr, "%s:%s:%d: include requires a filename argument.\n",
                CMDLINE_PACKAGE, filename, line_num);
      }
      continue;
    }
    len = strlen(fopt);
    strcat(my_argv, len > 1 ? "--" : "-");
    strcat(my_argv, fopt);
    if (len > 1 && ((farg && *farg) || equal))
      strcat(my_argv, "=");
    if (farg && *farg)
      strcat(my_argv, farg);
    ++(*my_argc);

    cmd_line_list_tmp = (struct line_list *)malloc(sizeof(struct line_list));
    cmd_line_list_tmp->next = cmd_line_list;
    cmd_line_list = cmd_line_list_tmp;
    cmd_line_list->string_arg = gengetopt_strdup(my_argv);
  } /* while */

  if (file)
    fclose(file);
  return result;
}

int cmdline_configfile(const char *filename,
                       struct gengetopt_args_info *args_info, int override,
                       int initialize, int check_required) {
  struct cmdline_params params;

  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  return cmdline_config_file(filename, args_info, &params);
}

int cmdline_config_file(const char *filename,
                        struct gengetopt_args_info *args_info,
                        struct cmdline_params *params) {
  int i, result;
  int my_argc = 1;
  char **my_argv_arg;
  char *additional_error;

  /* store the program name */
  cmd_line_list_tmp = (struct line_list *)malloc(sizeof(struct line_list));
  cmd_line_list_tmp->next = cmd_line_list;
  cmd_line_list = cmd_line_list_tmp;
  cmd_line_list->string_arg = gengetopt_strdup(CMDLINE_PACKAGE);

  result = _cmdline_configfile(filename, &my_argc);

  if (result != EXIT_FAILURE) {
    my_argv_arg = (char **)malloc((my_argc + 1) * sizeof(char *));
    cmd_line_list_tmp = cmd_line_list;

    for (i = my_argc - 1; i >= 0; --i) {
      my_argv_arg[i] = cmd_line_list_tmp->string_arg;
      cmd_line_list_tmp = cmd_line_list_tmp->next;
    }

    my_argv_arg[my_argc] = 0;

    additional_error =
        (char *)malloc(strlen(filename) + strlen(ADDITIONAL_ERROR) + 1);
    strcpy(additional_error, ADDITIONAL_ERROR);
    strcat(additional_error, filename);
    result = cmdline_internal(my_argc, my_argv_arg, args_info, params,
                              additional_error);

    free(additional_error);
    free(my_argv_arg);
  }

  free_cmd_list();
  if (result == EXIT_FAILURE) {
    cmdline_free(args_info);
    exit(EXIT_FAILURE);
  }

  return result;
}
/* vim: set ft=c noet ts=8 sts=8 sw=8 tw=80 nojs spell : */
