\chapter{Extended options for the latent field}
<<echo=FALSE>>=
library(INLA)
@ 
\section{Values}

In the definition of a model component in a formula
<<eval=FALSE>>=
... + f(idx, model="rw2") 
@
%%
then \tv{f} defines a \tv{RW2} model, say, and implicitely through the
variable \tv{idx} for which \emph{locations} the RW2 model should be
defined at, like
<<eval=FALSE>>=
sort(unique(idx))
@ 
%%
for a numerical \tv{idx}. Usually, this is what we want, but not
always. It does not happen often, but in some cases we need use the
argument \tv{values}, which defines the location for which the model
should be defined at, and we need to define this explicitely.
\footnote{Note that some models, like \tv{besag} for example, you
    cannot change the locations as for this model is defined through a
    \tv{graph} which defines the locations as
    $1, 2, \ldots, $\tv{graph->n}.}

All this is easier to explain all this through an example. We have
three points,
\begin{center}
<<dev='pdf', out.height='8cm', out.width='8cm'>>=
x = c(1, 2, 4)
y = c(2, 1, 10)
plot(x, y, pch=19, bty="l")
@ 
\end{center}
and we want to fit a spline through these points. We can then do
\begin{center}
<<dev='pdf', out.height='8cm', out.width='8cm'>>=
r = inla(y ~ -1 + f(x, model="rw2", constr=FALSE),  
         data = data.frame(y, x), 
         control.family = list(
             hyper = list(prec = list(initial=12, fixed=TRUE))))
plot(r$summary.random$x$ID, r$summary.random$x$mean, pch=19, bty="l")
lines( r$summary.random$x$ID, r$summary.random$x$mean)
@ 
\end{center}
which seems just like drawing a straight line between the observation,
and is indeed true. This is not what we wanted!
The reason is that \tv{x} defines the locations of
the spline, which is just at the locations \tv{x}. We want the spline to
be define also inbetween and even (maybe) outside this regions. For
this we need to pass a properly defined \tv{values} argument.
\begin{center}
<<dev='pdf', out.height='8cm', out.width='8cm'>>=
v = seq(0, 6, by = 0.2)
r = inla(y ~ -1 + f(x, model="rw2", constr=FALSE, values = v),  
         data = list(y=y, x=x, v=v), 
         control.family = list(
             hyper = list(prec = list(initial=12, fixed=TRUE))))
plot(r$summary.random$x$ID, r$summary.random$x$mean, pch=19, bty="l")
lines( r$summary.random$x$ID, r$summary.random$x$mean)
@ 
\end{center}
Note that \tv{x} must be a subset of \tv{v}, otherwise an error will
occure
<<errors=TRUE>>=
v = 10:20
r = inla(y ~ -1 + f(x, model="rw2", constr=FALSE, values = v),  
         data = list(y=y, x=x, v=v))
@ 
%%
The argument \tv{values} also allow us to produce credibility bounds
wherever we want, like
\begin{center}
<<dev='pdf', out.height='8cm', out.width='8cm'>>=
plot(r$summary.random$x$ID, r$summary.random$x$mean, pch=19, bty="l", 
     ylim = c(-5, 45))
lines( r$summary.random$x$ID, r$summary.random$x$mean, lwd=2)
lines( r$summary.random$x$ID, r$summary.random$x$"0.025quant", lty=2, lwd=2)
lines( r$summary.random$x$ID, r$summary.random$x$"0.975quant", lty=3, lwd=2)
@ 
\end{center}



\section{Replicate}

\section{Group}

\section{Linear combinations}

\section{Copy}

\section{Running \tv{inla()} remotely}

A really useful feature is the option to run \tv{inla()} remotely on a
different machine. If you have access to a computational server
somewhere of \tv{Linux} or \tv{MaxOSX} type, you can make use of this.

After a the setup, we can do like this
<<echo=TRUE, eval=FALSE>>=
n = 1000
x = runif(n)
y = x + rnorm(n)
r = inla(y ~ 1 + x,  data = data.frame(y, x), inla.call = "remote")
@ 
which will run the computations on a different server. The name of the
server is defined in the file \tv{$\sim$/.inlarc}, which for me, reads
\begin{verbatim}
### The name of the remote host.
RemoteHost="inla.math.ntnu.no"

### The username on the remote host
RemoteUser="hrue"

### Full path to the inla-program on the remote host
RemoteINLA="/usr/local/bin/inla"

### Arguments to ssh. Usually no need to change this
sshArguments="-x -o BatchMode=yes -o TCPKeepAlive=yes -e none"

### Port number
Port=22
\end{verbatim}
All these options are the default values, so you can also comment them
out using a '\#' or just leave them out. The options means, that I run
on the host \tv{inla.math.ntnu.no} using the account with usename
\tv{hrue} and the path to the \tv{inla}-binary is
\tv{/usr/local/bin/inla}. The easy way to install the
\tv{inla}-binary, is to have \tv{R} and \tv{R-INLA} installed and use
the \tv{inla}-binary in the \tv{R-INLA} package. You can find its path
by
<<echo=FALSE>>=
inla.setOption(inla.call=NULL)
@ 
<<echo=TRUE>>=
inla.getOption("inla.call")
@ 

The \tv{remote}-feature is made possible by using \tv{ssh} tools and
friends, which explains why you need to install \tv{Cygwin} on Windows
to make it work. The setup is easy enough but you need to doit correct
and every little detail is important; if in doubt seek help, upfont,
from a computer-wizard, and follow closely the details on this issue
in the \tv{FAQ} section on \tv{www.r-inla.org}.

There is more. You do not have to wait and sit for the job to be done.
You can submit the job or many, close the wifi-connection and shutdown
your laptop, and check and fetch the results when you get home. For
this use the argument \tv{inla.call="submit"} instead, and follow the
guidelines in the manual page \tv{?inla.qget}. You can check the
status of a job, fetch results, stop them, and clean up temporary
files, using \tv{inla.qstat}, \tv{inla.qget}, \tv{inla.qdel},
\tv{inla.qnuke}, respectively. This is a really useful feature
especially running larger models.
