\SweaveOpts{prefix.string=figs/burkitt} 
<<opts,echo=F,results=hide>>=
options(width=75, prompt = " ", continue = "   ")
require(sp) 
require(INLA)
require(fields)
##lcall <- inla.getOption('inla.call')
inla.setOption('inla.call'='remote')
@ 

\section{Burkitt example}\label{sec:burkitt}

We use the \texttt{burkitt} data set from the \pkg{splancs} package. 

<<data>>=
data('burkitt', package='splancs')
t(sapply(burkitt[, 1:3], summary))
@ 

The folowing commands shows the time when each event occurred, Figure~\ref{fig:timeshow}.
<<timeshow,eval=FALSE>>=
n <- nrow(burkitt)
par(mfrow=c(1,1), mar=c(1.5,.1,.1,.1), mgp=c(2,0.7,0))
plot(burkitt$t, rep(1,n), type='h', ylim=0:1, axes=FALSE, xlab='', ylab='')
box(); axis(1)
@ 

We have to define a set of knots over time in order to fit 
SPDE spatio temporal model. 
It is then used to built a temporal mesh 
<<tmesh,eval=FALSE>>=
k <- 6
tknots <- seq(min(burkitt$t), max(burkitt$t), length=k)
abline(v=tknots, lwd=4, col=4) ## add to plot
mesh.t <- inla.mesh.1d(tknots)
@ 

\setkeys{Gin}{width=0.99\textwidth}
\begin{figure}[h]\centering 
<<timeplot,echo=F,fig=T,eps=F,width=10,height=2>>=
<<timeshow>>
<<tmesh>>
@ 
\caption{Time when each event occurred (black) and knots used for inference (blue).}
\label{fig:timeshow}
\end{figure}

To work with the space, we first define a function to convert a polygon defined from a set of coordinates to an \texttt{SpatialPolygons} object:
<<coo2SP>>=
coo2sp <- function(coo) {
    n <- nrow(coo)
    if (any(coo[1,]!=coo[n,]))
        coo <- coo[c(1:n,1),]
    SpatialPolygons(list(Polygons(list(Polygon(coo)), '0')))
}
@ 

The spatial mesh can be done using the polygon of the region as a boundary
<<bound>>=
domainSP <- coo2sp(burbdy)
mesh.s <- inla.mesh.2d(burpts, boundary=inla.sp2segment(domainSP), 
                       max.edge=c(25, 50), cutoff=10) ### just a crude mesh
@ 

The SPDE model is defined using the spatial mesh as usual
<<spde>>=
m <- (spde <- inla.spde2.matern(mesh.s))$n.spde
@ 

The spatio temporal projector matrix is made considering 
both spatial and temporal locations and both spatial and temporal meshes. 
<<Ast>>=
dim(Ast <- inla.spde.make.A(mesh=mesh.s, loc=burpts, n.group=length(mesh.t$n), 
                            group=burkitt$t, group.mesh=mesh.t))
@ 
Internally \texttt{inla.spde.make.A} function makes a row Kronecker product (see \texttt{inla.row.kron}) between the spatial projector and the group (temporal in our case) projector.  
This matrix has number of columns equals to the number 
of nodes in the mesh times the number of groups. 

The index set is made considering the group feature: 
<<idx>>=
idx <- inla.spde.make.index('s', spde$n.spde, n.group=mesh.t$n)
@ 

The data stack can be made considering the ideas for the purerly spatial model. 
So, we do need to consider the expected number of cases at the 
1) integration points and 2) data locations. 
The first is now the spacetime volume at the mesh node and time knot, 
which is the area of each Voronoi polygon around the mesh location kronecker 
the length of the time window at each time point. 
The second is zero as for a point the expectation is zero, 
in accord to the likelihood approximation proposed by \cite{simpsonetal:2011}. 

We need to build the Voronoi polygons. 
Using a function from the \textbf{\textsf{deldir}} package: 
<<voronoi>>=
require(deldir)
dd <- deldir(mesh.s$loc[,1], mesh.s$loc[,2])
tiles <- tile.list(dd)
@ 

The area of the intersection between each Voronoi polygons and the domain region 
can be done using the \texttt{gIntersects} function from \textsf{\textbf{rgeos}} package. 
To use it we define a function to convert each Voronoi polygon into a \texttt{SpatialPolygons} and use the \texttt{gIntersects} function. 
It is done in the code below 
(show the sum of the intersection polygons areas):
<<i.pl.areas>>=
require(rgeos)
sum(w <- sapply(tiles, function(p) {
                    pl <- coo2sp(cbind(p$x, p$y))
                    if (gIntersects(pl, domainSP))
                        return(gArea(gIntersection(pl, domainSP)))
                    else return(0)
                }))
@ 
We can see that it sum up the same as the domain area:
<<areapl>>=
gArea(domainSP)
@ 

The spatio temporal volume is the product of these values and the time window length of each time knot.
<<stvol>>=
st.vol <- rep(w, k) * rep(diag(inla.mesh.fem(mesh.t)$c0), m)
@ 

The data stack is built using
<<stak>>=
y <- rep(0:1, c(k * m, n))
expected <- c(st.vol, rep(0, n))
stk <- inla.stack(data=list(y=y, expect=expected), 
    A=list(rBind(Diagonal(n=k*m), Ast), 1), 
    effects=list(idx, list(a0=rep(1, k*m + n))))
@ 

Model fitting (using the cruder approximation: 'gaussian')
<<fit,results=hide>>=
form <- y ~ 0 + a0 + 
    f(s, model=spde, group=s.group, control.group=list(model='ar1'))
burk.res <- inla(form, family='poisson', 
                 data=inla.stack.data(stk), E=expect,
                 control.predictor=list(A=inla.stack.A(stk)),
                 control.inla=list(strategy='gaussian'))
@ 

The exponential of the intercept plus the random effect at each spacetime integration point is the relative risk at each these points. 
This relative risk times the spacetime volume will give the expected number of points at each these spacetime locations. 
Summing it will approaches the number of observations:
<<nexpected>>=
eta.at.integration.points <- burk.res$summary.fix[1,1] + burk.res$summary.ran$s$mean
c(n=n, 'E(n)'=sum(st.vol*exp(eta.at.integration.points)))
@ 

%We can plot the posterior marginal distributions for the intercept and parameters, in Figure~\ref{fig:irf}, with
%<<irf,eval=FALSE>>=
%rf <- inla.spde2.result(burk.res, 's', spde)
%par(mfrow=c(2,3), mar=c(3,3,1,1), mgp=c(1.7,0.7,0))
%plot(burk.res$marginals.fix[[1]], type='l', xlab='Intercept')
%plot(burk.res$marginals.hy[[3]], type='l', xlab='time correlation')
%for (j in 15:17)
%    plot(rf[[j]][[1]], type='l', xlab=substring(names(rf)[j], 11))
%@ 
%\setkeys{Gin}{width=0.99\textwidth}
%\begin{figure}[h]\centering
%<<parsfig,echo=F,fig=T,eps=F,width=7,height=5>>=
%<<irf>>
%@ 
%\caption{Intercept and Random Field parameters posterior marginal distributions.}
%\label{fig:irf}
%\end{figure}

The projection over a grid for each time knot can be done with
<<>>=
r0 <- diff(range(burbdy[,1]))/diff(range(burbdy[,2]))
prj <- inla.mesh.projector(mesh.s, xlim=range(burbdy[,1]),
                           ylim=range(burbdy[,2]), dims=c(100, 100/r0)) 
ov <- over(SpatialPoints(prj$lattice$loc), domainSP)
m.prj <- lapply(1:k, function(j) {
  r <- inla.mesh.project(prj, burk.res$summary.ran$s$mean[1:m+(j-1)*m])
  r[is.na(ov)] <- NA;   return(r) 
})
@ 

The fitted latent field at each time knot is in Figure~\ref{fig:stppres}, 
produced with the code below. 
It can also be done for the standard deviation. 
<<plotstpp,eval=FALSE>>=
igr <- apply(abs(outer(burkitt$t, mesh.t$loc, '-')), 1, which.min)
zlm <- range(unlist(m.prj), na.rm=TRUE)
par(mfrow=c(2,3), mar=c(0,0,0,0))
for (j in 1:k) {
    image(x=prj$x, y=prj$y, z=m.prj[[j]], asp=1, 
          xlab='', zlim=zlm, axes=FALSE, col=tim.colors(64))
    points(burkitt[igr==j, 1:2], pch=19)
}; image.plot(legend.only=TRUE, zlim=zlm, legend.mar=5)
@ 
\setkeys{Gin}{width=0.99\textwidth}
\begin{figure}\centering
<<stppres,echo=F,fig=T,eps=F,width=5,height=7>>=
<<plotstpp>>
@ 
\caption{Fitted latent field at each time knot 
overlayed by the points closer in time.}
\label{fig:stppres}
\end{figure}
