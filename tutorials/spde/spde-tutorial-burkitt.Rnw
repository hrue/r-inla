\chapter{Spatio temporal point process}\label{ch:stpp}

\SweaveOpts{prefix.string=figs/nonstationar} 
<<opts,echo=F,results=hide>>=
options(width=75, prompt = " ", continue = "   ")
require(sp) 
require(INLA)
require(fields)
##lcall <- inla.getOption('inla.call')
inla.setOption('inla.call'='remote')
@ 

In this chapter we are going to show how to fit a 
spatio temporal log-Cox point process model. 
We use the \texttt{burkitt} data set from the \pkg{splancs} package. 

<<data>>=
data('burkitt', package='splancs')
t(sapply(burkitt[, 1:3], summary))
@ 

The folowing commands shows the time when each event occurred, Figure~\ref{fig:timeshow}.
<<timeshow,eval=FALSE>>=
n <- nrow(burkitt)
par(mfrow=c(1,1), mar=c(3,.1,.1,.1), mgp=c(2,1,0))
plot(burkitt$t, rep(1,n), type='h', xlim=c(0,max(burkitt$t)), 
     ylim=0:1, axes=FALSE, xlab='time', ylab='')
box(); axis(1)
@ 

We have to define a set of knots over time to define the 
SPDE spatio temporal model. 
And use it then to built a temporal mesh to project the 
field into the data time location 
<<tmesh,eval=FALSE>>=
tknots <- seq(0, 1, 0.2)*max(burkitt$t)
abline(v=tknots, lwd=4, col=4) ## add to plot
k <- (mesh.t <- inla.mesh.1d(tknots))$n 
@ 

\setkeys{Gin}{width=0.99\textwidth}
\begin{figure}[h]\centering 
<<timeplot,echo=F,fig=T,eps=F,width=10,height=2.5>>=
<<timeshow>>
<<tmesh>>
@ 
\caption{Time when each event occurred.}
\label{fig:timeshow}
\end{figure}

To work with the space, we first define a function to convert a polygon defined from a set of coordinates to an \texttt{SpatialPolygons} object:
<<coo2SP>>=
coo2sp <- function(coo) {
    n <- nrow(coo)
    if (any(coo[1,]!=coo[n,]))
        coo <- coo[c(1:n,1),]
    SpatialPolygons(list(Polygons(list(Polygon(coo)), '0')))
}
@ 

The spatial mesh can be done using the polygon of the region as a boundary
<<bound>>=
domainSP <- coo2sp(burbdy)
m <- (mesh.s <- inla.mesh.2d(burpts, boundary=inla.sp2segment(domainSP), 
                             max.edge=c(15, 50), cutoff=7))$n
@ 

The spatio temporal projector matrix is made considering 
both spatial and temporal locations and both meshes, spatial and temporal. 
<<Ast>>=
dim(Ast <- inla.spde.make.A(mesh=mesh.s, loc=burpts, n.group=length(mesh.t$n), 
                            group=burkitt$t, group.mesh=mesh.t))
@ 
This matrix has number of columns equals to the number 
of nodes in the mesh times the number of groups. 

The SPDE model is defined using the spatial mesh
<<spde>>=
spde <- inla.spde2.matern(mesh.s)
@ 

The index set is made considering the group feature: 
<<idx>>=
idx <- inla.spde.make.index('s', spde$n.spde, n.group=mesh.t$n)
@ 

The data stack can be made considering the ideas for the purerly spatial model. 
So, we do need to consider the expected number of cases at the 
1) integration points and 2) data locations. 
The first is now the spacetime volume at the mesh node and time knot, 
which is the area of each Voronoi polygon around the mesh location kronecker 
the length of the time window at each time point. 
The second is zero as for a point the expectation is zero, 
in accord to the likelihood approximation proposed by \cite{simpsonetal:2011}. 

We first need to build the Voronoi polygons. 
We choose to use a function from the \textbf{\textsf{deldir}} package:
<<voronoi>>=
require(deldir)
dd <- deldir(mesh.s$loc[,1], mesh.s$loc[,2])
tiles <- tile.list(dd)
@ 

The area of the intersection between each Voronoi polygons and the domain region 
can be done using the \texttt{gIntersects} function from \textsf{\textbf{rgeos}} package. 
To use it we define a function to convert each Voronoi polygon into a \texttt{SpatialPolygons} and use the \texttt{gIntersects} function. 
It is done in the code below 
(the sum of the intersection polygons areas is showed at end):
<<w>>=
require(rgeos)
sum(w <- sapply(tiles, function(p) {
                    pl <- coo2sp(cbind(p$x, p$y))
                    if (gIntersects(pl, domainSP))
                        return(gArea(gIntersection(pl, domainSP)))
                    else return(0)
                }))
@ 
We can see that it sum up the same as the domain area:
<<areapl>>=
gArea(domainSP)
@ 

So, we have computed the area of the intersection between each Voronoi polygon (one for each location of the spatial mesh) and the study domain. 
The spatial mesh vertices far out the study domain will have no intersection.
The spatio temporal volume is the product of these values and the time window length of each time knot.
<<stk, results=hide>>=
st.vol <- rep(w, k) * rep(diag(inla.mesh.fem(mesh.t)$c0), m)
@ 

The data stack is built using
<<stak>>=
y <- rep(0:1, c(k * m, n))
expected <- c(st.vol, rep(0, n))
stk <- inla.stack(data=list(y=y, expect=expected), 
    A=list(rBind(Diagonal(n=k*m), Ast), 1), 
    effects=list(idx, list(a0=rep(1, k*m + n)))) 
@ 

Model fitting (using the cruder approximation: 'gaussian')
<<fit,results=hide>>=
form <- y ~ 0 + a0 + 
    f(s, model=spde, group=s.group, control.group=list(model='ar1'))
burk.res <- inla(form, family='poisson', 
                 data=inla.stack.data(stk), E=expect,
                 control.predictor=list(A=inla.stack.A(stk)),
                 control.inla=list(strategy='gaussian'))
@ 

The exponential of the intercept plus the random effect at each spacetime integration point is the relative risk at each these points. 
This relative risk times the spacetime volume will give the expected number of points at each these spacetime locations. 
Summing it will approaches the number of observations:
<<intercept>>=
eta.at.integration.points <- burk.res$summary.fix[1,1] + burk.res$summary.ran$s$mean
c(n=n, 'E(n)'=sum(st.vol*exp(eta.at.integration.points)))
@ 

The projection over a grid for each time knot can be done with
<<>>=
r0 <- diff(range(burbdy[,1]))/diff(range(burbdy[,2]))
prj <- inla.mesh.projector(mesh.s, xlim=range(burbdy[,1]),
                           ylim=range(burbdy[,2]), dims=c(100, 100/r0)) 
ov <- over(SpatialPoints(prj$lattice$loc), domainSP)
m.prj <- lapply(1:k, function(j) {
  r <- inla.mesh.project(prj, burk.res$summary.ran$s$mean[1:m+(j-1)*m])
  r[is.na(ov)] <- NA;   return(r) 
})
@ 

The fitted latent field at each time knot is in Figure~\ref{fig:stppres}, 
produced with the code below. 
It can also be done for the standard deviation. 
<<plotstpp,eval=FALSE>>=
igr <- apply(abs(outer(burkitt$t, mesh.t$loc, '-')), 1, which.min)
zlm <- range(unlist(m.prj), na.rm=TRUE)
par(mfrow=c(2,3), mar=c(0,0,0,0))
for (j in 1:k) {
    image(x=prj$x, y=prj$y, z=m.prj[[j]], asp=1, 
          xlab='', zlim=zlm, axes=FALSE, col=tim.colors(64))
    points(burkitt[igr==j, 1:2], pch=19)
}; image.plot(legend.only=TRUE, zlim=zlm, legend.mar=5)
@ 
\setkeys{Gin}{width=0.99\textwidth}
\begin{figure}\centering
<<stppres,echo=F,fig=T,eps=F,width=5,height=7>>=
<<plotstpp>>
@ 
\caption{Fitted latent field at each time knot 
overlayed by the points closer in time.}
\label{fig:stppres}
\end{figure}

%% We can compare the number of cases closer to each time knot with 
%% the fitted ones. 
%% Considering the area of each pixel in the grid, the number of time points 
%% the intercept and the latent field at each pixel, we can compute the 
%% fitted number of cases with 
%% <<>>=
%% a1 <- diff(prj$x[1:2]) * diff(prj$x[1:2])
%% rbind(observed=table(igr), expected=sapply(m.prj, function(x) 
%%     sum(exp(burk.res$summary.fix[1,1] + x) * a1/k, na.rm=TRUE)))
%% @ 
