\chapter{Spatio temporal point process}\label{ch:stpp}

\SweaveOpts{prefix.string=figs/nonstationar} 
<<opts,echo=F,results=hide>>=
options(width=75, prompt = " ", continue = "   ")
require(sp) 
require(INLA)
require(fields)
##lcall <- inla.getOption('inla.call')
inla.setOption('inla.call'='remote')
@ 

In this chapter we are going to show how to fit a 
spatio temporal log-Cox point process model. 
We use the \texttt{burkitt} data set from the \pkg{splancs} package. 

<<data>>=
data('burkitt', package='splancs')
t(sapply(burkitt[, 1:3], summary))
@ 

We choose to scale the temporal making it in the $(0,1)$ interval 
<<yeart>>=
burkitt$t <- (burkitt$t - min(burkitt$t))/diff(range(burkitt$t))
@ 

We have to define a set of knots over time to define the 
SPDE spatio temporal model. 
And use it then to built a temporal mesh to project the 
field into the data time location 
<<tmesh>>=
tknots <- seq(0.1, 0.9, 0.2)
k <- (mesh.t <- inla.mesh.1d(tknots))$n
@ 

The spatial mesh can be done using the polygon of the region as a boundary
<<bound>>=
sp.b <- SpatialPolygons(list(Polygons(list(Polygon(burbdy)), '0')))
bound <- inla.sp2segment(sp.b)
mesh.s <- inla.mesh.2d(burpts, boundary=bound, 
                       max.edge=c(15, 50), cutoff=7)
@ 

The spatio temporal projector matrix is made considering 
both spatial and temporal locations and both meshes, spatial and temporal. 
<<Ast>>=
dim(Ast <- inla.spde.make.A(mesh=mesh.s, loc=burpts, n.group=length(mesh.t$n), 
                            group=burkitt$t, group.mesh=mesh.t))
@ 
This matrix has number of columns equals to the number 
of nodes in the mesh times the number of groups. 

The SPDE model is defined using the spatial mesh
<<spde>>=
spde <- inla.spde2.matern(mesh.s)
@ 

The index set is made considering the group feature: 
<<idx>>=
idx <- inla.spde.make.index('s', spde$n.spde, n.group=mesh.t$n)
@ 

The data stack can be made considering the ideas for the purerly spatial model. 
In addition, we have to consider the temporal volume at each temporal node. 
As we have equally spaced time knots and setted the time range equals 1, 
it is jus the one over the number of time knots. 
<<stk, results=hide>>=
m <- spde$n.spde
n <- nrow(burkitt) 
y <- rep(0:1, c(k * m, n))
st.volume <- diag(kronecker(Diagonal(n=k), 
                            spde$param.inla$M0))
expected <- c(st.volume, rep(0, n))
stk <- inla.stack(data=list(y=y, expect=expected), 
    A=list(rBind(Diagonal(n=k*m), Ast), 1), 
    effects=list(idx, list(a0=rep(1, k*m + n)))) 
@ 

Model fitting (using the cruder approximation: 'gaussian')
<<fit,results=hide>>=
form <- y ~ 0 + a0 + 
    f(s, model=spde, group=s.group, control.group=list(model='ar1'))
burk.res <- inla(form, family='poisson', 
                 data=inla.stack.data(stk), E=expect,
                 control.predictor=list(A=inla.stack.A(stk)),
                 control.inla=list(strategy='gaussian'))
@ 

The projection over a grid for each time knot can be done with
<<>>=
r0 <- diff(range(burbdy[,1]))/diff(range(burbdy[,2]))
prj <- inla.mesh.projector(mesh.s, xlim=range(burbdy[,1]),
                           ylim=range(burbdy[,2]), dims=c(100, 100/r0)) 
ov <- over(SpatialPoints(prj$lattice$loc), sp.b)
m.prj <- lapply(1:k, function(j) {
  r <- inla.mesh.project(prj, burk.res$summary.ran$s$mean[1:m+(j-1)*m])
  r[is.na(ov)] <- NA;   return(r) 
})
@ 

The fitted latent field at each time knot is in Figure~\ref{fig:stppres}, 
produced with the code below
<<plotstpp,eval=FALSE>>=
igr <- apply(abs(outer(burkitt$t, mesh.t$loc, '-')), 1, which.min)
zlm <- range(unlist(m.prj), na.rm=TRUE)
par(mfrow=c(2,3), mar=c(0,0,0,0))
for (j in 1:k) {
    image(x=prj$x, y=prj$y, z=m.prj[[j]], asp=1, 
          xlab='', zlim=zlm, axes=FALSE, col=tim.colors(64))
    points(burkitt[igr==j, 1:2], pch=19)
}; image.plot(legend.only=TRUE, zlim=zlm, legend.mar=0.1)
@ 
\setkeys{Gin}{width=0.99\textwidth}
\begin{figure}\centering
<<stppres,echo=F,fig=T,eps=F,width=5,height=7>>=
<<plotstpp>>
@ 
\caption{Fitted latent field at each time knot 
overlayed by the points closer in time.}
\label{fig:stppres}
\end{figure}

%% We can compare the number of cases closer to each time knot with 
%% the fitted ones. 
%% Considering the area of each pixel in the grid, the number of time points 
%% the intercept and the latent field at each pixel, we can compute the 
%% fitted number of cases with 
%% <<>>=
%% a1 <- diff(prj$x[1:2]) * diff(prj$x[1:2])
%% rbind(observed=table(igr), expected=sapply(m.prj, function(x) 
%%     sum(exp(burk.res$summary.fix[1,1] + x) * a1/k, na.rm=TRUE)))
%% @ 
