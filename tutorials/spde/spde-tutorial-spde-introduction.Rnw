\input{spde-tutorial-spde-results}
\input{spde-tutorial-mesh}

\section{The projector matrix}\label{sec:projmat} 

\SweaveOpts{prefix.string=figs/mesh}
<<sett,echo=F,results=hide>>=
options(width=75, prompt = " ", continue = "   ")
require(INLA) 
data(SPDEtoy)
load('mesh1.RData')
load('mesh5.RData')
source('spde-tutorial-functions.R') 
@ 

Because the SPDE model is defined on the 
mesh, we need an appropriate specification 
of the linear predictor for the data response. 
For details on this please see~\cite{lindgren:2012}. 

The key is that we have a random field 
modeled at the mesh vertices, with dimension $m$, 
and a response at $n$ locations. 
So, we need to define how the random field and 
other model components are linked to the response. 

Let the projector matrix $\bA$ to project the process 
at the mesh vertices to the locations response. 
The projector matrix can be builded with 
the \code{inla.spde.make.A} function. 
Considering that each mesh vertex has a weight, 
the value for one point within one triangle is 
the projection of the plane (formed by these 
three weights) at this point location. 
This projection is just a weighted average 
with the weights computed by the 
\code{inla.spde.make.A()} function. 
Using the toy data set and mesh number five we have
<<proj2>>=
coords <- as.matrix(SPDEtoy[,1:2])
A5 <- inla.spde.make.A(mesh5, loc=coords)
@ 

This matrix has dimension equal to the number of 
data locations by the number of vertices on 
the mesh 
<<dima1>>=
dim(A5)
@ 
We have exactly three non-zero elements on each line 
<<a5lines>>=
table(rowSums(A5>0))
@ 
because each point location is inside one of the triangles. 
These three non-zero elements on each line sums to one
<<rsum>>=
table(rowSums(A5))
@ 
because multiplication with any vector of weights 
at mesh nodes by this matrix is the projection 
of these weights at the location points. 

We have some columns on the projector 
matrix with all elements equals zero. 
<<colsA>>=
table(colSums(A5)>0)
@ 
These columns correspond the triangles 
without any  point locations inside.
These columns  can be droped and 
the stack functionality (section~\ref{sec:stack}) 
automatically handles this situation.

When we have a mesh where every pont location is on 
a mesh vertex, each line on the projector matrix has 
exacty one nonzero element. 
This is the case for the \code{m1} 
<<eacha1>>=
A1 <- inla.spde.make.A(mesh1, loc=coords)
table(rowSums(A1>0))
@
and all these elements are equal to one 
<<summarya1>>=
table(rowSums(A1))
@ 
because in this case the projection on the 
location points are just the weight at the 
corresponding node (at same location) of the mesh. 

\section{GRF sampling through SPDE}\label{sec:simula} 

The SPDE approach builds the model on the mesh vertices and 
we need to simulate values at the set of location points. 
We start by defining the spde model 
<<spde>>=
spde5 <- inla.spde2.matern(mesh5, alpha=2)
@ 
and build the associated precision matrix. 

This can be done with the \code{inla.spde2.precision()} function. 
To use this function, we have to provide the SPDE model 
and the parameters $\theta$ for the SPDE parametrization. 
$\theta$ is a length two vector where the second element 
is the logarithim of the scale parameter, log($\kappa$), 
and the first one is the 'local variance parameter' $\tau$
such that the marginal variance $\sigma_x^2$ is 
\[ \sigma_x^2 = \frac{1}{4\pi\tau^2\kappa^2} \] 
and we have that 
\[\log(\tau) = \theta_1 = -\log(4\pi\kappa^2\sigma_x^2)/2 \;.\] 

We do the simulation considering $\kappa=5$ and $\sigma_x^2=1$ 
<<params>>=
kappa <- 5;    s2x <- 1
@ 
so, we have 
<<theta>>=
theta <- c(-log(4*pi*s2x*kappa^2), log(kappa))
@ 
and we have the precision matrix $\bQ(\theta)$ by 
<<q5>>=
Q5 <- inla.spde2.precision(spde5, theta)
@ 

Now, we can use the \code{inla.qsample()} function 
to get a sample at mesh nodes by 
<<x5>>=
x5 <- inla.qsample(Q=Q5)
@ 
and to get a sample at the locations, we just 
project it with the projector matrix by 
<<x>>=
x <- drop(A5%*%x5)
@ 

We can write a more general function to generate 
one or more samples, by defining a function that 
needs just the coordinates and model parameters. 
A mesh can be provided and if not it is also 
generated within this function 
<<rspde>>=
rspde
@ 

We can generate samples at a million of locations 
in a matter of seconds  
<<sample>>=
pts1 <- matrix(runif(2e6), ncol=2)
x1 <- rspde(pts1, kappa=5, return.attributes=TRUE)
@ 

Some summary
<<summx1>>=
summary(x1)
table(x1>0)
@ 
and we have the attributes together 
<<attribs>>=
names(attributes(x1))
attr(x1, 'cpu') ### time in seconds
attr(x1, 'mesh')$n ### number of mesh nodes 
dim(attr(x1, 'Q')) 
dim(attr(x1, 'A'))
@ 

This function is used in some of next Chapters.

\section{Maximum likelihood inference}

We have that the latent random field $x$ 
is distributed as 
\[ x|\bQ \sim N(0, \bQ^{-1})\;\]
where $\bQ = \bQ(\theta)$, 
$\theta=\{\theta_1, \theta_2\}$ with 

$\theta_1$=log($\tau$) and $\theta_2$=log($\kappa$). 
Under the toy model, whe have an GF plus noise 
for the observation data. So, we have 
\[y|\mu_y,x,\bA,\bQ,\sigma_y^2 \sim N(\mu_y + \bA x, \bI \sigma^2_y)\;.\]
Integrating out $x$, we have that 
\[ y | \mu_y, \bQ, \bA, \sigma_y^2 \sim 
N(\mu_y, (\bA \bQ \bA' + \bI\sigma_y^2)^{-1}) \;.\]

The log-likelihood function, 
marginalized with respect $x$, becomes 
\[
-\frac{n}{2}\log(2\pi)-|\Sigma|-
\frac{1}{2}(y-\bF\beta)^{'}\Sigma^{-1}(y-\bF\beta) 
\]
where 
$\Sigma = (\bA \bQ \bA' + \bI\sigma_y^2)^{-1}$ 
and $\bQ=\bQ(\theta) = \bQ(\tau,\kappa)$. 
We choose $\tau^{'}$ to have marginal variance of $x$ equal 1, 
$\bQ(\tau^{'}, \kappa))$ = $\bQ^{'}$. 
In this case we write 
$\bW = (r\bI + Q(\tau^{'}, \kappa))$ 
where $r=\frac{\sigma^2_e}{\sigma^2_x}$ and 
\[
\Sigma = \sigma^2_x\bW\;.
\] 

Now, we can write a concentrated likelihood deriving 
the likelihood with respect to $\sigma^2_x$ and $\beta$. 
We have that 
\[ (\bF^{'}\bW\bF)\hat{\beta} = \bF^{'}\bW\by \;.\] 
and 
\[
\hat{\sigma}^2_x = (y_i-\bF\hat{\beta})^{'}\bW(y_i-\bF\hat{\beta})/n
\] 

Now, we can work with the log-likelihood 
as a function of a relative variance, instead of the noise variance, 
and the scale parameter $\kappa$. 
The concentrated log-likelihood can be writed as 
\[
-\frac{1}{2}\{|\bW| + n[\log(2\pi\hat{\sigma}^2_x)+1]\}
\]
And we can use a quasi-Newton 
optimization algorithim to find the maximum 
likelihood estimate of each the two parameters 
in the concentrated likelihood. 
These parameters are the ones in the $\bW$ matrix and 
are parametrized as log($r$) and log($\kappa$). 

To evaluate the likelihood function efficiently 
we need to compute the determinant $|\bW|$ 
and $\bW$ itself. Both computations needs care. 
We have that 
$\bW = (r\bI + Q(\tau^{'}, \kappa))$. 

To evaluate the determinant, we use a 
matrix determinant lemma such that we have 
\[\det(r\bI + \bA \bQ \bA^{'}) = 
  \det(\bQ + \bA^{'}r\bA) \det(\bQ) \det(r\bI)\;.
  \]
We implement the following function to compute it 
<<precdetf,echo=F>>=
precDetFun
@ 

The precision matrix can be evaluated 
using the Woodbury matrix identity. 
It says that for $\bC$ and $\bW$ invertible 
matrices we have  
\[(r\bI + \bA \bQ \bA^{'})^{-1} = 
 r^{-1}\bI - r^{-1}\bI\bA(\bQ + 
  \bA r^{-1}\bA)^{-1}\bA r^{-1}\;.\]
We implement it with the following function
<<precf,echo=F>>=
precFun
@ 

Considering $\theta$ and log($\sigma_y^2$) as a 
three parameter vetor, we have the following 
negative of the log likelihood function 
<<nllf,echo=F>>=
negLogLikFun
@ 

We proceed the maximum likelihood estimation, 
for the toy example dataset and compare with 
the results from \pkg{geoR} package of previous Chapter. 
We remember also the true parameter values
<<true>>=
beta0 <- 10; sigma2e <- 0.3; sigma2x <- 5; kappa <- 7; nu <- 1
@ 

We call the data
<<spdetoydata>>=
data(SPDEtoy)
@ 
build the mesh (using the true scale parameter to 
determine the edge lengths and \code{cutoff}), 
SPDE model (with $\alpha=2$) 
and the projector matrix
<<dprep>>=
xy <- as.matrix(SPDEtoy[,1:2])
(mesh <- inla.mesh.2d(xy, max.edge=c(0.5, 1)/kappa, 
                      cutoff=0.1/kappa))$n 
spde <- inla.spde2.matern(mesh)
A <- inla.mesh.project(mesh, loc=xy)$A
@

The maximum likelihood estimation is done 
using the \code{optim()} function. 
Using the default Nelder-Mead method
<<nm>>= 
opt <- optim(log(c(sigma2e/sigma2x, kappa)), 
             negLogLikFun, hessian=TRUE,
             X=matrix(1,nrow(xy)), A=A, 
             y=SPDEtoy[,3], spde=spde)
@ 

We also define a function to map the 
SPDE model parameters to the 
$\sigma_x^2$ and $\kappa$ user parameters. 
The function below recieves $\theta$, 
log($\sigma_y^2$) and $\beta$ (regression 
parameters) and returns $\sigma_x^2$, $\kappa$, 
$\sigma_y^2$ and $\beta$. 
<<par2user,echo=F>>=
par2user
@ 

We use this function to compare the results with 
the results from the \code{geoR} package 
<<lkfgeoR>>=
require(geoR)
lkf <- likfit(as.geodata(SPDEtoy),
              ini=c(sigma2x, 1/kappa), 
              kappa=1, ### kappa in geoR is nu 
              nugget=sigma2e, messages=FALSE)
@ 
and have similar results 
<<compare>>=
rbind(spde=par2user(opt$par, matrix(1, nrow(A)), A, SPDEtoy[,3], spde),
      geoR=c(lkf$beta, lkf$nugget, lkf$sigmasq, 1/lkf$phi), 
      true=c(beta0, sigma2e, sigma2x, kappa)) 
@ 

