\input{spde-tutorial-spde-results}
\input{spde-tutorial-aaa-mesh}

\section{The projector matrix}\label{sec:projmat} 

The R source for this example is available at
\url{http://www.math.ntnu.no/inla/r-inla.org/tutorials/spde/R/spde-tutorial-spde-introduction.R}


<<include=FALSE>>=
library(knitr)
opts_chunk$set(
fig.path='figs/mesh'
)
@

<<sett,echo=F,results='hide'>>=
options(width=75, prompt = " ", continue = "   ")
library(INLA) 
data(SPDEtoy)
load('mesh1.RData')
load('mesh5.RData')
source('R/spde-tutorial-functions.R') 
@ 

Because the SPDE model is defined on the 
mesh, we need an appropriate specification 
of the linear predictor for the data response. 
For details on this please see~\cite{lindgren:2012}. 

The key is that we have a random field 
modeled at the mesh vertices, with dimension $m$, 
and a response at $n$ locations. 
So, we need to define how the random field and 
other model components are linked to the response. 

Let the projector matrix $\bA$ to project the process 
at the mesh vertices to the locations response. 
The projector matrix can be builded with 
the \code{inla.spde.make.A} function. 
Considering that each mesh vertex has a weight, 
the value for one point within one triangle is 
the projection of the plane (formed by these 
three weights) at this point location. 
This projection is just a weighted average 
with the weights computed by the 
\code{inla.spde.make.A()} function. 
Using the toy data set and mesh number five we have
<<proj2>>=
coords <- as.matrix(SPDEtoy[,1:2])
A5 <- inla.spde.make.A(mesh5, loc=coords)
@ 

This matrix has dimension equal to the number of 
data locations by the number of vertices on 
the mesh 
<<dima1>>=
dim(A5)
@ 
We have exactly three non-zero elements on each line 
<<a5lines>>=
table(rowSums(A5>0))
@ 
because each point location is inside one of the triangles. 
These three non-zero elements on each line sums to one
<<rsum>>=
table(rowSums(A5))
@ 
because multiplication with any vector of weights 
at mesh nodes by this matrix is the projection 
of these weights at the location points. 

We have some columns on the projector 
matrix with all elements equals zero. 
<<colsA>>=
table(colSums(A5)>0)
@ 
These columns correspond the triangles 
without any  point locations inside.
These columns  can be droped and 
the stack functionality (section~\ref{sec:stack}) 
automatically handles this situation.

When we have a mesh where every pont location is on 
a mesh vertex, each line on the projector matrix has 
exacty one nonzero element. 
This is the case for the \code{m1} 
<<eacha1>>=
A1 <- inla.spde.make.A(mesh1, loc=coords)
table(rowSums(A1>0))
@
and all these elements are equal to one 
<<summarya1>>=
table(rowSums(A1))
@ 
because in this case the projection on the 
location points are just the weight at the 
corresponding node (at same location) of the mesh. 

\section{GRF sampling through SPDE}\label{sec:simula} 

The SPDE approach builds the model on the mesh vertices and 
we need to simulate values at the set of location points. 
We start by defining the spde model 
<<spde>>=
spde5 <- inla.spde2.matern(mesh5, alpha=2)
@ 
and build the associated precision matrix. 

This can be done with the \code{inla.spde2.precision()} function. 
To use this function, we have to provide the SPDE model 
and the parameters $\theta$ for the SPDE parametrization. 
$\theta$ is a length two vector where the second element 
is the logarithim of the scale parameter, log($\kappa$), 
and the first one is the 'local variance parameter' $\tau$
such that the marginal variance $\sigma_x^2$ is 
\[ \sigma_x^2 = \frac{1}{4\pi\tau^2\kappa^2} \] 
and we have that 
\[\log(\tau) = \theta_1 = -\log(4\pi\kappa^2\sigma_x^2)/2 \;.\] 

We do the simulation considering $\kappa=5$ and $\sigma_x^2=1$ 
<<params>>=
kappa <- 5;    s2x <- 1
@ 
so, we have 
<<theta>>=
theta <- c(-log(4*pi*s2x*kappa^2), log(kappa))
@ 
and we have the precision matrix $\bQ(\theta)$ by 
<<q5>>=
Q5 <- inla.spde2.precision(spde5, theta)
@ 

Now, we can use the \code{inla.qsample()} function 
to get a sample at mesh nodes by 
<<x5>>=
x5 <- inla.qsample(Q=Q5)
@ 
and to get a sample at the locations, we just 
project it with the projector matrix by 
<<x>>=
x <- drop(A5%*%x5)
@ 

We can write a more general function to generate 
one or more samples, by defining a function that 
needs just the coordinates and model parameters. 
A mesh can be provided and if not it is also 
generated within this function 
<<rspde>>=
rspde
@ 

We can generate samples at a million of locations 
in a matter of seconds  
<<sample>>=
pts1 <- matrix(runif(2e6), ncol=2)
x1 <- rspde(pts1, kappa=5, return.attributes=TRUE)
@ 

Some summary
<<summx1>>=
summary(x1)
table(x1>0)
@ 
and we have the attributes together 
<<attribs>>=
names(attributes(x1))
attr(x1, 'cpu') ### time in seconds
attr(x1, 'mesh')$n ### number of mesh nodes 
dim(attr(x1, 'Q')) 
dim(attr(x1, 'A'))
@ 

This function is used in some of next Chapters.
